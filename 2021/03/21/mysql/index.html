<!DOCTYPE html>
<html lang="zh-CN">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/images/img/logo.png">
  <link rel="icon" type="image/png" href="/img/logo.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="我们相信，未来可期！">
  <meta name="author" content="嗯，我们是对的">
  <meta name="keywords" content="">
  <title>【MySQL】学习笔记 - weitrable</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/github-gist.min.css" />
  

  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_yg9cfy8wd6.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script  src="/js/utils.js" ></script>
<meta name="generator" content="Hexo 5.2.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>WeiTrable</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/book/">
                <i class="iconfont icon-books"></i>
                电子书
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background" parallax=true
         style="background: url('/images/img/banner.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
              
  <div class="mt-3 post-meta">
    <i class="iconfont icon-date-fill" aria-hidden="true"></i>
    <time datetime="2021-03-21 12:21">
      2021年3月21日 中午
    </time>
  </div>


<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      41.3k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      484
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <div class="post-content mx-auto" id="post">
            
            <article class="markdown-body">
              <p><img src="/images/mysql/top.jpg" srcset="/img/loading.gif"><a id="more"></a></p>
<h3 id="磁盘文件"><a href="#磁盘文件" class="headerlink" title="磁盘文件"></a><strong>磁盘文件</strong></h3><p><img src="/images/mysql/logfile.png" srcset="/img/loading.gif"></p>
<p>MySQL的文件主要分为两大类，MySQl服务的文件和存储引擎的文件，主要分为三类：</p>
<ul>
<li>日志文件：MySQL实例写入的各种日志文件。</li>
<li>表结构文件：存放表结构定义的文件，.frm后缀文件，与存储引擎无关。</li>
<li>存储引擎数据文件：存储引擎负责对表中的数据进行读取和写入，每个存储引擎以自己的方式来保存表中的数据，在不同的存储引擎中数据存放的方式一般不同。 </li>
</ul>
<h4 id="日志文件"><a href="#日志文件" class="headerlink" title="日志文件"></a>日志文件</h4><p>记录数据库操作信息和错误信息，主要包括<em>错误日志</em>，<em>二进制日志</em>， <em>查询日志</em>， <em>慢查询日志</em>， <em>中继日志</em>等。</p>
<p>InnoBD相关的日志有：事务重做日志（redo log）和回滚日志（undo log）</p>
<p>查看命令：</p>
<pre><code class="hljs mysql">show variables like &#39;log_%&#39;;</code></pre>

<h4 id="错误日志（errorlog）"><a href="#错误日志（errorlog）" class="headerlink" title="错误日志（errorlog）"></a>错误日志（errorlog）</h4><p>​        用来记录 MySQL 服务器运行过程中遇到的所有严重错误信息以及MySQL每次启动和关闭的详细信息。比如，无法加载 MySQL 数据库的数据文件，或权限不正确等都会被记录在此，还有复制环境下，从服务器进程的信息也会被记录进错误日志。默认情况下，错误日志是开启的，从5.5.7开始无法关闭错误日志。</p>
<p>​      错误日志是存储在数据库的数据文件目录中，名称为 hostname.err，其中 hostname 为服务器主机名。在 MySQL 5.5.7 之前，数据库管理员可以删除很长时间之前的错误日志，以节省服务器上的硬盘空间， MySQL 5.5.7 之后，服务器将关闭此项功能，只能使用重命名原来的错误日志文件，手动冲洗日志创建一个新的，命令为：</p>
<p><code>mv hostname.err  hostname.err.old mysqladmin flush-logs</code></p>
<p>默认的错误日志名称为 hostname.err，其中 hostname 为服务器主机名。</p>
<p>错误日志所记录的信息是可以通过log-error和log-warnings来定义的，其中log-error是定义是否启用错误日志功能和错误日志的存储位置，log-warnings是定义是否将警告信息也定义至错误日志中。</p>
<pre><code class="hljs zsh"><span class="hljs-comment"># 可以直接定义为文件路径也可以为ON|OFF</span>
log_error=/var/<span class="hljs-built_in">log</span>/mysqld.log
<span class="hljs-comment"># 定义警告信息，默认为开启状态，默认2， 关闭设置为0</span>
log_warnings=2</code></pre>

<p><code>log_warnings=0</code>,不记录警告信息，只记录错误信息</p>
<p><code>log_warnings=1</code>,记录警告信息，错误日志包含错误信息和警告信息</p>
<p><code>log_warnings&gt;1</code>,记录警告信息，访问时报错和访问拒接的连接错误信息也会被记录到错误日志中</p>
<p>MySQL 5.7.2之前默认为1， 5.7.2起默认值为2。</p>
<h4 id="查询日志"><a href="#查询日志" class="headerlink" title="查询日志"></a>查询日志</h4><p>查询日志在 MySQL 中被称为 general log(通用日志)，查询日志里面记录了<strong>数据库执行的所有命令</strong>。不管语句是否正确，都会被记录，具体原因如下:</p>
<ul>
<li><p>insert 查询为了避免数据冲突，如果此前插入过数据，当前插入的数据如果跟主键或唯一键的数据重复肯定会报错；</p>
</li>
<li><p>update 时也会查询因为更新的时候很可能会更新某一块数据；</p>
</li>
<li><p>delete 查询，只删除符合条件的数据；</p>
</li>
</ul>
<p>因此都会产生日志，在并发操作非常多的场景下，查询信息会非常多，那么如果都记录下来会导致 IO 非常大，影响 MySQL 性能。因此如果不是在调试环境下，是不建议开启查询日志功能的。</p>
<p>查询日志的开启有助于帮助我们分析哪些语句执行密集，执行密集的 select 语句对应的数据是否能够被缓存，同时也可以帮助我们分析问题。所以，可以根据实际情况来决定是否开启查询日志。</p>
<p>查询日志模式是关闭的，可以通过以下命令开启查询日志：</p>
<p><code>set global generallog=1 set global logoutput=&#39;table&#39;;</code></p>
<p><code>general_log=1</code> 为开启查询日志，0 为关闭查询日志，这个设置命令即时生效，不用重启 MySQL 服务器。</p>
<h4 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h4><p>慢查询会导致 CPU、IOPS、内存消耗过高，当数据库遇到性能瓶颈时，大部分时间都是由于慢查询导致的。开启慢查询日志，可以让 MySQL 记录下查询超过指定时间的语句，之后运维人员通过定位分析，能够很好的优化数据库性能。默认情况下，慢查询日志是不开启的，只有手动开启了，慢查询才会被记录到慢查询日志中。使用如下命令记录当前数据库的慢查询语句：</p>
<pre><code class="hljs zsh"><span class="hljs-comment"># 开启慢查询日志</span>
slowquerylog=ON
<span class="hljs-comment"># 慢查询阈值，单位秒</span>
long_query_time=10
<span class="hljs-comment"># 慢查询日志文件名</span>
<span class="hljs-comment"># 没有指定，默认名为 hostname-slow.log hostname为主机名</span>
<span class="hljs-comment"># 需要指定，不是绝对路径</span>
slow_query_files=file_name</code></pre>

<p>使用命令 <code>set global slowquerylog=&#39;ON&#39;</code> 开启慢查询日志，只是对当前数据库有效，如果 MySQL 数据库重启后就会失效。所以如果要永久生效，就要修改配置文件<code> my.cnf</code>，设置<code> slowquerylog=ON</code> 并重启 MySQL 服务器。</p>
<h4 id="二进制日志（bin-log）"><a href="#二进制日志（bin-log）" class="headerlink" title="二进制日志（bin log）"></a>二进制日志（bin log）</h4><p>通过以下命令来查询 binlog 是否开启：</p>
<p><code>show variables like &#39;log_%&#39;;</code></p>
<p><img src="/images/mysql/binlog.png" srcset="/img/loading.gif"> </p>
<p>默认是关闭的。</p>
<pre><code class="hljs zsh">log-bin=OFF</code></pre>

<p>需要通过配置进行开启</p>
<pre><code class="hljs zsh">log-bin=mysql-bin</code></pre>

<p>其中<code>mysql-bin</code>是<code>bin log</code>日志文件的文件名前缀，<code>bin log</code>日志文件的完整名称：<code>mysql-bin-000001.log</code></p>
<p><code>bin log</code>是一个二进制文件，主要记录数据库所有的<code>DDL</code>语句和<code>DML</code>语句，但不包含<code>SELECT、SHOW</code>语句内容。<code>DDL</code>语句直接记录到<code>bin log</code>日志中，<code>DML</code>语句必须通过事务提交才能记录到<code>bin log</code>日志中。<code>bin log</code> 中记录了对 MySQL 数据库执行更改的所有操作，并且记录了语句发生时间、执行时长、操作数据等其它额外信息。</p>
<p><code>bin log</code>主要用于实现mysql<strong>主从复制、数据备份、数据恢复</strong>。</p>
<ul>
<li><p>恢复（<code>recovery</code>）：某些数据的恢复需要二进制日志。比如，在一个数据库全备文件恢复后，用户可以通过二进制日志进行 <code>point-in-time</code> 的恢复；</p>
</li>
<li><p>复制（<code>replication</code>）：其原理与恢复类似，通过复制和执行二进制日志使一台远程的MySQL数据库（一般称为 <code>slave</code> 或者 <code>standby</code>）与一台 MySQL 数据库（一般称为 <code>master</code> 或者 <code>primary</code>）进行实时同步；</p>
</li>
<li><p>审计（<code>audit</code>）：用户可以通过二进制日志中的信息来进行审计，判断是否有对数据库进行注入攻击。</p>
</li>
</ul>
<p>除了上面介绍的几个作用外，<code>binlog</code> 对于事务存储引擎的崩溃恢复也有非常重要的作用，在开启 <code>binlog</code> 的情况下，为了保证 <code>binlog</code> 与 <code>redo</code> 的一致性，MySQL 将采用事务的两阶段提交协议。当 MySQL 系统发生崩溃时，事务在存储引擎内部的状态可能为 <code>prepared</code>（准备状态）和 <code>commit</code>（提交状态）两种，对于 <code>prepared</code> 状态的事务，是进行提交操作还是进行回滚操作，这时需要参考<code> binlog</code>，如果事务在 <code>binlog</code> 中存在，那么将其提交；如果不在 <code>binlog</code> 中存在，那么将其回滚，这样就保证了数据在主库和从库之间的一致性。</p>
<p>binlog 格式分为: STATEMENT、ROW 和 MIXED 三种：</p>
<ul>
<li><p>STATEMENT 格式的 binlog 记录的是数据库上执行的原生 SQL 语句。这种格式的优点是简单，简单地记录和执行这些语句，能够让主备保持同步，在主服务器上执行的 SQL 语句，在从服务器上执行同样的语句。另一个好处是二进制日志里的时间更加紧凑，所以相对而言，基于语句的复制模式不会使用太多带宽，同时也节约磁盘空间。并且通过 mysqlbinlog 工具容易读懂其中的内容。缺点就是同一条 SQL 在主库和从库上执行的时间可能稍微或很大不相同，因此在传输的二进制日志中，除了查询语句，还包括了一些元数据信息，如当前的时间戳。即便如此，还存在着一些无法被正确复制的 SQL。比如，使用 <code>INSERT INTO TB1 VALUE(CUURENT_DATE()) </code>这一条使用函数的语句插入的数据复制到当前从服务器上来就会发生变化，存储过程和触发器在使用基于语句的复制模式时也可能存在问题；另外一个问题就是基于语句的复制必须是串行化的，比如：InnoDB 的 next-key 锁等，并不是所有的存储引擎都支持基于语句的复制；</p>
</li>
<li><p>ROW 格式是从 MySQL 5.1 开始支持基于行的复制，也就是基于数据的复制，基于行的更改。这种方式会将实际数据记录在二进制日志中，它有其自身的一些优点和缺点，最大的好处是可以正确地复制每一行数据，一些语句可以被更加有效地复制，另外就是几乎没有基于行的复制模式无法处理的场景，对于所有的 SQL 构造、触发器、存储过程等都能正确执行；它的缺点就是二进制日志可能会很大，而且不直观，所以，你不能使用 mysqlbinlog 来查看二进制日志，也无法通过看二进制日志判断当前执行到那一条 SQL 语句。现在对于 ROW 格式的二进制日志基本是标配了，主要是因为它的优势远远大于缺点，并且由于 ROW 格式记录行数据，所以可以基于这种模式做一些 DBA 工具，比如数据恢复，不同数据库之间数据同步等；</p>
</li>
<li><p>MIXED 也是 MySQL 默认使用的二进制日志记录方式，但 MIXED 格式默认采用基于语句的复制，一旦发现基于语句的无法精确的复制时，就会采用基于行的复制。比如用到 UUID()、USER()、CURRENTUSER()、ROWCOUNT() 等无法确定的函数。</p>
</li>
</ul>
<h4 id="回滚日志-undo-log"><a href="#回滚日志-undo-log" class="headerlink" title="回滚日志(undo log)"></a><strong>回滚日志(<code>undo log</code>)</strong></h4><p>用于存储日志被修改前的值，从而保证如果修改出现异常，可以使用 <code>undo log </code>日志来实现回滚操作。<code>undo log </code>和<code> redo log</code> 记录物理日志不一样，它是逻辑日志，可以认为当 <code>delete</code> 一条记录时，<code>undo log</code> 中会记录一条对应的<code> insert</code> 记录，反之亦然，当 <code>update</code> 一条记录时，它记录一条对应相反的 <code>update</code> 记录，当执行 rollback 时，就可以从 <code>undo log</code> 中的逻辑记录读取到相应的内容并进行回滚。<code>undo log </code>默认存放在共享表空间中，在 <code>mySQL 5.6</code> 中，<code>undo log</code> 的存放位置还可以通过变量<code>innodbundodirectory</code>来自定义存放目录，默认值为“.”表示 <code>datadir </code>目录。</p>
<p>作用：</p>
<pre><code class="hljs plain">保存事务发生前数据的一个版本，可以用于回滚，同时可以提供多版本并发控制下的读（MVCC），即非锁定读</code></pre>

<p>内容：</p>
<pre><code class="hljs mel">逻辑格式的体制。在执行<span class="hljs-keyword">undo</span>的时候，仅仅是将数据从逻辑上恢复之事务之前的状态，而不是从物理页面上操作实现的，这一点是不同于<span class="hljs-keyword">redo</span> <span class="hljs-keyword">log</span></code></pre>

<p>什么时候产生</p>
<pre><code class="hljs mel">事务开始前，将当前的版本生成<span class="hljs-keyword">undo</span> <span class="hljs-keyword">log</span>. <span class="hljs-keyword">undo</span>也会产生<span class="hljs-keyword">redo</span>来保证<span class="hljs-keyword">undo</span> <span class="hljs-keyword">log</span>的可靠性</code></pre>

<p>什么时候释放</p>
<pre><code class="hljs mel">当事务提交之后，<span class="hljs-keyword">undo</span> <span class="hljs-keyword">log</span>不能立马被删掉，而是放入待清理的链表，由purge线程判断是否有其他事务在使用<span class="hljs-keyword">undo</span>段中表的上一个事务之前的版本信息，决定是否可以清理<span class="hljs-keyword">undo</span> <span class="hljs-keyword">log</span>的日志空间</code></pre>

<p>对应物理文件：</p>
<pre><code class="hljs mel">mysql5<span class="hljs-number">.6</span>之前，<span class="hljs-keyword">undo</span>表空间位于共享表空间的回滚段中，共享表空间默认的名称为ibdata,位于数据文件目录中。
mysql5<span class="hljs-number">.6</span>之后，可以配置独立文件，完成数据库初始化后生效且不能改变<span class="hljs-keyword">undo</span> <span class="hljs-keyword">log</span>文件的个数，如果初始化数据库之前没有进行相关的配置，就无法配置独立的表空间。</code></pre>

<h4 id="重做日志-redo-log"><a href="#重做日志-redo-log" class="headerlink" title="重做日志(redo log)"></a><strong>重做日志(<code>redo log</code>)</strong></h4><p>为了最大程度的避免数据写入时，因为 IO 瓶颈造成的性能问题，MySQL 采用了这样一种缓存机制，先将数据写入内存中，再批量把内存中的数据统一刷回磁盘。为了避免将数据刷回磁盘过程中，因为掉电或系统故障带来的数据丢失问题，InnoDB 采用 <code>redo log</code> 来解决此问题。</p>
<p>作用：</p>
<pre><code class="hljs mel">确保事务的持久性。
防止发生故障的时间，尚有脏页为写入磁盘。在重启mysql服务是，根据<span class="hljs-keyword">redo</span> <span class="hljs-keyword">log</span>进行重做，从而达到事务的持久性。</code></pre>

<p>内容：</p>
<pre><code class="hljs mel">物理格式的日志，激励物理数据页面的修改信息，其<span class="hljs-keyword">redo</span> <span class="hljs-keyword">log</span>是顺序写入<span class="hljs-keyword">redo</span> <span class="hljs-keyword">log</span> <span class="hljs-keyword">file</span>的物理文件中去的。</code></pre>

<p>什么时候产生</p>
<pre><code class="hljs mel">事务开始之后就产生<span class="hljs-keyword">redo</span> <span class="hljs-keyword">log</span>. <span class="hljs-keyword">redo</span> <span class="hljs-keyword">log</span>的落盘并不是随着事务的提交才写入的，而是在事务的执行过程中便开始写入<span class="hljs-keyword">redo</span> <span class="hljs-keyword">log</span>文件中的。</code></pre>

<p>什么时候释放</p>
<pre><code class="hljs mel">当对应事务的脏页写入到磁盘之后，<span class="hljs-keyword">redo</span> <span class="hljs-keyword">log</span> 的使命也就完成了，重做日志占用的空间就可以冲用（被覆盖）。</code></pre>

<h4 id="SQL语句的交互流程"><a href="#SQL语句的交互流程" class="headerlink" title="SQL语句的交互流程"></a>SQL语句的交互流程</h4><blockquote>
<p>说一下SQL语句的交互流程，包括客户端与服务端之间的交互以及服务内部的整体流程</p>
</blockquote>
<pre><code class="hljs MySQL">-- id是主键
BEGIN
UPDATE user SET name&#x3D;&#39;aa&#39; WHERE id &#x3D; 1 FOR UPDATE;
COMMIT;</code></pre>

<p><img src="/images/mysql/sqlquery.png" srcset="/img/loading.gif"></p>
<p><img src="/images/mysql/querylogic.png" srcset="/img/loading.gif"></p>
<h5 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h5><p>当客户端登陆MySQL的时候，对身份认证和权限判断。</p>
<h5 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h5><p>执行查询语句的时候，会先查询缓存(MySQL 8.0 版本后移除)。</p>
<h5 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a>分析器</h5><p>假设在没有命中查询缓存的情况下，SQL请求就会来到分析器。分析器负责明确SQL要完成的功能，以及检查SQL的语法是否正确。</p>
<h5 id="查询优化器"><a href="#查询优化器" class="headerlink" title="查询优化器"></a>查询优化器</h5><p>优化器会计算「IO 成本 + CPU」成本最小的那个索引来执行。优化器执行选出最优索引等步骤后，会去调用存储引擎接口，开始去执行被 MySQL 解析过和优化过的 SQL 语句。</p>
<h5 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h5><p>执行 SQL 的动作是在存储引擎中完成的，数据是被存放在内存或者是磁盘中的。</p>
<h5 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h5><p>执行器从准备更新一条数据到事务的提交的流程</p>
<ol>
<li>首先执行器根据 MySQL 的执行计划来查询数据，先是从缓存池中查询数据，如果没有就会去数据库中查询，如果查询到了就将其放到缓存池中。</li>
<li>在数据被缓存到缓存池的同时，会写入 undo log 日志文件。</li>
<li>更新的动作是在 BufferPool 中完成的，同时会将更新后的数据添加到 redo log buffer 中。</li>
<li>完成以后就可以提交事务，在提交的同时会做以下三件事。</li>
<li>（第一件事）将redo log buffer中的数据刷入到 redo log 文件中。</li>
<li>（第二件事）将本次操作记录写入到 bin log文件中。</li>
<li>（第三件事）将 bin log 文件名字和更新内容在 bin log 中的位置记录到redo log中，同时在 redo log 最后添加 commit 标记。</li>
</ol>
<p><img src="/images/mysql/sqllog.png" srcset="/img/loading.gif"></p>
<h3 id="MySQL索引原理及优化"><a href="#MySQL索引原理及优化" class="headerlink" title="MySQL索引原理及优化"></a><strong>MySQL索引原理及优化</strong></h3><h4 id="索引介绍"><a href="#索引介绍" class="headerlink" title="索引介绍"></a>索引介绍</h4><h5 id="什么是索引"><a href="#什么是索引" class="headerlink" title="什么是索引"></a>什么是索引</h5><p>索引是一种能帮助 MySQL 提高查询效率的数据结构。</p>
<h5 id="索引优点和缺点"><a href="#索引优点和缺点" class="headerlink" title="索引优点和缺点"></a>索引优点和缺点</h5><p>索引的优点如下：</p>
<ul>
<li><p>快速访问数据表中的特定信息，提高检索速度。</p>
</li>
<li><p>创建唯一性索引，保证数据表中每一行数据的唯一性。</p>
</li>
<li><p>加速表与表之间的连接。</p>
</li>
<li><p>使用分组和排序进行数据检索时，可以显著减少查询中分组和排序的时间。</p>
</li>
</ul>
<p>索引的缺点：</p>
<ul>
<li><p>虽然提高了的查询速度，但却降低了更新表的速度，比如 update、insert，因为更新数据时，MySQL 不仅要更新数据，还要更新索引文件；</p>
</li>
<li><p>建立索引会占用磁盘文件的索引文件。</p>
</li>
</ul>
<p>使用索引注意事项：</p>
<ul>
<li><p>使用短索引，短索引不仅可以提高查询速度，更能节省磁盘空间和 I/O 操作；</p>
</li>
<li><p>索引列排序，MySQL 查询只使用一个索引，因此如果 where 子句中已经使用了索引的话，那么 order by 中的列是不会使用索引的，因此数据库默认排序可以符合要求的情况下，不要进行排序操作；尽量不要包含多个列的排序，如果需要最好给这些列创建复合索引；</p>
</li>
<li><p>like 语句操作，一般情况下不鼓励使用 like 操作，如果非使用不可， 注意 like “%aaa%” 不会使用索引，而like “aaa%”可以使用索引；</p>
</li>
<li><p>不要在列上进行运算；</p>
</li>
<li><p>不适用 NOT IN 和 &lt;&gt; 操作。</p>
</li>
</ul>
<h4 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h4><p>MySQL 的索引有两种分类方式：逻辑分类和物理分类。 按照逻辑分类，索引可分为：</p>
<h6 id="单列索引"><a href="#单列索引" class="headerlink" title="单列索引"></a>单列索引</h6><ul>
<li><p>主键索引：一张表只能有一个主键索引，不允许重复、不允许为 NULL；</p>
</li>
<li><p>唯一索引：数据列不允许重复，允许为 NULL 值，一张表可有多个唯一索引，但是一个唯一索引只能包含一列，比如身份证号码、卡号等都可以作为唯一索引；</p>
</li>
<li><p>普通索引：一张表可以创建多个普通索引，一个普通索引可以包含多个字段，允许数据重复，允许 NULL 值插入；</p>
</li>
</ul>
<h6 id="组合索引"><a href="#组合索引" class="headerlink" title="组合索引"></a>组合索引</h6><ul>
<li>在表中多个字段组合上创建的索引</li>
<li>组合索引的使用需要遵循<strong>最左前缀原则</strong></li>
<li>一般情况建议组合索引代替单列索引</li>
</ul>
<h6 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h6><ul>
<li>让搜索关键词更高效的一种索引，只有在MyISAM引擎、InnoDB（5.6以后）才能使用，而且只能在CHAR, VARCHAR, TEXT类型才能使用。</li>
<li>优先级最高 先执行 不会执行其他索引</li>
<li>存储引擎决定只执行一个索引</li>
</ul>
<h6 id="空间索引"><a href="#空间索引" class="headerlink" title="空间索引"></a>空间索引</h6><p>按照物理分类，索引可分为：</p>
<ul>
<li><p>聚集索引</p>
</li>
<li><p>非聚集索引</p>
</li>
</ul>
<h4 id="索引使用"><a href="#索引使用" class="headerlink" title="索引使用"></a>索引使用</h4><h5 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h5><p>各种索引的创建脚本如下：</p>
<pre><code class="hljs mysql">-- 创建主键索引 
alter table t add primary key add (&#96;id&#96;); 
-- 创建唯一索引 
alter table t add unique (&#96;username&#96;); 
-- 创建普通索引 
alter table t add index index_name (&#96;username&#96;); 

-- 创建组合索引 
alter table t add index index_name (&#96;username&#96;, &#96;age&#96;); 

-- 创建全文索引 
alter table t add fulltext (&#96;username&#96;);</code></pre>

<h5 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h5><pre><code class="hljs mysql">DROP INDEX index_name ON table;</code></pre>

<h5 id="查看索引"><a href="#查看索引" class="headerlink" title="查看索引"></a>查看索引</h5><pre><code class="hljs mysql">SHOW INDEX FROM tablename</code></pre>

<h4 id="索引存储结构"><a href="#索引存储结构" class="headerlink" title="索引存储结构"></a>索引存储结构</h4><h5 id="InnoDB存储引擎逻辑结构"><a href="#InnoDB存储引擎逻辑结构" class="headerlink" title="InnoDB存储引擎逻辑结构"></a>InnoDB存储引擎逻辑结构</h5><p><img src="/images/mysql/tablespace.png" srcset="/img/loading.gif"></p>
<p>InnoDB存储引擎逻辑存储结构可分为五级：表空间、段、区、页、行。</p>
<h5 id="索引存储结构-1"><a href="#索引存储结构-1" class="headerlink" title="索引存储结构"></a>索引存储结构</h5><p>索引在存储引擎中实现，不同的存储引擎使用不同的索引</p>
<p><strong>MyISAM和InnoDB</strong>存储引擎只支持<strong>B+TREE</strong>索引，即默认使用B+TREE,不能更换</p>
<p>MEMORY和HEAP存储引擎：执行HASH和BTREE</p>
<h5 id="B树与B-树"><a href="#B树与B-树" class="headerlink" title="B树与B+树"></a>B树与B+树</h5><h6 id="B树与B-树的区别"><a href="#B树与B-树的区别" class="headerlink" title="B树与B+树的区别"></a>B树与B+树的区别</h6><p>非叶子结点是否存储数据</p>
<pre><code class="hljs mipsasm"><span class="hljs-keyword">B树叶子结点和非叶子结点都会存储数据</span>
<span class="hljs-keyword">B+树只有叶子结点才会存储数据，而且存储的数据都在一行上，这些数据是由指针指向的，顺序的</span></code></pre>

<h5 id="非聚集索引（MyISAM）"><a href="#非聚集索引（MyISAM）" class="headerlink" title="非聚集索引（MyISAM）"></a>非聚集索引（MyISAM）</h5><ul>
<li><p>B+树叶子结点只存储数据行的指针。简单的说，<strong>数据跟索引不在一起</strong>。</p>
</li>
<li><p><strong>非聚集索引包含的主键索引和辅助索引都会存储指针的值</strong></p>
</li>
</ul>
<h6 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h6><p><img src="/images/mysql/prindex.png" srcset="/img/loading.gif"></p>
<h6 id="辅助索引（次要索引）"><a href="#辅助索引（次要索引）" class="headerlink" title="辅助索引（次要索引）"></a>辅助索引（次要索引）</h6><p>在MyISAM中主键索引与辅助索引在结构上没有区别，只是主键索引要求key是唯一的，辅助索引的key是可以重复的。</p>
<p><img src="/images/mysql/secondkey.png" srcset="/img/loading.gif"></p>
<h5 id="聚集索引（InnoDB）"><a href="#聚集索引（InnoDB）" class="headerlink" title="聚集索引（InnoDB）"></a>聚集索引（InnoDB）</h5><ul>
<li>主键索引的叶子结点都会存储数据，即<strong>数据和索引在一起</strong></li>
<li>辅助索引只存储主键值</li>
<li>如果没有主键索引，则使用唯一索引建立聚集索引；如果没有唯一索引，MySQL会按照一定规则创建聚集索引。</li>
</ul>
<h6 id="主键索引-1"><a href="#主键索引-1" class="headerlink" title="主键索引"></a>主键索引</h6><p>InnoDB要求<strong>必须有主键</strong>（MyISAM可以没有）。如果没有，MySQL会自动选择一个可以唯一标识数据记录的列作为主键；如果没有，MySQL会自动为InnoDB生成一个隐含字段作为主键，类型为长整型。</p>
<p><img src="/images/mysql/pkey.png" srcset="/img/loading.gif"></p>
<h6 id="辅助索引"><a href="#辅助索引" class="headerlink" title="辅助索引"></a>辅助索引</h6><p>聚集索引这种实现方式按照主键搜索非常高效，但是辅助索引需要查询两遍：辅助索引获得主键，然后主键到索引中检索获取记录。这也就是<strong>回表查询</strong>。</p>
<pre><code class="hljs mysql">select * from user where name&#x3D;&#39;Alice&#39;;  回表查询，检索两次 辅助索引——&gt;主键索引——&gt;数据
select id, name from user where name&#x3D;&#39;Alice&#39;; 不需要回表，辅助索引树上便可查到  覆盖索引（多用组合索引）</code></pre>

<p><img src="/images/mysql/spk.png" srcset="/img/loading.gif"></p>
<h4 id="组合索引-1"><a href="#组合索引-1" class="headerlink" title="组合索引"></a>组合索引</h4><h5 id="哪些情况要创建索引"><a href="#哪些情况要创建索引" class="headerlink" title="哪些情况要创建索引"></a>哪些情况要创建索引</h5><ol>
<li>主键自动创建索引</li>
<li>频繁作为查询条件需要创建索引</li>
<li>多表关联查询中，关联字段应该创建索引 on 两边都需要创建索引</li>
<li>查询中排序字段，需要创建索引</li>
<li>频繁查找字短 覆盖索引</li>
<li>查询中统计或者分组字段 需要创建索引</li>
</ol>
<h5 id="哪些情况不需要创建索引"><a href="#哪些情况不需要创建索引" class="headerlink" title="哪些情况不需要创建索引"></a>哪些情况不需要创建索引</h5><ol>
<li>表记录太少</li>
<li>经常进行增删改查的表</li>
<li>频繁更新的字段</li>
<li>where条件里使用频率不高的字段</li>
</ol>
<h5 id="为什么使用组合索引"><a href="#为什么使用组合索引" class="headerlink" title="为什么使用组合索引"></a>为什么使用组合索引</h5><p>组合索引根据<strong>最左原则</strong>进行排序，为了节省索引空间和提升搜索性能，可以使用组合索引。</p>
<p>查询遵循最左前缀原则</p>
<ol>
<li><p>前缀索引 where like a%  可以使用索引</p>
<p>​                where like %a  不能使用索引</p>
</li>
<li><p>从左向右匹配 直到遇到范围查询 &gt; &lt; between like</p>
</li>
</ol>
<p>建立索引（a, b, c, d）</p>
<p>​    where a=1 and b=3 and c&gt;4 and d=2     到了c&gt;4时听了，d=2用不到索引</p>
<p>​    可以通过键索引构建为（a, b, d, c）进行优化</p>
<h4 id="索引失效与分析"><a href="#索引失效与分析" class="headerlink" title="索引失效与分析"></a>索引失效与分析</h4><h5 id="执行计划"><a href="#执行计划" class="headerlink" title="执行计划"></a>执行计划</h5><p><code>EXPALIN</code>命令, 可以对select语句的执行计划进行分析</p>
<h5 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h5><pre><code class="hljs pgsql">id, select_type, <span class="hljs-keyword">table</span>, <span class="hljs-keyword">type</span>, possible_keys, key, key_len, <span class="hljs-keyword">ref</span>, <span class="hljs-keyword">rows</span>, Extra</code></pre>

<h6 id="id"><a href="#id" class="headerlink" title="id"></a>id</h6><ul>
<li>每个select语句都会自动分配一个唯一标识</li>
<li>表示查询中操作表的顺序<ul>
<li>id相同：执行顺序由上而下</li>
<li>id不同：如果是子查询，id会自增；id越大，优先级越高</li>
<li>id相同的不同的同时存在</li>
</ul>
</li>
<li>id列尾NULL表示这是个结果集，不需要用来进行查询</li>
</ul>
<h6 id="select-type（重要）"><a href="#select-type（重要）" class="headerlink" title="select_type（重要）"></a>select_type（重要）</h6><p>查询类型，主要用于区分普通查询、联合查询（union,union all）、子查询。</p>
<ul>
<li>simple:不需要使用union操作或者包含子查询的简单select查询。有连接查询时，外层的查询也是simple，有且只有一个。</li>
</ul>
<ul>
<li>primary:需要union插座或者含有子查询，位于最外层的单位查询的select_type是primary</li>
</ul>
<pre><code class="hljs mysql">mysql&gt; explain select (select name from user where name&#x3D;&#39;xxxx&#39;) from user;
+----+-------------+-------+------------+-------+---------------+-----------+---------+-------+------+----------+-------------+
| id | select_type | table | partitions | type  | possible_keys | key       | key_len | ref   | rows | filtered | Extra       |
+----+-------------+-------+------------+-------+---------------+-----------+---------+-------+------+----------+-------------+
|  1 | PRIMARY     | user  | NULL       | index | NULL          | index_com | 198     | NULL  |    9 |   100.00 | Using index |
|  2 | SUBQUERY    | user  | NULL       | ref   | index_com     | index_com | 99      | const |    1 |   100.00 | Using index |
+----+-------------+-------+------------+-------+---------------+-----------+---------+-------+------+----------+-------------+
2 rows in set (0.00 sec)
</code></pre>

<ul>
<li>subquery：除了from子句中包含的子查询外，其他地方出现的子查询都可能是subquery</li>
</ul>
<pre><code class="hljs mysql">mysql&gt; explain select * from user where id&#x3D;(select max(id) from user);
+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+------------------------------+
| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref   | rows | filtered | Extra                        |
+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+------------------------------+
|  1 | PRIMARY     | user  | NULL       | const | PRIMARY       | PRIMARY | 4       | const |    1 |   100.00 | NULL                         |
|  2 | SUBQUERY    | NULL  | NULL       | NULL  | NULL          | NULL    | NULL    | NULL  | NULL |     NULL | Select tables optimized away |
+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+------------------------------+
2 rows in set (0.00 sec)</code></pre>

<ul>
<li>dependent subquery:与dependent union类似，表示这个subquery的查询受外部查询的影响</li>
</ul>
<pre><code class="hljs mysql">mysql&gt; explain select id, name,(select name from dep d where d.dep&#x3D;u.id) from user u;
+----+--------------------+-------+------------+-------+---------------+-----------+---------+------+------+----------+-------------+
| id | select_type        | table | partitions | type  | possible_keys | key       | key_len | ref  | rows | filtered | Extra       |
+----+--------------------+-------+------------+-------+---------------+-----------+---------+------+------+----------+-------------+
|  1 | PRIMARY            | u     | NULL       | index | NULL          | index_com | 198     | NULL |    9 |   100.00 | Using index |
|  2 | DEPENDENT SUBQUERY | d     | NULL       | ALL   | NULL          | NULL      | NULL    | NULL |    2 |    50.00 | Using where |
+----+--------------------+-------+------------+-------+---------------+-----------+---------+------+------+----------+-------------+
2 rows in set (0.00 sec)</code></pre>

<ul>
<li>union:union连接的两个查询，第一个是primary，除第一个外的，都是union</li>
</ul>
<pre><code class="hljs mysql">mysql&gt; explain select * from user where name&#x3D;&#39;xxxx&#39; union select * from user where name&#x3D;&#39;zhangsan&#39;;
+----+--------------+------------+------------+------+---------------+-----------+---------+-------+------+----------+-----------------+
| id | select_type  | table      | partitions | type | possible_keys | key       | key_len | ref   | rows | filtered | Extra           |
+----+--------------+------------+------------+------+---------------+-----------+---------+-------+------+----------+-----------------+
|  1 | PRIMARY      | user       | NULL       | ref  | index_com     | index_com | 99      | const |    1 |   100.00 | Using index     |
|  2 | UNION        | user       | NULL       | ref  | index_com     | index_com | 99      | const |    1 |   100.00 | Using index     |
| NULL | UNION RESULT | &lt;union1,2&gt; | NULL       | ALL  | NULL          | NULL      | NULL    | NULL  | NULL |     NULL | Using temporary |
+----+--------------+------------+------------+------+---------------+-----------+---------+-------+------+----------+-----------------+
3 rows in set (0.00 sec)</code></pre>

<ul>
<li><p>dependent union:与union一样，出现union或者union all语句中，表示查询受外部表查询的影响</p>
</li>
<li><p>union result:包含union的结果集，id为NULL</p>
</li>
<li><p>Derived:from子句中出现的子查询，也叫做派生表</p>
</li>
</ul>
<h6 id="table"><a href="#table" class="headerlink" title="table"></a>table</h6><p>表名 ，查询中使用了别名，这里就显示别名</p>
<h6 id="type（重要）"><a href="#type（重要）" class="headerlink" title="type（重要）"></a>type（重要）</h6><p>依次由好到差</p>
<pre><code class="hljs pgsql"><span class="hljs-keyword">system</span>, const, eq_ref, <span class="hljs-keyword">ref</span>, fulltext, ref_or_null, unique_subquery, index_subquery, range, index_merge, <span class="hljs-keyword">index</span>, <span class="hljs-keyword">ALL</span></code></pre>

<p>除了ALL，其他类型都可以用到索引；</p>
<p>除了index_merge，其他type值可以用到一个索引</p>
<ul>
<li>system：表中只有一行或者是空表</li>
<li>const（重要）：使用唯一索引或者主键索引</li>
</ul>
<pre><code class="hljs mysql">mysql&gt; explain select * from user where id&#x3D;1;
+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref   | rows | filtered | Extra |
+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
|  1 | SIMPLE      | user  | NULL       | const | PRIMARY       | PRIMARY | 4       | const |    1 |   100.00 | NULL  |
+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+</code></pre>

<ul>
<li>eq_ref（重要）： 连接字段主键或者唯一索引</li>
</ul>
<p>通常出现在多表的join查询，表示对于前表的每一个结果，都<strong>只能匹配到后表的一行结果</strong>，并且查询到额比较操作通常是“=”，效率更高</p>
<pre><code class="hljs mysql">mysql&gt; explain select a.id from user a left join dep b on a.dep&#x3D;b.id;
+----+-------------+-------+------------+--------+---------------+---------+---------+------------+------+----------+-------------+
| id | select_type | table | partitions | type   | possible_keys | key     | key_len | ref        | rows | filtered | Extra       |
+----+-------------+-------+------------+--------+---------------+---------+---------+------------+------+----------+-------------+
|  1 | SIMPLE      | a     | NULL       | ALL    | NULL          | NULL    | NULL    | NULL       |    9 |   100.00 | NULL        |
|  1 | SIMPLE      | b     | NULL       | eq_ref | PRIMARY       | PRIMARY | 4       | test.a.dep |    1 |   100.00 | Using index |
+----+-------------+-------+------------+--------+---------------+---------+---------+------------+------+----------+-------------+</code></pre>

<ul>
<li>ref（重要）：针对非唯一索引，使用等值（=）查询非主键，或者使用了最左前缀原则索引的查询</li>
</ul>
<pre><code class="hljs mysql">mysql&gt; explain select * from user where name&#x3D;&#39;xxx&#39;;
+----+-------------+-------+------------+------+---------------+-----------+---------+-------+------+----------+-------+
| id | select_type | table | partitions | type | possible_keys | key       | key_len | ref   | rows | filtered | Extra |
+----+-------------+-------+------------+------+---------------+-----------+---------+-------+------+----------+-------+
|  1 | SIMPLE      | user  | NULL       | ref  | index_com     | index_com | 99      | const |    2 |   100.00 | NULL  |
+----+-------------+-------+------------+------+---------------+-----------+---------+-------+------+----------+-------+
1 row in set (0.00 sec)

mysql&gt; explain select * from user where name&#x3D;&#39;xxx&#39; and age&#x3D;2;
+----+-------------+-------+------------+------+---------------+-----------+---------+-------+------+----------+-----------------------+
| id | select_type | table | partitions | type | possible_keys | key       | key_len | ref   | rows | filtered | Extra                 |
+----+-------------+-------+------------+------+---------------+-----------+---------+-------+------+----------+-----------------------+
|  1 | SIMPLE      | user  | NULL       | ref  | index_com     | index_com | 99      | const |    2 |    11.11 | Using index condition |
+----+-------------+-------+------------+------+---------------+-----------+---------+-------+------+----------+-----------------------+
1 row in set (0.01 sec)</code></pre>

<ul>
<li>fulltext：全文索引检索</li>
<li>ref_or_null：与ref类似，只是增加了null值的比较，实际上用的不多</li>
<li>unique_subquery：用于where中的in形式子查询，子查询返回不重复唯一值</li>
<li>index_subquery：用于in形式子查询使用到辅助索引或者in常数列表，子查询可能返回重复值，可以使用索引将子查询去重</li>
<li>range（重要）：<strong>索引范围扫描</strong>，常见于&gt;, &lt;, is null, between, in, like等运算符的查询</li>
</ul>
<pre><code class="hljs mysql">mysql&gt; explain select * from user where name&#x3D;&#39;xxx&#39; and age&gt;3;
+----+-------------+-------+------------+-------+---------------+-----------+---------+------+------+----------+-----------------------+
| id | select_type | table | partitions | type  | possible_keys | key       | key_len | ref  | rows | filtered | Extra                 |
+----+-------------+-------+------------+-------+---------------+-----------+---------+------+------+----------+-----------------------+
|  1 | SIMPLE      | user  | NULL       | range | index_com     | index_com | 104     | NULL |    1 |   100.00 | Using index condition |
+----+-------------+-------+------------+-------+---------------+-----------+---------+------+------+----------+-----------------------+
1 row in set (0.00 sec)</code></pre>

<ul>
<li>index_merge：表示使用两个以上的索引，最后去交集或者并集。常见and, or的条件使用不同的索引。官方排序这个在ref_or_null之后，但实际上由于要读取所有索引，性能大部分时间不如range</li>
<li>index（重要）：<strong>关键字：条件是出现在索引树中的节点。可能没有完全匹配索引</strong></li>
</ul>
<p><strong>索引全表扫描</strong>，把索引从头到尾扫一遍，常见于使用索引列就可以处理，不需要读取文件查询，可以使用索引排序或者分组的查询。</p>
<pre><code class="hljs mysql">mysql&gt; explain select * from user order by id;
+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------+
| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra |
+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------+
|  1 | SIMPLE      | user  | NULL       | index | NULL          | PRIMARY | 4       | NULL |    9 |   100.00 | NULL  |
+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------+
1 row in set (0.00 sec)</code></pre>

<ul>
<li>ALL：全表扫描</li>
</ul>
<h6 id="possible-keys"><a href="#possible-keys" class="headerlink" title="possible_keys"></a>possible_keys</h6><p>此次查询中可能选用的索引，一个或多个</p>
<h6 id="key"><a href="#key" class="headerlink" title="key"></a>key</h6><p>查询真正使用到的索引。select_type为index_merge时，这里可能会出现两个以上索引；其他情况，select_type只会出现一个</p>
<h6 id="key-len"><a href="#key-len" class="headerlink" title="key_len"></a>key_len</h6><ul>
<li>用于处理查询的索引长度。如果是单列索引，那就整个索引算进去；如果是多列索引，那么查询不一定是所有的列。</li>
<li>另外，<em>key_len</em>指极端<em>where</em>条件中用到的索引长度，而排序和分组苦短用到了索引，也不会计算到<em>key_len</em>中。</li>
<li>不是准确值</li>
</ul>
<pre><code class="hljs mysql">mysql&gt; explain select * from user where id&#x3D;1;
+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref   | rows | filtered | Extra |
+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
|  1 | SIMPLE      | user  | NULL       | const | PRIMARY       | PRIMARY | 4       | const |    1 |   100.00 | NULL  |
+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
1 row in set (0.01 sec)

int为4</code></pre>

<h6 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h6><ul>
<li>如果使用的是常数等值，这里回现实const</li>
<li>如果是链接查询，被驱动表的执行计划这里会显示驱动表的关联字段</li>
<li>如果是条件使用表达式或者函数，或者条件列发生内部隐式转换，这里可能会显示func</li>
</ul>
<h6 id="rows"><a href="#rows" class="headerlink" title="rows"></a>rows</h6><p>这里是执行计划中估算的扫描行数，不是精确值（InnoDB不是精确值，MyISAM是精确值，主要原因是InnoDB里面使用了MVCC并发机制）</p>
<h6 id="Extra（重要）"><a href="#Extra（重要）" class="headerlink" title="Extra（重要）"></a>Extra（重要）</h6><p>这一列包含不适合其他列显示但非常重要的额外信息。</p>
<p><strong>using temporary</strong></p>
<ul>
<li>表示使用了临时表</li>
<li>MySQL在对比查询结果<em>order by</em> 和<em>group by</em></li>
<li>临时表可以是内存临时表和磁盘临时表，执行计划中看不出来，需要查看status变量（used_tmp_table, used_tmp_disk_table）才能看出来</li>
</ul>
<pre><code class="hljs mysql">mysql&gt; explain select distinct a.id from user a,dep b where a.dep&#x3D;b.id;
+----+-------------+-------+------------+-------+-------------------+---------+---------+------+------+----------+----------------------------------------------------+
| id | select_type | table | partitions | type  | possible_keys     | key     | key_len | ref  | rows | filtered | Extra                                              |
+----+-------------+-------+------------+-------+-------------------+---------+---------+------+------+----------+----------------------------------------------------+
|  1 | SIMPLE      | b     | NULL       | index | PRIMARY           | PRIMARY | 4       | NULL |    2 |   100.00 | Using index; Using temporary                       |
|  1 | SIMPLE      | a     | NULL       | ALL   | PRIMARY,index_com | NULL    | NULL    | NULL |    9 |    11.11 | Using where; Using join buffer (Block Nested Loop) |
+----+-------------+-------+------------+-------+-------------------+---------+---------+------+------+----------+----------------------------------------------------+
2 rows in set (0.03 sec)</code></pre>

<p><strong>no tables used</strong></p>
<p>不带from子句的查询或者From dual查询（oracle操作）</p>
<p><em>使用not in()形式子查询或者not exists运算符的连接查询（反连接）</em></p>
<p>即，一般链接查询是先查询哪表，再查询外表；反连接是先查询外表，再查询内表。</p>
<pre><code class="hljs mysql">mysql&gt; explain select now();
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra          |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+
|  1 | SIMPLE      | NULL  | NULL       | NULL | NULL          | NULL | NULL    | NULL | NULL |     NULL | No tables used |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+
1 row in set (0.00 sec)</code></pre>

<p><strong>using filesort(重要)</strong></p>
<ul>
<li>排序时无法使用到索引会出现这个，常见于order by 和group by语句中</li>
<li>说明MySQL会使用一个外部的索引排序，而不是按照索引顺序进行读取</li>
<li>MySQL中无法利用索引完成的排序操作称为“文件排序”</li>
</ul>
<pre><code class="hljs mysql">mysql&gt; explain select * from user order by dep;
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra          |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+
|  1 | SIMPLE      | user  | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    9 |   100.00 | Using filesort |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+
1 row in set (0.00 sec)</code></pre>

<p><strong>using index(重要)</strong></p>
<p>查询时<em>不需要回表查询</em>,直接通过索引就可以获取查询的数据</p>
<ul>
<li>表示想醒的select查询中使用到了覆盖索引，避免访问表的数据行，效率不错</li>
<li>如果同时使用Using where，说明索引被用来查找索引键值</li>
<li>如果没有同时出现Using where，表明索引用来读取数据而非执行查找动作</li>
</ul>
<pre><code class="hljs mysql">mysql&gt; explain select name, age from user where name&#x3D;&#39;xxx&#39;;
+----+-------------+-------+------------+------+---------------+-----------+---------+-------+------+----------+-------------+
| id | select_type | table | partitions | type | possible_keys | key       | key_len | ref   | rows | filtered | Extra       |
+----+-------------+-------+------------+------+---------------+-----------+---------+-------+------+----------+-------------+
|  1 | SIMPLE      | user  | NULL       | ref  | index_com     | index_com | 99      | const |    2 |   100.00 | Using index |
+----+-------------+-------+------------+------+---------------+-----------+---------+-------+------+----------+-------------+
1 row in set, (0.01 sec)</code></pre>

<p><strong>using where(重要)</strong></p>
<p>表示存储引擎返回的记录并不是所有都满足查询条件，需要server层进行过滤。效率比较低</p>
<pre><code class="hljs mysql">mysql&gt; explain select * from user where age&#x3D;23;
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | user  | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    9 |    11.11 | Using where |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+
1 row in set (0.00 sec)

mysql&gt; explain select name, age from user where name&#x3D;&#39;xxx&#39; order by id;
+----+-------------+-------+------------+------+---------------+-----------+---------+-------+------+----------+------------------------------------------+
| id | select_type | table | partitions | type | possible_keys | key       | key_len | ref   | rows | filtered | Extra                                    |
+----+-------------+-------+------------+------+---------------+-----------+---------+-------+------+----------+------------------------------------------+
|  1 | SIMPLE      | user  | NULL       | ref  | index_com     | index_com | 99      | const |    2 |   100.00 | Using where; Using index; Using filesort |
+----+-------------+-------+------------+------+---------------+-----------+---------+-------+------+----------+------------------------------------------+
1 row in set (0.00 sec)</code></pre>

<p>查询条件中氛围限制条件和检查条件。5.6之前，存储引擎只能使用限定条件扫描数据并返回，然后server层根据检查条件进行过滤返回真正符合查询的数据。5.6.x之后支持<em>ICP</em>特性，可以把检查条件页下推倒存储引擎层，不符合检查条件和限制条件的数据，直接不读取，这样就大大减少了存储引擎层扫描的记录数量。Extra列显示using index condition。</p>
<pre><code class="hljs mysql">mysql&gt; explain select * from user where name&#x3D;&#39;xxx&#39; and age&gt;3;
+----+-------------+-------+------------+-------+---------------+-----------+---------+------+------+----------+-----------------------+
| id | select_type | table | partitions | type  | possible_keys | key       | key_len | ref  | rows | filtered | Extra                 |
+----+-------------+-------+------------+-------+---------------+-----------+---------+------+------+----------+-----------------------+
|  1 | SIMPLE      | user  | NULL       | range | index_com     | index_com | 104     | NULL |    1 |   100.00 | Using index condition |
+----+-------------+-------+------------+-------+---------------+-----------+---------+------+------+----------+-----------------------+
1 row in set (0.00 sec)

mysql&gt; explain select * from user where name like &#39;xx%&#39;;
+----+-------------+-------+------------+-------+---------------+-----------+---------+------+------+----------+-----------------------+
| id | select_type | table | partitions | type  | possible_keys | key       | key_len | ref  | rows | filtered | Extra                 |
+----+-------------+-------+------------+-------+---------------+-----------+---------+------+------+----------+-----------------------+
|  1 | SIMPLE      | user  | NULL       | range | index_com     | index_com | 99      | NULL |    3 |   100.00 | Using index condition |
+----+-------------+-------+------------+-------+---------------+-----------+---------+------+------+----------+-----------------------+
1 row in set (0.00 sec)</code></pre>

<p><strong>firstmatch(tb_name)</strong></p>
<p>5.6.x开始引入的优化子查询的新特性之一，常见于where子句含有in()类型的子查询。如果内表的数据量比较大，就可能出现这个。</p>
<p><strong>loosescan(m..n)</strong></p>
<p>5.6.x之后引入的优化子查询的新特性之一，在in()类型的子查询中，子查询返回的可能有重复记录时，就可能出现这个.</p>
<p>除此之外，还有很多查询数据字典库，执行计划过程中发现不可能存在结果的一些提示信息</p>
<h6 id="filtered"><a href="#filtered" class="headerlink" title="filtered"></a>filtered</h6><p>使用explain extended时会出现这个。5.7之后的版本默认会有这个字段（不需要使用explain extended）。这个字段表示存储引擎返回的数据在server层过滤后，剩下多少满足查询的记录比例（100%不是具体记录数）。</p>
<h4 id="相关面试题"><a href="#相关面试题" class="headerlink" title="相关面试题"></a>相关面试题</h4><h5 id="什么是索引？"><a href="#什么是索引？" class="headerlink" title="什么是索引？"></a>什么是索引？</h5><p>索引是一种能帮助 MySQL 提高查询效率的数据结构。</p>
<h5 id="索引分别有哪些优点和缺点？"><a href="#索引分别有哪些优点和缺点？" class="headerlink" title="索引分别有哪些优点和缺点？"></a>索引分别有哪些优点和缺点？</h5><p>索引的优点如下：</p>
<ul>
<li><p>快速访问数据表中的特定信息，提高检索速度。</p>
</li>
<li><p>创建唯一性索引，保证数据表中每一行数据的唯一性。</p>
</li>
<li><p>加速表与表之间的连接。</p>
</li>
<li><p>使用分组和排序进行数据检索时，可以显著减少查询中分组和排序的时间。</p>
</li>
</ul>
<p>索引的缺点：</p>
<ul>
<li><p>虽然提高了的查询速度，但却降低了更新表的速度，比如 update、insert，因为更新数据时，MySQL 不仅要更新数据，还要更新索引文件；</p>
</li>
<li><p>建立索引会占用磁盘文件的索引文件。</p>
</li>
</ul>
<p>使用索引注意事项：</p>
<ul>
<li><p>使用短索引，短索引不仅可以提高查询速度，更能节省磁盘空间和 I/O 操作；</p>
</li>
<li><p>索引列排序，MySQL 查询只使用一个索引，因此如果 where 子句中已经使用了索引的话，那么 order by 中的列是不会使用索引的，因此数据库默认排序可以符合要求的情况下，不要进行排序操作；尽量不要包含多个列的排序，如果需要最好给这些列创建复合索引；</p>
</li>
<li><p>like 语句操作，一般情况下不鼓励使用 like 操作，如果非使用不可， 注意 like “%aaa%” 不会使用索引，而like “aaa%”可以使用索引；</p>
</li>
<li><p>不要在列上进行运算；</p>
</li>
<li><p>不适用 NOT IN 和 &lt;&gt; 操作。</p>
</li>
</ul>
<h5 id="索引有几种类型？分别如何创建？"><a href="#索引有几种类型？分别如何创建？" class="headerlink" title="索引有几种类型？分别如何创建？"></a>索引有几种类型？分别如何创建？</h5><p>MySQL 的索引有两种分类方式：逻辑分类和物理分类。 按照逻辑分类，索引可分为：</p>
<ul>
<li><p>主键索引：一张表只能有一个主键索引，不允许重复、不允许为 NULL；</p>
</li>
<li><p>唯一索引：数据列不允许重复，允许为 NULL 值，一张表可有多个唯一索引，但是一个唯一索引只能包含一列，比如身份证号码、卡号等都可以作为唯一索引；</p>
</li>
<li><p>普通索引：一张表可以创建多个普通索引，一个普通索引可以包含多个字段，允许数据重复，允许 NULL 值插入；</p>
</li>
<li><p>全文索引：让搜索关键词更高效的一种索引。</p>
</li>
</ul>
<p>按照物理分类，索引可分为：</p>
<ul>
<li><p>聚集索引：一般是表中的主键索引，如果表中没有显示指定主键，则会选择表中的第一个不允许为 NULL 的唯一索引，如果还是没有的话，就采用 Innodb 存储引擎为每行数据内置的 6 字节 ROWID 作为聚集索引。每张表只有一个聚集索引，因为聚集索引的键值的逻辑顺序决定了表中相应行的物理顺序。聚集索引在精确查找和范围查找方面有良好的性能表现（相比于普通索引和全表扫描），聚集索引就显得弥足珍贵，聚集索引选择还是要慎重的（一般不会让没有语义的自增 id 充当聚集索引）；</p>
</li>
<li><p>非聚集索引：该索引中索引的逻辑顺序与磁盘上行的物理存储顺序不同（非主键的那一列），一个表中可以拥有多个非聚集索引。</p>
</li>
</ul>
<p>各种索引的创建脚本如下：</p>
<pre><code class="hljs mysql">-- 创建主键索引 
alter table t add primary key add (&#96;id&#96;); 
-- 创建唯一索引 
alter table t add unique (&#96;username&#96;); 
-- 创建普通索引 
alter table t add index index_name (&#96;username&#96;); 
-- 创建全文索引 
alter table t add fulltext (&#96;username&#96;);</code></pre>

<h5 id="能否给手机号的前-6-位创建索引？如何创建？"><a href="#能否给手机号的前-6-位创建索引？如何创建？" class="headerlink" title="能否给手机号的前 6 位创建索引？如何创建？"></a>能否给手机号的前 6 位创建索引？如何创建？</h5><p>可以，创建方式有两种：</p>
<ul>
<li><p><code>alter table t add index index_phone(phone(6));</code></p>
</li>
<li><p><code>create index index_phone on t(phone(6));</code></p>
</li>
</ul>
<h5 id="如何查询一张表的所有索引？"><a href="#如何查询一张表的所有索引？" class="headerlink" title="如何查询一张表的所有索引？"></a>如何查询一张表的所有索引？</h5><p><code>SHOW INDEX FROM T</code> 查询表 T 所有索引。</p>
<h5 id="主索引和唯一索引有什么区别？"><a href="#主索引和唯一索引有什么区别？" class="headerlink" title="主索引和唯一索引有什么区别？"></a>主索引和唯一索引有什么区别？</h5><ul>
<li><p>主索引不能重复且不能为空，唯一索引不能重复，但可以为空；</p>
</li>
<li><p>一张表只能有一个主索引，但可以有多个唯一索引；</p>
</li>
<li><p>主索引的查询性能要高于唯一索引。</p>
</li>
</ul>
<h5 id="主索引和非主索引有什么区别？"><a href="#主索引和非主索引有什么区别？" class="headerlink" title="主索引和非主索引有什么区别？"></a>主索引和非主索引有什么区别？</h5><p>存储结构上</p>
<p>​    主键索引：叶子节点存储整行数据</p>
<p>​    非主键索引：叶子节点存储主键值</p>
<p>检索上</p>
<p>​    主键索引：直接通过索引获取数据</p>
<p>​    非主键索引：可能会有回表查询</p>
<p>创建方式上</p>
<p>​    主键索引：表中主键自动创建；若无主键，唯一索引+NotNull主键；若没有，自重创建隐士列rowid做主键</p>
<p>​    非主键索引：主动创建</p>
<h5 id="辅助索引为什么只存主键？"><a href="#辅助索引为什么只存主键？" class="headerlink" title="辅助索引为什么只存主键？"></a>辅助索引为什么只存主键？</h5><p>空间上：成本高</p>
<p>时间上：查询成本少了，插入成本不变，更新成本高</p>
<h5 id="在-InnDB-中主键索引为什么比普通索引的查询性能高？"><a href="#在-InnDB-中主键索引为什么比普通索引的查询性能高？" class="headerlink" title="在 InnDB 中主键索引为什么比普通索引的查询性能高？"></a>在 InnDB 中主键索引为什么比普通索引的查询性能高？</h5><p>因为普通索引的查询会多执行一次检索操作。</p>
<p>比如主键查询 select * from t where id=10 只需要搜索 id 的这棵 B+ 树。</p>
<p>普通索引查询 select * from t where f=3 会先查询 f 索引树，得到 id 的值之后再去搜索 id 的 B+ 树，因为多执行了一次检索，所以执行效率就比主键索引要低。</p>
<h5 id="唯一索引和普通索引哪个性能更好？"><a href="#唯一索引和普通索引哪个性能更好？" class="headerlink" title="唯一索引和普通索引哪个性能更好？"></a>唯一索引和普通索引哪个性能更好？</h5><ul>
<li><p>对于查询操作来说：普通索引和唯一索引的性能相近，都是从索引树中进行查询；</p>
</li>
<li><p>对于更新操作来说：唯一索引要比普通索引执行的慢，因为唯一索引需要先将数据读取到内存中，再在内存中进行数据的唯一效验，所以执行起来要比普通索引更慢。</p>
</li>
</ul>
<h5 id="什么叫回表查询？"><a href="#什么叫回表查询？" class="headerlink" title="什么叫回表查询？"></a>什么叫回表查询？</h5><p>普通索引查询到主键索引后，回到主键索引树搜索的过程，我们称为回表查询。</p>
<p>参考SQL：</p>
<pre><code class="hljs mysql">mysql&gt; create table T( id int primary key, k int not null, name varchar(16), index (k))engine&#x3D;InnoDB;</code></pre>

<p>如果语句是 select * from T where ID=500，即主键查询方式，则只需要检索主键 ID 字段。</p>
<pre><code class="hljs mysql">mysql&gt; select * from T where ID&#x3D;500; 
+-----+---+-------+ 
| id | k | name | 
+-----+---+-------+ 
| 500 | 5 | name5 | 
+-----+---+-------+</code></pre>

<p>如果语句是 select * from T where k=5，即普通索引查询方式，则需要先搜索 k 索引树，得到 ID 的值为 500，再到 ID 索引树搜索一次，这个过程称为回表查询。</p>
<pre><code class="hljs mysql">mysql&gt; select * from T where k&#x3D;5; 
+-----+---+-------+ 
| id | k | name | 
+-----+---+-------+ 
| 500 | 5 | name5 | 
+-----+---+-------+</code></pre>

<p>也就是说，基于非主键索引的查询需要多扫描一棵索引树。因此，我们在应用中应该尽量使用主键查询。</p>
<h5 id="以下-SQL-有什么问题？该如何优化？"><a href="#以下-SQL-有什么问题？该如何优化？" class="headerlink" title="以下 SQL 有什么问题？该如何优化？"></a>以下 SQL 有什么问题？该如何优化？</h5><pre><code class="hljs mysql">select * from t where f&#x2F;2&#x3D;100;</code></pre>

<p>该 SQL 会导致引擎放弃索引而全表扫描，尽量避免在索引列上计算。可改为：</p>
<pre><code class="hljs mysql">select * from t where f&#x3D;100*2;</code></pre>

<h5 id="为什么-MySQL-官方建议使用自增主键作为表的主键？"><a href="#为什么-MySQL-官方建议使用自增主键作为表的主键？" class="headerlink" title="为什么 MySQL 官方建议使用自增主键作为表的主键？"></a>为什么 MySQL 官方建议使用自增主键作为表的主键？</h5><p>因为自增主键是连续的，在插入过程中尽量减少页分裂，即使要进行页分裂，也只会分裂很少一部分；并且自增主键也能减少数据的移动，每次插入都是插入到最后，所以自增主键作为表的主键，对于表的操作来说性能是最高的。</p>
<p>InnoDB存储引擎逻辑存储结构可分为五级：表空间、段（索引段+数据段）、区（1M=64个页）、页(默认16K)、行。</p>
<p><img src="/images/mysql/tablespace.png" srcset="/img/loading.gif"></p>
<p>假设一页有4条数据</p>
<p>非自增情况</p>
<p><img src="/images/mysql/page1.png" srcset="/img/loading.gif"></p>
<p><img src="/images/mysql/page2.png" srcset="/img/loading.gif"></p>
<p><img src="/images/mysql/page3.png" srcset="/img/loading.gif"></p>
<p>自增情况</p>
<p><img src="/images/mysql/page4.png" srcset="/img/loading.gif"></p>
<h5 id="自增主键有哪些优缺点"><a href="#自增主键有哪些优缺点" class="headerlink" title="自增主键有哪些优缺点?"></a>自增主键有哪些优缺点?</h5><p>优点：</p>
<ul>
<li><p>数据存储空间很小；</p>
</li>
<li><p>性能最好；</p>
</li>
<li><p>减少页分裂。</p>
</li>
</ul>
<p>缺点：</p>
<ul>
<li><p>数据量过大，可能会超出自增长取值范围；</p>
</li>
<li><p>无法满足分布式存储，分库分表的情况下无法合并表；</p>
</li>
<li><p>主键有自增规律，容易被破解；</p>
</li>
</ul>
<p>综上所述：是否需要使用自增主键，需要根据自己的业务场景来设计。如果是单表单库，则优先考虑自增主键，如果是分布式存储，分库分表，则需要考虑数据合并的业务场景来做数据库设计方案。</p>
<h5 id="MySQL-最多可以创建多少个索引列？"><a href="#MySQL-最多可以创建多少个索引列？" class="headerlink" title="MySQL 最多可以创建多少个索引列？"></a>MySQL 最多可以创建多少个索引列？</h5><p>MySQL 中最多可以创建 16 个索引列。</p>
<h5 id="以下-like-查询会使用索引的是哪一个选项？为什么？"><a href="#以下-like-查询会使用索引的是哪一个选项？为什么？" class="headerlink" title="以下 like 查询会使用索引的是哪一个选项？为什么？"></a>以下 like 查询会使用索引的是哪一个选项？为什么？</h5><p>A.like ‘%A%’  B.like ‘%A’  C.like ‘A%’  D.以上都不是 </p>
<p>答：C 题目解析：like 查询要走索引，查询字符不能以通配符（%）开始。</p>
<h5 id="如何让-like-abc-走索引查询？"><a href="#如何让-like-abc-走索引查询？" class="headerlink" title="如何让 like %abc 走索引查询？"></a>如何让 like %abc 走索引查询？</h5><p>我们知道如果要让 like 查询要走索引，查询字符不能以通配符（%）开始，如果要让 like %abc 也走索引，可以使用 REVERSE() 函数来创建一个函数索引，查询脚本如下：</p>
<pre><code class="hljs mysql">select * from t where reverse(f) like reverse(&#39;%abc&#39;);</code></pre>

<h5 id="列值为-NULL-时，查询会使用到索引吗？"><a href="#列值为-NULL-时，查询会使用到索引吗？" class="headerlink" title="列值为 NULL 时，查询会使用到索引吗？"></a>列值为 NULL 时，查询会使用到索引吗？</h5><p>在 MySQL 5.6 以上的 InnoDB 存储引擎会正常触发索引。但为了兼容低版本的 MySQL 和兼容其他数据库存储引擎，不建议使用 NULL 值来存储和查询数据，建议设置列为 NOT NULL，并设置一个默认值，比如 0 和空字符串等，如果是 datetime 类型，可以设置成 1970-01-01 00:00:00 这样的特殊值。</p>
<h5 id="以下语句会走索引么？"><a href="#以下语句会走索引么？" class="headerlink" title="以下语句会走索引么？"></a>以下语句会走索引么？</h5><p><code>select * from t where year(date)&gt;2018;</code></p>
<p>不会，因为在索引列上涉及到了运算。</p>
<h5 id="MySQL-联合索引应该注意什么？"><a href="#MySQL-联合索引应该注意什么？" class="headerlink" title="MySQL 联合索引应该注意什么？"></a>MySQL 联合索引应该注意什么？</h5><p>联合索引又叫复合索引，MySQL 中的联合索引，遵循最左匹配原则，比如，联合索引为 key(a,b,c)，则能触发索引的搜索组合是 a|ab|abc 这三种查询。</p>
<h5 id="联合索引的作用是什么？"><a href="#联合索引的作用是什么？" class="headerlink" title="联合索引的作用是什么？"></a>联合索引的作用是什么？</h5><p>联合索引的作用如下：</p>
<ul>
<li><p>用于多字段查询，比如，建了一个 key(a,b,c) 的联合索引，那么实际等于建了 key(a)、key(a,b)、key(a,b,c) 等三个索引，我们知道，每多一个索引，就会多一些写操作和占用磁盘空间的开销，尤其是对大数据量的表来说，这可以减少一部分不必要的开销；</p>
</li>
<li><p>覆盖索引，比如，对于联合索引 key(a,b,c) 来说，如果使用 SQL：select a,b,c from table where a=1 and b = 1 ，就可以直接通过遍历索引取得数据，而无需回表查询，这就减少了随机的 IO 操作，减少随机的 IO 操作，可以有效的提升数据库查询的性能，是非常重要的数据库优化手段之一；</p>
</li>
<li><p>索引列越多，通过索引筛选出的数据越少。</p>
</li>
</ul>
<h5 id="什么是最左匹配原则？它的生效原则有哪些？"><a href="#什么是最左匹配原则？它的生效原则有哪些？" class="headerlink" title="什么是最左匹配原则？它的生效原则有哪些？"></a>什么是最左匹配原则？它的生效原则有哪些？</h5><p>最左匹配原则也叫最左前缀原则，是 MySQL 中的一个重要原则，说的是索引以最左边的为起点任何连续的索引都能匹配上，当遇到范围查询（&gt;、&lt;、between、like）就会停止匹配。 生效原则来看以下示例，比如表中有一个联合索引字段 index(a,b,c)：</p>
<ul>
<li>where a=1 只使用了索引 a；</li>
<li>where a=1 and b=2 只使用了索引 a,b；</li>
<li>where a=1 and b=2 and c=3 使用a,b,c；</li>
<li>where b=1 or where c=1 不使用索引；</li>
<li>where a=1 and c=3 只使用了索引 a；</li>
<li>where a=3 and b like ‘xx%’ and c=3 只使用了索引 a,b。</li>
</ul>
<h5 id="什么是前缀索引？"><a href="#什么是前缀索引？" class="headerlink" title="什么是前缀索引？"></a>什么是前缀索引？</h5><p>前缀索引也叫局部索引，比如给身份证的前 10 位添加索引，类似这种给某列部分信息添加索引的方式叫做前缀索引。</p>
<h5 id="为什么要用前缀索引？"><a href="#为什么要用前缀索引？" class="headerlink" title="为什么要用前缀索引？"></a>为什么要用前缀索引？</h5><p>前缀索引能有效减小索引文件的大小，让每个索引页可以保存更多的索引值，从而提高了索引查询的速度。但前缀索引也有它的缺点，不能在 order by 或者 group by 中触发前缀索引，也不能把它们用于覆盖索引。</p>
<h5 id="什么情况下适合使用前缀索引？"><a href="#什么情况下适合使用前缀索引？" class="headerlink" title="什么情况下适合使用前缀索引？"></a>什么情况下适合使用前缀索引？</h5><p>当字符串本身可能比较长，而且前几个字符就开始不相同，适合使用前缀索引；相反情况下不适合使用前缀索引，比如，整个字段的长度为 20，索引选择性为 0.9，而我们对前 10 个字符建立前缀索引其选择性也只有 0.5，那么我们需要继续加大前缀字符的长度，但是这个时候前缀索引的优势已经不明显，就没有创建前缀索引的必要了。</p>
<h5 id="什么是覆盖索引？"><a href="#什么是覆盖索引？" class="headerlink" title="什么是覆盖索引？"></a>什么是覆盖索引？</h5><p>覆盖索引是指，索引上的信息足够满足查询请求，不需要再回到主键上去取数据。</p>
<h5 id="什么是页？"><a href="#什么是页？" class="headerlink" title="什么是页？"></a>什么是页？</h5><p>页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页。主存和磁盘以页为单位交换数据。数据库系统的设计者巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次磁盘 IO 就可以完全载入。</p>
<h5 id="索引的常见存储算法有哪些？"><a href="#索引的常见存储算法有哪些？" class="headerlink" title="索引的常见存储算法有哪些？"></a>索引的常见存储算法有哪些？</h5><ul>
<li><p>哈希存储法：以 key、value 方式存储，把值存入数组中使用哈希值确认数据的位置，如果发生哈希冲突，使用链表存储数据；</p>
</li>
<li><p>有序数组存储法：按顺序存储，优点是可以使用二分法快速找到数据，缺点是更新效率，适合静态数据存储；</p>
</li>
<li><p>搜索树：以树的方式进行存储，查询性能好，更新速度快。</p>
</li>
</ul>
<h5 id="InnoDB-为什么要使用-B-树，而不是-B-树、Hash、红黑树或二叉树？"><a href="#InnoDB-为什么要使用-B-树，而不是-B-树、Hash、红黑树或二叉树？" class="headerlink" title="InnoDB 为什么要使用 B+ 树，而不是 B 树、Hash、红黑树或二叉树？"></a>InnoDB 为什么要使用 B+ 树，而不是 B 树、Hash、红黑树或二叉树？</h5><p>因为 B 树、Hash、红黑树或二叉树存在以下问题：</p>
<ul>
<li><p>B 树：不管叶子节点还是非叶子节点，都会保存数据，这样导致在非叶子节点中能保存的指针数量变少（有些资料也称为扇出），指针少的情况下要保存大量数据，只能增加树的高度，导致IO操作变多，查询性能变低；</p>
</li>
<li><p>Hash：虽然可以快速定位，但是没有顺序，IO 复杂度高；</p>
</li>
<li><p>二叉树：树的高度不均匀，不能自平衡，查找效率跟数据有关（树的高度），并且 IO 代价高；</p>
</li>
<li><p>红黑树：树的高度随着数据量增加而增加，IO 代价高。</p>
</li>
</ul>
<h5 id="为什么-InnoDB-要使用-B-树来存储索引？"><a href="#为什么-InnoDB-要使用-B-树来存储索引？" class="headerlink" title="为什么 InnoDB 要使用 B+ 树来存储索引？"></a>为什么 InnoDB 要使用 B+ 树来存储索引？</h5><p>B+Tree 中的 B 是 Balance，是平衡的意思，它在经典 B Tree 的基础上进行了优化，增加了顺序访问指针，在B+Tree 的每个叶子节点增加一个指向相邻叶子节点的指针，就形成了带有顺序访问指针的 B+Tree，这样就提高了区间访问性能：如果要查询 key 为从 18 到 49 的所有数据记录，当找到 18 后，只需顺着节点和指针顺序遍历就可以一次性访问到所有数据节点，极大提到了区间查询效率（无需返回上层父节点重复遍历查找减少 IO 操作）。</p>
<p>索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上，这样的话，索引查找过程中就要产生磁盘 IO 消耗，相对于内存存取，IO 存取的消耗要高几个数量级，所以索引的结构组织要尽量减少查找过程中磁盘 IO 的存取次数，从而提升索引效率。 综合所述，InnDB 只有采取 B+ 树的数据结构存储索引，才能提供数据库整体的操作性能。</p>
<h5 id="优化器选择查询索引的影响因素有哪些？"><a href="#优化器选择查询索引的影响因素有哪些？" class="headerlink" title="优化器选择查询索引的影响因素有哪些？"></a>优化器选择查询索引的影响因素有哪些？</h5><p>优化器的目的是使用最小的代价选择最优的执行方案，影响优化器选择索引的因素如下：</p>
<ul>
<li><p>扫描行数，扫描的行数越少，执行代价就越少，执行效率就会越高；</p>
</li>
<li><p>是否使用了临时表；</p>
</li>
<li><p>是否排序。</p>
</li>
</ul>
<h5 id="MySQL-是如何判断索引扫描行数的多少？"><a href="#MySQL-是如何判断索引扫描行数的多少？" class="headerlink" title="MySQL 是如何判断索引扫描行数的多少？"></a>MySQL 是如何判断索引扫描行数的多少？</h5><p>MySQL 的扫描行数是通过索引统计列（cardinality）大致得到并且判断的，而索引统计列（cardinality）可以通过查询命令 show index 得到，索引扫描行数的多少就是通过这个值进行判断的。</p>
<h5 id="MySQL-是如何得到索引基数的？它准确吗？"><a href="#MySQL-是如何得到索引基数的？它准确吗？" class="headerlink" title="MySQL 是如何得到索引基数的？它准确吗？"></a>MySQL 是如何得到索引基数的？它准确吗？</h5><p>MySQL 的索引基数并不准确，因为 MySQL 的索引基数是通过采样统计得到的，比如 InnoDb 默认会有 N 个数据页，采样统计会统计这些页面上的不同值得到一个平均值，然后除以这个索引的页面数就得到了这个索引基数。</p>
<h5 id="MySQL-如何指定查询的索引？"><a href="#MySQL-如何指定查询的索引？" class="headerlink" title="MySQL 如何指定查询的索引？"></a>MySQL 如何指定查询的索引？</h5><p>在 MySQL 中可以使用 force index 强行选择一个索引，具体查询语句如下：</p>
<pre><code class="hljs mysql">select * from t force index(index_t);</code></pre>

<h5 id="在-MySQL-中指定了查询索引，为什么没有生效？"><a href="#在-MySQL-中指定了查询索引，为什么没有生效？" class="headerlink" title="在 MySQL 中指定了查询索引，为什么没有生效？"></a>在 MySQL 中指定了查询索引，为什么没有生效？</h5><p>我们知道在 MySQL 中使用 force index 可以指定查询的索引，但并不是一定会生效，原因是 MySQL 会根据优化器自己选择索引，如果 force index 指定的索引出现在候选索引上，这个时候 MySQL 不会在判断扫描的行数的多少直接使用指定的索引，如果没在候选索引中，即使 force index 指定了索引也是不会生效的。</p>
<h5 id="以下-or-查询有什么问题吗？该如何优化？"><a href="#以下-or-查询有什么问题吗？该如何优化？" class="headerlink" title="以下 or 查询有什么问题吗？该如何优化？"></a>以下 or 查询有什么问题吗？该如何优化？</h5><p><code>select * from t where num=10 or num=20;</code></p>
<p>答：如果使用 or 查询会使 MySQL 放弃索引而全表扫描，可以改为：</p>
<pre><code class="hljs mysql">select * from t where num&#x3D;10 union select * from t where num&#x3D;20;</code></pre>

<h5 id="以下查询要如何优化？"><a href="#以下查询要如何优化？" class="headerlink" title="以下查询要如何优化？"></a>以下查询要如何优化？</h5><p>表中包含索引：</p>
<ul>
<li><p>KEY mid (mid)</p>
</li>
<li><p>KEY begintime (begintime)</p>
</li>
<li><p>KEY dg (day,group)</p>
</li>
</ul>
<p>使用以下 SQL 进行查询：</p>
<p><code>select f from t where day=&#39;2010-12-31&#39; and group=18 and begintime&lt;&#39;2019-12-31 12:14:28&#39; order by begintime limit 1;</code></p>
<p>答：此查询理论上是使用 dg 索引效率更高，通过 explain 可以对比查询扫描次数。由于使用了 order by begintime 则使查询放弃了 dg 索引，而使用 begintime 索引，从侧面印证 order by 关键字会影响查询使用索引，这时可以使查询强制使用索引，改为以下SQL：</p>
<pre><code class="hljs mysql">select f from t use index(dg) where day&#x3D;&#39;2010-12-31&#39; and group&#x3D;18 and begintime&lt; &#39;2019-12-31 12:14:28&#39; order by begintime limit 1;</code></pre>

<h5 id="MySQL-会错选索引吗？"><a href="#MySQL-会错选索引吗？" class="headerlink" title="MySQL 会错选索引吗？"></a>MySQL 会错选索引吗？</h5><p>MySQL 会错选索引，比如 k 索引的速度更快，但是 MySQL 并没有使用而是采用了 v 索引，这种就叫错选索引，因为索引选择是 MySQL 的服务层的优化器来自动选择的，但它在复杂情况下也和人写程序一样出现缺陷。</p>
<h5 id="如何解决-MySQL-错选索引的问题？"><a href="#如何解决-MySQL-错选索引的问题？" class="headerlink" title="如何解决 MySQL 错选索引的问题？"></a>如何解决 MySQL 错选索引的问题？</h5><ul>
<li><p>删除错选的索引，只留下对的索引；</p>
</li>
<li><p>使用 force index 指定索引；</p>
</li>
<li><p>修改 SQL 查询语句引导 MySQL 使用我们期望的索引，比如把 order by b limit 1 改为 order by b,a limit 1 语义是相同的，但 MySQL 查询的时候会考虑使用 a 键上的索引。</p>
</li>
</ul>
<h5 id="如何优化身份证的索引？"><a href="#如何优化身份证的索引？" class="headerlink" title="如何优化身份证的索引？"></a>如何优化身份证的索引？</h5><p>在中国因为前 6 位代表的是地区，所以很多人的前六位都是相同的，如果我们使用前缀索引为 6 位的话，性能提升也并不是很明显，但如果设置的位数过长，那么占用的磁盘空间也越大，数据页能放下的索引值就越少，搜索效率也越低。针对这种情况优化方案有以下两种：</p>
<ul>
<li><p>使用身份证倒序存储，这样设置前六位的意义就很大了；</p>
</li>
<li><p>使用 hash 值，新创建一个字段用于存储身份证的 hash 值。</p>
</li>
</ul>
<h3 id="MySQL锁原理及案"><a href="#MySQL锁原理及案" class="headerlink" title="MySQL锁原理及案"></a><strong>MySQL锁原理及案</strong></h3><h4 id="锁基础"><a href="#锁基础" class="headerlink" title="锁基础"></a>锁基础</h4><p>按照所里的粒度分类，MySQL主要包含三种类型（级别）的锁定机制：</p>
<ul>
<li>全局锁：锁的是整个datebase，由MySQL的SQL layer层实现</li>
<li>表级锁：锁的是某个table，由MySQL的SQL layer层实现</li>
<li>行级锁：锁的是某行数据，也可能是行之间的间隙，由某些存储引擎实现，比如InnoDB</li>
</ul>
<p>按照锁的功能可以分为：共享读锁和排它写锁</p>
<p>按照锁的实现方式分为：悲观锁和乐观锁</p>
<p>表级锁与行级锁区别</p>
<ul>
<li>表级锁：开销小，加锁块；不会出现死锁；锁粒度大，发生冲突的概率高，并发度低</li>
<li>行级锁：开销大，加锁慢；会出现死锁；锁粒度小，发生锁冲突的概率低，并发度高</li>
</ul>
<p><img src="/images/mysql/lock.png" srcset="/img/loading.gif"></p>
<h4 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h4><p>表级锁有两种：</p>
<ul>
<li>表锁</li>
<li>与数据锁（meta data lock, MDL）</li>
</ul>
<p>查看锁状态</p>
<pre><code class="hljs mysql">mysql&gt;  
+----------------------------+-------+
| Variable_name              | Value |
+----------------------------+-------+
| Table_locks_immediate      | 172   |
| Table_locks_waited         | 0     |
| Table_open_cache_hits      | 61    |
| Table_open_cache_misses    | 10    |
| Table_open_cache_overflows | 0     |
+----------------------------+-------+
5 rows in set (0.05 sec)</code></pre>

<p>表现形式：</p>
<ul>
<li>表共享读锁（Table Read Lock）</li>
<li>表独占写锁（Table Write Lock）</li>
</ul>
<p>手动加锁</p>
<pre><code class="hljs mysql">lock table 表名称 read(write), 表名称2 read(write), 其他；</code></pre>

<p>查看表锁情况</p>
<pre><code class="hljs mysql">show open tables;</code></pre>

<p>删除表锁</p>
<pre><code class="hljs mysql">unlock tables;</code></pre>

<h5 id="操作演示"><a href="#操作演示" class="headerlink" title="操作演示"></a>操作演示</h5><pre><code class="hljs mysql">-- 新建表
 
CREATE TABLE mylock (
	id INT(11) NOT NULL AUTO_INCREMENT,
	name VARCHAR(20) DEFAULT NULL,
	PRIMARY KEY (id)
);
INSERT INTO mylock VALUES(1, &#39;a&#39;);
INSERT INTO mylock VALUES(2, &#39;b&#39;);
INSERT INTO mylock VALUES(3, &#39;c&#39;);
INSERT INTO mylock VALUES(4, &#39;d&#39;);
INSERT INTO mylock VALUES(5, &#39;e&#39;);</code></pre>

<p><img src="/images/mysql/tlock.png" srcset="/img/loading.gif"></p>
<pre><code class="hljs mysql">-- session1
mysql&gt; lock table mylock read;
Query OK, 0 rows affected (0.00 sec)

mysql&gt; select * from mylock;
+----+------+
| id | name |
+----+------+
|  1 | a    |
|  2 | b    |
|  3 | c    |
|  4 | d    |
|  5 | e    |
+----+------+
5 rows in set (0.00 sec)

mysql&gt; select * from dept;
ERROR 1100 (HY000): Table &#39;dept&#39; was not locked with LOCK TABLES
-- session2
mysql&gt; select * from mylock;
+----+------+
| id | name |
+----+------+
|  1 | a    |
|  2 | b    |
|  3 | c    |
|  4 | d    |
|  5 | e    |
+----+------+
5 rows in set (0.00 sec)
mysql&gt; update mylock set name&#x3D;&#39;bb&#39; where id&#x3D;2;  -- 修改阻塞，自动加上行写锁
-- session1
mysql&gt; unlock tables;
Query OK, 0 rows affected (0.00 sec)
-- session2
Query OK, 1 row affected (1 min 35.08 sec)
Rows matched: 1  Changed: 1  Warnings: 0        -- session1解锁后立刻执行
mysql&gt; update mylock set name&#x3D;&#39;b&#39; where id&#x3D;2;    
Query OK, 1 row affected (0.01 sec)
Rows matched: 1  Changed: 1  Warnings: 0
-- session1
mysql&gt; select * from dept;                      -- session1可以访问其他表
+----+------+
| id | name |
+----+------+
|  1 | a    |
|  2 | b    |
|  3 | c    |
|  4 | d    |
|  5 | e    |
+----+------+
5 rows in set (0.00 sec)</code></pre>

<p><img src="/images/mysql/twlock.png" srcset="/img/loading.gif"></p>
<pre><code class="hljs mysql">-- session1
mysql&gt; lock table mylock read;
Query OK, 0 rows affected (0.00 sec)

mysql&gt; select * from mylock;
+----+------+
| id | name |
+----+------+
|  1 | a    |
|  2 | b    |
|  3 | c    |
|  4 | d    |
|  5 | e    |
+----+------+
5 rows in set (0.00 sec)

mysql&gt; select * from dept;
ERROR 1100 (HY000): Table &#39;dept&#39; was not locked with LOCK TABLES
mysql&gt; update mylock set name&#x3D;&#39;b&#39; where id&#x3D;2;   -- session可以修改
Query OK, 1 row affected (0.01 sec)
Rows matched: 1  Changed: 1  Warnings: 0
-- session2
mysql&gt; select * from mylock;                    -- 查询阻塞
-- session1
mysql&gt; unlock tables;
Query OK, 0 rows affected (0.00 sec)
-- session2
+----+------+
| id | name |
+----+------+
|  1 | a    |
|  2 | b    |
|  3 | c    |
|  4 | d    |
|  5 | e    |
+----+------+
5 rows in set (0.00 sec)</code></pre>

<h4 id="元数据锁-MDL"><a href="#元数据锁-MDL" class="headerlink" title="元数据锁(MDL)"></a>元数据锁(MDL)</h4><p><strong>MDL不需要显示使用，在访问一个表的时候会自动加上</strong>。**MDL的锁作用是保证写的正确性，可以想像一下：如果一个查询正在遍历表中的数据，而执行期间另一个线程对这个表结构做变更删除一行，那么查询县城拿到的结果便可能跟当前的表结构对应不上。</p>
<p>因此，在MySQ L5.5版本中引入MDL，<strong>当对一个表中做增删改查操作时，加MDL读锁；当要对表结构变更操作时，加MDL写锁</strong>。</p>
<ul>
<li>读锁之间不互斥，因此可以有多个线程对一行表增删改查</li>
<li>读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性。因此，如果有两个线程同时要给一个表加字段，其中一个要等另一个执行完才能执行。</li>
</ul>
<p><img src="/images/mysql/tmlock.png" srcset="/img/loading.gif"></p>
<pre><code class="hljs mysql">-- session1
mysql&gt; begin;
Query OK, 0 rows affected (0.00 sec)
mysql&gt; select * from mylock;
+----+------+
| id | name |
+----+------+
|  1 | a    |
|  2 | b    |
|  3 | c    |
|  4 | d    |
|  5 | e    |
+----+------+
5 rows in set (0.00 sec)
-- session2
mysql&gt; alter table mylock add dep int;        -- 阻塞
-- session1
mysql&gt; commit;                                -- 释放锁
Query OK, 0 rows affected (0.00 sec)
-- session2
Query OK, 0 rows affected (12.80 sec)         -- 完成修改
Records: 0  Duplicates: 0  Warnings: 0

mysql&gt; desc mylock;
+-------+-------------+------+-----+---------+----------------+
| Field | Type        | Null | Key | Default | Extra          |
+-------+-------------+------+-----+---------+----------------+
| id    | int(11)     | NO   | PRI | NULL    | auto_increment |
| name  | varchar(20) | YES  |     | NULL    |                |
| dep   | int(11)     | YES  |     | NULL    |                |
+-------+-------------+------+-----+---------+----------------+
3 rows in set (0.00 sec)</code></pre>

<h4 id="MySQL行级锁"><a href="#MySQL行级锁" class="headerlink" title="MySQL行级锁"></a>MySQL行级锁</h4><h5 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h5><p>由存储引擎实现，利用存储引擎锁住索引项来实现。</p>
<p>InnoDB的行级锁，按照锁定范围来说，分为三种：</p>
<pre><code class="hljs mysql">- 记录锁（Record locks）:锁定索引中一条记录
- 间隙锁（Gap Locks）:要么锁索引中间的值，要么锁住第一个索引记录前面的值或者最后一个索引后面的值。
- Next-key Locks:是索引记录上的记录锁在索引记录之前的间隙锁的组合</code></pre>

<p>InnoDB的行级锁，按照功能分为两种：</p>
<pre><code class="hljs mysql">- 共享锁（S）:允许一个事务去读一行，阻止其他事务获得相同数据集的排它锁
- 排它锁（S）:允许获得排它锁的事务更新数据，阻止其他事务获得相同数据集的共享读锁(不是读)和排它锁</code></pre>

<p>对于UPDATE、DELETE、INSERT语句，InnoDB会自动给设计数据集加排它锁（X）;</p>
<p>对于普通SELECT语句，InnoDB不回家任何锁，事务可以通过以下语句显示给记录集加共享锁和排它锁。</p>
<p><strong>手动添加共享锁(S)</strong></p>
<pre><code class="hljs mysql">select * from table_name where ... lock in share mode;</code></pre>

<p><strong>手动添加排它锁(X)</strong></p>
<pre><code class="hljs mysql">select * from table_name where ... for update;</code></pre>

<p>InnoDB也实现了表级锁，也就是意向锁。意向锁是mysql内部使用的，不需要用户干预。</p>
<pre><code class="hljs mysql">- 意向共享锁（IS）:事务打算给数据行加行共享锁，事务给一个数据行加行共享锁必须先去的该表的IS锁。
- 意向排它锁（IX）:事务打算给数据行加行排它锁，事务给一个数据行加行排它锁必须先去的该表的IX锁。</code></pre>

<p>意向锁和行锁可以共存，意向锁的主要作用是为了【全表更新数据】是的性能提升。否则在全表更新数据时，需要先检索该表是否有某系记录上面有行锁。</p>
<table>
<thead>
<tr>
<th></th>
<th>共享锁(S)</th>
<th>排它锁(X)</th>
<th>意向共享锁（IS）</th>
<th>意向排它锁（IX）</th>
</tr>
</thead>
<tbody><tr>
<td>共享锁(S)</td>
<td>兼容</td>
<td>冲突</td>
<td>兼容</td>
<td>冲突</td>
</tr>
<tr>
<td>排它锁(X)</td>
<td>冲突</td>
<td>冲突</td>
<td>冲突</td>
<td>冲突</td>
</tr>
<tr>
<td>意向共享锁（IS）</td>
<td>兼容</td>
<td>冲突</td>
<td>兼容</td>
<td>兼容</td>
</tr>
<tr>
<td>意向排它锁（IX）</td>
<td>冲突</td>
<td>冲突</td>
<td>兼容</td>
<td>兼容</td>
</tr>
</tbody></table>
<p><strong>InnoDB行锁</strong>是通过给索引上的<strong>索引项加锁来实现</strong>的，因此InnoDB这种行锁的实现特点意味着：只有通过<strong>索引条件检索的数据</strong>，InnoDB才使用<strong>行级锁</strong>；否则，InnoDB将使用<strong>表级锁</strong></p>
<p>InnoDB锁使用<strong>行级锁</strong>争用状态查看命令</p>
<pre><code class="hljs mysql">mysql&gt; show status like &#39;innodb_row_lock%&#39;;
+-------------------------------+-------+
| Variable_name                 | Value |
+-------------------------------+-------+
| Innodb_row_lock_current_waits | 0     |  -- 当前正在等待锁定的数量
| Innodb_row_lock_time          | 0     |  -- +从系统启动到现在锁定总时间长度
| Innodb_row_lock_time_avg      | 0     |  -- +每次等待锁话平均时间
| Innodb_row_lock_time_max      | 0     |  -- 从系统启动到现在等待最长那次时间
| Innodb_row_lock_waits         | 0     |  -- +从系统启动到现在总共等待的次数
+-------------------------------+-------+
5 rows in set (0.00 sec)</code></pre>

<h5 id="两阶段锁"><a href="#两阶段锁" class="headerlink" title="两阶段锁"></a>两阶段锁</h5><p>传统的RDMS加锁原则就是2PL（Two-Phase Locking,两阶段锁）。相对而言，2PL比较容易理解：加锁阶段与解锁阶段，并且保证加锁阶段与解锁阶段不相交。</p>
<p><img src="/2021/03/21/mysql/mysql/2pl.png" srcset="/img/loading.gif"></p>
<pre><code class="hljs plain">加锁阶段：只加锁，不放锁
解锁阶段：只放锁，不加锁</code></pre>

<h5 id="行读锁"><a href="#行读锁" class="headerlink" title="行读锁"></a>行读锁</h5><pre><code class="hljs mysql">-- session1
mysql&gt; begin;
Query OK, 0 rows affected (0.00 sec)

mysql&gt; select * from mylock where id&#x3D;1 lock in share mode; -- 手动id&#x3D;1加行读锁
+----+------+------+
| id | name | dep  |
+----+------+------+
|  1 | a    | NULL |
+----+------+------+
1 row in set (0.00 sec)
-- session2

mysql&gt; update mylock set name&#x3D;&#39;bb&#39; where id&#x3D;2;  -- 未锁定可以修改
ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction   -- 锁定超时
Query OK, 1 row affected (0.01 sec) 
Rows matched: 1  Changed: 1  Warnings: 0
mysql&gt; update mylock set name&#x3D;&#39;aa&#39; where id&#x3D;1;  -- 锁定不可修改
-- session1
mysql&gt; commit;  -- 提交事务&#x2F;rollback释放锁
Query OK, 0 rows affected (0.00 sec)
-- session2
Query OK, 1 row affected (12.06 sec)
Rows matched: 1  Changed: 1  Warnings: 0</code></pre>

<h5 id="行读锁升级为表锁"><a href="#行读锁升级为表锁" class="headerlink" title="行读锁升级为表锁"></a>行读锁升级为表锁</h5><pre><code class="hljs mysql">-- session1
mysql&gt; begin;
Query OK, 0 rows affected (0.00 sec)
mysql&gt; select * from mylock where name&#x3D;&#39;a&#39; lock in share mode; -- 手动name&#x3D;&#39;a&#39;非索引 行读锁升级表锁
+----+------+------+
| id | name | dep  |
+----+------+------+
|  1 | a    | NULL |
+----+------+------+
1 row in set (0.00 sec)
-- session2
mysql&gt; update mylock set name&#x3D;&#39;b&#39; where id&#x3D;2;  -- 阻塞 不可修改
ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction
mysql&gt; update mylock set name&#x3D;&#39;a&#39; where id&#x3D;1;   -- 阻塞 不可修改
ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction
-- session1
mysql&gt; commit;  -- 提交事务&#x2F;rollback释放锁
Query OK, 0 rows affected (0.00 sec)
-- session2
mysql&gt; update mylock set name&#x3D;&#39;b&#39; where id&#x3D;2;
Query OK, 1 row affected (0.00 sec)
Rows matched: 1  Changed: 1  Warnings: 0
mysql&gt; update mylock set name&#x3D;&#39;a&#39; where id&#x3D;1;
Query OK, 0 rows affected (0.00 sec)
Rows matched: 1  Changed: 0  Warnings: 0</code></pre>

<h5 id="行写锁"><a href="#行写锁" class="headerlink" title="行写锁"></a>行写锁</h5><pre><code class="hljs mysql">-- session1
mysql&gt; begin;
Query OK, 0 rows affected (0.00 sec)

mysql&gt; select * from mylock where id&#x3D;1 for update;
-- session2
mysql&gt; update mylock set name&#x3D;&#39;bb&#39; where id&#x3D;2;  -- 未锁定可以修改
Query OK, 1 row affected (0.01 sec) 
Rows matched: 1  Changed: 1  Warnings: 0
mysql&gt; select * from mylock where id&#x3D;1;  -- select本身不加锁 可以访问
+----+------+------+
| id | name | dep  |
+----+------+------+
|  1 | a    | NULL |
+----+------+------+
1 row in set (0.00 sec)
mysql&gt; select * from mylock where id&#x3D;1 lock in share mode; -- 共享读锁不可获得
ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction 
mysql&gt; update mylock set name&#x3D;&#39;aa&#39; where id&#x3D;1;  -- 锁定不可修改
ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction 
-- session1
mysql&gt; commit;  -- 提交事务&#x2F;rollback释放锁
Query OK, 0 rows affected (0.00 sec)
-- session2
Query OK, 1 row affected (12.06 sec)
Rows matched: 1  Changed: 1  Warnings: 0</code></pre>

<h5 id="行写锁升级为表锁"><a href="#行写锁升级为表锁" class="headerlink" title="行写锁升级为表锁"></a>行写锁升级为表锁</h5><pre><code class="hljs mysql">-- session1
mysql&gt; begin;
Query OK, 0 rows affected (0.00 sec)
mysql&gt; select * from mylock where name&#x3D;&#39;a&#39; for update; -- 手动name&#x3D;&#39;a&#39;非索引 行读锁升级表锁
+----+------+------+
| id | name | dep  |
+----+------+------+
|  1 | a    | NULL |
+----+------+------+
1 row in set (0.00 sec)
-- session2
mysql&gt; select * from mylock;
+----+------+------+
| id | name | dep  |
+----+------+------+
|  1 | a    | NULL |
|  2 | b    | NULL |
|  3 | c    | NULL |
|  4 | d    | NULL |
|  5 | e    | NULL |
+----+------+------+
5 rows in set (0.00 sec)

mysql&gt; select * from mylock where id&#x3D;1;
+----+------+------+
| id | name | dep  |
+----+------+------+
|  1 | a    | NULL |
+----+------+------+
1 row in set (0.00 sec)
mysql&gt; select * from mylock where id&#x3D;1 lock in share mode; -- 阻塞 不可获得锁
ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction
mysql&gt; update mylock set name&#x3D;&#39;b&#39; where id&#x3D;2;  -- 阻塞 不可修改
ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction
mysql&gt; update mylock set name&#x3D;&#39;a&#39; where id&#x3D;1;   -- 阻塞 不可修改
ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction
-- session1
mysql&gt; commit;  -- 提交事务&#x2F;rollback释放锁
Query OK, 0 rows affected (0.00 sec)
-- session2
mysql&gt; update mylock set name&#x3D;&#39;b&#39; where id&#x3D;2;
Query OK, 1 row affected (0.00 sec)
Rows matched: 1  Changed: 1  Warnings: 0
mysql&gt; update mylock set name&#x3D;&#39;a&#39; where id&#x3D;1;
Query OK, 0 rows affected (0.00 sec)
Rows matched: 1  Changed: 0  Warnings: 0</code></pre>

<h5 id="间隙锁"><a href="#间隙锁" class="headerlink" title="间隙锁"></a>间隙锁</h5><pre><code class="hljs mysql">create table news(id int, number int, primary key(id), index idx_num(number));
insert into news values(1,2);
insert into news values(3,4);
insert into news values(6,5);
insert into news values(8,5);
insert into news values(10,5);
insert into news values(13,11);
mysql&gt; select * from news;
+----+--------+
| id | number |  # id主键 索引 number
+----+--------+
|  1 |      2 |
|  3 |      4 |
|  6 |      5 |
|  8 |      5 |
| 10 |      5 |
| 13 |     11 |
+----+--------+
6 rows in set (0.01 sec)

-- session1
mysql&gt; start transaction;
Query OK, 0 rows affected (0.00 sec)
mysql&gt; select * from news where number&#x3D;4 for update;
-- id在2、5之间和3-5之间且number2-6在均被锁住
+----+--------+
| id | number |
+----+--------+
|  3 |      4 |
+----+--------+
1 row in set (0.01 sec)
-- session2
mysql&gt; start transaction;
mysql&gt; insert into news values(2,4);  -- 阻塞
ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction
mysql&gt; insert into news values(2,2);  -- 阻塞
ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction
mysql&gt; insert into news values(4,4);  -- 阻塞
ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction
mysql&gt; insert into news values(4,5);  -- 阻塞
ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction
mysql&gt; insert into news values(5,7);
Query OK, 1 row affected (0.00 sec)
mysql&gt; insert into news values(7,5);
Query OK, 1 row affected (0.01 sec)
mysql&gt; insert into news values(9,5);
Query OK, 1 row affected (0.01 sec)
mysql&gt; insert into news values(11,5);
Query OK, 1 row affected (0.01 sec)

insert into news values(13,11);
mysql&gt; select * from news;
mysql&gt; select * from news;
+----+--------+
| id | number |
+----+--------+
|  1 |      2 |
|  3 |      4 |
|  6 |      5 |
|  8 |      5 |
| 10 |      5 |
| 13 |     11 |
+----+--------+
6 rows in set (0.01 sec)
-- session1
mysql&gt; start transaction;
Query OK, 0 rows affected (0.00 sec)
mysql&gt; select * from news where number&#x3D;13 for update;
      （select * from news where id&gt;1 and id&lt;4 for update;）
mysql&gt; start transaction;
mysql&gt; insert into news values(11,5);
Query OK, 1 row affected (0.00 sec)
mysql&gt; insert into news values(12,11);
Query OK, 1 row affected (0.00 sec)
mysql&gt; insert into news values(14,11);
ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction
mysql&gt; insert into news values(15,12);
ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction
检索条件number&#x3D;13，想做取得最靠近的值11作为作区间，向右由于没有记录因此取得无穷大作为右区间，即session1间隙锁区间（11，无穷大）
</code></pre>

<h5 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h5><p>两个session互相等待对方的释放资源之后，才能释放自己的资源</p>
<pre><code class="hljs mysql">-- session1
mysql&gt;begin;
Query OK, 0 rows affected (0.00 sec)
mysql&gt;update mylock set name&#x3D;&#39;m&#39; where id&#x3D;1;  -- 手动加行写锁 id&#x3D;1,使用索引
Query OK, 1 row affected (0.00 sec)
Rows matched: 1  Changed: 1  Warnings: 0
-- session2
mysql&gt;begin;
Query OK, 0 rows affected (0.00 sec)
mysql&gt;update mylock set name&#x3D;&#39;m&#39; where id&#x3D;2;  -- 手动加行写锁 id&#x3D;2,使用索引
Query OK, 1 row affected (0.00 sec)
Rows matched: 1  Changed: 1  Warnings: 0
-- session1
mysql&gt;update mylock set name&#x3D;&#39;nn&#39; where id&#x3D;2; -- 加写锁被阻塞
-- session2
mysql&gt;update mylock set name&#x3D;&#39;nn&#39; where id&#x3D;1; -- 加写锁会死锁 不允许操作
ERROR 1213 (40001): Deadlock found when trying to get lock; try restarting transaction</code></pre>

<h4 id="相关面试题-1"><a href="#相关面试题-1" class="headerlink" title="相关面试题"></a>相关面试题</h4><h5 id="什么是锁？MySQL-中提供了几类锁？"><a href="#什么是锁？MySQL-中提供了几类锁？" class="headerlink" title="什么是锁？MySQL 中提供了几类锁？"></a>什么是锁？MySQL 中提供了几类锁？</h5><p>锁是实现数据库并发控制的重要手段，可以保证数据库在多人同时操作时能够正常运行。MySQL 提供了全局锁、行级锁、表级锁。其中 InnoDB 支持表级锁和行级锁，MyISAM 只支持表级锁。</p>
<h5 id="什么是全局锁？它的应用场景有哪些？"><a href="#什么是全局锁？它的应用场景有哪些？" class="headerlink" title="什么是全局锁？它的应用场景有哪些？"></a>什么是全局锁？它的应用场景有哪些？</h5><p>全局锁就是对整个数据库实例加锁，它的典型使用场景就是做全库逻辑备份。 这个命令可以使整个库处于只读状态。使用该命令之后，数据更新语句、数据定义语句、更新类事务的提交语句等操作都会被阻塞。</p>
<h5 id="什么是共享锁？"><a href="#什么是共享锁？" class="headerlink" title="什么是共享锁？"></a>什么是共享锁？</h5><p>共享锁又称读锁 (read lock)，是读取操作创建的锁。其他用户可以并发读取数据，但任何事务都不能对数据进行修改（获取数据上的排他锁），直到已释放所有共享锁。当如果事务对读锁进行修改操作，很可能会造成死锁。</p>
<h5 id="什么是排它锁？"><a href="#什么是排它锁？" class="headerlink" title="什么是排它锁？"></a>什么是排它锁？</h5><p>排他锁 exclusive lock（也叫 writer lock）又称写锁。</p>
<p>若某个事物对某一行加上了排他锁，只能这个事务对其进行读写，在此事务结束之前，其他事务不能对其进行加任何锁，其他进程可以读取,不能进行写操作，需等待其释放。</p>
<p>排它锁是悲观锁的一种实现，在上面悲观锁也介绍过。</p>
<p>若事务 1 对数据对象 A 加上 X 锁，事务 1 可以读 A 也可以修改 A，其他事务不能再对 A 加任何锁，直到事物 1 释放 A 上的锁。这保证了其他事务在事物 1 释放 A 上的锁之前不能再读取和修改 A。排它锁会阻塞所有的排它锁和共享锁。</p>
<h5 id="InnoDB-存储引擎有几种锁算法？"><a href="#InnoDB-存储引擎有几种锁算法？" class="headerlink" title="InnoDB 存储引擎有几种锁算法？"></a>InnoDB 存储引擎有几种锁算法？</h5><ul>
<li><p>Record Lock — 单个行记录上的锁；</p>
</li>
<li><p> Gap Lock — 间隙锁，锁定一个范围，不包括记录本身；</p>
</li>
<li><p>Next-Key Lock — 锁定一个范围，包括记录本身。</p>
</li>
</ul>
<h5 id="使用全局锁会导致什么问题？"><a href="#使用全局锁会导致什么问题？" class="headerlink" title="使用全局锁会导致什么问题？"></a>使用全局锁会导致什么问题？</h5><p>如果在主库备份，在备份期间不能更新，业务停摆，所以更新业务会处于等待状态。</p>
<p>如果在从库备份，在备份期间不能执行主库同步的 binlog，导致主从延迟。</p>
<h5 id="如何处理逻辑备份时，整个数据库不能插入的情况？"><a href="#如何处理逻辑备份时，整个数据库不能插入的情况？" class="headerlink" title="如何处理逻辑备份时，整个数据库不能插入的情况？"></a>如何处理逻辑备份时，整个数据库不能插入的情况？</h5><p>如果使用全局锁进行逻辑备份就会让整个库成为只读状态，幸好官方推出了一个逻辑备份工具 MySQLdump 来解决了这个问题，只需要在使用 MySQLdump 时，使用参数 -single-transaction 就会在导入数据之前启动一个事务来保证数据的一致性，并且这个过程是支持数据更新操作的。</p>
<h5 id="如何设置数据库为全局只读锁？"><a href="#如何设置数据库为全局只读锁？" class="headerlink" title="如何设置数据库为全局只读锁？"></a>如何设置数据库为全局只读锁？</h5><p>使用命令 <code>flush tables with read lock</code>（简称 FTWRL）就可以实现设置数据库为全局只读锁。</p>
<h5 id="除了-FTWRL-可以设置数据库只读外，还有什么别的方法？"><a href="#除了-FTWRL-可以设置数据库只读外，还有什么别的方法？" class="headerlink" title="除了 FTWRL 可以设置数据库只读外，还有什么别的方法？"></a>除了 FTWRL 可以设置数据库只读外，还有什么别的方法？</h5><p>除了使用 FTWRL 外，还可以使用命令 <code>set global readonly=true</code> 设置数据库为只读。</p>
<h5 id="FTWRL-和-set-global-readonly-true-有什么区别？"><a href="#FTWRL-和-set-global-readonly-true-有什么区别？" class="headerlink" title="FTWRL 和 set global readonly=true 有什么区别？"></a>FTWRL 和 set global readonly=true 有什么区别？</h5><p>FTWRL 和 set global readonly=true 都是设置整个数据库为只读状态，但他们最大的区别就是，当执行 FTWRL 的客户端断开之后，整个数据库会取消只读，而 set global readonly=true 会一直让数据处于只读状态。</p>
<h5 id="如何实现表锁？"><a href="#如何实现表锁？" class="headerlink" title="如何实现表锁？"></a>如何实现表锁？</h5><p>MySQL 里标记锁有两种：表级锁、元数据锁（meta data lock）简称 MDL。表锁的语法是 lock tables t read/write。</p>
<p>可以用 unlock tables 主动释放锁，也可以在客户端断开的时候自动释放。lock tables 语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象。</p>
<p>对于 InnoDB 这种支持行锁的引擎，一般不使用 lock tables 命令来控制并发，毕竟锁住整个表的影响面还是太大。</p>
<p>MDL：不需要显式使用，在访问一个表的时候会被自动加上。</p>
<p>MDL 的作用：保证读写的正确性。</p>
<p>在对一个表做增删改查操作的时候，加 MDL 读锁；当要对表做结构变更操作的时候，加 MDL 写锁。</p>
<p>读锁之间不互斥，读写锁之间，写锁之间是互斥的，用来保证变更表结构操作的安全性。</p>
<p>MDL 会直到事务提交才会释放，在做表结构变更的时候，一定要小心不要导致锁住线上查询和更新。</p>
<h5 id="InnoDB-如何实现行锁？"><a href="#InnoDB-如何实现行锁？" class="headerlink" title="InnoDB 如何实现行锁？"></a>InnoDB 如何实现行锁？</h5><p>行级锁是 MySQL 中粒度最小的一种锁，他能大大减少数据库操作的冲突。</p>
<p>INNODB 的行级锁有共享锁（S LOCK）和排他锁（X LOCK）两种。共享锁允许事物读一行记录，不允许任何线程对该行记录进行修改。排他锁允许当前事物删除或更新一行记录，其他线程不能操作该记录。</p>
<p>共享锁：SELECT … LOCK IN SHARE MODE，MySQL 会对查询结果集中每行都添加共享锁，前提是当前线程没有对该结果集中的任何行使用排他锁，否则申请会阻塞。</p>
<p>排他锁：select * from t where id=1 for update，其中 id 字段必须有索引，MySQL 会对查询结果集中每行都添加排他锁，在事物操作中，任何对记录的更新与删除操作会自动加上排他锁。前提是当前没有线程对该结果集中的任何行使用排他锁或共享锁，否则申请会阻塞。</p>
<h5 id="悲观锁和乐观锁有什么区别？"><a href="#悲观锁和乐观锁有什么区别？" class="headerlink" title="悲观锁和乐观锁有什么区别？"></a>悲观锁和乐观锁有什么区别？</h5><p>顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会 block 直到它拿到锁。正因为如此，悲观锁需要耗费较多的时间，另外与乐观锁相对应的，悲观锁是由数据库自己实现了的，要用的时候，我们直接调用数据库的相关语句就可以了。</p>
<p>说到这里，由悲观锁涉及到的另外两个锁概念就出来了，它们就是共享锁与排它锁。共享锁和排它锁是悲观锁的不同的实现，它俩都属于悲观锁的范畴。</p>
<p>乐观锁是用数据版本（Version）记录机制实现，这是乐观锁最常用的一种实现方式。何谓数据版本？即为数据增加一个版本标识，一般是通过为数据库表增加一个数字类型的 version 字段来实现。当读取数据时，将 version 字段的值一同读出，数据每更新一次，对此 version 值加 1。当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的version值进行比对，如果数据库表当前版本号与第一次取出来的 version 值相等，则予以更新，否则认为是过期数据。</p>
<p>比如：</p>
<p>1、数据库表三个字段，分别是<code>id、value、version</code> <code>select id,value,version from t where id=#&#123;id&#125; </code></p>
<p>2、每次更新表中的value字段时，为了防止发生冲突，需要这样操作</p>
<p><code>update t set value=2,version=version+1 where id=#&#123;id&#125; and version=#&#123;version&#125;</code></p>
<h5 id="乐观锁有什么优点和缺点？"><a href="#乐观锁有什么优点和缺点？" class="headerlink" title="乐观锁有什么优点和缺点？"></a>乐观锁有什么优点和缺点？</h5><p>因为没有加锁所以乐观锁的优点就是执行性能高。它的缺点就是有可能产生 ABA 的问题，ABA 问题指的是有一个变量 V 初次读取的时候是 A 值，并且在准备赋值的时候检查到它仍然是 A 值，会误以为没有被修改会正常的执行修改操作，实际上这段时间它的值可能被改了其他值，之后又改回为 A 值，这个问题被称为 ABA 问题。</p>
<h5 id="优化锁方面你有什么建议？"><a href="#优化锁方面你有什么建议？" class="headerlink" title="优化锁方面你有什么建议？"></a>优化锁方面你有什么建议？</h5><ul>
<li><p>尽量使用较低的隔离级别。</p>
</li>
<li><p>精心设计索引， 并尽量使用索引访问数据， 使加锁更精确， 从而减少锁冲突的机会。</p>
</li>
<li><p>选择合理的事务大小，小事务发生锁冲突的几率也更小。</p>
</li>
<li><p>给记录集显示加锁时，最好一次性请求足够级别的锁。比如要修改数据的话，最好直接申请排他锁，而不是先申请共享锁，修改时再请求排他锁，这样容易产生死锁。</p>
</li>
<li><p>不同的程序访问一组表时，应尽量约定以相同的顺序访问各表，对一个表而言，尽可能以固定的顺序存取表中的行。这样可以大大减少死锁的机会。</p>
</li>
<li><p>尽量用相等条件访问数据，这样可以避免间隙锁对并发插入的影响。</p>
</li>
<li><p>不要申请超过实际需要的锁级别。</p>
</li>
<li><p>除非必须，查询时不要显示加锁。 MySQL 的 MVCC 可以实现事务中的查询不用加锁，优化事务性能；MVCC 只在 COMMITTED READ（读提交）和 REPEATABLE READ（可重复读）两种隔离级别下工作。</p>
</li>
<li><p>对于一些特定的事务，可以使用表锁来提高处理速度或减少死锁的可能。</p>
</li>
</ul>
<h5 id="什么是死锁？"><a href="#什么是死锁？" class="headerlink" title="什么是死锁？"></a>什么是死锁？</h5><p>是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象,若无外力作用,它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的过程称为死锁。</p>
<p>死锁是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象,若无外力作用,它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的过程称为死锁。</p>
<h5 id="常见的死锁案例有哪些？"><a href="#常见的死锁案例有哪些？" class="headerlink" title="常见的死锁案例有哪些？"></a>常见的死锁案例有哪些？</h5><ul>
<li><p>将投资的钱拆封几份借给借款人，这时处理业务逻辑就要把若干个借款人一起锁住<code> select * from xxx where id in (xx,xx,xx) for update</code>。</p>
</li>
<li><p>批量入库，存在则更新，不存在则插入。解决方法<code> insert into tab(xx,xx) on duplicate key update xx=&#39;xx&#39;</code>。</p>
</li>
</ul>
<h5 id="如何处理死锁？"><a href="#如何处理死锁？" class="headerlink" title="如何处理死锁？"></a>如何处理死锁？</h5><p>对待死锁常见的两种策略：</p>
<ul>
<li><p>通过<code> innodblockwait_timeout</code> 来设置超时时间，一直等待直到超时；</p>
</li>
<li><p>发起死锁检测，发现死锁之后，主动回滚死锁中的某一个事务，让其它事务继续执行。</p>
</li>
</ul>
<h5 id="如何查看死锁？"><a href="#如何查看死锁？" class="headerlink" title="如何查看死锁？"></a>如何查看死锁？</h5><ul>
<li><p>使用命令 show engine innodb status 查看最近的一次死锁。</p>
</li>
<li><p>InnoDB Lock Monitor 打开锁监控，每 15s 输出一次日志。使用完毕后建议关闭，否则会影响数据库性能。</p>
</li>
</ul>
<h5 id="如何避免死锁？"><a href="#如何避免死锁？" class="headerlink" title="如何避免死锁？"></a>如何避免死锁？</h5><ul>
<li><p>为了在单个 InnoDB 表上执行多个并发写入操作时避免死锁，可以在事务开始时通过为预期要修改的每个元祖（行）使用 SELECT … FOR UPDATE 语句来获取必要的锁，即使这些行的更改语句是在之后才执行的。</p>
</li>
<li><p>在事务中，如果要更新记录，应该直接申请足够级别的锁，即排他锁，而不应先申请共享锁、更新时再申请排他锁，因为这时候当用户再申请排他锁时，其他事务可能又已经获得了相同记录的共享锁，从而造成锁冲突，甚至死锁</p>
</li>
<li><p>如果事务需要修改或锁定多个表，则应在每个事务中以相同的顺序使用加锁语句。在应用中，如果不同的程序会并发存取多个表，应尽量约定以相同的顺序来访问表，这样可以大大降低产生死锁的机会</p>
</li>
<li><p>通过 <code>SELECT … LOCK IN SHARE MODE </code>获取行的读锁后，如果当前事务再需要对该记录进行更新操作，则很有可能造成死锁。</p>
</li>
<li><p>改变事务隔离级别。</p>
</li>
</ul>
<h5 id="InnoDB-默认是如何对待死锁的？"><a href="#InnoDB-默认是如何对待死锁的？" class="headerlink" title="InnoDB 默认是如何对待死锁的？"></a>InnoDB 默认是如何对待死锁的？</h5><p>InnoDB 默认是使用设置死锁时间来让死锁超时的策略，默认 innodblockwait_timeout 设置的时长是 50s。</p>
<h5 id="如何开启死锁检测？"><a href="#如何开启死锁检测？" class="headerlink" title="如何开启死锁检测？"></a>如何开启死锁检测？</h5><p>设置 <code>innodbdeadlockdetect </code>设置为 on 可以主动检测死锁，在 Innodb 中这个值默认就是 on 开启的状态。</p>
<h3 id="MySQL分库分表原理及实践"><a href="#MySQL分库分表原理及实践" class="headerlink" title="MySQL分库分表原理及实践"></a>MySQL分库分表原理及实践</h3><h4 id="MyCat"><a href="#MyCat" class="headerlink" title="MyCat"></a>MyCat</h4><p><img src="/images/mysql/mycat.png" srcset="/img/loading.gif"></p>
<h5 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h5><ul>
<li>Schema：由它指定逻辑数据库（相当于MySQL的datebase数据库）</li>
<li>Table：逻辑表（相当于MySQL的table表）</li>
<li>DataNode：真正存储数据的物理节点</li>
<li>DateHost：存储节点所在的数据库主机（指定MySQL数据库的连接信息）</li>
<li>User：MyCat用户（类似于MySQL的用户，支持多用户）</li>
</ul>
<h5 id="主要解决问题"><a href="#主要解决问题" class="headerlink" title="主要解决问题"></a>主要解决问题</h5><ul>
<li>海量数据存储</li>
<li>查询优化</li>
</ul>
<h5 id="支持数据库"><a href="#支持数据库" class="headerlink" title="支持数据库"></a>支持数据库</h5><p><img src="/images/mysql/catdb.png" srcset="/img/loading.gif"></p>
<h5 id="分片策略"><a href="#分片策略" class="headerlink" title="分片策略"></a>分片策略</h5><p>MyCAT支持水平分片语垂直分片：</p>
<ul>
<li>水平分片：一个表格的数据分割到多个节点上，按照行分割。</li>
<li>垂直分片：一个数据库中多个表A,B,C，A存储到节点1，B存储到节点2，C存储到节点3。</li>
</ul>
<p><img src="/images/mysql/catdate.png" srcset="/img/loading.gif"></p>
<p><img src="/images/mysql/catdate2.png" srcset="/img/loading.gif"></p>
<p>MyCAT通过定义表的分片规则来实现分片，没个表格可以捆绑一个分片规则，每个分片规则制定一个分片字段并绑定一个函数，来实现动态分片算法。</p>
<ul>
<li>Schema：逻辑库，与MySQL的datebase数据对应，一个逻辑库中定义了所有包括的Table。</li>
<li>Table：表，即物理数据库中存储的某张表，与传统数据库不同，这里的表格需要声明其所存储的逻辑数据节点DataNode。<strong>可以指定表的分片规则</strong></li>
<li>DataNode：MyCAT的逻辑数据节点，是存放Table的具体物理节点，也称之为分片节点，通过DateHost来关联到后段某个具体数据库上。</li>
<li>DateHost：定义某个物理库的访问地址，用于捆绑到DataNode上。</li>
</ul>
<h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><pre><code class="hljs zsh"><span class="hljs-comment"># 下载</span>
wget http://dl.mycat.org.cn/1.6.7.4/Mycat-server-1.6.7.4-release/Mycat-server-1.6.7.4-release-20200105164103-linux.tar.gz

<span class="hljs-comment"># 解压</span>
tar -zxvf Mycat-server-1.6.7.4-release-20200105164103-linux.tar.gz /weitrue/install

<span class="hljs-comment"># 进入mycat目录</span>
<span class="hljs-built_in">cd</span> /weitrue/install/mycat

<span class="hljs-comment"># 启动/关闭  进入mycat/bin下</span>
./mycat start     <span class="hljs-comment"># 启动</span>
./mycat stop      <span class="hljs-comment"># 关闭</span>
./mycat restart   <span class="hljs-comment"># 重启</span>
./mycat status    <span class="hljs-comment"># 状态</span>

<span class="hljs-comment"># 使用mysql客户端直接连接mycat服务,默认端口【8066】</span>
mysql -uroot -p123456 -h127.0.0.1 -P8066</code></pre>

<h5 id="分片设置"><a href="#分片设置" class="headerlink" title="分片设置"></a>分片设置</h5><h6 id="配置schema-xml文件"><a href="#配置schema-xml文件" class="headerlink" title="配置schema.xml文件"></a>配置schema.xml文件</h6><p><code>schema.xml</code>是Mycat中重要的配置文件之一，主要管理着MyCAT的逻辑库、表、分片规则、DataNode以及DateHost之间的映射关系。</p>
<ul>
<li><code>&lt;schema&gt;</code>定义Mycat实例中的逻辑库。<ul>
<li><code>&lt;table&gt;</code>定义Mycat中的逻辑表。</li>
</ul>
</li>
<li><code>&lt;dataNode&gt;</code>定义了Mycat的数据节点，即数据分片。</li>
<li><code>&lt;dataHost&gt;</code>定义了具体的数据库实例、读写分离配置和心跳语句。</li>
</ul>
<pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot;?&gt;</span>
<span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">mycat</span>:schema <span class="hljs-meta-keyword">SYSTEM</span> <span class="hljs-meta-string">&quot;schema.dtd&quot;</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">mycat:schema</span> <span class="hljs-attr">xmlns:mycat</span>=<span class="hljs-string">&quot;http://io.mycat/&quot;</span>&gt;</span>
				<span class="hljs-comment">&lt;!-- </span>
<span class="hljs-comment">						schema:逻辑库 name：逻辑库名 sqlMaxLimit 一次去多少条数据，如果超过limit</span>
<span class="hljs-comment">              table 逻辑表</span>
<span class="hljs-comment">                dataNode 数据节点 对应 dataNode标签名</span>
<span class="hljs-comment">                rule 分片规则 对应rule.xml</span>
<span class="hljs-comment">                subTables	字表		</span>
<span class="hljs-comment">                primaryKey 分片主键 可缓存</span>
<span class="hljs-comment"> 				--&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">schema</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;TESTDB&quot;</span> <span class="hljs-attr">checkSQLschema</span>=<span class="hljs-string">&quot;false&quot;</span> <span class="hljs-attr">sqlMaxLimit</span>=<span class="hljs-string">&quot;100&quot;</span> <span class="hljs-attr">randomDataNode</span>=<span class="hljs-string">&quot;dn1&quot;</span>&gt;</span>
                <span class="hljs-comment">&lt;!-- auto sharding by id (long) --&gt;</span>
                <span class="hljs-comment">&lt;!--splitTableNames 启用&lt;table name 属性使用逗号分割配置多个表,即多个表使用这个配置--&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;item&quot;</span> <span class="hljs-attr">dataNode</span>=<span class="hljs-string">&quot;dn1,dn2,dn3&quot;</span> <span class="hljs-attr">rule</span>=<span class="hljs-string">&quot;mod-long&quot;</span> <span class="hljs-attr">primaryKey</span>=<span class="hljs-string">&quot;ID&quot;</span>/&gt;</span>               
        <span class="hljs-tag">&lt;/<span class="hljs-name">schema</span>&gt;</span>
  
        <span class="hljs-comment">&lt;!-- &lt;dataNode name=&quot;dn1$0-743&quot; dataHost=&quot;localhost1&quot; database=&quot;db$0-743&quot;/&gt; --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dataNode</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dn1&quot;</span> <span class="hljs-attr">dataHost</span>=<span class="hljs-string">&quot;localhost1&quot;</span> <span class="hljs-attr">database</span>=<span class="hljs-string">&quot;db1&quot;</span> /&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dataNode</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dn2&quot;</span> <span class="hljs-attr">dataHost</span>=<span class="hljs-string">&quot;localhost1&quot;</span> <span class="hljs-attr">database</span>=<span class="hljs-string">&quot;db2&quot;</span> /&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dataNode</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dn3&quot;</span> <span class="hljs-attr">dataHost</span>=<span class="hljs-string">&quot;localhost1&quot;</span> <span class="hljs-attr">database</span>=<span class="hljs-string">&quot;db3&quot;</span> /&gt;</span>
				<span class="hljs-comment">&lt;!-- </span>
<span class="hljs-comment">						dataHost:数据主机</span>
<span class="hljs-comment">            balance 1:读写分离 0:读写不分离</span>
<span class="hljs-comment">            writeType 0:第一个writrHost写 1:随机writrHost写</span>
<span class="hljs-comment">            dbDriver 数据驱动 native: MySQL JDBC:Oracle SQLServer</span>
<span class="hljs-comment">            switchType	是否主动读 1:主从自动切换 -1:不切换 2:当从机延时超过slaveThreshold(毫秒级)值时切换为主读		</span>
<span class="hljs-comment"> 				--&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dataHost</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;localhost1&quot;</span> <span class="hljs-attr">maxCon</span>=<span class="hljs-string">&quot;1000&quot;</span> <span class="hljs-attr">minCon</span>=<span class="hljs-string">&quot;10&quot;</span> <span class="hljs-attr">balance</span>=<span class="hljs-string">&quot;0&quot;</span></span>
<span class="hljs-tag">                          <span class="hljs-attr">writeType</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">dbType</span>=<span class="hljs-string">&quot;mysql&quot;</span> <span class="hljs-attr">dbDriver</span>=<span class="hljs-string">&quot;native&quot;</span> <span class="hljs-attr">switchType</span>=<span class="hljs-string">&quot;1&quot;</span>  <span class="hljs-attr">slaveThreshold</span>=<span class="hljs-string">&quot;100&quot;</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">heartbeat</span>&gt;</span>select user()<span class="hljs-tag">&lt;/<span class="hljs-name">heartbeat</span>&gt;</span>
                <span class="hljs-comment">&lt;!-- can have multi write hosts --&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">writeHost</span> <span class="hljs-attr">host</span>=<span class="hljs-string">&quot;hostM1&quot;</span> <span class="hljs-attr">url</span>=<span class="hljs-string">&quot;localhost:3306&quot;</span> <span class="hljs-attr">user</span>=<span class="hljs-string">&quot;root&quot;</span> <span class="hljs-attr">password</span>=<span class="hljs-string">&quot;123456&quot;</span>&gt;</span>
                <span class="hljs-tag">&lt;/<span class="hljs-name">writeHost</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dataHost</span>&gt;</span></code></pre>

<h6 id="rule-xml"><a href="#rule-xml" class="headerlink" title="rule.xml"></a><code>rule.xml</code></h6><p><code>rule.xml</code>定义我们对表拆分涉及到的规则定义。</p>
<pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>
<span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">mycat</span>:rule <span class="hljs-meta-keyword">SYSTEM</span> <span class="hljs-meta-string">&quot;rule.dtd&quot;</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">mycat:rule</span> <span class="hljs-attr">xmlns:mycat</span>=<span class="hljs-string">&quot;http://io.mycat/&quot;</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">tableRule</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;mod-long&quot;</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">rule</span>&gt;</span>
                        <span class="hljs-tag">&lt;<span class="hljs-name">columns</span>&gt;</span>id<span class="hljs-tag">&lt;/<span class="hljs-name">columns</span>&gt;</span>
                        <span class="hljs-tag">&lt;<span class="hljs-name">algorithm</span>&gt;</span>mod-long<span class="hljs-tag">&lt;/<span class="hljs-name">algorithm</span>&gt;</span>
                <span class="hljs-tag">&lt;/<span class="hljs-name">rule</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">tableRule</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">function</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;mod-long&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;io.mycat.route.function.PartitionByMod&quot;</span>&gt;</span>
                <span class="hljs-comment">&lt;!-- how many data nodes --&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;count&quot;</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">function</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">mycat:rule</span>&gt;</span></code></pre>

<h6 id="server-xml"><a href="#server-xml" class="headerlink" title="server.xml"></a><code>server.xml</code></h6><pre><code class="hljs xml"></code></pre>

<h6 id="十大分片规则"><a href="#十大分片规则" class="headerlink" title="十大分片规则"></a>十大分片规则</h6><p><strong>连续分片</strong></p>
<ul>
<li>日期分片<ul>
<li>按月</li>
<li>按日</li>
<li>按小时</li>
</ul>
</li>
<li>范围约定：配置简单，即预先制定可能的id范围对应某个分片<ul>
<li>优势：扩容无需迁移数据</li>
<li>缺点：热点数据，并发受限</li>
</ul>
</li>
</ul>
<p><strong>离散分片</strong></p>
<ul>
<li>枚举法</li>
<li>求模法</li>
<li>字符串拆分hash法</li>
<li>固定分片hash法</li>
<li>一致性哈希（解决扩容问题）</li>
<li>编程指定</li>
</ul>
<p><strong>综合分片</strong></p>
<ul>
<li>通配取模</li>
<li>ASCii码求模通配</li>
</ul>
<h5 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h5><p>建立在MySQL主从复制的基础上实现，必须搭建MySQL的主从复制。</p>
<p><img src="/images/mysql/mycatrw.png" srcset="/img/loading.gif"></p>
<pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- &lt;dataNode name=&quot;dn1$0-743&quot; dataHost=&quot;localhost1&quot; database=&quot;db$0-743&quot;/&gt; --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dataNode</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dn1&quot;</span> <span class="hljs-attr">dataHost</span>=<span class="hljs-string">&quot;localhost1&quot;</span> <span class="hljs-attr">database</span>=<span class="hljs-string">&quot;db1&quot;</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dataNode</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dn2&quot;</span> <span class="hljs-attr">dataHost</span>=<span class="hljs-string">&quot;localhost1&quot;</span> <span class="hljs-attr">database</span>=<span class="hljs-string">&quot;db2&quot;</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dataNode</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dn3&quot;</span> <span class="hljs-attr">dataHost</span>=<span class="hljs-string">&quot;localhost1&quot;</span> <span class="hljs-attr">database</span>=<span class="hljs-string">&quot;db3&quot;</span> /&gt;</span>
<span class="hljs-comment">&lt;!-- </span>
<span class="hljs-comment">		dataHost:数据主机</span>
<span class="hljs-comment">        balance 1:读写分离 0:读写不分离</span>
<span class="hljs-comment">        writeType 0:第一个writrHost写 1:随机writrHost写</span>
<span class="hljs-comment">        dbDriver 数据驱动 native: MySQL JDBC:Oracle SQLServer</span>
<span class="hljs-comment">        switchType	是否主动读 1:主从自动切换 -1:不切换 2:当从机延时超过slaveThreshold(毫秒级)值时切换为主读		</span>
<span class="hljs-comment">	--&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dataHost</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;localhost1&quot;</span> <span class="hljs-attr">maxCon</span>=<span class="hljs-string">&quot;1000&quot;</span> <span class="hljs-attr">minCon</span>=<span class="hljs-string">&quot;10&quot;</span> <span class="hljs-attr">balance</span>=<span class="hljs-string">&quot;1&quot;</span></span>
<span class="hljs-tag">                      <span class="hljs-attr">writeType</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">dbType</span>=<span class="hljs-string">&quot;mysql&quot;</span> <span class="hljs-attr">dbDriver</span>=<span class="hljs-string">&quot;native&quot;</span> <span class="hljs-attr">switchType</span>=<span class="hljs-string">&quot;2&quot;</span>  <span class="hljs-attr">slaveThreshold</span>=<span class="hljs-string">&quot;100&quot;</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">heartbeat</span>&gt;</span>show slave status<span class="hljs-tag">&lt;/<span class="hljs-name">heartbeat</span>&gt;</span>
            <span class="hljs-comment">&lt;!-- can have multi write hosts --&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">writeHost</span> <span class="hljs-attr">host</span>=<span class="hljs-string">&quot;hostM1&quot;</span> <span class="hljs-attr">url</span>=<span class="hljs-string">&quot;localhost:3306&quot;</span> <span class="hljs-attr">user</span>=<span class="hljs-string">&quot;root&quot;</span> <span class="hljs-attr">password</span>=<span class="hljs-string">&quot;123456&quot;</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">writeHost</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dataHost</span>&gt;</span></code></pre>

<p><code>switchType=&quot;2&quot;</code>和<code>slaveThreshold=&quot;100&quot;</code>意味着开启MySQL主从复制状态绑定的读写分离语切换机制。Mycat心跳机制通过检测<code>show slave status</code>中<code>&quot;Seconds_Behind_Master&quot; &quot;Slave_IO_Running&quot; &quot;Slave_SQL_Running&quot;</code>三个字段来确定当前主从的状态以及<code>Seconds_Behind_Master</code>主从复制延时。</p>
<h4 id="MySQL分库分表"><a href="#MySQL分库分表" class="headerlink" title="MySQL分库分表"></a>MySQL分库分表</h4><h5 id="数据切分方案"><a href="#数据切分方案" class="headerlink" title="数据切分方案"></a>数据切分方案</h5><ul>
<li>垂直切分：根据业务模块进行切分，不同模块的表分到不同的库中。</li>
<li>水平切分：将一张大表按照一定切分规则，按照<strong>行</strong>切分到不同表或者不同库中。</li>
</ul>
<h6 id="水平切分原则"><a href="#水平切分原则" class="headerlink" title="水平切分原则"></a>水平切分原则</h6><p>常用的主要分为：</p>
<ul>
<li>按照ID取模：对ID取模，余数决定改行数据放到哪张表或者哪个库中。</li>
<li>按照日期：按照年月日，将数据切分到不同的表或者库中。</li>
<li>按照范围：可以对某一列按照范围进行切分不同的范围切分到不同的表或者库中。</li>
</ul>
<h6 id="切分原则"><a href="#切分原则" class="headerlink" title="切分原则"></a>切分原则</h6><ul>
<li>第一原则：能不切分尽量不要切分</li>
<li>第二原则：如果要切分一定要选择合适的规则，提前规划好</li>
<li>第三原则：数据切分尽量通过数据冗余或者表分组来<strong>降低跨库join</strong>的可能</li>
<li>第四原则：由于数据库中间件对数据join实现的优劣难以把握，而且实现高性能难度极大，业务读取尽量少使用多表join</li>
</ul>
<h5 id="分库分表需要解决问题"><a href="#分库分表需要解决问题" class="headerlink" title="分库分表需要解决问题"></a>分库分表需要解决问题</h5><h6 id="分布式事务问题"><a href="#分布式事务问题" class="headerlink" title="分布式事务问题"></a>分布式事务问题</h6><h6 id="分布式主键ID问题"><a href="#分布式主键ID问题" class="headerlink" title="分布式主键ID问题"></a>分布式主键ID问题</h6><h6 id="跨库join问题"><a href="#跨库join问题" class="headerlink" title="跨库join问题"></a>跨库join问题</h6><h6 id="跨库count、group、orderby问题"><a href="#跨库count、group、orderby问题" class="headerlink" title="跨库count、group、orderby问题"></a>跨库count、group、orderby问题</h6><h3 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h3><h4 id="基础模块"><a href="#基础模块" class="headerlink" title="基础模块"></a>基础模块</h4><h5 id="说一下-MySQL-执行一条查询语句的内部执行过程？"><a href="#说一下-MySQL-执行一条查询语句的内部执行过程？" class="headerlink" title="说一下 MySQL 执行一条查询语句的内部执行过程？"></a>说一下 MySQL 执行一条查询语句的内部执行过程？</h5><ul>
<li><p>客户端先通过连接器连接到 MySQL 服务器。</p>
</li>
<li><p>连接器权限验证通过之后，先查询是否有查询缓存，如果有缓存（之前执行过此语句）则直接返回缓存数据，如果没有缓存则进入分析器。</p>
</li>
<li><p>分析器会对查询语句进行语法分析和词法分析，判断 SQL 语法是否正确，如果查询语法错误会直接返回给客户端错误信息，如果语法正确则进入优化器。</p>
</li>
<li><p>优化器是对查询语句进行优化处理，例如一个表里面有多个索引，优化器会判别哪个索引性能更好。</p>
</li>
<li><p>优化器执行完就进入执行器，执行器就开始执行语句进行查询比对了，直到查询到满足条件的所有数据，然后进行返回。</p>
</li>
</ul>
<h5 id="MySQL-提示“不存在此列”是执行到哪个节点报出的？"><a href="#MySQL-提示“不存在此列”是执行到哪个节点报出的？" class="headerlink" title="MySQL 提示“不存在此列”是执行到哪个节点报出的？"></a>MySQL 提示“不存在此列”是执行到哪个节点报出的？</h5><p>此错误是执行到分析器阶段报出的，因为 MySQL 会在分析器阶段检查 SQL 语句的正确性。</p>
<h5 id="MySQL-查询缓存的功能有何优缺点？"><a href="#MySQL-查询缓存的功能有何优缺点？" class="headerlink" title="MySQL 查询缓存的功能有何优缺点？"></a>MySQL 查询缓存的功能有何优缺点？</h5><p>MySQL 查询缓存功能是在连接器之后发生的，它的优点是效率高，如果已经有缓存则会直接返回结果。 查询缓存的缺点是失效太频繁导致缓存命中率比较低，任何更新表操作都会清空查询缓存，因此导致查询缓存非常容易失效。</p>
<h5 id="如何关闭-MySQL-的查询缓存功能？"><a href="#如何关闭-MySQL-的查询缓存功能？" class="headerlink" title="如何关闭 MySQL 的查询缓存功能？"></a>如何关闭 MySQL 的查询缓存功能？</h5><p>MySQL 查询缓存默认是开启的，配置 querycachetype 参数为 DEMAND（按需使用）关闭查询缓存，MySQL 8.0 之后直接删除了查询缓存的功能。</p>
<h5 id="MySQL-的常用引擎都有哪些？"><a href="#MySQL-的常用引擎都有哪些？" class="headerlink" title="MySQL 的常用引擎都有哪些？"></a>MySQL 的常用引擎都有哪些？</h5><p>MySQL 的常用引擎有 InnoDB、MyISAM、Memory 等，从 MySQL 5.5.5 版本开始 InnoDB 就成为了默认的存储引擎。</p>
<h5 id="MySQL-可以针对表级别设置数据库引擎吗？怎么设置？"><a href="#MySQL-可以针对表级别设置数据库引擎吗？怎么设置？" class="headerlink" title="MySQL 可以针对表级别设置数据库引擎吗？怎么设置？"></a>MySQL 可以针对表级别设置数据库引擎吗？怎么设置？</h5><p>可以针对不同的表设置不同的引擎。在 create table 语句中使用 engine=引擎名（比如Memory）来设置此表的存储引擎。完整代码如下：</p>
<pre><code class="hljs mysql">create table student(  
  id int primary key auto_increment,  
  username varchar(120),  
  age int 
) ENGINE&#x3D;Memory</code></pre>

<h5 id="常用的存储引擎-InnoDB-和-MyISAM-有什么区别？"><a href="#常用的存储引擎-InnoDB-和-MyISAM-有什么区别？" class="headerlink" title="常用的存储引擎 InnoDB 和 MyISAM 有什么区别？"></a>常用的存储引擎 InnoDB 和 MyISAM 有什么区别？</h5><p>InnoDB 和 MyISAM 最大的区别是 InnoDB 支持事务，而 MyISAM 不支持事务，它们主要区别如下：</p>
<ul>
<li><p>InnoDB 支持崩溃后安全恢复，MyISAM 不支持崩溃后安全恢复；</p>
</li>
<li><p>InnoDB 支持行级锁，MyISAM 不支持行级锁，只支持到表锁；</p>
</li>
<li><p>InnoDB 支持外键，MyISAM 不支持外键；</p>
</li>
<li><p>MyISAM 性能比 InnoDB 高；</p>
</li>
<li><p>MyISAM 支持 FULLTEXT 类型的全文索引，InnoDB 不支持 FULLTEXT 类型的全文索引，但是 InnoDB 可以使用 sphinx 插件支持全文索引，并且效果更好；</p>
</li>
<li><p>InnoDB 主键查询性能高于 MyISAM。</p>
</li>
</ul>
<h5 id="InnoDB-有哪些特性？"><a href="#InnoDB-有哪些特性？" class="headerlink" title="InnoDB 有哪些特性？"></a>InnoDB 有哪些特性？</h5><p>1）插入缓冲(insert buffer)：对于非聚集索引的插入和更新，不是每一次直接插入索引页中，而是首先判断插入的非聚集索引页是否在缓冲池中，如果在，则直接插入，否则，先放入一个插入缓冲区中。好似欺骗数据库这个非聚集的索引已经插入到叶子节点了，然后再以一定的频率执行插入缓冲和非聚集索引页子节点的合并操作，这时通常能将多个插入合并到一个操作中，这就大大提高了对非聚集索引执行插入和修改操作的性能。</p>
<p>2）两次写(double write)：两次写给 InnoDB 带来的是可靠性，主要用来解决部分写失败(partial page write)。doublewrite 有两部分组成，一部分是内存中的 doublewrite buffer ，大小为 2M，另外一部分就是物理磁盘上的共享表空间中连续的 128 个页，即两个区，大小同样为 2M。当缓冲池的作业刷新时，并不直接写硬盘，而是通过 memcpy 函数将脏页先拷贝到内存中的 doublewrite buffer，之后通过 doublewrite buffer 再分两次写，每次写入 1M 到共享表空间的物理磁盘上，然后马上调用 fsync 函数，同步磁盘。如下图所示</p>
<p> <img src="/images/mysql/innodb.png" srcset="/img/loading.gif"></p>
<p>3）自适应哈希索引(adaptive hash index)：由于 InnoDB 不支持 hash 索引，但在某些情况下 hash 索引的效率很高，于是出现了 adaptive hash index 功能， InnoDB 存储引擎会监控对表上索引的查找，如果观察到建立 hash 索引可以提高性能的时候，则自动建立 hash 索引。</p>
<h5 id="一张自增表中有三条数据，删除了两条数据之后重启数据库，再新增一条数据，此时这条数据的-ID-是几？"><a href="#一张自增表中有三条数据，删除了两条数据之后重启数据库，再新增一条数据，此时这条数据的-ID-是几？" class="headerlink" title="一张自增表中有三条数据，删除了两条数据之后重启数据库，再新增一条数据，此时这条数据的 ID 是几？"></a>一张自增表中有三条数据，删除了两条数据之后重启数据库，再新增一条数据，此时这条数据的 ID 是几？</h5><p>如果这张表的引擎是 MyISAM，那么 ID=4，如果是 InnoDB 那么 ID=2（MySQL 8 之前的版本）。</p>
<h5 id="MySQL-中什么情况会导致自增主键不能连续？"><a href="#MySQL-中什么情况会导致自增主键不能连续？" class="headerlink" title="MySQL 中什么情况会导致自增主键不能连续？"></a>MySQL 中什么情况会导致自增主键不能连续？</h5><p>以下情况会导致 MySQL 自增主键不能连续：</p>
<ul>
<li><p>唯一主键冲突会导致自增主键不连续；</p>
</li>
<li><p>事务回滚也会导致自增主键不连续。</p>
</li>
</ul>
<h5 id="InnoDB-中自增主键能不能被持久化？"><a href="#InnoDB-中自增主键能不能被持久化？" class="headerlink" title="InnoDB 中自增主键能不能被持久化？"></a>InnoDB 中自增主键能不能被持久化？</h5><p>自增主键能不能被持久化，说的是 MySQL 重启之后 InnoDB 能不能恢复重启之前的自增列，InnoDB 在 8.0 之前是没有持久化能力的，但 MySQL 8.0 之后就把自增主键保存到 redo log（一种日志类型，下文会详细讲）中，当 MySQL 重启之后就会从 redo log 日志中恢复。</p>
<h5 id="什么是独立表空间和共享表空间？它们的区别是什么？"><a href="#什么是独立表空间和共享表空间？它们的区别是什么？" class="headerlink" title="什么是独立表空间和共享表空间？它们的区别是什么？"></a>什么是独立表空间和共享表空间？它们的区别是什么？</h5><p>共享表空间：指的是数据库的所有的表数据，索引文件全部放在一个文件中，默认这个共享表空间的文件路径在 data 目录下。 独立表空间：每一个表都将会生成以独立的文件方式来进行存储。 共享表空间和独立表空间最大的区别是如果把表放再共享表空间，即使表删除了空间也不会删除，所以表依然很大，而独立表空间如果删除表就会清除空间。</p>
<h5 id="如何设置独立表空间？"><a href="#如何设置独立表空间？" class="headerlink" title="如何设置独立表空间？"></a>如何设置独立表空间？</h5><p>独立表空间是由参数 innodbfileper_table 控制的，把它设置成 ON 就是独立表空间了，从 MySQL 5.6.6 版本之后，这个值就默认是 ON 了。</p>
<p>如何进行表空间收缩？</p>
<p>使用重建表的方式可以收缩表空间，重建表有以下三种方式：</p>
<ul>
<li><p><code>alter table t engine=InnoDB</code></p>
</li>
<li><p><code>optmize table t</code></p>
</li>
<li><p><code>truncate table t</code></p>
</li>
</ul>
<h5 id="说一下重建表的执行流程？"><a href="#说一下重建表的执行流程？" class="headerlink" title="说一下重建表的执行流程？"></a>说一下重建表的执行流程？</h5><ul>
<li><p>建立一个临时文件，扫描表 t 主键的所有数据页；</p>
</li>
<li><p>用数据页中表 t 的记录生成 B+ 树，存储到临时文件中；</p>
</li>
<li><p>生成临时文件的过程中，将所有对 t 的操作记录在一个日志文件（row log）中；</p>
</li>
<li><p>临时文件生成后，将日志文件中的操作应用到临时文件，得到一个逻辑数据上与表 t相同的数据文件；</p>
</li>
<li><p>用临时文件替换表 t 的数据文件。</p>
</li>
</ul>
<h5 id="表的结构信息存在哪里？"><a href="#表的结构信息存在哪里？" class="headerlink" title="表的结构信息存在哪里？"></a>表的结构信息存在哪里？</h5><p>表结构定义占有的存储空间比较小，在 MySQL 8 之前，表结构的定义信息存在以 .frm 为后缀的文件里，在 MySQL 8 之后，则允许把表结构的定义信息存在系统数据表之中。</p>
<h5 id="如果把一个-InnoDB-表的主键删掉，是不是就没有主键，就没办法进行回表查询了？"><a href="#如果把一个-InnoDB-表的主键删掉，是不是就没有主键，就没办法进行回表查询了？" class="headerlink" title="如果把一个 InnoDB 表的主键删掉，是不是就没有主键，就没办法进行回表查询了？"></a>如果把一个 InnoDB 表的主键删掉，是不是就没有主键，就没办法进行回表查询了？</h5><p>可以回表查询，如果把主键删掉了，那么 InnoDB 会自己生成一个长度为 6 字节的 rowid 作为主键。</p>
<h5 id="执行一个-update-语句以后，我再去执行-hexdump-命令直接查看-ibd-文件内容，为什么没有看到数据有改变呢？"><a href="#执行一个-update-语句以后，我再去执行-hexdump-命令直接查看-ibd-文件内容，为什么没有看到数据有改变呢？" class="headerlink" title="执行一个 update 语句以后，我再去执行 hexdump 命令直接查看 ibd 文件内容，为什么没有看到数据有改变呢？"></a>执行一个 update 语句以后，我再去执行 hexdump 命令直接查看 ibd 文件内容，为什么没有看到数据有改变呢？</h5><p>可能是因为 update 语句执行完成后，InnoDB 只保证写完了 redo log、内存，可能还没来得及将数据写到磁盘。</p>
<h5 id="内存表和临时表有什么区别？"><a href="#内存表和临时表有什么区别？" class="headerlink" title="内存表和临时表有什么区别？"></a>内存表和临时表有什么区别？</h5><ul>
<li><p>内存表，指的是使用 Memory 引擎的表，建表语法是 create table … engine=memory。这种表的数据都保存在内存里，系统重启的时候会被清空，但是表结构还在。除了这两个特性看上去比较“奇怪”外，从其他的特征上看，它就是一个正常的表。</p>
</li>
<li><p>而临时表，可以使用各种引擎类型 。如果是使用 InnoDB 引擎或者 MyISAM 引擎的临时表，写数据的时候是写到磁盘上的。</p>
</li>
</ul>
<h5 id="并发事务会带来哪些问题？"><a href="#并发事务会带来哪些问题？" class="headerlink" title="并发事务会带来哪些问题？"></a>并发事务会带来哪些问题？</h5><ul>
<li><p>脏读</p>
</li>
<li><p>修改丢失</p>
</li>
<li><p>不可重复读</p>
</li>
<li><p>幻读</p>
</li>
</ul>
<h5 id="什么是脏读和幻读？"><a href="#什么是脏读和幻读？" class="headerlink" title="什么是脏读和幻读？"></a>什么是脏读和幻读？</h5><p>脏读是一个事务在处理过程中读取了另外一个事务未提交的数据；幻读是指同一个事务内多次查询返回的结果集不一样（比如增加了或者减少了行记录）。</p>
<h5 id="为什么会出现幻读？幻读会带来什么问题？"><a href="#为什么会出现幻读？幻读会带来什么问题？" class="headerlink" title="为什么会出现幻读？幻读会带来什么问题？"></a>为什么会出现幻读？幻读会带来什么问题？</h5><p>因为行锁只能锁定存在的行，针对新插入的操作没有限定，所以就有可能产生幻读。 幻读带来的问题如下：</p>
<ul>
<li><p>对行锁语义的破坏；</p>
</li>
<li><p>破坏了数据一致性。</p>
</li>
</ul>
<h5 id="如何避免幻读？"><a href="#如何避免幻读？" class="headerlink" title="如何避免幻读？"></a>如何避免幻读？</h5><p>使用间隙锁的方式来避免出现幻读。间隙锁，是专门用于解决幻读这种问题的锁，它锁的了行与行之间的间隙，能够阻塞新插入的操作 间隙锁的引入也带来了一些新的问题，比如：降低并发度，可能导致死锁。</p>
<h5 id="如何查看-MySQL-的空闲连接？"><a href="#如何查看-MySQL-的空闲连接？" class="headerlink" title="如何查看 MySQL 的空闲连接？"></a>如何查看 MySQL 的空闲连接？</h5><p>在 MySQL 的命令行中使用 show processlist; 查看所有连接，其中 Command 列显示为 Sleep 的表示空闲连接，如下图所示：</p>
<p><img src="/images/mysql/processlist.png" srcset="/img/loading.gif"></p>
<h5 id="MySQL-中的字符串类型都有哪些？"><a href="#MySQL-中的字符串类型都有哪些？" class="headerlink" title="MySQL 中的字符串类型都有哪些？"></a>MySQL 中的字符串类型都有哪些？</h5><p>MySQL 的字符串类型和取值如下：</p>
<table>
<thead>
<tr>
<th><strong>类型</strong></th>
<th><strong>取值范围</strong></th>
</tr>
</thead>
<tbody><tr>
<td>CHAR(N)</td>
<td>0~255</td>
</tr>
<tr>
<td>VARCHAR(N)</td>
<td>0~65536</td>
</tr>
<tr>
<td>TINYBLOB</td>
<td>0~255</td>
</tr>
<tr>
<td>BLOB</td>
<td>0~65535</td>
</tr>
<tr>
<td>MEDUIMBLOB</td>
<td>0~167772150</td>
</tr>
<tr>
<td>LONGBLOB</td>
<td>0~4294967295</td>
</tr>
<tr>
<td>TINYTEXT</td>
<td>0~255</td>
</tr>
<tr>
<td>TEXT</td>
<td>0~65535</td>
</tr>
<tr>
<td>MEDIUMTEXT</td>
<td>0~167772150</td>
</tr>
<tr>
<td>LONGTEXT</td>
<td>0~4294967295</td>
</tr>
<tr>
<td>VARBINARY(N)</td>
<td>0~N个字节的变长字节字符集</td>
</tr>
<tr>
<td>BINARY(N)</td>
<td>0~N个字节的定长字节字符集</td>
</tr>
</tbody></table>
<h5 id="VARCHAR-和-CHAR-的区别是什么？分别适用的场景有哪些？"><a href="#VARCHAR-和-CHAR-的区别是什么？分别适用的场景有哪些？" class="headerlink" title="VARCHAR 和 CHAR 的区别是什么？分别适用的场景有哪些？"></a>VARCHAR 和 CHAR 的区别是什么？分别适用的场景有哪些？</h5><p>VARCHAR 和 CHAR 最大区别就是，VARCHAR 的长度是可变的，而 CHAR 是固定长度，CHAR 的取值范围为1-255，因此 VARCHAR 可能会造成存储碎片。由于它们的特性决定了 CHAR 比较适合长度较短的字段和固定长度的字段，如身份证号、手机号等，反之则适合使用 VARCHAR。</p>
<h5 id="MySQL-存储金额应该使用哪种数据类型？为什么？"><a href="#MySQL-存储金额应该使用哪种数据类型？为什么？" class="headerlink" title="MySQL 存储金额应该使用哪种数据类型？为什么？"></a>MySQL 存储金额应该使用哪种数据类型？为什么？</h5><p>MySQL 存储金额应该使用 decimal ，因为如果存储其他数据类型，比如 float 有导致小数点后数据丢失的风险。</p>
<h5 id="limit-3-2-的含义是什么？"><a href="#limit-3-2-的含义是什么？" class="headerlink" title="limit 3,2 的含义是什么？"></a>limit 3,2 的含义是什么？</h5><p>去除前三条数据之后查询两条信息。</p>
<h5 id="now-和-current-date-有什么区别？"><a href="#now-和-current-date-有什么区别？" class="headerlink" title="now() 和 current_date() 有什么区别？"></a>now() 和 current_date() 有什么区别？</h5><p>now() 返回当前时间包含日期和时分秒，current_date() 只返回当前时间，如下图所示：</p>
<p> <img src="/images/mysql/cur.png" srcset="/img/loading.gif"></p>
<h5 id="如何去重计算总条数？"><a href="#如何去重计算总条数？" class="headerlink" title="如何去重计算总条数？"></a>如何去重计算总条数？</h5><p>使用 distinct 去重，使用 count 统计总条数，具体实现脚本如下：</p>
<pre><code class="hljs mysql">select count(distinct f) from t;</code></pre>

<h5 id="lastinsertid-函数功能是什么？有什么特点？"><a href="#lastinsertid-函数功能是什么？有什么特点？" class="headerlink" title="lastinsertid() 函数功能是什么？有什么特点？"></a>lastinsertid() 函数功能是什么？有什么特点？</h5><p>lastinsertid() 用于查询最后一次自增表的编号，它的特点是查询时不需要不需要指定表名，使用 select last_insert_id() 即可查询，因为不需要指定表名所以它始终以最后一条自增编号为主，可以被其它表的自增编号覆盖。比如 A 表的最大编号是 10，lastinsertid() 查询出来的值为 10，这时 B 表插入了一条数据，它的最大编号为 3，这个时候使用 lastinsertid() 查询的值就是 3。</p>
<h5 id="删除表的数据有几种方式？它们有什么区别？"><a href="#删除表的数据有几种方式？它们有什么区别？" class="headerlink" title="删除表的数据有几种方式？它们有什么区别？"></a>删除表的数据有几种方式？它们有什么区别？</h5><p>删除数据有两种方式：delete 和 truncate，它们的区别如下：</p>
<ul>
<li><p>delete 可以添加 where 条件删除部分数据，truncate 不能添加 where 条件只能删除整张表；</p>
</li>
<li><p>delete 的删除信息会在 MySQL 的日志中记录，而 truncate 的删除信息不被记录在 MySQL 的日志中，因此 detele 的信息可以被找回而 truncate 的信息无法被找回；</p>
</li>
<li><p>truncate 因为不记录日志所以执行效率比 delete 快。</p>
</li>
</ul>
<p>delete 和 truncate 的使用脚本如下：</p>
<pre><code class="hljs mysql">delete from t where username&#x3D;&#39;redis&#39;; 
truncate table t;</code></pre>

<h5 id="MySQL-中支持几种模糊查询？它们有什么区别？"><a href="#MySQL-中支持几种模糊查询？它们有什么区别？" class="headerlink" title="MySQL 中支持几种模糊查询？它们有什么区别？"></a>MySQL 中支持几种模糊查询？它们有什么区别？</h5><p>MySQL 中支持两种模糊查询：regexp 和 like，like 是对任意多字符匹配或任意单字符进行模糊匹配，而 regexp 则支持正则表达式的匹配方式，提供比 like 更多的匹配方式。</p>
<p>regexp 和 like 的使用示例如下： </p>
<pre><code class="hljs mysql">select * from person where uname like &#39;%SQL%&#39;; select  from person where uname regexp &#39;.SQL*.&#39;;</code></pre>

<h5 id="MySQL-支持枚举吗？如何实现？它的用途是什么？"><a href="#MySQL-支持枚举吗？如何实现？它的用途是什么？" class="headerlink" title="MySQL 支持枚举吗？如何实现？它的用途是什么？"></a>MySQL 支持枚举吗？如何实现？它的用途是什么？</h5><p>MySQL 支持枚举，它的实现方式如下：</p>
<pre><code class="hljs mysql">create table t(   
  sex enum(&#39;boy&#39;,&#39;grid&#39;) default &#39;unknown&#39; 
);</code></pre>

<p>枚举的作用是预定义结果值，当插入数据不在枚举值范围内，则插入失败，提示错误 Data truncated for column ‘xxx’ at row n 。</p>
<h5 id="count-column-和-count-有什么区别？"><a href="#count-column-和-count-有什么区别？" class="headerlink" title="count(column) 和 count(*) 有什么区别？"></a>count(column) 和 count(*) 有什么区别？</h5><p>count(column) 和 count() 最大区别是统计结果可能不一致，count(column) 统计不会统计列值为 null 的数据，而 count() 则会统计所有信息，所以最终的统计结果可能会不同。</p>
<h5 id="以下关于-count-说法正确的是？"><a href="#以下关于-count-说法正确的是？" class="headerlink" title="以下关于 count 说法正确的是？"></a>以下关于 count 说法正确的是？</h5><p>A. count 的查询性能在各种存储引擎下的性能都是一样的。</p>
<p>B. count 在 MyISAM 比 InnoDB 的性能要低。 </p>
<p>C. count 在 InnoDB 中是一行一行读取，然后累计计数的。 </p>
<p>D. count 在 InnoDB 中存储了总条数，查询的时候直接取出。</p>
<p>答：C</p>
<h5 id="为什么-InnoDB-不把总条数记录下来，查询的时候直接返回呢？"><a href="#为什么-InnoDB-不把总条数记录下来，查询的时候直接返回呢？" class="headerlink" title="为什么 InnoDB 不把总条数记录下来，查询的时候直接返回呢？"></a>为什么 InnoDB 不把总条数记录下来，查询的时候直接返回呢？</h5><p>因为 InnoDB 使用了事务实现，而事务的设计使用了多版本并发控制，即使是在同一时间进行查询，得到的结果也可能不相同，所以 InnoDB 不能把结果直接保存下来，因为这样是不准确的。</p>
<h5 id="能否使用-show-table-status-中的表行数作为表的总行数直接使用？为什么？"><a href="#能否使用-show-table-status-中的表行数作为表的总行数直接使用？为什么？" class="headerlink" title="能否使用 show table status 中的表行数作为表的总行数直接使用？为什么？"></a>能否使用 show table status 中的表行数作为表的总行数直接使用？为什么？</h5><p>不能，因为 show table status 是通过采样统计估算出来的，官方文档说误差可能在 40% 左右，所以 show table status 中的表行数不能直接使用。</p>
<h5 id="以下哪个-SQL-的查询性能最高？"><a href="#以下哪个-SQL-的查询性能最高？" class="headerlink" title="以下哪个 SQL 的查询性能最高？"></a>以下哪个 SQL 的查询性能最高？</h5><p>A. select count(*) from t where time&gt;1000 and time&lt;4500 </p>
<p>B. show table status where name=’t’ </p>
<p>C. select count(id) from t where time&gt;1000 and time&lt;4500 </p>
<p>D. select count(name) from t where time&gt;1000 and time&lt;4500</p>
<p>答：B 题目解析：因为 show table status 的表行数是估算出来，而其他的查询因为添加了 where 条件，即使是 MyISAM 引擎也不能直接使用已经存储的总条数，所以 show table status 的查询性能最高。</p>
<h5 id="InnoDB-和-MyISAM-执行-select-count-from-t，哪个效率更高？为什么？"><a href="#InnoDB-和-MyISAM-执行-select-count-from-t，哪个效率更高？为什么？" class="headerlink" title="InnoDB 和 MyISAM 执行 select count(*) from t，哪个效率更高？为什么？"></a>InnoDB 和 MyISAM 执行 select count(*) from t，哪个效率更高？为什么？</h5><p>MyISAM 效率最高，因为 MyISAM 内部维护了一个计数器，直接返回总条数，而 InnoDB 要逐行统计。</p>
<h5 id="在-MySQL-中有对-count-做优化吗？做了哪些优化？"><a href="#在-MySQL-中有对-count-做优化吗？做了哪些优化？" class="headerlink" title="在 MySQL 中有对 count(*) 做优化吗？做了哪些优化？"></a>在 MySQL 中有对 count(*) 做优化吗？做了哪些优化？</h5><p>count(*) 在不同的 MySQL 引擎中的实现方式是不相同的，在没有 where 条件的情况下：</p>
<ul>
<li><p>MyISAM 引擎会把表的总行数存储在磁盘上，因此在执行 count(*) 的时候会直接返回这个这个行数，执行效率很高；</p>
</li>
<li><p>InnoDB 引擎中 count(*) 就比较麻烦了，需要把数据一行一行的从引擎中读出来，然后累计基数。</p>
</li>
</ul>
<p>但即使这样，在 InnoDB 中，MySQL 还是做了优化的，我们知道对于 count() 这样的操作，遍历任意索引树得到的结果，在逻辑上都是一样的，因此，MySQL 优化器会找到最小的那颗索引树来遍历，这样就能在保证逻辑正确的前提下，尽量少扫描数据量，从而优化了 count() 的执行效率。</p>
<h5 id="在-InnoDB-引擎中-count-、count-1-、count-主键-、count-字段-哪个性能最高？"><a href="#在-InnoDB-引擎中-count-、count-1-、count-主键-、count-字段-哪个性能最高？" class="headerlink" title="在 InnoDB 引擎中 count(*)、count(1)、count(主键)、count(字段) 哪个性能最高？"></a>在 InnoDB 引擎中 count(*)、count(1)、count(主键)、count(字段) 哪个性能最高？</h5><p>count(字段)&lt;count(主键 id)&lt;count(1)≈count(*) 题目解析：</p>
<ul>
<li><p>对于 count(主键 id) 来说，InnoDB 引擎会遍历整张表，把每一行的 id 值都取出来，返回给 server 层。server 层拿到 id 后，判断是不可能为空的，就按行累加。</p>
</li>
<li><p>对于 count(1) 来说，InnoDB 引擎遍历整张表，但不取值。server 层对于返回的每一行，放一个数字“1”进去，判断是不可能为空的，按行累加。</p>
</li>
<li><p>对于 count(字段) 来说，如果这个“字段”是定义为 not null 的话，一行行地从记录里面读出这个字段，判断不能为 null，按行累加；如果这个“字段”定义允许为 null，那么执行的时候，判断到有可能是 null，还要把值取出来再判断一下，不是 null 才累加。</p>
</li>
<li><p>对于 count(*) 来说，并不会把全部字段取出来，而是专门做了优化，不取值，直接按行累加。</p>
</li>
</ul>
<p>所以最后得出的结果是：count(字段)&lt;count(主键 id)&lt;count(1)≈count(*)。</p>
<h5 id="MySQL-中内连接、左连接、右连接有什么区别？"><a href="#MySQL-中内连接、左连接、右连接有什么区别？" class="headerlink" title="MySQL 中内连接、左连接、右连接有什么区别？"></a>MySQL 中内连接、左连接、右连接有什么区别？</h5><ul>
<li><p>内连（inner join）— 把匹配的关联数据显示出来；</p>
</li>
<li><p>左连接（left join）— 把左边的表全部显示出来，右边的表显示出符合条件的数据；</p>
</li>
<li><p>右连接（right join）— 把右边的表全部显示出来，左边的表显示出符合条件的数据；</p>
</li>
</ul>
<h5 id="什么是视图？如何创建视图？"><a href="#什么是视图？如何创建视图？" class="headerlink" title="什么是视图？如何创建视图？"></a>什么是视图？如何创建视图？</h5><p>视图是一种虚拟的表，具有和物理表相同的功能，可以对视图进行增、改、查操作。视图通常是一个表或者多个表的行或列的子集。 视图创建脚本如下：</p>
<pre><code class="hljs mysql">create view vname as select column_names from table_name where condition;</code></pre>

<h5 id="视图有哪些优点？"><a href="#视图有哪些优点？" class="headerlink" title="视图有哪些优点？"></a>视图有哪些优点？</h5><ul>
<li><p>获取数据更容易，相对于多表查询来说；</p>
</li>
<li><p>视图能够对机密数据提供安全保护；</p>
</li>
<li><p>视图的修改不会影响基本表，提供了独立的操作单元，比较轻量。</p>
</li>
</ul>
<h5 id="MySQL-中“视图”的概念有几个？分别代表什么含义？"><a href="#MySQL-中“视图”的概念有几个？分别代表什么含义？" class="headerlink" title="MySQL 中“视图”的概念有几个？分别代表什么含义？"></a>MySQL 中“视图”的概念有几个？分别代表什么含义？</h5><p>MySQL 中的“视图”概念有两个，它们分别是：</p>
<ul>
<li><p>MySQL 中的普通视图也是我们最常用的 view，创建语法是 create view …,它的查询和普通表一样；</p>
</li>
<li><p>InnoDB 实现 MVCC（Multi-Version Concurrency Control）多版本并发控制时用到的一致性读视图，它没有物理结构，作用是事务执行期间定于可以看到的数据。</p>
</li>
</ul>
<h5 id="使用-delete-误删数据怎么找回？"><a href="#使用-delete-误删数据怎么找回？" class="headerlink" title="使用 delete 误删数据怎么找回？"></a>使用 delete 误删数据怎么找回？</h5><p>可以用 Flashback 工具通过闪回把数据恢复回来。</p>
<h5 id="Flashback-恢复数据的原理是什么？"><a href="#Flashback-恢复数据的原理是什么？" class="headerlink" title="Flashback 恢复数据的原理是什么？"></a>Flashback 恢复数据的原理是什么？</h5><p>Flashback 恢复数据的原理是是修改 binlog 的内容，拿回原库重放，从而实现数据找回。</p>
<h4 id="MySQL-事务"><a href="#MySQL-事务" class="headerlink" title="MySQL 事务"></a>MySQL 事务</h4><h5 id="事务是什么？"><a href="#事务是什么？" class="headerlink" title="事务是什么？"></a>事务是什么？</h5><p>事务是一系列的数据库操作，是数据库应用的基本单位。MySQL 事务主要用于处理操作量大，复杂度高的数据。</p>
<h5 id="事务有哪些特性？"><a href="#事务有哪些特性？" class="headerlink" title="事务有哪些特性？"></a>事务有哪些特性？</h5><p>在 MySQL 中只有 InnDB 引擎支持事务，它的四个特性如下：</p>
<ul>
<li><p>原子性（Atomic）：要么全部执行，要么全部不执行；</p>
</li>
<li><p>一致性（Consistency）：事务的执行使得数据库从一种正确状态转化为另一种正确状态；</p>
</li>
<li><p>隔离性（Isolation）：在事务正确提交之前，不允许把该事务对数据的任何改变提供给其他事务；</p>
</li>
<li><p>持久性（Durability）：事务提交后，其结果永久保存在数据库中。</p>
</li>
</ul>
<h5 id="MySQL-中有几种事务隔离级别？分别是什么？"><a href="#MySQL-中有几种事务隔离级别？分别是什么？" class="headerlink" title="MySQL 中有几种事务隔离级别？分别是什么？"></a>MySQL 中有几种事务隔离级别？分别是什么？</h5><p>MySQL 中有四种事务隔离级别，它们分别是：</p>
<ul>
<li><p>read uncommited：未提交读，读到未提交数据；</p>
</li>
<li><p>read committed：读已提交，也叫不可重复读，两次读取到的数据不一致；</p>
</li>
<li><p>repetable read：可重复读；</p>
</li>
<li><p>serializable：串行化，读写数据都会锁住整张表，数据操作不会出错，但并发性能极低，开发中很少用到。</p>
</li>
</ul>
<p>MySQL 默认使用 REPEATABLE-READ 的事务隔离级别。</p>
<h5 id="幻读和不可重复读的区别？"><a href="#幻读和不可重复读的区别？" class="headerlink" title="幻读和不可重复读的区别？"></a>幻读和不可重复读的区别？</h5><ul>
<li><p>不可重复读的重点是修改：在同一事务中，同样的条件，第一次读的数据和第二次读的数据不一样。（因为中间有其他事务提交了修改）。</p>
</li>
<li><p>幻读的重点在于新增或者删除：在同一事务中，同样的条件,，第一次和第二次读出来的记录数不一样。（因为中间有其他事务提交了插入/删除）。</p>
</li>
</ul>
<h5 id="并发事务一般有哪些问题？"><a href="#并发事务一般有哪些问题？" class="headerlink" title="并发事务一般有哪些问题？"></a>并发事务一般有哪些问题？</h5><ul>
<li><p>更新丢失（Lost Update）：当两个或多个事务选择同一行，然后基于最初选定的值更新该行时，由于每个事务都不知道其他事务的存在，就会发生丢失更新问题，最后的更新覆盖了由其他事务所做的更新。例如，两个编辑人员制作了同一文档的电子副本，每个编辑人员独立地更改其副本，然后保存更改后的副本，这样就覆盖了原始文档。 最后保存其更改副本的编辑人员覆盖另一个编辑人员所做的更改，如果在前一个编辑人员完成并提交事务之前，另一个编辑人员不能访问同一文件，则可避免此问题。</p>
</li>
<li><p>脏读（Dirty Reads）：一个事务正在对一条记录做修改，在这个事务完成并提交前， 这条记录的数据就处于不一致状态； 这时， 另一个事务也来读取同一条记录，如果不加控制，第二个事务读取了这些脏数据，并据此做进一步的处理，就会产生未提交的数据依赖关系，这种现象被形象地叫做脏读。</p>
</li>
<li><p>不可重复读（Non-Repeatable Reads）：一个事务在读取某些数据后的某个时间，再次读取以前读过的数据，却发现其读出的数据已经发生了改变、或某些记录已经被删除了！这种现象就叫做“不可重复读” 。</p>
</li>
<li><p>幻读（Phantom Reads）： 一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象就称为“幻读” 。</p>
</li>
</ul>
<h5 id="并发事务会有什么问题？应该如何解决？"><a href="#并发事务会有什么问题？应该如何解决？" class="headerlink" title="并发事务会有什么问题？应该如何解决？"></a>并发事务会有什么问题？应该如何解决？</h5><p>并发事务可能造成：脏读、不可重复读和幻读等问题 ，这些问题其实都是数据库读一致性问题，必须由数据库提供一定的事务隔离机制来解决，解决方案如下：</p>
<ul>
<li><p>加锁：在读取数据前，对其加锁，阻止其他事务对数据进行修改。</p>
</li>
<li><p>提供数据多版本并发控制（MultiVersion Concurrency Control，简称 MVCC 或 MCC），也称为多版本数据库：不用加任何锁， 通过一定机制生成一个数据请求时间点的一致性数据快照（Snapshot)， 并用这个快照来提供一定级别 （语句级或事务级） 的一致性读取，从用户的角度来看，好象是数据库可以提供同一数据的多个版本。</p>
</li>
</ul>
<h5 id="什么是-MVCC？"><a href="#什么是-MVCC？" class="headerlink" title="什么是 MVCC？"></a>什么是 MVCC？</h5><p>MVCC 全称是多版本并发控制系统，InnoDB 和 Falcon 存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control）机制解决幻读问题。</p>
<h5 id="MVCC-是怎么工作的？"><a href="#MVCC-是怎么工作的？" class="headerlink" title="MVCC 是怎么工作的？"></a>MVCC 是怎么工作的？</h5><p>InnoDB 的 MVCC 是通过在每行记录后面保存两个隐藏的列来实现，这两个列一个保存了行的创建时间，一个保存行的过期时间（删除时间）。当然存储的并不是真实的时间而是系统版本号（system version number）。每开始一个新的事务，系统版本号都会自动新增，事务开始时刻的系统版本号会作为事务的版本号，用来查询到每行记录的版本号进行比较。</p>
<h5 id="REPEATABLE-READ（可重读）隔离级别下-MVCC-如何工作？"><a href="#REPEATABLE-READ（可重读）隔离级别下-MVCC-如何工作？" class="headerlink" title="REPEATABLE READ（可重读）隔离级别下 MVCC 如何工作？"></a>REPEATABLE READ（可重读）隔离级别下 MVCC 如何工作？</h5><ul>
<li><p>SELECT：InnoDB 会根据以下条件检查每一行记录：第一，InnoDB 只查找版本早于当前事务版本的数据行，这样可以确保事务读取的行要么是在开始事务之前已经存在要么是事务自身插入或者修改过的。第二，行的删除版本号要么未定义，要么大于当前事务版本号，这样可以确保事务读取到的行在事务开始之前未被删除。</p>
</li>
<li><p>INSERT：InnoDB 为新插入的每一行保存当前系统版本号作为行版本号。</p>
</li>
<li><p>DELETE：InnoDB 为删除的每一行保存当前系统版本号作为行删除标识。</p>
</li>
<li><p>UPDATE：InnoDB 为插入的一行新纪录保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为删除标识保存这两个版本号，使大多数操作都不用加锁。它不足之处是每行记录都需要额外的存储空间，需要做更多的行检查工作和一些额外的维护工作。</p>
</li>
</ul>
<h5 id="MySQL-事务实现原理是什么？"><a href="#MySQL-事务实现原理是什么？" class="headerlink" title="MySQL 事务实现原理是什么？"></a>MySQL 事务实现原理是什么？</h5><p>事务的实现是基于数据库的存储引擎，不同的存储引擎对事务的支持程度不一样。MySQL 中支持事务的存储引擎有InnoDB 和 NDB。 InnoDB 是高版本 MySQL 的默认的存储引擎，因此就以 InnoDB 的事务实现为例，InnoDB 是通过多版本并发控制（MVCC，Multiversion Concurrency Control ）解决不可重复读问题，加上间隙锁（也就是并发控制）解决幻读问题。因此 InnoDB 的 RR 隔离级别其实实现了串行化级别的效果，而且保留了比较好的并发性能。事务的隔离性是通过锁实现，而事务的原子性、一致性和持久性则是通过事务日志实现。 </p>
<h5 id="如何设置-MySQL-的事务隔离级别？"><a href="#如何设置-MySQL-的事务隔离级别？" class="headerlink" title="如何设置 MySQL 的事务隔离级别？"></a>如何设置 MySQL 的事务隔离级别？</h5><p>MySQL 事务隔离级别 MySQL.cnf 文件里设置的（默认目录 /etc/my.cnf），在文件的文末添加配置：</p>
<p><code>transaction-isolation = REPEATABLE-READ</code></p>
<p>可用的配置值：<code>READ-UNCOMMITTED、READ-COMMITTED、REPEATABLE-READ、SERIALIZABLE</code>。</p>
<h5 id="InnoDB-默认的事务隔离级别是什么？如何修改？"><a href="#InnoDB-默认的事务隔离级别是什么？如何修改？" class="headerlink" title="InnoDB 默认的事务隔离级别是什么？如何修改？"></a>InnoDB 默认的事务隔离级别是什么？如何修改？</h5><p><code>InnoDB </code>默认的事务隔离是 <code>repetable read</code>（可重复读）；可以通过<code> set</code> 作用域 <code>transaction isolation level </code>事务隔离级别 来修改事务的隔离级别</p>
<p>如：</p>
<pre><code class="hljs mysql">MySQL&gt; set global transaction isolation level read committed;  &#x2F;&#x2F; 设置全局事务隔离级别为 read committed   
MySQL&gt; set session transaction isolation level read committed; &#x2F;&#x2F; 设置当前会话事务隔离级别为 read committed</code></pre>

<h5 id="InnoDB-如何开启手动提交事务？"><a href="#InnoDB-如何开启手动提交事务？" class="headerlink" title="InnoDB 如何开启手动提交事务？"></a>InnoDB 如何开启手动提交事务？</h5><p><code>InnoDB</code> 默认是自动提交事务的，每一次<code> SQL</code> 操作（非<code>select</code>操作）都会自动提交一个事务，如果要手动开启事务需要设置 <code>set autocommit=0 </code>禁止自动提交事务，相当于开启手动提交事务。</p>
<h5 id="在-InnoDB-中设置了-autocommit-0，添加一条信息之后没有手动执行提交操作，请问这条信息可以被查到吗？"><a href="#在-InnoDB-中设置了-autocommit-0，添加一条信息之后没有手动执行提交操作，请问这条信息可以被查到吗？" class="headerlink" title="在 InnoDB 中设置了 autocommit=0，添加一条信息之后没有手动执行提交操作，请问这条信息可以被查到吗？"></a>在 InnoDB 中设置了 autocommit=0，添加一条信息之后没有手动执行提交操作，请问这条信息可以被查到吗？</h5><p><code>autocommit=0</code> 表示禁止自动事务提交，在添加操作之后没有进行手动提交，默认情况下其他连接客户端是查询不到此条新增数据的。</p>
<h5 id="如何手动操作事务？"><a href="#如何手动操作事务？" class="headerlink" title="如何手动操作事务？"></a>如何手动操作事务？</h5><p>使用 begin 开启事务；rollback 回滚事务；commit 提交事务。具体使用示例如下：</p>
<pre><code class="hljs mysql">begin; 
insert person(name,age) values(&#39;laowang&#39;,18); 
rollback; 
commit;</code></pre>

<h4 id="MySQL-日志"><a href="#MySQL-日志" class="headerlink" title="MySQL 日志"></a>MySQL 日志</h4><h5 id="MySQL-有哪些重要的日志文件？"><a href="#MySQL-有哪些重要的日志文件？" class="headerlink" title="MySQL 有哪些重要的日志文件？"></a>MySQL 有哪些重要的日志文件？</h5><p><img src="/images/mysql/logfile.png" srcset="/img/loading.gif"></p>
<p>MySQL 中的重要日志分为以下几个：</p>
<p> ① 错误日志：用来记录 MySQL 服务器运行过程中的错误信息，比如，无法加载 MySQL 数据库的数据文件，或权限不正确等都会被记录在此，还有复制环境下，从服务器进程的信息也会被记录进错误日志。默认情况下，错误日志是开启的，且无法被禁止。</p>
<p>​      错误日志是存储在数据库的数据文件目录中，名称为 hostname.err，其中 hostname 为服务器主机名。在 MySQL 5.5.7 之前，数据库管理员可以删除很长时间之前的错误日志，以节省服务器上的硬盘空间， MySQL 5.5.7 之后，服务器将关闭此项功能，只能使用重命名原来的错误日志文件，手动冲洗日志创建一个新的，命令为：</p>
<p><code>mv hostname.err  hostname.err.old mysqladmin flush-logs</code></p>
<p>② 查询日志：查询日志在 MySQL 中被称为 general log(通用日志)，查询日志里的内容不要被“查询日志”误导，认为里面只存储 select 语句，其实不然，查询日志里面记录了数据库执行的所有命令，不管语句是否正确，都会被记录，具体原因如下:</p>
<ul>
<li><p>insert 查询为了避免数据冲突，如果此前插入过数据，当前插入的数据如果跟主键或唯一键的数据重复那肯定会报错；</p>
</li>
<li><p>update 时也会查询因为更新的时候很可能会更新某一块数据；</p>
</li>
<li><p>delete 查询，只删除符合条件的数据；</p>
</li>
</ul>
<p>因此都会产生日志，在并发操作非常多的场景下，查询信息会非常多，那么如果都记录下来会导致 IO 非常大，影响 MySQL 性能，因此如果不是在调试环境下，是不建议开启查询日志功能的。</p>
<p>查询日志的开启有助于帮助我们分析哪些语句执行密集，执行密集的 select 语句对应的数据是否能够被缓存，同时也可以帮助我们分析问题，所以，我们可以根据自己的实际情况来决定是否开启查询日志。</p>
<p>查询日志模式是关闭的，可以通过以下命令开启查询日志：</p>
<p><code>set global generallog=1 set global logoutput=&#39;table&#39;;</code></p>
<p><code>general_log=1</code> 为开启查询日志，0 为关闭查询日志，这个设置命令即时生效，不用重启 MySQL 服务器。</p>
<p>③ 慢日志：慢查询会导致 CPU、IOPS、内存消耗过高，当数据库遇到性能瓶颈时，大部分时间都是由于慢查询导致的。开启慢查询日志，可以让 MySQL 记录下查询超过指定时间的语句，之后运维人员通过定位分析，能够很好的优化数据库性能。默认情况下，慢查询日志是不开启的，只有手动开启了，慢查询才会被记录到慢查询日志中。使用如下命令记录当前数据库的慢查询语句：</p>
<p><code>set global slowquerylog=&#39;ON&#39;;</code></p>
<p>使用 <code>set global slowquerylog=&#39;ON&#39;</code> 开启慢查询日志，只是对当前数据库有效，如果 MySQL 数据库重启后就会失效。所以如果要永久生效，就要修改配置文件<code> my.cnf</code>，设置<code> slowquerylog=1</code> 并重启 MySQL 服务器。</p>
<p>④ <code>redo log</code>（重做日志）：为了最大程度的避免数据写入时，因为 IO 瓶颈造成的性能问题，MySQL 采用了这样一种缓存机制，先将数据写入内存中，再批量把内存中的数据统一刷回磁盘。为了避免将数据刷回磁盘过程中，因为掉电或系统故障带来的数据丢失问题，InnoDB 采用 <code>redo log</code> 来解决此问题。</p>
<p>⑤ <code>undo log</code>（回滚日志）：用于存储日志被修改前的值，从而保证如果修改出现异常，可以使用 <code>undo log </code>日志来实现回滚操作。<code>undo log </code>和<code> redo log</code> 记录物理日志不一样，它是逻辑日志，可以认为当 <code>delete</code> 一条记录时，<code>undo log</code> 中会记录一条对应的<code> insert</code> 记录，反之亦然，当 <code>update</code> 一条记录时，它记录一条对应相反的 <code>update</code> 记录，当执行 rollback 时，就可以从 <code>undo log</code> 中的逻辑记录读取到相应的内容并进行回滚。<code>undo log </code>默认存放在共享表空间中，在 <code>mySQL 5.6</code> 中，<code>undo log</code> 的存放位置还可以通过变量<code>innodbundodirectory</code>来自定义存放目录，默认值为“.”表示 <code>datadir </code>目录。</p>
<p>⑥ <code>bin log</code>（二进制日志）：是一个二进制文件，主要记录所有数据库表结构变更，比如，<code>CREATE、ALTER TABLE</code> 等，以及表数据修改，比如，<code>INSERT、UPDATE、DELETE</code> 的所有操作，<code>bin log</code> 中记录了对 MySQL 数据库执行更改的所有操作，并且记录了语句发生时间、执行时长、操作数据等其它额外信息，但是它不记录<code>SELECT、SHOW</code>等那些不修改数据的 SQL 语句。</p>
<p>binlog 的作用如下：</p>
<ul>
<li><p>恢复（recovery）：某些数据的恢复需要二进制日志。比如，在一个数据库全备文件恢复后，用户可以通过二进制日志进行 point-in-time 的恢复；</p>
</li>
<li><p>复制（replication）：其原理与恢复类似，通过复制和执行二进制日志使一台远程的MySQL数据库（一般称为 slave 或者 standby）与一台 MySQL 数据库（一般称为 master 或者 primary）进行实时同步；</p>
</li>
<li><p>审计（audit）：用户可以通过二进制日志中的信息来进行审计，判断是否有对数据库进行注入攻击。</p>
</li>
</ul>
<p>除了上面介绍的几个作用外，binlog 对于事务存储引擎的崩溃恢复也有非常重要的作用，在开启 binlog 的情况下，为了保证 binlog 与 redo 的一致性，MySQL 将采用事务的两阶段提交协议。当 MySQL 系统发生崩溃时，事务在存储引擎内部的状态可能为 prepared（准备状态）和 commit（提交状态）两种，对于 prepared 状态的事务，是进行提交操作还是进行回滚操作，这时需要参考 binlog，如果事务在 binlog 中存在，那么将其提交；如果不在 binlog 中存在，那么将其回滚，这样就保证了数据在主库和从库之间的一致性。</p>
<p>binlog 默认是关闭状态，可以在 MySQL 配置文件（my.cnf）中通过配置参数 <code>log-bin = [base-name]</code> 开启记录 binlog 日志，如果不指定 <code>base-name</code>，则默认二进制日志文件名为主机名，并以自增的数字作为后缀，比如：<code>mysql-bin.000001</code>，所在目录为数据库所在目录（datadir）。</p>
<p>通过以下命令来查询 binlog 是否开启：</p>
<p><code>show variables like &#39;log_%&#39;;</code></p>
<p><img src="/images/mysql/binlog.png" srcset="/img/loading.gif"> </p>
<p>binlog 格式分为: STATEMENT、ROW 和 MIXED 三种：</p>
<ul>
<li><p>STATEMENT 格式的 binlog 记录的是数据库上执行的原生 SQL 语句。这种格式的优点是简单，简单地记录和执行这些语句，能够让主备保持同步，在主服务器上执行的 SQL 语句，在从服务器上执行同样的语句。另一个好处是二进制日志里的时间更加紧凑，所以相对而言，基于语句的复制模式不会使用太多带宽，同时也节约磁盘空间。并且通过 mysqlbinlog 工具容易读懂其中的内容。缺点就是同一条 SQL 在主库和从库上执行的时间可能稍微或很大不相同，因此在传输的二进制日志中，除了查询语句，还包括了一些元数据信息，如当前的时间戳。即便如此，还存在着一些无法被正确复制的 SQL。比如，使用 <code>INSERT INTO TB1 VALUE(CUURENT_DATE()) </code>这一条使用函数的语句插入的数据复制到当前从服务器上来就会发生变化，存储过程和触发器在使用基于语句的复制模式时也可能存在问题；另外一个问题就是基于语句的复制必须是串行化的，比如：InnoDB 的 next-key 锁等，并不是所有的存储引擎都支持基于语句的复制；</p>
</li>
<li><p>ROW 格式是从 MySQL 5.1 开始支持基于行的复制，也就是基于数据的复制，基于行的更改。这种方式会将实际数据记录在二进制日志中，它有其自身的一些优点和缺点，最大的好处是可以正确地复制每一行数据，一些语句可以被更加有效地复制，另外就是几乎没有基于行的复制模式无法处理的场景，对于所有的 SQL 构造、触发器、存储过程等都能正确执行；它的缺点就是二进制日志可能会很大，而且不直观，所以，你不能使用 mysqlbinlog 来查看二进制日志，也无法通过看二进制日志判断当前执行到那一条 SQL 语句。现在对于 ROW 格式的二进制日志基本是标配了，主要是因为它的优势远远大于缺点，并且由于 ROW 格式记录行数据，所以可以基于这种模式做一些 DBA 工具，比如数据恢复，不同数据库之间数据同步等；</p>
</li>
<li><p>MIXED 也是 MySQL 默认使用的二进制日志记录方式，但 MIXED 格式默认采用基于语句的复制，一旦发现基于语句的无法精确的复制时，就会采用基于行的复制。比如用到 UUID()、USER()、CURRENTUSER()、ROWCOUNT() 等无法确定的函数。</p>
</li>
</ul>
<h5 id="redo-log-和-binlog-有什么区别？"><a href="#redo-log-和-binlog-有什么区别？" class="headerlink" title="redo log 和 binlog 有什么区别？"></a>redo log 和 binlog 有什么区别？</h5><p>redo log（重做日志）和 binlog（归档日志）都是 MySQL 的重要的日志，它们的区别如下：</p>
<ul>
<li><p>redo log 是物理日志，记录的是“在某个数据页上做了什么修改”。</p>
</li>
<li><p>binlog 是逻辑日志，记录的是这个语句的原始逻辑，比如“给 ID=2 这一行的 c 字段加 1 ”。</p>
</li>
<li><p>redo log 是 InnoDB 引擎特有的；binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用。</p>
</li>
<li><p>redo log 是循环写的，空间固定会用完；binlog 是可以追加写入的。“追加写”是指 binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。</p>
</li>
</ul>
<p>最开始 MySQL 里并没有 InnoDB 引擎，MySQL 自带的引擎是 MyISAM，但是 MyISAM 没有 crash-safe 的能力，binlog 日志只能用于归档。而 InnoDB 是另一个公司以插件形式引入 MySQL 的，既然只依靠 binlog 是没有 crash-safe 能力的，所以 InnoDB 使用另外一套日志系统，也就是 redo log 来实现 crash-safe 能力。</p>
<h5 id="什么是-crash-safe？"><a href="#什么是-crash-safe？" class="headerlink" title="什么是 crash-safe？"></a>什么是 crash-safe？</h5><p>crash-safe 是指发生宕机等意外情况下，服务器重启后数据依然不会丢失的情况。</p>
<h5 id="什么是脏页和干净页？"><a href="#什么是脏页和干净页？" class="headerlink" title="什么是脏页和干净页？"></a>什么是脏页和干净页？</h5><p>MySQL 为了操作的性能优化，会把数据更新先放入内存中，之后再统一更新到磁盘。当内存数据和磁盘数据内容不一致的时候，我们称这个内存页为脏页；内存数据写到磁盘后，内存的数据和磁盘上的内容就一致了，我们称为“干净页”。</p>
<h5 id="什么情况下会引发-MySQL-刷脏页（flush）的操作？"><a href="#什么情况下会引发-MySQL-刷脏页（flush）的操作？" class="headerlink" title="什么情况下会引发 MySQL 刷脏页（flush）的操作？"></a>什么情况下会引发 MySQL 刷脏页（flush）的操作？</h5><ul>
<li><p>内存写满了，这个时候就会引发 flush 操作，对应到 InnoDB 就是 redo log 写满了；</p>
</li>
<li><p>系统的内存不足了，当需要新的内存页的时候，就会淘汰一些内存页，如果淘汰的是脏页这个时候就会触发 flush 操作；</p>
</li>
<li><p>系统空闲的时候，MySQL 会同步内存中的数据到磁盘也会触发 flush 操作；</p>
</li>
<li><p>MySQL 服务关闭的时候也会刷脏页，触发 flush 操作。</p>
</li>
</ul>
<h5 id="MySQL-刷脏页的速度很慢可能是什么原因？"><a href="#MySQL-刷脏页的速度很慢可能是什么原因？" class="headerlink" title="MySQL 刷脏页的速度很慢可能是什么原因？"></a>MySQL 刷脏页的速度很慢可能是什么原因？</h5><p>在 MySQL 中单独刷一个脏页的速度是很快的，如果发现刷脏页的速度很慢，说明触发了 MySQL 刷脏页的“连坐”机制，MySQL 的“连坐”机制是指当 MySQL 刷脏页的时候如果发现相邻的数据页也是脏页也会一起刷掉，而这个动作可以一直蔓延下去，这就是导致 MySQL 刷脏页慢的原因了。</p>
<h5 id="如何控制-MySQL-只刷新当前脏页？"><a href="#如何控制-MySQL-只刷新当前脏页？" class="headerlink" title="如何控制 MySQL 只刷新当前脏页？"></a>如何控制 MySQL 只刷新当前脏页？</h5><p>在 InnoDB 中设置 innodbflushneighbors 这个参数的值为 0，来规定 MySQL 只刷当前脏页，MySQL 8 这个值默认是 0。</p>
<h5 id="MySQL-的-WAL-技术是解决什么问题的？"><a href="#MySQL-的-WAL-技术是解决什么问题的？" class="headerlink" title="MySQL 的 WAL 技术是解决什么问题的？"></a>MySQL 的 WAL 技术是解决什么问题的？</h5><p>A.防止误删除，找回数据用的</p>
<p>B.容灾恢复，为了还原异常数据用的</p>
<p>C.事务处理，为了数据库的稳定性</p>
<p>D.为了降低 IO 成本 </p>
<p>答：D 题目解析：WAL 技术的全称是 Write Ahead Logging（中文：预写式日志），是先写日志，再写磁盘的方式，因为每次更新都写磁盘的话 IO 成本很高，所以才有了 WAL 技术。</p>
<h5 id="为什么有时候会感觉-MySQL-偶尔卡一下？"><a href="#为什么有时候会感觉-MySQL-偶尔卡一下？" class="headerlink" title="为什么有时候会感觉 MySQL 偶尔卡一下？"></a>为什么有时候会感觉 MySQL 偶尔卡一下？</h5><p>如果偶尔感觉 MySQL 卡一下，可能是 MySQL 正在刷脏页，正在把内存中的更新操作刷到磁盘中。</p>
<h5 id="redo-log-和-binlog-是怎么关联的"><a href="#redo-log-和-binlog-是怎么关联的" class="headerlink" title="redo log 和 binlog 是怎么关联的?"></a>redo log 和 binlog 是怎么关联的?</h5><p>它们有一个共同的数据字段，叫 XID。崩溃恢复的时候，会按顺序扫描 redo log：</p>
<ul>
<li><p>如果碰到既有 prepare、又有 commit 的 redo log，就直接提交；</p>
</li>
<li><p>如果碰到只有 parepare、而没有 commit 的 redo log，就拿着 XID 去 binlog 找对应的事务。</p>
</li>
</ul>
<h5 id="MySQL-怎么知道-binlog-是完整的"><a href="#MySQL-怎么知道-binlog-是完整的" class="headerlink" title="MySQL 怎么知道 binlog 是完整的?"></a>MySQL 怎么知道 binlog 是完整的?</h5><ul>
<li><p>statement 格式的 binlog，完整的标识是最后有 COMMIT 关键字。</p>
</li>
<li><p>row 格式的 binlog，完整的标识是最后会有一个 XID event 关键字。</p>
</li>
</ul>
<h5 id="MySQL-中可不可以只要-binlog，不要-redo-log？"><a href="#MySQL-中可不可以只要-binlog，不要-redo-log？" class="headerlink" title="MySQL 中可不可以只要 binlog，不要 redo log？"></a>MySQL 中可不可以只要 binlog，不要 redo log？</h5><p>不可以，binlog 没有崩溃恢复的能力。</p>
<h5 id="MySQL-中可不可以只要-redo-log，不要-binlog？"><a href="#MySQL-中可不可以只要-redo-log，不要-binlog？" class="headerlink" title="MySQL 中可不可以只要 redo log，不要 binlog？"></a>MySQL 中可不可以只要 redo log，不要 binlog？</h5><p>不可以，原因有以下两个：</p>
<ul>
<li><p>redo log 是循环写不能保证所有的历史数据，这些历史数据只能在 binlog 中找到；</p>
</li>
<li><p>binlog 是高可用的基础，高可用的实现原理就是 binlog 复制。</p>
</li>
</ul>
<h5 id="为什么-binlog-cache-是每个线程自己维护的，而-redo-log-buffer-是全局共用的？"><a href="#为什么-binlog-cache-是每个线程自己维护的，而-redo-log-buffer-是全局共用的？" class="headerlink" title="为什么 binlog cache 是每个线程自己维护的，而 redo log buffer 是全局共用的？"></a>为什么 binlog cache 是每个线程自己维护的，而 redo log buffer 是全局共用的？</h5><p>因为 binlog 是不能“被打断的”，一个事务的 binlog 必须连续写，因此要整个事务完成后，再一起写到文件里。而 redo log 并没有这个要求，中间有生成的日志可以写到 redo log buffer 中，redo log buffer 中的内容还能“搭便车”，其他事务提交的时候可以被一起写到磁盘中。</p>
<h5 id="事务执行期间，还未提交，如果发生-crash，redo-log-丢失，会导致主备不一致呢？"><a href="#事务执行期间，还未提交，如果发生-crash，redo-log-丢失，会导致主备不一致呢？" class="headerlink" title="事务执行期间，还未提交，如果发生 crash，redo log 丢失，会导致主备不一致呢？"></a>事务执行期间，还未提交，如果发生 crash，redo log 丢失，会导致主备不一致呢？</h5><p>不会，因为这时候 binlog 也还在 binlog cache 里，没发给备库，crash 以后 redo log 和 binlog 都没有了，从业务角度看这个事务也没有提交，所以数据是一致的。</p>
<h5 id="在-MySQL-中用什么机制来优化随机读-写磁盘对-IO-的消耗？"><a href="#在-MySQL-中用什么机制来优化随机读-写磁盘对-IO-的消耗？" class="headerlink" title="在 MySQL 中用什么机制来优化随机读/写磁盘对 IO 的消耗？"></a>在 MySQL 中用什么机制来优化随机读/写磁盘对 IO 的消耗？</h5><p>redo log 是用来节省随机写磁盘的 IO 消耗，而 change buffer 主要是节省随机读磁盘的 IO 消耗。redo log 会把 MySQL 的更新操作先记录到内存中，之后再统一更新到磁盘，而 change buffer 也是把关键查询数据先加载到内存中，以便优化 MySQL 的查询。</p>
<h5 id="以下说法错误的是？"><a href="#以下说法错误的是？" class="headerlink" title="以下说法错误的是？"></a>以下说法错误的是？</h5><p>A.redo log 是 InnoDB 引擎特有的，它的固定大小的 </p>
<p>B.redo log 日志是不全的，只有最新的一些日志，这和它的内存大小有关</p>
<p>C.redo log 可以保证数据库异常重启之后，数据不丢失</p>
<p>D.binlog 是 MySQL 自带的日志，它能保证数据库异常重启之后，数据不丢失 </p>
<p>答：D 题目解析：binlog 是 MySQL 自带的日志，但它并不能保证数据库异常重启之后数据不丢失。</p>
<h5 id="以下说法正确的是？"><a href="#以下说法正确的是？" class="headerlink" title="以下说法正确的是？"></a>以下说法正确的是？</h5><p>A.redo log 日志是追加写的，后面的日志并不会覆盖前面的日志</p>
<p>B.binlog 日志是追加写的，后面的日志并不会覆盖前面的日志</p>
<p>C.redo log 和 binlog 日志都是追加写的，后面的日志并不会覆盖前面的日志 </p>
<p>D.以上说法都正确</p>
<p>答：B 题目解析：binlog 日志是追加写的，后面的日志并不会覆盖前面的日志，redo log 日志是固定大小的，后面的日志会覆盖前面的日志。</p>
<h5 id="有没有办法把-MySQL-的数据恢复到过去某个指定的时间节点？怎么恢复？"><a href="#有没有办法把-MySQL-的数据恢复到过去某个指定的时间节点？怎么恢复？" class="headerlink" title="有没有办法把 MySQL 的数据恢复到过去某个指定的时间节点？怎么恢复？"></a>有没有办法把 MySQL 的数据恢复到过去某个指定的时间节点？怎么恢复？</h5><p>可以恢复，只要你备份了这段时间的所有 binlog，同时做了全量数据库的定期备份，比如，一天一备，或者三天一备，这取决于你们的备份策略，这个时候你就可以把之前备份的数据库先还原到测试库，从备份的时间点开始，将备份的 binlog 依次取出来，重放到你要恢复数据的那个时刻，这个时候就完成了数据到指定节点的恢复。比如，今天早上 9 点的时候，你想把数据恢复成今天早上 6:00:00 的状态，这个时候你可以先取出今天凌晨（00:01:59）备份的数据库文件，还原到测试库，再从 binlog 文件中依次取出 00:01:59 之后的操作信息，重放到 6:00:00 这个时刻，这就完成了数据库的还原。</p>
<h4 id="MySQL-命令和内置函数"><a href="#MySQL-命令和内置函数" class="headerlink" title="MySQL 命令和内置函数"></a>MySQL 命令和内置函数</h4><h5 id="如何用命令行方式连接-MySQL-数据库？"><a href="#如何用命令行方式连接-MySQL-数据库？" class="headerlink" title="如何用命令行方式连接 MySQL 数据库？"></a>如何用命令行方式连接 MySQL 数据库？</h5><p>使用 mysql -u用户名 -p密码; 输入用户名和密码就可以正常进入数据库连接了，实例如下：</p>
<p><code>mysql -uroot -p123456;</code></p>
<p>其中，用户名为 root，密码为 123456。</p>
<h5 id="关于命令-mysql-h-127-0-0-1-uroot-P-3307-p3307-以下说法错误的是？"><a href="#关于命令-mysql-h-127-0-0-1-uroot-P-3307-p3307-以下说法错误的是？" class="headerlink" title="关于命令 mysql -h 127.0.0.1 -uroot -P 3307 -p3307 以下说法错误的是？"></a>关于命令 mysql -h 127.0.0.1 -uroot -P 3307 -p3307 以下说法错误的是？</h5><p>A.-h 和 -P 可以省略 </p>
<p>B.-u 和用户名之间不能有空格</p>
<p>C.-p 和密码之间不能用空格</p>
<p>D.小写 -p 对应的是用户密码，大写 -P 对应的是 MySQL 服务器的端口</p>
<p>答：B 题目解析：-p 和密码之间不能用空格，否则空格会被识别为密码的一部分，提示密码错误。-u 和用户名之间可以有空格。</p>
<h5 id="如何创建用户？并给用户授权？"><a href="#如何创建用户？并给用户授权？" class="headerlink" title="如何创建用户？并给用户授权？"></a>如何创建用户？并给用户授权？</h5><p>创建用户使用关键字：CREATE USER ，授权使用关键字： GRANT ，具体实现脚本如下：</p>
<pre><code class="hljs mysql">-- 创建用户laowang 
create user &#39;laowang&#39;@&#39;localhost&#39; identified by &#39;123456&#39;; 
-- 授权 test 数据库给 laowang 
grant all on test.* to &#39;laowang&#39;@&#39;localhost&#39;</code></pre>

<h5 id="如何修改-MySQL-密码？"><a href="#如何修改-MySQL-密码？" class="headerlink" title="如何修改 MySQL 密码？"></a>如何修改 MySQL 密码？</h5><p>使用如下命令，修改密码：</p>
<p><code>mysqladmin -u用户名 -p旧密码 password 新密码;</code></p>
<p>注意：刚开始 root 没有密码，所以 -p 旧密码一项就可以省略了。</p>
<h5 id="如何使用-SQL-创建数据库，并设置数据库的编码格式？"><a href="#如何使用-SQL-创建数据库，并设置数据库的编码格式？" class="headerlink" title="如何使用 SQL 创建数据库，并设置数据库的编码格式？"></a>如何使用 SQL 创建数据库，并设置数据库的编码格式？</h5><p>创建数据库可使用关键字： CREATE DATABASE ，设置编码格式使用关键字： CHARSET ，具体 SQL 如下：</p>
<pre><code class="hljs mysql">create database learndb default charset utf8 collate utf8_general_ci;</code></pre>

<h5 id="如何修改数据库、表的编码格式？"><a href="#如何修改数据库、表的编码格式？" class="headerlink" title="如何修改数据库、表的编码格式？"></a>如何修改数据库、表的编码格式？</h5><p>使用 alter 关键字设置库或表的编码格式即可，具体代码如下：</p>
<pre><code class="hljs mysql">mysql&gt; alter database dbname default character set utf8; mysql&gt; alter table t default character set utf8;</code></pre>

<h5 id="如何使用-SQL-创建表？"><a href="#如何使用-SQL-创建表？" class="headerlink" title="如何使用 SQL 创建表？"></a>如何使用 SQL 创建表？</h5><p>创建表的 SQL 如下：</p>
<pre><code class="hljs mysql">create table t(   
  tid int not null autoincrement,   
  tname char(50) not null,   
  tage int null default 18,   
  primary key(t_id) 
)engine&#x3D;innodb;</code></pre>

<p>其中：</p>
<ul>
<li><p>auto_increment：表示自增；</p>
</li>
<li><p>primary key：用于指定主键；</p>
</li>
<li><p>engine：用于指定表的引擎。</p>
</li>
</ul>
<h5 id="在-MySQL-命令行中如何查看表结构信息？"><a href="#在-MySQL-命令行中如何查看表结构信息？" class="headerlink" title="在 MySQL 命令行中如何查看表结构信息？"></a>在 MySQL 命令行中如何查看表结构信息？</h5><p>使用 desc 表名 查看表结构信息，示例信息如下：</p>
<p> <img src="/images/mysql/desc.png" srcset="/img/loading.gif"></p>
<p>使用 desc person; 查看表 person 的结构信息。</p>
<h5 id="如何使用-SQL-查看已知表的建表脚本？"><a href="#如何使用-SQL-查看已知表的建表脚本？" class="headerlink" title="如何使用 SQL 查看已知表的建表脚本？"></a>如何使用 SQL 查看已知表的建表脚本？</h5><p>查看已知表的建表脚本，命令如下：</p>
<p>mysql&gt; show create table 表名; </p>
<p>效果如下图所示：</p>
<p><img src="/images/mysql/create.png" srcset="/img/loading.gif"></p>
<h5 id="如何使用-SQL-语句更新表结构？"><a href="#如何使用-SQL-语句更新表结构？" class="headerlink" title="如何使用 SQL 语句更新表结构？"></a>如何使用 SQL 语句更新表结构？</h5><p>更新表结构信息可以使用 alter table 子句，如，为表增加一列的脚本如下：alter</p>
<p><code>alter table t add name char(20)；</code></p>
<p>如果要重命名表名，使用如下命令：</p>
<p><code>rename table new_t to t;</code></p>
<h5 id="MySQL-有哪些删除方式？有什么区别？"><a href="#MySQL-有哪些删除方式？有什么区别？" class="headerlink" title="MySQL 有哪些删除方式？有什么区别？"></a>MySQL 有哪些删除方式？有什么区别？</h5><p>MySQL 有三种删除方式： 1）删除表数据：</p>
<p><code>delete from t;</code></p>
<p>2）删除数据，保留表结构：</p>
<p><code>truncate table t;</code></p>
<p>3）删数据和表结构：</p>
<p><code>drop table t;</code></p>
<p>它们的区别如下：</p>
<ul>
<li><p>delete 可以有条件的删除，也可以回滚数据，删除数据时进行两个动作：删除与备份，所以速度很慢；</p>
</li>
<li><p>truncate 删除所有数据，无条件选择删除，不可回滚，保留表结构；</p>
</li>
<li><p>drop：删除数据和表结构 删除速度最快。</p>
</li>
</ul>
<p>执行速度，一般来说：drop&gt; truncate &gt; delete。</p>
<p>补充：delete 语句是数据库操作语言（dml），这个操作会放到 rollback segement 中，事务提交之后才生效；如果有相应的 trigger，执行的时候将被触发。truncate、drop 是数据库定义语言（ddl），操作立即生效，原数据不放到 rollback segment 中，不能回滚，操作不触发 trigger。</p>
<p>应用场景：</p>
<ul>
<li><p>当你不再需要该表时， 用 drop</p>
</li>
<li><p>当你仍要保留该表，但要删除所有记录时， 用 truncate</p>
</li>
<li><p>当你要删除部分记录时（always with a where clause），用 delete</p>
</li>
</ul>
<h5 id="如何开启和关闭-MySQL-服务？"><a href="#如何开启和关闭-MySQL-服务？" class="headerlink" title="如何开启和关闭 MySQL 服务？"></a>如何开启和关闭 MySQL 服务？</h5><p>使用 systemctl stop mysqld 停止 MySQL 服务，使用 systemctl start mysqld 启动 MySQL 服务。</p>
<h5 id="如何查询当前-MySQL-安装的版本号？"><a href="#如何查询当前-MySQL-安装的版本号？" class="headerlink" title="如何查询当前 MySQL 安装的版本号？"></a>如何查询当前 MySQL 安装的版本号？</h5><p>使用 SELECT VERSION(); </p>
<p>可以查询当前连接的 MySQL 的版本号。</p>
<h5 id="如何查看某张表的存储引擎？"><a href="#如何查看某张表的存储引擎？" class="headerlink" title="如何查看某张表的存储引擎？"></a>如何查看某张表的存储引擎？</h5><p>可使用 show table status from db where name=’t’; 查询数据库 db 中表 t 的所有信息，其中 Engine 列表示表 t 使用的存储引擎，如下图所示：</p>
<p> <img src="/images/mysql/engine.png" srcset="/img/loading.gif"></p>
<h5 id="如何查看当前数据库增删改查的执行次数统计？"><a href="#如何查看当前数据库增删改查的执行次数统计？" class="headerlink" title="如何查看当前数据库增删改查的执行次数统计？"></a>如何查看当前数据库增删改查的执行次数统计？</h5><p>使用以下命令行查看：</p>
<pre><code class="hljs mysql">mysql&gt; show global status where variablename in(&#39;comselect&#39;,&#39;cominsert&#39;,&#39;comdelete&#39;,&#39;comupdate&#39;); 
+---------------+-------+ 
| Variablename | Value | 
+---------------+-------+ 
| Comdelete   | 0   | 
| Cominsert   | 1   | 
| Comselect   | 40   | 
| Comupdate   | 0   | 
+---------------+-------+</code></pre>

<h5 id="如何查询线程连接数？"><a href="#如何查询线程连接数？" class="headerlink" title="如何查询线程连接数？"></a>如何查询线程连接数？</h5><p>使用如下命令：</p>
<p><code>mysql&gt; show global status like &#39;threads_%&#39;;</code></p>
<p>执行效果如下图所示：</p>
<p> <img src="/images/mysql/thread.png" srcset="/img/loading.gif"></p>
<p>其中：</p>
<ul>
<li><p>Threads_cached：代表当前此时此刻线程缓存中有多少空闲线程；</p>
</li>
<li><p>Threads_connected：代表当前已建立连接的数量，因为一个连接就需要一个线程，所以也可以看成当前被使用的线程数；</p>
</li>
<li><p>Threads_created：代表从最近一次服务启动，已创建线程的数量；</p>
</li>
<li><p>Threads_running：代表当前激活的（非睡眠状态）线程数。</p>
</li>
</ul>
<h5 id="如何查看-MySQL-的最大连接数？能不能修改？怎么修改？"><a href="#如何查看-MySQL-的最大连接数？能不能修改？怎么修改？" class="headerlink" title="如何查看 MySQL 的最大连接数？能不能修改？怎么修改？"></a>如何查看 MySQL 的最大连接数？能不能修改？怎么修改？</h5><p>查询 MySQL 最大连接数，使用如下命令：</p>
<p><code>mysql&gt; show variables like &#39;max_connections%&#39;;</code></p>
<p>此命令输出的结果如下：</p>
<p> <img src="/images/mysql/maxconn.png" srcset="/img/loading.gif"></p>
<p>可以修改 MySQL 的最大连接数，可以在 MySQL 的配置文件 my.cnf 里修改最大连接数，通过修改 maxconnections 的值，然后重启 MySQL 就会生效，如果 my.ini 文件中没有找到 maxconnections，可自行添加 max_connections 的设置，内容如下：</p>
<p><code>max_connections=200</code></p>
<h5 id="CHAR-LENGTH-和-LENGTH-有什么区别？"><a href="#CHAR-LENGTH-和-LENGTH-有什么区别？" class="headerlink" title="CHAR_LENGTH 和 LENGTH 有什么区别？"></a>CHAR_LENGTH 和 LENGTH 有什么区别？</h5><p>CHARLENGTH 是字符数，而 LENGTH 是字节数。它们在不同编码下，值是不相同的，比如对于 UTF-8 编码来说，一个中文字的 LENGTH 为 1，而 CHARLENGTH 通常等于 3，如下图所示：</p>
<p> <img src="/images/mysql/charlength.png" srcset="/img/loading.gif"></p>
<h5 id="UNION-和-UNION-ALL-的用途是什么？有什么区别？"><a href="#UNION-和-UNION-ALL-的用途是什么？有什么区别？" class="headerlink" title="UNION 和 UNION ALL 的用途是什么？有什么区别？"></a>UNION 和 UNION ALL 的用途是什么？有什么区别？</h5><p>UNION 和 UNION ALL 都是用于合并数据集的，它们的区别如下：</p>
<ul>
<li><p>去重：UNION 会对结果进行去重，UNION ALL 则不会进行去重操作；</p>
</li>
<li><p>排序：UNION 会对结果根据字段进行排序，而 UNION ALL 则不会进行排序；</p>
</li>
<li><p>性能：UNION ALL 的性能要高于 UNION。</p>
</li>
</ul>
<h5 id="以下关于-WHERE-和-HAVING-说法正确的是？"><a href="#以下关于-WHERE-和-HAVING-说法正确的是？" class="headerlink" title="以下关于 WHERE 和 HAVING 说法正确的是？"></a>以下关于 WHERE 和 HAVING 说法正确的是？</h5><p>A.任何情况 WHERE 和 HAVING 都可以相互替代 </p>
<p>B.GROUP BY 前后都可以使用 WHERE </p>
<p>C.使用 SELECT X FROM T HAVING Y&gt;20 查询报错 </p>
<p>D.使用 SELECT X FROM T WHERE Y&gt;20 查询报错 </p>
<p>答：C，HAVING 非报错用法是 SELECT X,Y FROM T HAVING Y&gt;20 。</p>
<h5 id="空值和-NULL-的区别是什么？"><a href="#空值和-NULL-的区别是什么？" class="headerlink" title="空值和 NULL 的区别是什么？"></a>空值和 NULL 的区别是什么？</h5><p>空值表示字段的值为空，而 NULL 则表示字段没有值，它们的区别如下：</p>
<ul>
<li><p>空值不占用空间，NULL 值是未知的占用空间；</p>
</li>
<li><p>空值判断使用 =’’ 或 &lt;&gt;’’ 来判断，NULL 值使用 IS NULL 或 IS NOT NULL 来判断；</p>
</li>
<li><p>使用 COUNT 统计某字段时，如果是 NULL 则会忽略不统计，而空值则会算入统计之内。</p>
</li>
</ul>
<p>比如，其中字段 name 有一个 NULL 值和两个空值，查询结果如图：</p>
<p> <img src="/images/mysql/count.png" srcset="/img/loading.gif"></p>
<h5 id="MySQL-的常用函数有哪些？"><a href="#MySQL-的常用函数有哪些？" class="headerlink" title="MySQL 的常用函数有哪些？"></a>MySQL 的常用函数有哪些？</h5><ul>
<li><p>sum(field) – 求某个字段的和值；</p>
</li>
<li><p>count(*) – 查询总条数；</p>
</li>
<li><p>min(field) – 某列中最小的值；</p>
</li>
<li><p>max(field) – 某列中最大的值；</p>
</li>
<li><p>avg(field) – 求平均数；</p>
</li>
<li><p>current_date() – 获取当前日期；</p>
</li>
<li><p>now() – 获取当前日期和时间；</p>
</li>
<li><p>concat(a, b) – 连接两个字符串值以创建单个字符串输出；</p>
</li>
<li><p>datediff(a, b) – 确定两个日期之间的差异，通常用于计算年龄。</p>
</li>
</ul>
<h4 id="MySQL-性能优化-amp-分布式"><a href="#MySQL-性能优化-amp-分布式" class="headerlink" title="MySQL 性能优化 &amp; 分布式"></a>MySQL 性能优化 &amp; 分布式</h4><h5 id="MySQL-性能指标都有哪些？如何得到这些指标？"><a href="#MySQL-性能指标都有哪些？如何得到这些指标？" class="headerlink" title="MySQL 性能指标都有哪些？如何得到这些指标？"></a>MySQL 性能指标都有哪些？如何得到这些指标？</h5><p>MySQL 的性能指标如下：</p>
<p>① TPS（Transaction Per Second） 每秒事务数，即数据库每秒执行的事务数。</p>
<p>MySQL 本身没有直接提供 TPS 参数值，如果我们想要获得 TPS 的值，只有我们自己计算了，可以根据 MySQL 数据库提供的状态变量，来计算 TPS。</p>
<p>需要使用的参数：</p>
<ul>
<li><p>Com_commit ：表示提交次数，通过命令 show global status like ‘Com_commit’; 获取；</p>
</li>
<li><p>Com_rollback：表示回滚次数，通过命令 show global status like ‘Com_rollback’; 获取。</p>
</li>
</ul>
<p>我们定义第一次获取的 Comcommit 的值与 Comrollback 值的和为 c_r1，时间为 t1；</p>
<p>第二次获取的 Comcommit 的值与 Comrollback 值的和为 cr2，时间为 t2，t1 与 t2 单位为秒。 那么 TPS = ( cr2 - c_r1 ) / ( t2 - t1 ) 算出来的就是该 MySQL 实例在 t1 与 t2 生命周期之间的平均 TPS。</p>
<p>② QPS（Query Per Second） 每秒请求次数，也就是数据库每秒执行的 SQL 数量，包含 INSERT、SELECT、UPDATE、DELETE 等。 QPS = Queries / Seconds Queries 是系统状态值—总查询次数，可以通过 show status like ‘queries’; 查询得出，如下所示：</p>
<p> <img src="/imaegs/queries.png" srcset="/img/loading.gif"></p>
<p>Seconds 是监控的时间区间，单位为秒。 比如，采样 10 秒内的查询次数，那么先查询一次 Queries 值（Q1），等待 10 秒，再查询一次 Queries 值（Q2），那么 QPS 就可以通过，如下公式获得：</p>
<p>QPS = (Q2 - Q1) / 10</p>
<p>③ IOPS（Input/Output Operations per Second） 每秒处理的 I/O 请求次数。</p>
<p>IOPS 是判断磁盘 I/O 能力的指标之一，一般来讲 IOPS 指标越高，那么单位时间内能够响应的请求自然也就越多。理论上讲，只要系统实际的请求数低于 IOPS 的能力，就相当于每一个请求都能得到即时响应，那么 I/O 就不会是瓶颈了。</p>
<p>注意：IOPS 与磁盘吞吐量不一样，吞吐量是指单位时间内可以成功传输的数据数量。</p>
<p>可以使用 iostat 命令，查看磁盘的 IOPS，命令如下：</p>
<pre><code class="hljs zsh">yum install sysstat iostat  -dx 1 10</code></pre>

<p>执行效果如下图所示：</p>
<p> <img src="/images/mysql/iostat.png" srcset="/img/loading.gif"></p>
<p>IOPS = r/s + w/s 其中：</p>
<p>l r/s：代表每秒读了多少次；</p>
<p>l w/s：代表每秒写了多少次。</p>
<h5 id="什么是慢查询？"><a href="#什么是慢查询？" class="headerlink" title="什么是慢查询？"></a>什么是慢查询？</h5><p>慢查询是 MySQL 中提供的一种慢查询日志，它用来记录在 MySQL 中响应时间超过阀值的语句，具体指运行时间超过 longquerytime 值的 SQL，则会被记录到慢查询日志中。longquerytime 的默认值为 10，意思是运行 10S 以上的语句。默认情况下，MySQL 数据库并不启动慢查询日志，需要我们手动来设置这个参数，如果不是调优需要的话，一般不建议启动该参数，因为开启慢查询日志会给 MySQL 服务器带来一定的性能影响。慢查询日志支持将日志记录写入文件，也支持将日志记录写入数据库表。</p>
<p>使用 <code>mysql&gt; show variables like &#39;%slow_query_log%&#39;; </code>来查询慢查询日志是否开启，执行效果如下图所示：</p>
<p> <img src="/images/mysql/slow.png" srcset="/img/loading.gif"></p>
<p>slowquerylog 的值为 OFF 时，表示未开启慢查询日志。</p>
<h5 id="如何开启慢查询日志？"><a href="#如何开启慢查询日志？" class="headerlink" title="如何开启慢查询日志？"></a>如何开启慢查询日志？</h5><p>开启慢查询日志，可以使用如下 MySQL 命令：</p>
<p><code>mysql&gt; set global slowquerylog=1</code></p>
<p>不过这种设置方式，只对当前数据库生效，如果 MySQL 重启也会失效，如果要永久生效，就必须修改 MySQL 的配置文件 my.cnf，配置如下：</p>
<p><code>slowquerylog =1 slowquerylogfile=/tmp/mysqlslow.log</code></p>
<h5 id="如何定位慢查询？"><a href="#如何定位慢查询？" class="headerlink" title="如何定位慢查询？"></a>如何定位慢查询？</h5><p>使用 MySQL 中的 explain 分析执行语句，比如：</p>
<p><code>explain select * from t where id=5;</code></p>
<p>如下图所示：</p>
<p><img src="/images/mysql/explain.png" srcset="/img/loading.gif"></p>
<p>其中：</p>
<ul>
<li><p>id — 选择标识符。id越大优先级越高，越先被执行。</p>
</li>
<li><p>select_type — 表示查询的类型。</p>
</li>
<li><p>table — 输出结果集的表</p>
</li>
<li><p>partitions — 匹配的分区</p>
</li>
<li><p>type — 表示表的连接类型</p>
</li>
<li><p>possible_keys — 表示查询时，可能使用的索引</p>
</li>
<li><p>key — 表示实际使用的索引</p>
</li>
<li><p>key_len — 索引字段的长度</p>
</li>
<li><p>ref— 列与索引的比较</p>
</li>
<li><p>rows — 大概估算的行数</p>
</li>
<li><p>filtered — 按表条件过滤的行百分比</p>
</li>
<li><p>Extra — 执行情况的描述和说明</p>
</li>
</ul>
<p>其中最重要的就是 type 字段，type 值类型如下：</p>
<ul>
<li><p>all — 扫描全表数据</p>
</li>
<li><p>index — 遍历索引</p>
</li>
<li><p>range — 索引范围查找</p>
</li>
<li><p>index_subquery — 在子查询中使用 ref</p>
</li>
<li><p>uniquesubquery — 在子查询中使用 eqref</p>
</li>
<li><p>refornull — 对 null 进行索引的优化的 ref</p>
</li>
<li><p>fulltext — 使用全文索引</p>
</li>
<li><p>ref — 使用非唯一索引查找数据</p>
</li>
<li><p>eq_ref — 在 join 查询中使用主键或唯一索引关联</p>
</li>
<li><p>const — 将一个主键放置到 where 后面作为条件查询， MySQL 优化器就能把这次查询优化转化为一个常量，如何转化以及何时转化，这个取决于优化器，这个比 eq_ref 效率高一点</p>
</li>
</ul>
<h5 id="MySQL-的优化手段都有哪些？"><a href="#MySQL-的优化手段都有哪些？" class="headerlink" title="MySQL 的优化手段都有哪些？"></a>MySQL 的优化手段都有哪些？</h5><p>MySQL 的常见的优化手段有以下五种：</p>
<p>① 查询优化</p>
<ul>
<li><p>避免 SELECT *，只查询需要的字段。</p>
</li>
<li><p>小表驱动大表，即小的数据集驱动大的数据集，比如，当 B 表的数据集小于 A 表时，用 in 优化 exist，两表执行顺序是先查 B 表，再查 A 表，查询语句：select * from A where id in (select id from B) 。</p>
</li>
<li><p>一些情况下，可以使用连接代替子查询，因为使用 join 时，MySQL 不会在内存中创建临时表。</p>
</li>
</ul>
<p>② 优化索引的使用</p>
<ul>
<li><p>尽量使用主键查询，而非其他索引，因为主键查询不会触发回表查询。</p>
</li>
<li><p>不做列运算，把计算都放入各个业务系统实现</p>
</li>
<li><p>查询语句尽可能简单，大语句拆小语句，减少锁时间</p>
</li>
<li><p>不使用 select * 查询</p>
</li>
<li><p>or 查询改写成 in 查询</p>
</li>
<li><p>不用函数和触发器</p>
</li>
<li><p>避免 %xx 查询</p>
</li>
<li><p>少用 join 查询</p>
</li>
<li><p>使用同类型比较，比如 ‘123’ 和 ‘123’、123 和 123</p>
</li>
<li><p>尽量避免在 where 子句中使用 != 或者 &lt;&gt; 操作符，查询引用会放弃索引而进行全表扫描</p>
</li>
<li><p>列表数据使用分页查询，每页数据量不要太大</p>
</li>
<li><p>用 exists 替代 in 查询</p>
</li>
<li><p>避免在索引列上使用 is null 和 is not null</p>
</li>
<li><p>尽量使用主键查询</p>
</li>
<li><p>避免在 where 子句中对字段进行表达式操作</p>
</li>
<li><p>尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型</p>
</li>
</ul>
<p>③ 表结构设计优化</p>
<ul>
<li><p>使用可以存下数据最小的数据类型。</p>
</li>
<li><p>使用简单的数据类型，int 要比 varchar 类型在 MySQL 处理简单。</p>
</li>
<li><p>尽量使用 tinyint、smallint、mediumint 作为整数类型而非 int。</p>
</li>
<li><p>尽可能使用 not null 定义字段，因为 null 占用 4 字节空间。</p>
</li>
<li><p>尽量少用 text 类型，非用不可时最好考虑分表。</p>
</li>
<li><p>尽量使用 timestamp，而非 datetime。</p>
</li>
<li><p>单表不要有太多字段，建议在 20 个字段以内。</p>
</li>
</ul>
<p>④ 表拆分</p>
<p>当数据库中的数据非常大时，查询优化方案也不能解决查询速度慢的问题时，我们可以考虑拆分表，让每张表的数据量变小，从而提高查询效率。 </p>
<p>a）垂直拆分：是指数据表列的拆分，把一张列比较多的表拆分为多张表，比如，用户表中一些字段经常被访问，将这些字段放在一张表中，另外一些不常用的字段放在另一张表中，插入数据时，使用事务确保两张表的数据一致性。 垂直拆分的原则：</p>
<ul>
<li><p>把不常用的字段单独放在一张表；</p>
</li>
<li><p>把 text，blob 等大字段拆分出来放在附表中；</p>
</li>
<li><p>经常组合查询的列放在一张表中。</p>
</li>
</ul>
<p>b）水平拆分：指数据表行的拆分，表的行数超过200万行时，就会变慢，这时可以把一张的表的数据拆成多张表来存放。</p>
<p>通常情况下，我们使用取模的方式来进行表的拆分，比如，一张有 400W 的用户表 users，为提高其查询效率我们把其分成 4 张表 users1，users2，users3，users4，然后通过用户 ID 取模的方法，同时查询、更新、删除也是通过取模的方法来操作。</p>
<p>⑤ 读写分离</p>
<p>一般情况下对数据库而言都是“读多写少”，换言之，数据库的压力多数是因为大量的读取数据的操作造成的，我们可以采用数据库集群的方案，使用一个库作为主库，负责写入数据；其他库为从库，负责读取数据。这样可以缓解对数据库的访问压力。</p>
<h5 id="MySQL-常见读写分离方案有哪些？"><a href="#MySQL-常见读写分离方案有哪些？" class="headerlink" title="MySQL 常见读写分离方案有哪些？"></a>MySQL 常见读写分离方案有哪些？</h5><p>MySQL 常见的读写分离方案，如下列表：</p>
<p>1）应用层解决方案 可以通过应用层对数据源做路由来实现读写分离，比如，使用 SpringMVC + MyBatis，可以将 SQL 路由交给 Spring，通过 AOP 或者 Annotation 由代码显示的控制数据源。 优点：路由策略的扩展性和可控性较强。 缺点：需要在 Spring 中添加耦合控制代码。</p>
<p>2）中间件解决方案 通过 MySQL 的中间件做主从集群，比如：Mysql Proxy、Amoeba、Atlas 等中间件都能符合需求。 优点：与应用层解耦。 缺点：增加一个服务维护的风险点，性能及稳定性待测试，需要支持代码强制主从和事务。</p>
<h5 id="介绍一下-Sharding-JDBC-的功能和执行流程？"><a href="#介绍一下-Sharding-JDBC-的功能和执行流程？" class="headerlink" title="介绍一下 Sharding-JDBC 的功能和执行流程？"></a>介绍一下 Sharding-JDBC 的功能和执行流程？</h5><p>Sharding-JDBC 在客户端对数据库进行水平分区的常用解决方案，也就是保持表结构不变，根据策略存储数据分片，这样每一片数据被分散到不同的表或者库中，</p>
<p>Sharding-JDBC 提供以下功能：</p>
<ul>
<li><p>分库分表</p>
</li>
<li><p>读写分离</p>
</li>
<li><p>分布式主键生成</p>
</li>
</ul>
<p>Sharding-JDBC 的执行流程：当业务代码调用数据库执行的时候，先触发 Sharding-JDBC 的分配规则对 SQL 语句进行解析、改写之后，才会对改写的 SQL 进行执</p>
<p>行和结果归并，然后返回给调用层。</p>
<h5 id="什么是-MySQL-多实例？如何配置-MySQL-多实例？"><a href="#什么是-MySQL-多实例？如何配置-MySQL-多实例？" class="headerlink" title="什么是 MySQL 多实例？如何配置 MySQL 多实例？"></a>什么是 MySQL 多实例？如何配置 MySQL 多实例？</h5><p>MySQL 多实例就是在同一台服务器上启用多个 MySQL 服务，它们监听不同的端口，运行多个服务进程，它们相互独立，互不影响的对外提供服务，便于节约服务器</p>
<p>资源与后期架构扩展。 多实例的配置方法有两种：</p>
<ul>
<li><p>一个实例一个配置文件，不同端口；</p>
</li>
<li><p>同一配置文件(my.cnf)下配置不同实例，基于 MySQL 的 d_multi 工具。</p>
</li>
</ul>
<h5 id="怎样保证确保备库无延迟？"><a href="#怎样保证确保备库无延迟？" class="headerlink" title="怎样保证确保备库无延迟？"></a>怎样保证确保备库无延迟？</h5><p>通常保证主备无延迟有以下三种方法：</p>
<ul>
<li><p>每次从库执行查询请求前，先判断 secondsbehindmaster 是否已经等于 0。如果还不等于 0 ，那就必须等到这个参数变为 0 才能执行查询请求，secondsbehindmaster 参数是用来衡量主备延迟时间的长短；</p>
</li>
<li><p>对比位点确保主备无延迟。MasterLogFile 和 ReadMasterLogPos，表示的是读到的主库的最新位点，RelayMasterLogFile 和 ExecMasterLog_Pos，表示的是备库执行的最新位点；</p>
</li>
<li><p>对比 GTID 集合确保主备无延迟。AutoPosition=1 ，表示这对主备关系使用了 GTID 协议；RetrievedGtidSet，是备库收到的所有日志的 GTID 集合；ExecutedGtid_Set，是备库所有已经执行完成的 GTID 集合。</p>
</li>
</ul>
<h4 id="MySQL-常见的开放性问题"><a href="#MySQL-常见的开放性问题" class="headerlink" title="MySQL 常见的开放性问题"></a>MySQL 常见的开放性问题</h4><h5 id="有一个超级大表，如何优化分页查询？"><a href="#有一个超级大表，如何优化分页查询？" class="headerlink" title="有一个超级大表，如何优化分页查询？"></a>有一个超级大表，如何优化分页查询？</h5><p>超级大表的分页优化分有以下两种方式：</p>
<ul>
<li><p>数据库层面优化：利用子查询优化超多分页场景，比如：SELECT a.* FROM 表 1 a, (select id from 表 1 where 条件 LIMIT 100000,20 ) b where a.id=b.id ，先快速定位需要获取的 id 段，然后再关联查询。MySQL 并不是跳过 offset 行，而是取 offset+N 行，然后返回放弃前 offset 行，返回 N 行，那当 offset 特别大的时候，效率就非常的低下，要么控制返回的总页数，要么对超过特定阈值的页数进行 SQL 改写，利用子查询先快速定位需要获取的 id 段，然后再关联查询，就是对分页进行 SQL 改写的具体实现；</p>
</li>
<li><p>程序层面优化：可以利用缓存把查询的结果缓存起来，这样再下一次查询的时候性能就非常高了。</p>
</li>
</ul>
<h5 id="线上修改表结构有哪些风险？"><a href="#线上修改表结构有哪些风险？" class="headerlink" title="线上修改表结构有哪些风险？"></a>线上修改表结构有哪些风险？</h5><p>线上修改表结构有可能 MySQL 服务器阻塞，因为在执行 DML（select、update、delete、insert）操作时，会给表增加一个元数据锁，这个元数据锁是为了保证在查询期间表结构不会被修改，而执行修改表结构时，必须要等待元数据锁完成之后才能执行，这就可能造成数据库服务器的阻塞。</p>
<p>在 MySQL 5.6 开始提供了 online ddl 功能，允许一些 DDL（create table/view/index/syn/cluster）语句和 DML 语句并发，在 5.7 版本对 online ddl 又有了增强，这使得大部分 DDL 操作可以在线进行，详见：<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/innodb-create-index-overview.html%EF%BC%8C%E8%BF%99%E4%BD%BF%E5%BE%97%E5%9C%A8%E7%BA%BF%E4%B8%8A%E4%BF%AE%E6%94%B9%E8%A1%A8%E7%BB%93%E6%9E%84%E7%9A%84%E9%A3%8E%E9%99%A9%E5%8F%98%E7%9A%84%E6%9B%B4%E5%A4%A7%EF%BC%8C%E5%A6%82%E6%9E%9C%E5%9C%A8%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%BF%85%E9%A1%BB%E5%9C%A8%E7%BA%BF%E4%BF%AE%E6%94%B9%E8%A1%A8%E7%BB%93%E6%9E%84%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%8F%82%E8%80%83%E4%BB%A5%E4%B8%8B%E6%96%B9%E6%A1%88%EF%BC%9A">https://dev.mysql.com/doc/refman/5.7/en/innodb-create-index-overview.html，这使得在线上修改表结构的风险变的更大，如果在业务开发过程中必须在线修改表结构，可以参考以下方案：</a></p>
<ul>
<li><p>尽量在业务量小的时间段进行；</p>
</li>
<li><p>查看官方文档，确认要做的表修改可以和 DML 并发，不会阻塞线上业务；</p>
</li>
<li><p>推荐使用 percona 公司的 pt-online-schema-change 工具，该工具被官方的 online ddl 更为强大，它的基本原理是：通过 insert…select… 语句进行一次全量拷贝，通过触发器记录表结构变更过程中产生的增量，从而达到表结构变更的目的。比如，要对 A 表进行变更，它的主要流程为：</p>
</li>
</ul>
<p>1）创建目的表结构的空表 A_new；</p>
<p>2）在A表上创建触发器，包括增、删、改触发器；</p>
<p>3）通过 insert…select…limit N 语句分片拷贝数据到目的表；</p>
<p>4）Copy完成后，将 A_new 表 rename 到 A 表。</p>
<h5 id="查询长时间不返回可能是什么原因？应该如何处理？"><a href="#查询长时间不返回可能是什么原因？应该如何处理？" class="headerlink" title="查询长时间不返回可能是什么原因？应该如何处理？"></a>查询长时间不返回可能是什么原因？应该如何处理？</h5><p>查询速度慢的原因很多，常见如下几种：</p>
<p> 1）查询字段没有索引或者没有触发索引查询，没有触发索引查询的情况如下： 不会使用索引的情况如下：</p>
<ul>
<li><p>以 % 开头的 like 查询不会使用 b-tree 索引；</p>
</li>
<li><p>数据类型出现隐式转换时不会使用索引，比如，某列是 varchar 类型，却使用了columnname=1 的查询语句，这是不会使用索引，正确触发索引的查询语句为：columnname=’1’ ；</p>
</li>
<li><p>不符合最左前缀原则；</p>
</li>
<li><p>如果查询条件有 or 分割，or 前面的使用索引，or 后面的未使用索引，则不会使用索引，因为即使 or 之前的使用了索引，但是 or 之后的也需要全表查询，索引就忽略索引，直接全表查询；</p>
</li>
<li><p>如果 MySQL 认为使用索引会比全表查询更慢，则不会使用索引。</p>
</li>
</ul>
<p>2）I/O 压力大，读取磁盘速度变慢。 </p>
<p>3）内存不足 </p>
<p>4）网络速度慢 </p>
<p>5）查询出的数据量过大，可以采用多次查询或其他的方法降低数据量 </p>
<p>6）死锁，一般碰到这种情况的话，大概率是表被锁住了，可以使用 show processlist; 命令，看看 SQL 语句的状态，再针对不同的状态做相应的处理。</p>
<p> <img src="/images/mysql/deadlock.png" srcset="/img/loading.gif"></p>
<p>其中，当 State 列值为 Locked 时，表示被锁定。 其它关于查看死锁的命令：</p>
<p> a）查看当前的事务：</p>
<p><code>select * from informationschema.innodbtrx;</code></p>
<p>b）查看当前锁定的事务：</p>
<p><code>select * from informationschema.innodblocks;</code></p>
<p>c）查看当前等锁的事务</p>
<p><code>select * from informationschema.innodblock_waits;</code></p>
<p>以上问题的解决方案如下：</p>
<p>1）正确创建和使用索引。 </p>
<p>2）把数据、日志、索引放到不同的 IO 设备上，减少主数据库的 IO 操作。更换 MySQL 的磁盘为固态硬盘，以提高磁盘的 IO 性能。 </p>
<p>3）升级内存，更换更大的内存。</p>
<p>4）提升网速，升级带宽。 </p>
<p>5）用 Profiler 来跟踪查询，得到查询所需的时间，找出有问题的 SQL 语句，优化 SQL。 </p>
<p>6）查询时值返回需要的字段。 </p>
<p>7）设置死锁的超时时间，限制和避免死锁消耗过多服务器的资源。 </p>
<p>8）尽量少用视图，它的效率低，对视图操作比直接对表操作慢,可以用存储过程来代替视图。不要用视图嵌套，嵌套视图增加了寻找原始数据的难度。</p>
<h5 id="什么是-MySQL-主从？主从同步有什么好处？"><a href="#什么是-MySQL-主从？主从同步有什么好处？" class="headerlink" title="什么是 MySQL 主从？主从同步有什么好处？"></a>什么是 MySQL 主从？主从同步有什么好处？</h5><p>MySQL 主从同步：MySQL 有多个服务器去，一个服务器作为主服务器，其它服务器作为从服务器，通过配置我们可以将主服务器的所有数据或者部分数据复制到从服务器上。复制的过程是异步进行的。</p>
<p>主从同步的好处：（读写分离，数据备份，负载均衡）我们可以设置主服务器写入数据，读取数据使用从服务器。保证数据库负载均衡。数据随时都在进行同步备份，保证了数据的安全性。</p>
<h5 id="MySQL-主从延迟的原因有哪些？"><a href="#MySQL-主从延迟的原因有哪些？" class="headerlink" title="MySQL 主从延迟的原因有哪些？"></a>MySQL 主从延迟的原因有哪些？</h5><p>主从延迟可以根据 MySQL 提供的命令判断，比如，在从服务器使用命令： show slave status;，其中 SecondsBehindMaster 如果为 0 表示主从复制状态正常。 导致</p>
<p>主从延迟的原因有以下几个：</p>
<ul>
<li><p>主库有大事务处理；</p>
</li>
<li><p>主库做大量的增、删、改操作；</p>
</li>
<li><p>主库对大表进行字段新增、修改或添加索引等操作；</p>
</li>
<li><p>主库的从库太多，导致复制延迟。从库数量一般 3-5 个为宜，要复制的节点过多，导致复制延迟；</p>
</li>
<li><p>从库硬件配置比主库差，导致延迟。查看 Master 和 Slave 的配置，可能因为从库的配置过低，执行时间长，由此导致的复制延迟时间长；</p>
</li>
<li><p>主库读写压力大，导致复制延迟；</p>
</li>
<li><p>从库之间的网络延迟。主从库网卡、网线、连接的交换机等网络设备都可能成为复制的瓶颈，导致复制延迟，另外跨公网主从复制很容易导致主从复制延迟。</p>
</li>
</ul>
<h5 id="MySQL-主从与-MongoDB-副本集有什么区别？"><a href="#MySQL-主从与-MongoDB-副本集有什么区别？" class="headerlink" title="MySQL 主从与 MongoDB 副本集有什么区别？"></a>MySQL 主从与 MongoDB 副本集有什么区别？</h5><ul>
<li><p>MongoDB 是在同一个服务器（一台机器），同时复制备份多个数据库</p>
</li>
<li><p>MySQL 复制备份数据是在多个服务器（多台机器），复制备份多个数据库</p>
</li>
<li><p>MongoDB 复制备份是同步的，MySQL 复制备份可以是异步的，也可以主从同步</p>
</li>
<li><p>MongoDB 读写在指定的某一个数据库作为主数据库</p>
</li>
<li><p>MySQL 一般主服务器写，从服务器读，读写分离</p>
</li>
</ul>
<h5 id="如何保证数据不被误删？"><a href="#如何保证数据不被误删？" class="headerlink" title="如何保证数据不被误删？"></a>如何保证数据不被误删？</h5><p>保证数据不被误删的方法如下列表：</p>
<ul>
<li><p>权限控制与分配（数据库和服务器权限）</p>
</li>
<li><p>避免数据库账号信息泄露，在生产环境中，业务代码不要使用明文保存数据库连接信息；</p>
</li>
<li><p>重要的数据库操作，通过平台型工具自动实施，减少人工操作；</p>
</li>
<li><p>部署延迟复制从库，万一误删除时用于数据回档，且从库设置为 read-only；</p>
</li>
<li><p>确认备份制度及时有效；</p>
</li>
<li><p>启用 SQL 审计功能，养成良好 SQL 习惯；</p>
</li>
<li><p>启用 sqlsafeupdates 选项，不允许没 where 条件的更新/删除；</p>
</li>
<li><p>将系统层的 rm 改为 mv；</p>
</li>
<li><p>线上不进行物理删除，改为逻辑删除（将 row data 标记为不可用）；</p>
</li>
<li><p>启用堡垒机，屏蔽高危 SQL；</p>
</li>
<li><p>降低数据库中普通账号的权限级别；</p>
</li>
<li><p>开启 binlog，方便追溯数据。</p>
</li>
</ul>
<h5 id="MySQL-服务器-CPU-飙升应该如何处理？"><a href="#MySQL-服务器-CPU-飙升应该如何处理？" class="headerlink" title="MySQL 服务器 CPU 飙升应该如何处理？"></a>MySQL 服务器 CPU 飙升应该如何处理？</h5><p>使用 show full processlist; 查出慢查询，为了缓解数据库服务器压力，先使用 kill 命令杀掉慢查询的客户端，效果如下：</p>
<p> <img src="/images/mysql/fullprocesslist.png" srcset="/img/loading.gif"></p>
<p>然后再去项目中找到执行慢的 SQL 语句进行修改和优化。</p>
<h5 id="MySQL-毫无规律的异常重启，可能产生的原因是什么？该如何解决？"><a href="#MySQL-毫无规律的异常重启，可能产生的原因是什么？该如何解决？" class="headerlink" title="MySQL 毫无规律的异常重启，可能产生的原因是什么？该如何解决？"></a>MySQL 毫无规律的异常重启，可能产生的原因是什么？该如何解决？</h5><p>可能是积累的长连接导致内存占用太多，被系统强行杀掉导致的异常重启，因为在 MySQL 中长连接在执行过程中使用的临时内存对象，只有在连接断开的时候才会</p>
<p>释放，这就会导致内存不断飙升，解决方案如下：</p>
<ul>
<li><p>定期断开空闲的长连接；</p>
</li>
<li><p>如果是用的是 MySQL 5.7 以上的版本，可以定期执行 <code>mysqlresetconnection</code> 重新初始化连接资源，这个过程会释放之前使用的内存资源，恢复到连接刚初始化的状态。</p>
</li>
</ul>
<h5 id="如何实现一个高并发的系统？"><a href="#如何实现一个高并发的系统？" class="headerlink" title="如何实现一个高并发的系统？"></a>如何实现一个高并发的系统？</h5><p>这道面试题涉及的知识点比较多，主要考察的是面试者的综合技术能力。高并发系统的设计手段有很多，主要体现在以下五个方面。</p>
<p>1）前端优化</p>
<p>① 静态资源缓存：将活动页面上的所有可以静态的元素全部静态化，尽量减少动态元素；通过 CDN、浏览器缓存，来减少客户端向服务器端的数据请求。</p>
<p>② 禁止重复提交：用户提交之后按钮置灰，禁止重复提交。</p>
<p>③ 用户限流：在某一时间段内只允许用户提交一次请求，比如，采取 IP 限流。</p>
<p>2）中间层负载分发</p>
<p>可利用负载均衡，比如 nginx 等工具，可以将并发请求分配到不同的服务器，从而提高了系统处理并发的能力。 nginx 负载分发的五种方式：</p>
<p>① 轮询（默认） 每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器不能正常响应，nginx 能自动剔除故障服务器。 </p>
<p>② 按权重（weight） 使用 weight 参数，指定轮询几率，weight 和访问比率成正比，用于后端服务器性能不均的情况，配置如下：</p>
<p><code>upstream backend &#123;   server 192.168.0.14 weight=10;   server 192.168.0.15 weight=10; &#125;</code></p>
<p>③ IP 哈希值（ip_hash） 每个请求按访问 IP 的哈希值分配，这样每个访客固定访问一个后端服务器，可以解决 session 共享的问题，配置如下：</p>
<p><code>upstream backend &#123;   ip_hash;   server 192.168.0.14:88;   server 192.168.0.15:80; &#125;</code></p>
<p>④ 响应时间（fair） 按后端服务器的响应时间来分配请求，响应时间短的优先分配，配置如下：</p>
<p><code>upstream backend &#123;   fair;   server server1.com;   server server2.com; &#125;</code></p>
<p>⑤ URL 哈希值（url_hash） 按访问 url 的 hash 结果来分配请求，和 IP 哈希值类似。</p>
<p><code>upstream backend &#123;   hash $request_uri;   server server1.com;   server server2.com;  &#125;</code></p>
<p>3）控制层（网关层）</p>
<p>限制同一个用户的访问频率，限制访问次数，防止多次恶意请求。</p>
<p>4）服务层</p>
<p>① 业务服务器分离：比如，将秒杀业务系统和其他业务分离，单独放在高配服务器上，可以集中资源对访问请求抗压。</p>
<p>② 采用 MQ（消息队列）缓存请求：MQ 具有削峰填谷的作用，可以把客户端的请求先导流到 MQ，程序在从 MQ 中进行消费（执行请求），这样可以避免短时间内大量请求，导致服务器程序无法响应的问题。 </p>
<p>③ 利用缓存应对读请求，比如，使用 Redis 等缓存，利用 Redis 可以分担数据库很大一部分压力。</p>
<p>5）数据库层</p>
<p>① 合理使用数据库引擎 </p>
<p>② 合理设置事务隔离级别，合理使用事务 </p>
<p>③ 正确使用 SQL 语句和查询索引 </p>
<p>④ 合理分库分表 </p>
<p>⑤ 使用数据库中间件实现数据库读写分离 </p>
<p>⑥ 设置数据库主从读写分离</p>

            </article>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/Datebase/">Datebase</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Datebase/">Datebase</a>
                    
                      <a class="hover-with-bg" href="/tags/MySQL/">MySQL</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <div class="post-prev col-6">
                    
                    
                      <a href="/2021/03/22/redis/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">【Redis】学习笔记</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </div>
                  <div class="post-next col-6">
                    
                    
                      <a href="/2021/03/12/lt-graph/">
                        <span class="hidden-mobile">【LeetCode】图结构相关</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </div>
                </div>
              
            </div>

            
          </div>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Wei</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/weitrue" target="_blank" rel="nofollow noopener">
        <span>Trable</span></a>
    </div>
    

    
  <!-- 备案信息 -->
  <div class="beian">
    <a href="http://beian.miit.gov.cn/" target="_blank"
       rel="nofollow noopener">杭ICP证123456号</a>
    
      <a
        href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=12345678"
        rel="nofollow noopener"
        class="beian-police"
        target="_blank"
      >
        <span class="beian-police-sep">&nbsp;|&nbsp;</span>
        
          <img src="/images/img/police_beian.png" srcset="/img/loading.gif" alt="police-icon" />
        
        <span>杭公网安备12345678号</span>
      </a>
     
  </div>


    
     <div>
  	<span id="timeDate">载入天数...</span>
 	<span id="times">载入时分秒...</span>
 	<script>
          var now = new Date();
          function createtime(){
           var grt= new Date("02/14/2020 00:00:00");//此处修改你的建站时间或者网站上线时间
           now.setTime(now.getTime()+250);
           days = (now - grt ) / 1000 / 60 / 60 / 24;
           dnum = Math.floor(days);
           hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum);
           hnum = Math.floor(hours);
           if(String(hnum).length ==1 ){
                hnum = "0" + hnum;
           }
           minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
           mnum = Math.floor(minutes);
           if(String(mnum).length ==1 ){
                mnum = "0" + mnum;
           }
           seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
           snum = Math.round(seconds);
           if(String(snum).length ==1 ){
                snum = "0" + snum;
           }
           document.getElementById("timeDate").innerHTML = "本站安全运行&nbsp"+dnum+"&nbsp天";
           document.getElementById("times").innerHTML = hnum + "&nbsp小时&nbsp" + mnum + "&nbsp分&nbsp" + snum + "&nbsp秒";
          }
          setInterval("createtime()",250);
       </script>
    </div>
 </div>
 </footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/main.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>







  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: 'article.markdown-body',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "【MySQL】学习笔记&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>







  
  
    <script type="text/javascript">
      //定义获取词语下标
      var a_idx = 0;
      jQuery(document).ready(function ($) {
        //点击body时触发事件
        $("body").click(function (e) {
          //需要显示的词语
          var a = new Array("富强", "民主", "文明", "和谐", "自由", "平等", "公正", "法治", "爱国", "敬业", "诚信", "友善");
          //设置词语给span标签
          var $i = $("<span/>").text(a[a_idx]);
          //下标等于原来下标+1  余 词语总数
          a_idx = (a_idx + 1) % a.length;
          //获取鼠标指针的位置，分别相对于文档的左和右边缘。
          //获取x和y的指针坐标
          var x = e.pageX, y = e.pageY;
          //在鼠标的指针的位置给$i定义的span标签添加css样式
          $i.css({
            "z-index": 999,
            "top": y - 20,
            "left": x,
            "position": "absolute",
            "font-weight": "bold",
            "color": rand_color()
          });
          // 随机颜色
          function rand_color() {
            return "rgb(" + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + ")"
          }
          //在body添加这个标签
          $("body").append($i);
          //animate() 方法执行 CSS 属性集的自定义动画。
          //该方法通过CSS样式将元素从一个状态改变为另一个状态。CSS属性值是逐渐改变的，这样就可以创建动画效果。
          //详情请看http://www.w3school.com.cn/jquery/effect_animate.asp
          $i.animate({
            //将原来的位置向上移动180
            "top": y - 180,
            "opacity": 0
            //1500动画的速度
          }, 1500, function () {
            //时间到了自动删除
            $i.remove();
          });
        });
      })
      ;
    </script>
  











  

  

  

  

  

  





<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
