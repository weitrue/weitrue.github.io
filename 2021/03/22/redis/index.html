<!DOCTYPE html>
<html lang="zh-CN">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/images/img/logo.png">
  <link rel="icon" type="image/png" href="/img/logo.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="我们相信，未来可期！">
  <meta name="author" content="嗯，我们是对的">
  <meta name="keywords" content="">
  <title>【Redis】学习笔记 - weitrable</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/github-gist.min.css" />
  

  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_yg9cfy8wd6.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script  src="/js/utils.js" ></script>
<meta name="generator" content="Hexo 5.2.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>WeiTrable</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/book/">
                <i class="iconfont icon-books"></i>
                电子书
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background" parallax=true
         style="background: url('/images/img/banner.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
              
  <div class="mt-3 post-meta">
    <i class="iconfont icon-date-fill" aria-hidden="true"></i>
    <time datetime="2021-03-22 17:58">
      2021年3月22日 下午
    </time>
  </div>


<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      14.4k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      186
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <div class="post-content mx-auto" id="post">
            
            <article class="markdown-body">
              <p><img src="/images/redis/top.png" srcset="/img/loading.gif"><a id="more"></a></p>
<h3 id="Redis安装"><a href="#Redis安装" class="headerlink" title="Redis安装"></a>Redis安装</h3><h4 id="单机版redis环境安装"><a href="#单机版redis环境安装" class="headerlink" title="单机版redis环境安装"></a>单机版redis环境安装</h4><p>环境准备:</p>
<p>  系统：centos7 </p>
<h5 id="下载redis安装包"><a href="#下载redis安装包" class="headerlink" title="下载redis安装包"></a>下载redis安装包</h5><p>node01服务器执行以下命令下载redis安装包</p>
<pre><code class="hljs zsh"><span class="hljs-built_in">cd</span> /weitrue/soft
wget http://download.redis.io/releases/redis-6.0.1.tar.gz</code></pre>

<h5 id="解压redis压缩包到指定目录"><a href="#解压redis压缩包到指定目录" class="headerlink" title="解压redis压缩包到指定目录"></a>解压redis压缩包到指定目录</h5><pre><code class="hljs zsh"><span class="hljs-comment">#node01执行以下命令进行解压redis</span>
<span class="hljs-built_in">cd</span> /weitrue/soft
tar -zxvf redis-6.0.1.tar.gz -C ../install/</code></pre>

<h5 id="安装C程序运行环境"><a href="#安装C程序运行环境" class="headerlink" title="安装C程序运行环境"></a>安装C程序运行环境</h5><p>node01执行以下命令安装C程序运行环境</p>
<pre><code class="hljs shell">su root
yum -y install gcc-c++
<span class="hljs-meta">#</span><span class="bash"> 查看gcc版本是否在5.3以上，centos7.6默认安装4.8.5</span>
gcc -v
<span class="hljs-meta">#</span><span class="bash"> 升级gcc到5.3及以上,如下：</span>
<span class="hljs-meta">#</span><span class="bash">升级到gcc 9.3：</span>
yum -y install centos-release-scl
yum -y install devtoolset-9-gcc devtoolset-9-gcc-c++ devtoolset-9-binutils

scl enable devtoolset-9 bash
需要注意的是scl命令启用只是临时的，退出shell或重启就会恢复原系统gcc版本。
如果要长期使用gcc 9.3的话：

echo &quot;source /opt/rh/devtoolset-9/enable&quot; &gt;&gt;/etc/profile
<span class="hljs-meta">#</span><span class="bash">这样退出shell重新打开就是新版的gcc了</span></code></pre>

<h5 id="安装较新版本的tcl"><a href="#安装较新版本的tcl" class="headerlink" title="安装较新版本的tcl"></a>安装较新版本的tcl</h5><p>下载安装较新版本的tcl</p>
<h6 id="使用压缩包进行安装（不推荐）"><a href="#使用压缩包进行安装（不推荐）" class="headerlink" title="使用压缩包进行安装（不推荐）"></a>使用压缩包进行安装（不推荐）</h6><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">node01执行以下命令下载tcl安装包</span>
cd /weitrue/soft
wget http://downloads.sourceforge.net/tcl/tcl8.6.1-src.tar.gz
<span class="hljs-meta">#</span><span class="bash">解压tcl</span>
tar -zxvf tcl8.6.1-src.tar.gz -C ../install/
<span class="hljs-meta">#</span><span class="bash">进入指定目录</span>
cd ../install/tcl8.6.1/unix/
./configure
make  &amp;&amp; make  install</code></pre>

<h6 id="在线安装tcl（墙裂推荐）"><a href="#在线安装tcl（墙裂推荐）" class="headerlink" title="在线安装tcl（墙裂推荐）"></a>在线安装tcl（墙裂推荐）</h6><p>node01执行以下命令在线安装tcl</p>
<pre><code class="hljs shell">sudo yum  -y  install  tcl</code></pre>

<h5 id="进行编译redis"><a href="#进行编译redis" class="headerlink" title="进行编译redis"></a>进行编译redis</h5><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> node01执行以下命令进行编译：</span>
cd /weitrue/install/redis-6.0.1/
<span class="hljs-meta">#</span><span class="bash"> make MALLOC=libc   或者使用命令  make  进行编译</span>
make test &amp;&amp; make install</code></pre>

<h5 id="修改redis配置文件"><a href="#修改redis配置文件" class="headerlink" title="修改redis配置文件"></a>修改redis配置文件</h5><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> node01执行以下命令修改redis配置文件</span>
cd /weitrue/install/redis-6.0.1/
mkdir -p /weitrue/install/redis-6.0.1/logs
mkdir -p /weitrue/install/redis-6.0.1/redisdata
vim redis.conf
bind node01
daemonize yes
pidfile /weitrue/install/redis-6.0.1/redis_6379.pid
logfile &quot;/weitrue/install/redis-6.0.1/logs/redis.log&quot;
dir /weitrue/install/redis-6.0.1/redisdata</code></pre>

<p><code>daemonize yes</code>: redis采用的是单进程多线程的模式。<br>当redis.conf中选项daemonize设置成yes时，代表开启守护进程模式。在该模式下，redis会在后台运行，并将进程pid号写入至redis.conf选项pidfile设置的文件中，此时redis将一直运行，除非手动kill该进程。<br><code>daemonize no</code>: 当daemonize选项设置成no时，当前界面将进入redis的命令行界面，exit强制退出或者关闭连接工具(putty,xshell等)都会导致redis进程退出。</p>
<h5 id="启动redis"><a href="#启动redis" class="headerlink" title="启动redis"></a>启动redis</h5><p>node01执行以下命令启动redis</p>
<pre><code class="hljs shell">cd  /weitrue/install/redis-6.0.1
src/redis-server  redis.conf
<span class="hljs-meta">#</span><span class="bash"> 查看进程</span>
ps aux|grep redis
或者
ps -ef | grep redis | grep -v &quot;grep&quot;  # 加上| grep -v &quot;grep&quot;，是指不看grep进程</code></pre>

<h5 id="连接redis客户端"><a href="#连接redis客户端" class="headerlink" title="连接redis客户端"></a>连接redis客户端</h5><p>node01执行以下命令连接redis客户端</p>
<pre><code class="hljs shell">cd /weitrue/install/redis-6.0.1
src/redis-cli -h node01</code></pre>

<h4 id="redis的操作命令"><a href="#redis的操作命令" class="headerlink" title="redis的操作命令"></a>redis的操作命令</h4><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">检测redis服务是否启动</span>
PING
<span class="hljs-meta">#</span><span class="bash">设置key、value</span>
SET KEY_NAME VALUE
<span class="hljs-meta">#</span><span class="bash">删除</span>
del key
<span class="hljs-meta">#</span><span class="bash">获取key是否存在</span>
exists key
<span class="hljs-meta">#</span><span class="bash">获取key的类型</span>
type key
<span class="hljs-meta">#</span><span class="bash">为key改名</span>
rename key newkey
renamenx key newkey
<span class="hljs-meta">#</span><span class="bash">切换数据库</span>
select index
<span class="hljs-meta">#</span><span class="bash">退出客户端</span>
quit</code></pre>

<h3 id="redis的数据类型"><a href="#redis的数据类型" class="headerlink" title="redis的数据类型"></a><strong>redis的数据类型</strong></h3><p>Redis支持的常用5种数据类型指的是value类型，分别为：<strong>字符串String、列表List、哈希Hash、集合Set、有序集合Zset</strong>，但是Redis后续又丰富了几种数据类型分别是Bitmaps、HyperLogLogs、GEO。</p>
<p> 由于Redis是基于标准C写的，只有最基础的数据类型，因此Redis为了满足对外使用的5种数据类型，开发了属于自己<strong>独有的一套基础数据结构</strong>，使用这些数据结构来实现5种数据类型。</p>
<p>Redis为了平衡空间和时间效率，针对value的具体类型在底层会采用不同的数据结构来实现，其中哈希表和压缩列表是复用比较多的数据结构，如下图展示了对外数据类型和底层数据结构之间的映射关系：</p>
<p><img src="/images/redis/wps4.jpg" srcset="/img/loading.gif"></p>
<p>从图中可以看到ziplist压缩列表可以作为Zset、Set、List三种数据类型的底层实现，看来很强大，压缩列表是一种为了节约内存而开发的且经过特殊编码之后的连续内存块顺序型数据结构，底层结构还是比较复杂的。</p>
<h4 id="redis当中各种数据类型的操作"><a href="#redis当中各种数据类型的操作" class="headerlink" title="redis当中各种数据类型的操作"></a>redis当中各种数据类型的操作</h4><p>redis自身是一个Map，其中所有的数据都是采用key : value 的形式存储</p>
<p><img src="/images/redis/image-20200529015634835.png" srcset="/img/loading.gif"></p>
<h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><pre><code class="hljs plain">存储的数据：单个数据，最简单的数据存储类型，也是最常用的数据存储类型
存储数据的格式：一个存储空间保存一个数据
存储内容：通常使用字符串，如果字符串以整数的形式展示，可以作为数字操作使用</code></pre>

<p><img src="/images/redis/image-20200529020001463.png" srcset="/img/loading.gif"></p>
<p>下表列出了常用的 redis 字符串命令</p>
<pre><code class="hljs shell">1.SET key value: 设置指定`key`的值,O(1)。示例：`SET hello world`

2.GET key:获取指定`key`的值,O(1)。示例：`GET hello`

3.GETRANGE key start end:返回`key`中字符串值的子字符,包含end。示例：`GETRANGE hello 0 3`

4.GETSET key value:将给定`key`的值设为`value`，并返回`key`的旧值(old value)。示例：`GETSET hello world2`

5.MGET key1 [key2...]:获取所有(一个或多个)给定`key`的值。示例：`MGET hello world`

6.SETEX key seconds value:将值`value`关联到`key`，并将`key`的过期时间设为 seconds (以秒为单位)。示例：`SETEX hello 10 world3`

7.SETNX key value: 只有在`key`不存在时设置`key`的值。示例：`SETNX weitrue 1`

8.SETRANGE key offset value: 用 value 参数覆写给定 key 所储存的字符串值，从偏移量`offset`开始。示例：`SETRANGE weitrue 0 helloredis`

9.STRLEN key: 返回`key所储存的字符串值的长度,O(1)。示例：`STRLEN weitrue`

10.MSET key value [key value ...]:同时设置一个或多个`key-value`对，原子操作。示例：`MSET weitrue2 weitruevalue2 weitrue3 weitruevalue3`

11.MSETNX key value [key value ...]:同时设置一个或多个`key-value`对，当且仅当所有给定 key 都不存在。示例：`MSETNX weitrue4 weitruevalue4 weitrue5 weitruevalue5`

12.PSETEX key milliseconds value:这个命令和 SETEX 命令相似，但它以毫秒为单位设置`key`的生存时间，而不是像`SETEX`命令那样，以秒为单位。示例：`PSETEX weitrue6 6000 weitrue6value`

13.INCR key:将 key 中储存的数字值增一, 可用于分布式id等。示例：`set weitrue 1`,`INCR weitrue`,`GET weitrue` 

14.INCRBY key increment:将`key`所储存的值加上给定的增量值（increment）。示例：`INCRBY weitrue 2`, `get weitrue`

15.INCRBYFLOAT key increment: 将`key`所储存的值加上给定的浮点增量值（increment）。示例：`INCRBYFLOAT weitrue 0.8`

16.DECR key:将`key`中储存的数字值减一。示例：`set weitrue 1`, `DECR weitrue`, `GET weitrue`

17.DECRBY key: `key`所储存的值减去给定的减量值（decrement） 。示例：`DECRBY weitrue 3`

18.APPEND key value: 如果`key`已经存在并且是一个字符串， APPEND 命令将指定的`value`追加到该`key`原来值（value）的末尾。示例：`APPEND weitrue hello`</code></pre>

<h4 id="对key的操作"><a href="#对key的操作" class="headerlink" title="对key的操作"></a>对key的操作</h4><p>下表给出了与 Redis 键相关的基本命令：</p>
<ul>
<li><code>dbsize</code>：计算key的总数，O(1)</li>
</ul>
<pre><code class="hljs shell">DEL key: 该命令用于在`key`存在时删除`key`。示例：`del weitrue`

DUMP key: 序列化给定`key`，并返回被序列化的值。示例：`DUMP key`
EXISTS key: 检查给定 key 是否存在。示例：`exists weitrue`

EXPIRE key seconds: 为给定`key`设置过期时间，以秒计。示例：`expire weitrue 5`

PEXPIRE key milliseconds: 设置`key`的过期时间以毫秒计。示例：`PEXPIRE set2 3000000`

KEYS pattern: 查找所有符合给定模式(pattern)的`key`。示例：`keys *`

PERSIST key: 移除`key`的过期时间，`key`将持久保持。示例：`persist set2`

PTTL key: 以毫秒为单位返回`key`的剩余的过期时间。示例：`pttl  set2`

TTL key: 以秒为单位，返回给定`key`的剩余生存时间(TTL, time to live)。示例：`ttl set2`

RANDOMKEY: 从当前数据库中随机返回一个`key`。示例： `randomkey`

RENAME key newkey: 修改`key`的名称示例：`rename set5 set8`

RENAMENX key newkey: 仅当`newkey`不存在时，将`key`改名为`newkey`。示例：`renamenx  set8 set10`

TYPE key: 返回`key`所储存的值的类型。示例：`type  set10`</code></pre>

<h4 id="hash列表的操作"><a href="#hash列表的操作" class="headerlink" title="hash列表的操作"></a>hash列表的操作</h4><pre><code class="hljs angelscript">Redis hash 是一个<span class="hljs-built_in">string</span>类型的field和value的映射表，hash特别适合用于存储对象。
Redis 中每个 hash 可以存储 <span class="hljs-number">232</span> - <span class="hljs-number">1</span> 键值对（<span class="hljs-number">40</span>多亿）</code></pre>

<p>下表列出了 redis hash 基本的相关命令：</p>
<pre><code class="hljs shell">HSET key field value: 将哈希表 `key` 中的字段 `field` 的值设为 `value` 。示例：`HSET key1 field1 value1`

HSETNX key field value: 只有在字段 `field` 不存在时，设置哈希表字段的值。示例：`HSETNX key1 field2 value2`

HMSET key field1 value1 [field2 value2 ...]: 同时将多个`field-value`(域-值)对设置到哈希表`key`中, O(n)。示例：`HMSET key1 field3 value3 field4 value4`

HEXISTS key field: 查看哈希表`key`中，指定的字段是否存在。示例：`HEXISTS key1 field4HEXISTS key1 field6`

HGET key field: 获取存储在哈希表中指定字段的值。示例：`HGET key1 field4`

HGETALL key: 获取在哈希表中指定 `key` 的所有字段和值。示例：`HGETALL key1`

HKEYS key: 获取所有哈希表中的字段。示例：`HKEYS key1`

HLEN key: 获取哈希表中字段的数量。示例：`HLEN key1`

HMGET key field1 [field2 ...]: 获取所有给定字段的值, O(n)。示例：`HMGET key1 field1 field2`

HINCRBY key field increment: 为哈希表`key`中的指定字段的整数值加上增量`increment`。示例：`HSET key2 field1 1HINCRBY key2 field1 1HGET key2 field1`

HINCRBYFLOAT key field increment: 为哈希表`key`中的指定字段的浮点数值加上增量`increment`。示例：`HINCRBYFLOAT key2 field1 0.8`

HVALS key: 获取哈希表中所有值。示例：`HVALS key1`

HDEL key field1 [field2 ...]: 删除一个或多个哈希表字段。示例：`HDEL key1 field1	HVALS key1`</code></pre>

 <pre><code class="hljs shell">node01:6379&gt; HSET app:mytest1 test1 &quot;123&quot;
OK
node01:6379&gt; HGET app:mytest test1
&quot;123&quot;</code></pre>

<h4 id="list列表的操作"><a href="#list列表的操作" class="headerlink" title="list列表的操作"></a>list列表的操作</h4> <pre><code class="hljs angelscript">Redis列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）

一个列表最多可以包含 <span class="hljs-number">232</span> - <span class="hljs-number">1</span> 个元素 (<span class="hljs-number">4294967295</span>, 每个列表超过<span class="hljs-number">40</span>亿个元素)。</code></pre>

<p>下表列出了列表相关的基本命令:</p>
<pre><code class="hljs shell">LPUSH key value1 [value2]: 将一个或多个值插入到列表头部。示例：`LPUSH list1 value1 value2`

LRANGE key start stop: 查看list当中指定范围（包含stop）的数据。示例：`LRANGE list1 0 -1`

LPUSHX key value: 将一个值插入到已存在的列表头部。示例：`LPUSHX list1 value3` `LINDEX list1 0`

RPUSH key value1 [value2]: 在列表中添加一个或多个值。示例：`RPUSH list1 value4 value5` `LRANGE list1 0 -1`

RPUSHX key value: 为已存在的列表添加值。示例：`RPUSHX list1 value6`

LINSERT key BEFORE|AFTER pivot value: 在列表的元素前或者后插入元素。示例：
`LINSERT list1 BEFORE value3 beforevalue3`

LINDEX key index: 通过索引获取列表中的元素, O(n)。示例：`LINDEX list1 0`

LSET key index value: 通过索引设置列表元素的值, O(n)。示例：`LSET list1 0 hello`

LLEN key: 获取列表长度。示例：`LLEN list1`

LPOP key: 移出并获取列表的第一个元素。示例：`LPOP list1`

RPOP key: 移除列表的最后一个元素，返回值为移除的元素。示例：`RPOP list1`

BLPOP key1 [key2 ...] timeout: 移出并获取列表的第一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。示例：`BLPOP list1 2000`

BRPOP key1 [key2 ...] timeout: 移出并获取列表的最后一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。示例：`BRPOP list1 2000`

RPOPLPUSH source destination: 移除列表的最后一个元素，并将该元素添加到另一个列表并返回。示例：`RPOPLPUSH list1 list2`

BRPOPLPUSH source destination timeout: 从列表中弹出一个值，将弹出的元素插入到另外一个列表中并返回它； 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。示例：`BRPOPLPUSH list1 list2 2000`

LTRIM key start stop: 对一个列表进行修剪(trim)，就是说，让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除。示例：`LTRIM list1 0 2`

DEL key1 key2: 删除指定key的列表。示例：`DEL list2`</code></pre>

<pre><code class="hljs routeros">Tips:
LPUSH + LPOP = STACK
LPUSH + RPOP = QUEUE
LPUSH + LTRIM = 固定大小集合或者LRU
LPUSH + BRPOP = 消息队列</code></pre>

<h4 id="set集合"><a href="#set集合" class="headerlink" title="set集合"></a>set集合</h4> <pre><code class="hljs angelscript">redis 的 Set 是 String 类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。

Redis 中集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(<span class="hljs-number">1</span>)。

集合中最大的成员数为 <span class="hljs-number">232</span> - <span class="hljs-number">1</span> (<span class="hljs-number">4294967295</span>, 每个集合可存储<span class="hljs-number">40</span>多亿个成员)。</code></pre>

<p>下表列出了 Redis 集合基本命令：</p>
<pre><code class="hljs shell">SADD key member1 [member2 ...]: 向集合添加一个或多个成员。示例：`SADD set1 setvalue1 setvalue2`

SMEMBERS key: 返回集合中的所有成员。示例：`SMEMBERS set1`

SCARD key: 获取集合的成员数。示例：`SCARD set1`

SDIFF key1 [key2 ...]: 返回给定所有集合的差集。示例：`SADD set2 setvalue2 setvalue3SDIFF set1 set2`

SDIFFSTORE destkey key1 [key2 ...]: 返回给定所有集合的差集并存储在 destkey 中。示例：`SDIFFSTORE set3 set1 set2`

SINTER key1 [key2 ...]: 返回给定所有集合的交集。示例：`SINTER set1 set2`

SINTERSTORE destkey key1 [key2 ...]: 返回给定所有集合的交集并存储在`destkey`中。示例：`SINTERSTORE set4 set1 set2`

SISMEMBER key member: 判断 member 元素是否是集合`key`的成员。示例：`SISMEMBER set1 setvalue1`

SMOVE sourcekey destkey member: 将`member`元素从`sourcekey`集合移动到`destkey`集合。示例：`SMOVE set1 set2 setvalue1`

SPOP key: 移除并返回集合中的一个随机元素。示例：`SPOP set2`

SRANDMEMBER key [count ...]: 返回集合中一个或多个随机数。示例：`SRANDMEMBER set2 2`

SREM key member1 [member2 ...]: 移除集合中一个或多个成员。示例：`SREM set2 setvalue1`

SUNION key1 [key2 ...]: 返回所有给定集合的并集。示例：`SUNION set1 set2`

SUNIONSTORE destkey key1 [key2 ...]: 所有给定集合的并集存储在`destkey`集合中。示例：`SUNIONSTORE set5 set1 set2`</code></pre>

<h4 id="zset集合"><a href="#zset集合" class="headerlink" title="zset集合"></a>zset集合</h4><p>下表列出了 redis 有序集合的基本命令:</p>
<pre><code class="hljs shell">ZADD key score1 member1 [score2 member2 ...]: 向有序集合添加一个或多个成员，或者更新已存在成员的分数。例如：`ADD zset1 90 ze1`

ZCARD key: 获取有序集合的成员数。例如：`zcard zset1`

ZCOUNT key min max: 计算在有序集合中指定区间分数的成员数。例如：`zcount zset1 90 91`

ZINCRBY key increment member: 有序集合中对指定成员的分数加上增量`increment`。例如：`zincrby zset1 1 ze1`

ZINTERSTORE destkey numkeys key [key ...]: 计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合 destkey 中。例如：`ZINTERSTORE destkey 1 zset1`

ZLEXCOUNT key min max: 在有序集合中计算指定字典区间内成员数量。例如：``

ZRANGE key start stop [WITHSCORES]: 通过索引区间返回有序集合指定区间内的成员。例如：`ZRANGE destkey 0 -1`

ZRANGEBYLEX key min max [LIMIT offset count]: 通过字典区间返回有序集合的成员。例如：
node02:15&gt;ZADD myzset 0 a 0 b 0 c 0 d 0 e 0 f 0 g
&quot;7&quot;
node02:15&gt;ZRANGEBYLEX myzset - [c
 1)  &quot;a&quot;
 2)  &quot;b&quot;
 3)  &quot;c&quot;

ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT]: 通过分数返回有序集合指定区间内的成员。例如：`ZRANGEBYSCORE zset1 90 99`

ZRANK key member: 返回有序集合中指定成员的索引。例如：`ZRANK zset1 ze1`

ZREM key member [member ...]: 移除有序集合中的一个或多个成员。例如：`ZREM destkey ze2`

ZREMRANGEBYLEX key min max]: 移除有序集合中给定的字典区间的所有成员。例如：
node02:15&gt;ZRANGE myzset 0 -1
 1)  &quot;d&quot;
 2)  &quot;e&quot;
 3)  &quot;f&quot;
 4)  &quot;g&quot;

ZREMRANGEBYRANK key start stop: 移除有序集合中给定的排名区间的所有成员。例如：
node02:15&gt;ZADD salary 2000 jack 5000 tom 3500 peter
&quot;3&quot;
node02:15&gt;ZREMRANGEBYRANK salary 0 1
&quot;2&quot;

ZREMRANGEBYSCORE key min max: 移除有序集合中给定的分数区间的所有成员。例如：
node02:15&gt;ZREMRANGEBYSCORE salary 1500 3500
&quot;2&quot;
node02:15&gt;ZRANGE salary 0 -1 WITHSCORES
 1)  &quot;tom&quot;
 2)  &quot;5000&quot;

ZREVRANGE key start stop [WITHSCORES]: 返回有序集中指定区间内的成员，通过索引，分数从高到低。例如：
node02:15&gt;ZRANGE salary 0 -1 WITHSCORES
 1)  &quot;jack&quot;
 2)  &quot;2000&quot;
 3)  &quot;peter&quot;
 4)  &quot;3500&quot;
 5)  &quot;tom&quot;
 6)  &quot;5000&quot;
node02:15&gt;ZREVRANGE salary 0 -1 WITHSCORES
 1)  &quot;tom&quot;
 2)  &quot;5000&quot;
 3)  &quot;peter&quot;
 4)  &quot;3500&quot;
 5)  &quot;jack&quot;
 6)  &quot;2000&quot;

ZREVRANGEBYSCORE key max min [WITHSCORES]: 返回有序集中指定分数区间内的成员，分数从高到低排序。例如：
node02:15&gt;ZREVRANGEBYSCORE salary 10000 2000
 1)  &quot;tom&quot;
 2)  &quot;peter&quot;
 3)  &quot;jack&quot;

ZREVRANK key member: 返回有序集合中指定成员的排名，有序集成员按分数值递减(从大到小)排序。例如：
node02:15&gt;ZREVRANK salary peter
&quot;1&quot;

ZSCORE key member: 返回有序集中，成员的分数值。例如：
node02:15&gt;ZSCORE salary peter
&quot;3500&quot;

ZUNIONSTORE destkey numkeys key [key ...]: 计算给定的一个或多个有序集的并集，并存储在新的 key 中。例如：
node02:15&gt;ZADD zset1 1 &quot;one&quot;
&quot;1&quot;
node02:15&gt;ZADD zset1 2 &quot;two&quot;
&quot;1&quot;
node02:15&gt;ZADD zset2 1 &quot;one&quot;
&quot;1&quot;
node02:15&gt;ZADD zset2 2 &quot;two&quot;
&quot;1&quot;
node02:15&gt;ZADD zset2 3 &quot;three&quot;
&quot;1&quot;
node02:15&gt;ZUNIONSTORE out 2 zset1 zset2 WEIGHTS 2 3
&quot;5&quot;
node02:15&gt;ZRANGE out 0 -1 WITHSCORES
 1)  &quot;one&quot;
 2)  &quot;5&quot;
 3)  &quot;three&quot;
 4)  &quot;9&quot;
 5)  &quot;two&quot;
 6)  &quot;10&quot;
 7)  &quot;ze1&quot;
 8)  &quot;182&quot;
 9)  &quot;ze2&quot;
 10)  &quot;198&quot;

ZSCAN key cursor [MATCH pattern] [COUNT count]: 迭代有序集合中的元素（包括元素成员和元素分值）。例如：
node02:15&gt;ZSCAN out 0 match z*
 1)  &quot;0&quot;
 2)    
 1)   &quot;ze1&quot;
 2)   &quot;182&quot;
 3)   &quot;ze2&quot;
 4)   &quot;198&quot;</code></pre>

<h3 id="瑞士军刀"><a href="#瑞士军刀" class="headerlink" title="瑞士军刀"></a>瑞士军刀</h3><h4 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h4> <pre><code class="hljs shell">Redis 在 2.8.9 版本添加了 HyperLogLog 结构。
Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的。
在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。
但是，因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。

什么是基数?
比如数据集 &#123;1, 3, 5, 7, 5, 7, 8&#125;， 那么这个数据集的基数集为 &#123;1, 3, 5 ,7, 8&#125;, 基数(不重复元素)为5。 基数估计就是在误差可接受的范围内，快速计算基数。</code></pre>

 <pre><code class="hljs shell">Redis HyperLogLog 命令
下表列出了 redis HyperLogLog 的基本命令：

1	PFADD key element [element ...] 
node01:6379&gt;PFADD test 123
添加指定元素到 HyperLogLog 中。
2	PFCOUNT key [key ...] 
node01:6379&gt;PFCOUNT test 
返回给定 HyperLogLog 的基数估算值。
3	PFMERGE destkey sourcekey [sourcekey ...] 
node01:6379&gt;PFCOUNT kbv weitrue kkv   
将多个 HyperLogLog 合并为一个 HyperLogLog</code></pre>

<h6 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h6><p><img src="/images/redis/hyperloglog.png" srcset="/img/loading.gif"></p>
<p> 但是，这个统计是不准确的，官方给出错误率为0.81%</p>
<h4 id="pipeline"><a href="#pipeline" class="headerlink" title="pipeline"></a>pipeline</h4><ul>
<li><p>1次pipeline(n条命令) = 1次网络事件+n次命令时间.</p>
</li>
<li><p>pipeline命令 非<strong>原子</strong>原子命令,而原生批量命令<strong>m操作</strong>是原子命令。</p>
<p><img src="/images/redis/pipem.png" srcset="/img/loading.gif"></p>
<p><img src="/images/redis/pipeline.png" srcset="/img/loading.gif"></p>
</li>
<li><p>pipeline每次只能坐拥在一个redis节点。</p>
</li>
</ul>
<p>Java代码执行对比</p>
<pre><code class="hljs Java">        Jedis jedis = <span class="hljs-keyword">null</span>;
        <span class="hljs-comment">// 连接池大小设置</span>
        GenericObjectPoolConfig genericObjectPoolConfig = <span class="hljs-keyword">new</span> GenericObjectPoolConfig();
        JedisPool jedisPool = <span class="hljs-keyword">new</span> JedisPool(genericObjectPoolConfig, <span class="hljs-string">&quot;node02&quot;</span>, <span class="hljs-number">6379</span>);
        <span class="hljs-keyword">long</span> startTime = System.currentTimeMillis();
        <span class="hljs-keyword">try</span>&#123;
            jedis = jedisPool.getResource();
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;<span class="hljs-number">10000</span> ; i++) &#123;
                jedis.hset(<span class="hljs-string">&quot;pip_test&quot;</span>, <span class="hljs-string">&quot;field&quot;</span>+i, <span class="hljs-string">&quot;value&quot;</span>+i);
            &#125;
        &#125;<span class="hljs-keyword">catch</span> (Exception e) &#123;
            e.printStackTrace();
        &#125; <span class="hljs-keyword">finally</span> &#123;
            <span class="hljs-keyword">if</span> (jedis != <span class="hljs-keyword">null</span>) &#123;
                jedis.close();
            &#125;
        &#125;
        System.out.println(System.currentTimeMillis() - startTime);
        startTime = System.currentTimeMillis();
        <span class="hljs-comment">// 使用pipeline</span>
				<span class="hljs-keyword">try</span>&#123;
            jedis = jedisPool.getResource();
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;
                Pipeline pipelined = jedis.pipelined();
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i * <span class="hljs-number">100</span> ; j &lt;(i + <span class="hljs-number">1</span>) * <span class="hljs-number">100</span> ; j++) &#123;
                    pipelined.hset(<span class="hljs-string">&quot;pip_test&quot;</span>, <span class="hljs-string">&quot;field&quot;</span>+j, <span class="hljs-string">&quot;value&quot;</span>+j);
                &#125;
                pipelined.syncAndReturnAll();
            &#125;
        &#125;<span class="hljs-keyword">catch</span> (Exception e) &#123;
            e.printStackTrace();
        &#125; <span class="hljs-keyword">finally</span> &#123;
            <span class="hljs-keyword">if</span> (jedis != <span class="hljs-keyword">null</span>) &#123;
                jedis.close();
            &#125;
        &#125;
        System.out.println(System.currentTimeMillis() - startTime);

<span class="hljs-comment">// 输出</span>
<span class="hljs-number">12126</span>
<span class="hljs-number">165</span></code></pre>

<h4 id="bitmap-位图"><a href="#bitmap-位图" class="headerlink" title="bitmap(位图)"></a>bitmap(位图)</h4><p>redis可以直接操作位</p>
<p><img src="/images/redis/bitmap-big.png" srcset="/img/loading.gif"></p>
<pre><code class="hljs shell">node02:15&gt;set bitkey big
&quot;OK&quot;
node02:15&gt;get bitkey
&quot;big&quot;
node02:15&gt;getbit bitkey 0
&quot;0&quot;
node02:15&gt;getbit bitkey 1
&quot;1&quot;
node02:15&gt;getbit bitkey 2
&quot;1&quot;
node02:15&gt;</code></pre>

<p>操作命令：</p>
<pre><code class="hljs shell">setbit key offset value            # 给位图指定索引位置设置值，value只能是0或1
getbit key offset                  # 位图指定索引位置二进制值
bitcount key [start end]           # 获取位图指定范围（start 到 end，单位为字节，不指定的话获取全部）位值为1的个数
bitop op destkey key [key ...]     # 做多个bitmap的and（交集） or（并集） not（非） xor（异或）操作并将结果结果保存在destkey中
bitpos key targetBit [start] [end] # 计算位图指定范围（start 到 end，单位为字节，不指定的话获取全部）第一个便宜量对应位置的值等于targetBit的位置</code></pre>

<p><img src="/images/redis/bitc.png" srcset="/img/loading.gif"></p>
<p><img src="/images/redis/bit2.png" srcset="/img/loading.gif"></p>
<h4 id="GEO"><a href="#GEO" class="headerlink" title="GEO"></a>GEO</h4><p>GEO: 地理信息定位。存储经纬度，计算距离、位置等。</p>
<p><code>type getKey = zset</code></p>
<pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 增加地理位置信息</span>
geoadd key longitude latitude member [longitude latitude member ...]
node02:15&gt;geoadd cities:locations 116.28 39.55 beijing
&quot;1&quot;
node02:15&gt;geoadd cities:locations 117.12 39.08 tianjin
&quot;1&quot;
node02:15&gt;geoadd cities:locations 114.29 38.02 shijiazhuang 118.01 39.38 tangshan
&quot;2&quot;

<span class="hljs-meta">#</span><span class="bash"> 获取地理位置信息</span>
geopos key member [member ...]
node02:15&gt;geopos cities:locations beijing
 1)    
 1)   &quot;116.28000229597091675&quot;
 2)   &quot;39.5500007245470826&quot;

<span class="hljs-meta">#</span><span class="bash"> 计算距离 unit:m(米),km(千米),mi(英里),ft(尺)</span>
geodist key member1 member2 [unit]
node02:15&gt;geodist cities:locations beijing tianjin
&quot;89206.0576&quot;</code></pre>

<p><img src="/images/redis/georadius.png" srcset="/img/loading.gif"></p>
<h3 id="redis的持久化"><a href="#redis的持久化" class="headerlink" title="redis的持久化"></a>redis的持久化</h3><p>由于redis是一个内存数据库，所有的数据都是保存在内存当中的，内存当中的数据极易丢失，所以redis的数据持久化就显得尤为重要。</p>
<p>什么是持久化呢?<br>利用永久性存储介质将数据进行保存，在特定的时间将保存的数据进行恢复的工作机制称为持久化。</p>
<p>为什么要进行持久化?<br>防止数据的意外丢失，确保数据安全性。</p>
<pre><code class="hljs angelscript">持久化过程:
<span class="hljs-number">1.</span>将当前数据状态进行保存，快照形式，存储数据结果，存储格式简单，关注点在数据
<span class="hljs-number">2.</span>将数据的操作过程进行保存，日志形式，存储操作过程，存储格式复杂，关注点在数据的操作过程</code></pre>

<p><img src="/images/redis/image-20200528230621178.png" srcset="/img/loading.gif"></p>
<h4 id="RDB持久化"><a href="#RDB持久化" class="headerlink" title="RDB持久化"></a>RDB持久化</h4><pre><code class="hljs plain">Redis会定期保存数据快照至一个rbd文件中，并在启动时自动加载rdb文件，恢复之前保存的数据。</code></pre>

<h5 id="RDB的启动方式"><a href="#RDB的启动方式" class="headerlink" title="RDB的启动方式"></a>RDB的启动方式</h5><h6 id="save"><a href="#save" class="headerlink" title="save"></a>save</h6><pre><code class="hljs shell">save
<span class="hljs-meta">#</span><span class="bash">手动执行一次保存操作</span>
dbfilename dump-端口号.rdb
说明：设置本地数据库文件名，默认值为dump.rdb经验：通常设置为dump-端口号.rdb
dir
说明：设置存储.rdb文件的路径
经验：通常设置成存储空间较大的目录中,目录名称data.
rdbcompression yes
说明：设置存储至本地数据库时是否压缩数据，默认为yes，采用LZF 压缩
经验：通常默认为开启状态，如果设置为no，可以节省CPU 运行时间，但会使存储的文件变大（巨大）
rdbchecksum  yes
说明：设置是否进行RDB文件格式校验，该校验过程在写文件和读文件过程均进行
经验：通常默认为开启状态，如果设置为no，可以节约读写性过程约10%时间消耗，但是存在一定的数据损坏风险
<span class="hljs-meta">#</span><span class="bash">注意:</span>
save指令的执行会阻塞当前Redis服务器，直到当前RDB过程完成为止，有可能会造成长时间阻塞，线上环境不建议使用</code></pre>

<p>save的工作原理</p>
<p><img src="/images/redis/image-20200529114206278.png" srcset="/img/loading.gif"></p>
<h6 id="bgsave"><a href="#bgsave" class="headerlink" title="bgsave"></a>bgsave</h6><pre><code class="hljs shell">bgsave
<span class="hljs-meta">#</span><span class="bash">手动启动后台保存操作，但不是立即执行</span>
dbfilename dump-端口号.rdb
dir
rdbcompression yes
rdbchecksum yes
stop-writes-on-bgsave-error yes
说明：后台存储过程中如果出现错误现象，是否停止保存操作
经验：通常默认为开启状态</code></pre>

<p><img src="/images/redis/image-20200528232539204.png" srcset="/img/loading.gif"></p>
<pre><code class="hljs shell">可以在配置文件中配置Redis进行快照保存的时机：
<span class="hljs-meta">#</span><span class="bash">save [seconds] [changes]</span>
<span class="hljs-meta">#</span><span class="bash">second：监控时间范围</span>
<span class="hljs-meta">#</span><span class="bash">changes：监控key的变化量</span>

<span class="hljs-meta">#</span><span class="bash">意为在[seconds]秒内如果发生了[changes]次数据修改，则进行一次RDB快照保存</span></code></pre>

<p><img src="/images/redis/save&bgsave.png" srcset="/img/loading.gif"></p>
<h6 id="save自动保存配置"><a href="#save自动保存配置" class="headerlink" title="save自动保存配置"></a>save自动保存配置</h6><p>修改redis的配置文件</p>
<pre><code class="hljs shell">cd /weitrue/install/redis-6.0.1/
cat clusters/redis.conf
save 900 1
save 300 10
save 60 10000
<span class="hljs-meta">#</span><span class="bash">save 5 1</span>
dbfilename &quot;dump.rdb&quot; 
dir &quot;/weitrue/install/redis-6.0.1/rdbstro&quot;</code></pre>

<pre><code class="hljs lsl">前三个选项是redis的配置文件默认自带的存储机制。
表示每隔多少秒，有多少个<span class="hljs-type">key</span>发生变化就生成一份dump.rdb文件，作为redis的快照文件。
例如：save  <span class="hljs-number">60</span>  <span class="hljs-number">10000</span> 表示在<span class="hljs-number">60</span>秒内，有<span class="hljs-number">10000</span>个<span class="hljs-type">key</span>发生变化，就会生成一份redis的快照
第四行表示：每隔五秒钟，有一条数据发生变化都需要重新生成redis的快照，需要自己根据实际情况指定。
第五行dbfilename指定了把内存里的数据库写入本地文件的名称，该文件是进行压缩后的二进制文件；
第六行dir指定了RDB二进制文件存放目录 ；</code></pre>

<p><img src="/images/redis/1589191932950.png" srcset="/img/loading.gif"></p>
<p> 修改RDB配置</p>
<pre><code class="hljs zsh"><span class="hljs-comment"># 在命令行里进行配置,服务器重启才会生效:</span>
node01:6379&gt; CONFIG GET save 
1) <span class="hljs-string">&quot;save&quot;</span>
2) <span class="hljs-string">&quot;900 1 300 10 60 10000&quot;</span>
node01:6379&gt; CONFIG SET save <span class="hljs-string">&quot;21600 1000&quot;</span>
OK</code></pre>

<p>注意：</p>
<pre><code class="hljs css">重新启动<span class="hljs-selector-tag">redis</span>服务
每次生成新的<span class="hljs-selector-tag">dump</span><span class="hljs-selector-class">.rdb</span>都会覆盖掉之前的老的快照</code></pre>

<p>save配置原理</p>
<p><img src="/images/redis/image-20200528234120923.png" srcset="/img/loading.gif"></p>
<pre><code class="hljs shell">save配置要根据实际业务情况进行设置，频度过高或过低都会出现性能问题，结果可能是灾难性的save配置中对于second与changes设置通常具有互补对应关系，尽量不要设置成包含性关系save配置启动后执行的是bgsave操作
<span class="hljs-meta">#</span><span class="bash">save配置:</span>
1.dbfilename dump-端口.rdb
2.dir
3.rdbcompression yes
4.rdbchecksum yes</code></pre>

<h5 id="rdb特殊启动形式"><a href="#rdb特殊启动形式" class="headerlink" title="rdb特殊启动形式"></a>rdb特殊启动形式</h5><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">全量复制</span>
  在主从复制中详细讲解
<span class="hljs-meta">#</span><span class="bash">服务器运行过程中重启</span>
  debug reload
<span class="hljs-meta">#</span><span class="bash">关闭服务器时指定保存数据</span>
  shutdown save
默认情况下执行shutdown命令时，自动执行bgsave(如果没有开启AOF持久化功能)</code></pre>

<h5 id="RDB优缺点"><a href="#RDB优缺点" class="headerlink" title="RDB优缺点"></a>RDB优缺点</h5><pre><code class="hljs angelscript">优:
<span class="hljs-number">1.</span>RDB是一个紧凑压缩的二进制文件，存储效率较高
<span class="hljs-number">2.</span>RDB内部存储的是redis在某个时间点的数据快照，非常适合用于数据备份，全量复制等场景
<span class="hljs-number">3.</span>RDB恢复数据的速度要比AOF快很多
<span class="hljs-number">4.</span>应用：服务器中每X小时执行bgsave备份，并将RDB文件拷贝到远程机器中，用于灾难恢复。
缺:
<span class="hljs-number">1.</span>RDB方式无论是执行指令还是利用配置，无法做到实时持久化，具有较大的可能性丢失数据
<span class="hljs-number">2.</span>bgsave指令每次运行要执行fork操作创建子进程，要牺牲掉一些性能
<span class="hljs-number">3.</span>Redis的众多版本中未进行RDB文件格式的版本统一，有可能出现各版本服务之间数据格式无法兼容现象</code></pre>

<h4 id="AOF持久化"><a href="#AOF持久化" class="headerlink" title="AOF持久化"></a>AOF持久化</h4><pre><code class="hljs erlang">   以独立日志的方式记录每次写命令，重启时再重新执行AOF文件中命令达到恢复数据的目的。与RDB相比可以简单描述为改记录数据为记录数据产生的过程.
AOF的主要作用是解决了数据持久化的实时性，目前已经是Redis持久化的主流方式</code></pre>

<h5 id="AOF的读写原理"><a href="#AOF的读写原理" class="headerlink" title="AOF的读写原理"></a>AOF的读写原理</h5><p><img src="/images/redis/image-20200530231955448.png" srcset="/img/loading.gif"></p>
<h5 id="AOF写数据三种策略"><a href="#AOF写数据三种策略" class="headerlink" title="AOF写数据三种策略"></a>AOF写数据三种策略</h5><pre><code class="hljs vala"><span class="hljs-meta"># always(每次）</span>
  每次写入操作均同步到AOF文件中，数据零误差，性能较低,不建议使用
<span class="hljs-meta"># everysec（每秒）</span>
  每秒将缓冲区中的指令同步到AOF文件中，数据准确性较高，性能较高,建议使用，也是默认配置
   在系统突然宕机的情况下丢失<span class="hljs-number">1</span>秒内的数据
<span class="hljs-meta"># no（系统控制）</span>
    由操作系统控制每次同步到AOF文件的周期，整体过程不可控</code></pre>

<h5 id="AOF功能开启"><a href="#AOF功能开启" class="headerlink" title="AOF功能开启"></a>AOF功能开启</h5><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">配置</span>
appendonly yes|no                # 是否开启AOF持久化功能，默认为不开启状态
appendfsync  always|everysec|no  # AOF写数据策略</code></pre>

<h5 id="AOF相关配置"><a href="#AOF相关配置" class="headerlink" title="AOF相关配置"></a>AOF相关配置</h5><pre><code class="hljs shell">cd /weitrue/install/redis-6.0.1
vim redis.conf
appendonly yes
appendfsync everysec    # appendfsync always / appendfsync no

appendfilename filename # AOF持久化文件名，默认文件名未appendonly.aof，建议配置为appendonly-端口号.aof
dir                     # AOF持久化文件保存路径，与RDB持久化文件保持一致即可</code></pre>

<h5 id="AOF重写"><a href="#AOF重写" class="headerlink" title="AOF重写"></a>AOF重写</h5><pre><code class="hljs shell">随着命令不断写入AOF，文件会越来越大，为了解决这个问题，Redis引入了AOF重写机制压缩文件体积。AOF文件重写是将Redis进程内的数据转化为写命令同步到新AOF文件的过程。简单说就是将对同一个数据的若干条命令执行结果转化成最终结果数据对应的指令进行记录。

<span class="hljs-meta">#</span><span class="bash">AOF重写作用</span>
降低磁盘占用量，提高磁盘利用率
提高持久化效率，降低持久化写时间，提高IO性能
降低数据恢复用时间，提高数据恢复效率。

<span class="hljs-meta">#</span><span class="bash">AOF重写规则</span>
  1.进程内已超时的数据不再写入文件
  2.忽略无效指令，重写时使用进程内数据直接生成，这样新的AOF文件只保留最终数据的写入命令
     如del key1、hdelkey2、sremkey3、set key4 111、set key4 222等
  3.对同一数据的多条写命令合并为一条命令
    如lpushlist1 a、lpushlist1 b、lpushlist1 c 可以转化为：lpushlist1 a b c。
    为防止数据量过大造成客户端缓冲区溢出，对list、set、hash、zset等类型，每条指令最多写入64个元素</code></pre>

<h6 id="AOF重写方式"><a href="#AOF重写方式" class="headerlink" title="AOF重写方式"></a>AOF重写方式</h6><ul>
<li>手动重写</li>
</ul>
<pre><code class="hljs shell">bgrewriteaof</code></pre>

<ul>
<li>自动重写</li>
</ul>
<pre><code class="hljs shell">auto-aof-rewrite-min-size size
auto-aof-rewrite-percentage percentage</code></pre>

<h6 id="AOF自动重写方式"><a href="#AOF自动重写方式" class="headerlink" title="AOF自动重写方式"></a>AOF自动重写方式</h6><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 自动重写触发条件设置</span>
auto-aof-rewrite-min-size （达到某一内存开始重写）
sizeauto-aof-rewrite-percentage percent   （达到某一%）

<span class="hljs-meta">#</span><span class="bash"> 自动重写触发比对参数（运行指令info Persistence获取具体信息) </span>
aof_current_size  （设置内存）
aof_base_size      （基础尺寸）</code></pre>

<h5 id="AOF工作流程"><a href="#AOF工作流程" class="headerlink" title="AOF工作流程"></a>AOF工作流程</h5><p><img src="/images/redis/image-20200531004807324.png" srcset="/img/loading.gif"></p>
<h5 id="AOF重写流程"><a href="#AOF重写流程" class="headerlink" title="AOF重写流程"></a>AOF重写流程</h5><p><img src="/images/redis/image-20200531004404062.png" srcset="/img/loading.gif"></p>
<h5 id="AOF优点："><a href="#AOF优点：" class="headerlink" title="AOF优点："></a>AOF优点：</h5><pre><code class="hljs angelscript"><span class="hljs-number">1</span>、 最安全，在启用appendfsync always时，任何已写入的数据都不会丢失，使用在启用appendfsync everysec也至多只会丢失<span class="hljs-number">1</span>秒的数据

<span class="hljs-number">2</span>、 AOF文件在发生断电等问题时也不会损坏，即使出现了某条日志只写入了一半的情况，也可以使用redis-check-aof工具轻松修复。

<span class="hljs-number">3</span>、 AOF文件易读，可修改，在进行了某些错误的数据清除操作后，只要AOF文件没有rewrite，就可以把AOF文件备份出来，把错误的命令删除，然后恢复数据。</code></pre>

<h5 id="AOF的缺点："><a href="#AOF的缺点：" class="headerlink" title="AOF的缺点："></a>AOF的缺点：</h5><pre><code class="hljs angelscript"><span class="hljs-number">1</span>、 AOF文件通常比RDB文件更大

<span class="hljs-number">2</span>、 性能消耗比RDB高

<span class="hljs-number">3</span>、 数据恢复速度比RDB慢

Redis的数据持久化工作本身就会带来延迟，需要根据数据的安全级别和性能要求制定合理的持久化策略：

AOF + fsync always的设置虽然能够绝对确保数据安全，但每个操作都会触发一次fsync，会对Redis的性能有比较明显的影响

AOF + fsync every second是比较好的折中方案，每秒fsync一次

AOF + fsync never会提供AOF持久化方案下的最优性能使用RDB持久化通常会提供比使用AOF更高的性能，但需要注意RDB的策略配置


每一次RDB快照和AOF Rewrite都需要Redis主进程进行fork操作。fork操作本身可能会产生较高的耗时，与CPU和Redis占用的内存大小有关。根据具体的情况合理配置RDB快照和AOF Rewrite时机，避免过于频繁的fork带来的延迟

Redis在fork子进程时需要将内存分页表拷贝至子进程，以占用了<span class="hljs-number">24</span>GB内存的Redis实例为例，共需要拷贝<span class="hljs-number">24</span>GB / <span class="hljs-number">4</span>kB * <span class="hljs-number">8</span> = <span class="hljs-number">48</span>MB的数据。在使用单Xeon <span class="hljs-number">2.27</span>Ghz的物理机上，这一fork操作耗时<span class="hljs-number">216</span>ms。</code></pre>

<h4 id="RDB与AOF"><a href="#RDB与AOF" class="headerlink" title="RDB与AOF"></a>RDB与AOF</h4><p><img src="/images/redis/rdb&aof.png" srcset="/img/loading.gif"></p>
<h4 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h4><ul>
<li><p>同步操作</p>
<ul>
<li>虽然fork同步操作是非常快的，但是如果需要同步的数据量过大(比如超过20G)，fork就会阻塞redis主进程。</li>
</ul>
</li>
<li><p>与内存量息息相关</p>
<ul>
<li>内存越大，fork同步数据耗时越长，当然也跟服务器有关，服务器有物理机，也有虚拟机。</li>
</ul>
</li>
<li><p>info:latest_fork_usec</p>
<ul>
<li>使用此命令可以查看持久化花费的时间，如果持久化时间过长，就会造成卡顿。</li>
<li>例如：如果redis此时QPS上万，此时redis正在持久化，而且持久化时间比较长（1s或者10几秒），此时就会严重阻塞redis。</li>
</ul>
<pre><code class="hljs shell">node02:0&gt;info Stats
&quot;# Stats
total_connections_received:5
total_commands_processed:13
instantaneous_ops_per_sec:0
total_net_input_bytes:346
total_net_output_bytes:7191
instantaneous_input_kbps:0.00
instantaneous_output_kbps:0.00
rejected_connections:0
sync_full:0
sync_partial_ok:0
sync_partial_err:0
expired_keys:0
evicted_keys:0
keyspace_hits:0
keyspace_misses:0
pubsub_channels:0
pubsub_patterns:0
latest_fork_usec:0   # &lt;-------
migrate_cached_sockets:0
&quot;

node02:0&gt;info
&quot;# Server
redis_version:3.2.8
redis_git_sha1:00000000
redis_git_dirty:0
redis_build_id:3a7af52404e97f38
redis_mode:standalone
os:Linux 3.10.0-957.el7.x86_64 x86_64
arch_bits:64
multiplexing_api:epoll
gcc_version:4.8.5
process_id:26189
run_id:2cf1aa7e1893ae1b5427ae9e1963e30e10716673
tcp_port:6379
uptime_in_seconds:122
uptime_in_days:0
hz:10
lru_clock:6488420
executable:/weitrue/install/redis-6.0.1/src/redis-server
config_file:/weitrue/install/redis-6.0.1/redis.conf

<span class="hljs-meta">#</span><span class="bash"> Clients</span>
connected_clients:2
client_longest_output_list:0
client_biggest_input_buf:0
blocked_clients:0

<span class="hljs-meta">#</span><span class="bash"> Memory</span>
used_memory:2168928
used_memory_human:2.07M
used_memory_rss:4009984
used_memory_rss_human:3.82M
used_memory_peak:2201664
used_memory_peak_human:2.10M
total_system_memory:1907941376
total_system_memory_human:1.78G
used_memory_lua:37888
used_memory_lua_human:37.00K
maxmemory:0
maxmemory_human:0B
maxmemory_policy:noeviction
mem_fragmentation_ratio:1.85
mem_allocator:libc

<span class="hljs-meta">#</span><span class="bash"> Persistence</span>
loading:0
rdb_changes_since_last_save:0
rdb_bgsave_in_progress:0
rdb_last_save_time:1617101034
rdb_last_bgsave_status:ok
rdb_last_bgsave_time_sec:-1
rdb_current_bgsave_time_sec:-1
aof_enabled:0
aof_rewrite_in_progress:0
aof_rewrite_scheduled:0
aof_last_rewrite_time_sec:-1
aof_current_rewrite_time_sec:-1
aof_last_bgrewrite_status:ok
aof_last_write_status:ok

<span class="hljs-meta">#</span><span class="bash"> Stats</span>
total_connections_received:5
total_commands_processed:11
instantaneous_ops_per_sec:0
total_net_input_bytes:298
total_net_output_bytes:4947
instantaneous_input_kbps:0.00
instantaneous_output_kbps:0.00
rejected_connections:0
sync_full:0
sync_partial_ok:0
sync_partial_err:0
expired_keys:0
evicted_keys:0
keyspace_hits:0
keyspace_misses:0
pubsub_channels:0
pubsub_patterns:0
latest_fork_usec:0
migrate_cached_sockets:0

<span class="hljs-meta">#</span><span class="bash"> Replication</span>
role:master
connected_slaves:0
master_repl_offset:0
repl_backlog_active:0
repl_backlog_size:1048576
repl_backlog_first_byte_offset:0
repl_backlog_histlen:0

<span class="hljs-meta">#</span><span class="bash"> CPU</span>
used_cpu_sys:0.18
used_cpu_user:0.11
used_cpu_sys_children:0.00
used_cpu_user_children:0.00

<span class="hljs-meta">#</span><span class="bash"> Cluster</span>
cluster_enabled:0

<span class="hljs-meta">#</span><span class="bash"> Keyspace</span>
db0:keys=79,expires=0,avg_ttl=0
db15:keys=12,expires=0,avg_ttl=0
&quot;</code></pre>

</li>
</ul>
<h5 id="改善fork"><a href="#改善fork" class="headerlink" title="改善fork"></a>改善fork</h5><p><img src="/images/redis/improve-fork.png" srcset="/img/loading.gif"></p>
<h3 id="Redis-发布订阅"><a href="#Redis-发布订阅" class="headerlink" title="Redis 发布订阅"></a>Redis 发布订阅</h3><p><img src="/images/redis/pub-sub.png" srcset="/img/loading.gif"></p>
<pre><code class="hljs angelscript">Redis 的发布与订阅功能可以让用户将消息同时发送给多个客户端。 
这个功能由几个不同的角色 协作组成： 
<span class="hljs-number">1.</span>发布者（publisher）：发布消息的客户端。 
<span class="hljs-number">2.</span>频道（channel）：构建在服务器内部，负责接收发布者发送的消息，并将消息转发给频道的订阅者。 
<span class="hljs-number">3.</span>模式（pattern）：构建在服务器内部，负责对频道进行匹配，当被匹配的频道接到消息时，模式也会 
将消息转发给模式的订阅者。 
<span class="hljs-number">4.</span>订阅者（subscriber）：通过订阅频道或者模式来获取消息的客户端。每个频道或者模式都可以有任 意多个订阅者(仅能获得开始订阅以后的消息，订阅前的消息无法获得)。</code></pre>

<h5 id="订阅命令"><a href="#订阅命令" class="headerlink" title="订阅命令"></a>订阅命令</h5> <pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">订阅频道</span>
SUBSCRIBE channel [channel ...]
订阅给定的一个或多个频道。
node02:15&gt;SUBSCRIBE wo
Switch to Pub/Sub mode. Close console tab to stop listen for messages.
 1)  &quot;subscribe&quot;
 2)  &quot;wo&quot;
 3)  &quot;1&quot;
 1)  &quot;message&quot;
 2)  &quot;wo&quot;
 3)  &quot;hello&quot;
 1)  &quot;message&quot;
 2)  &quot;wo&quot;
 3)  &quot;test&quot;</code></pre>

<h6 id="消息发布"><a href="#消息发布" class="headerlink" title="消息发布"></a>消息发布</h6><pre><code class="hljs shell">node02:15&gt;PUBLISH wo hello
&quot;1&quot;</code></pre>

<h6 id="订阅多个"><a href="#订阅多个" class="headerlink" title="订阅多个"></a>订阅多个</h6><pre><code class="hljs shell">通配符*
<span class="hljs-meta">redis&gt;</span><span class="bash"> PSUBSCRIBE new*</span></code></pre>

<h6 id="消息发布-1"><a href="#消息发布-1" class="headerlink" title="消息发布"></a>消息发布</h6><pre><code class="hljs shell"><span class="hljs-meta">redis&gt;</span><span class="bash">PUBLISH new1 hello</span></code></pre>

<h6 id="列出指定频道订阅着数量"><a href="#列出指定频道订阅着数量" class="headerlink" title="列出指定频道订阅着数量"></a>列出指定频道订阅着数量</h6><pre><code class="hljs shell"><span class="hljs-meta">redis&gt;</span><span class="bash"> PUBSUB numsub [channel...]</span></code></pre>

<h3 id="Redis-事务"><a href="#Redis-事务" class="headerlink" title="Redis 事务"></a>Redis 事务</h3><pre><code class="hljs nginx"><span class="hljs-attribute">Redis</span> 的事务功能允许用户将多个命令包裹起来，然后一次性地、按 顺序地执行被包裹的所有命令。
在事务执行的过程中，服务器不会中断事务而改去执行其他命令请求，只有在事务包裹的所有命令都
被执行完毕之后，服务器才会去处理其他命令请求。</code></pre>

<h4 id="事务命令"><a href="#事务命令" class="headerlink" title="事务命令"></a>事务命令</h4><pre><code class="hljs plain">为了避免遇上以上所说的情况， 我们需要用到 Redis 的事务功能， 通过事务， 我们可以让 Redis 
一次性地执行多个命令， 并且确保事务中的命令要么就全部都 执行，要么就一个都不执行。</code></pre>

<p><strong>事务命令</strong>：                                                     作用： </p>
<p>MULTI                                                             开始一个新的事务。    </p>
<p>DISCARD                                                         放弃事务。</p>
<p>EXEC                                                                 执行事务中的所有命令。</p>
<p><strong>开始事务</strong></p>
<pre><code class="hljs shell">MULTI
开始一个事务。 
在这个命令执行之后，客户端发送的所有针对数据库或者数据库键的命令都不会被立即执行，而是被放
入到一个事务队列里面，并返回 QUEUED 表示命令已入队。
<span class="hljs-meta">redis&gt;</span><span class="bash"> MULTI <span class="hljs-comment"># 开始一个事务</span></span>
OK
<span class="hljs-meta">redis&gt;</span><span class="bash"> SET msg <span class="hljs-string">&quot;hello world&quot;</span> <span class="hljs-comment"># 将这个 SET 命令放入事务队列</span></span>
QUEUED</code></pre>

<p><strong>放弃事务：</strong></p>
<pre><code class="hljs shell">DISCARD
取消事务，放弃执行事务队列中的所有命令。
<span class="hljs-meta"> redis&gt;</span><span class="bash"> MULTI</span>
 OK
<span class="hljs-meta"> redis&gt;</span><span class="bash"> SET msg <span class="hljs-string">&quot;hello world&quot;</span></span>
 QUEUED
<span class="hljs-meta"> redis&gt;</span><span class="bash"> DISCARD <span class="hljs-comment"># 事务已被取消</span></span>
 OK</code></pre>

<p><strong>执行事务</strong></p>
<pre><code class="hljs shell">EXEC
按照命令被入队到事务队列中的顺序，执行事务队列中的所有命令。
<span class="hljs-meta">redis&gt;</span><span class="bash"> MULTI </span>
OK
<span class="hljs-meta">redis&gt;</span><span class="bash"> SET msg <span class="hljs-string">&quot;hello world&quot;</span></span>
QUEUED
<span class="hljs-meta">redis&gt;</span><span class="bash"> SET msg <span class="hljs-string">&quot;hello world&quot;</span></span>
QUEUED
<span class="hljs-meta">redis&gt;</span><span class="bash"> EXEC</span></code></pre>

<h3 id="Redis-安全"><a href="#Redis-安全" class="headerlink" title="Redis 安全"></a>Redis 安全</h3><p>我们可以通过 redis 的配置文件设置密码参数，这样客户端连接到 redis 服务就需要密码验证，这样可以让你的 redis 服务更安全。 </p>
<pre><code class="hljs shell">实例
我们可以通过以下命令查看是否设置了密码验证：
127.0.0.1:6379&gt; CONFIG get requirepass
1) &quot;requirepass&quot;
2) &quot;&quot;
默认情况下 requirepass 参数是空的，这就意味着你无需通过密码验证就可以连接到 redis 服务。
你可以通过以下命令来修改该参数：
127.0.0.1:6379&gt; CONFIG set requirepass &quot;weitrue&quot;
OK
127.0.0.1:6379&gt; CONFIG get requirepass
1) &quot;requirepass&quot;
2) &quot;weitrue&quot;</code></pre>

<p>设置密码后，客户端连接 redis 服务就需要密码验证，否则无法执行命令。</p>
<pre><code class="hljs shell">语法
AUTH 命令基本语法格式如下：
127.0.0.1:6379&gt; AUTH password
实例
127.0.0.1:6379&gt; AUTH &quot;weitrue&quot;
OK</code></pre>

<p>取消密码 —重启服务</p>
<pre><code class="hljs plain">AUTH命令跟其他redis命令一样，是没有加密的；阻止不了攻击者在网络上窃取你的密码；</code></pre>

<h3 id="Redis-性能测试"><a href="#Redis-性能测试" class="headerlink" title="Redis 性能测试"></a>Redis 性能测试</h3><p>Redis 性能测试是通过同时执行多个命令实现的。</p>
<pre><code class="hljs shell">语法
redis 性能测试的基本命令如下：

redis-benchmark [option] [option value]
注意：该命令是在 redis 的目录下执行的，而不是 redis 客户端的内部指令。

实例
以下实例同时执行 10000 个请求来检测性能：

[hadoop@node02 redis-6.0.1]$ src/redis-benchmark  -h node02 -p 6379  -n 10000 -q
PING_INLINE: 72992.70 requests per second
PING_BULK: 70921.98 requests per second
SET: 66666.66 requests per second
GET: 73529.41 requests per second
INCR: 75187.97 requests per second
LPUSH: 68493.15 requests per second
RPUSH: 76923.08 requests per second
LPOP: 74626.87 requests per second
RPOP: 75757.58 requests per second
SADD: 76335.88 requests per second
SPOP: 76923.08 requests per second
LPUSH (needed to benchmark LRANGE): 75757.58 requests per second
LRANGE_100 (first 100 elements): 40983.61 requests per second
LRANGE_300 (first 300 elements): 19120.46 requests per second
LRANGE_500 (first 450 elements): 13605.44 requests per second
LRANGE_600 (first 600 elements): 10672.36 requests per second
MSET (10 keys): 59880.24 requests per second</code></pre>

<pre><code class="hljs lsl">redis 性能测试工具可选参数如下所示：
序号	选项	描述	                                 默认值
<span class="hljs-number">1</span>	-h	指定服务器主机名	                     <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>
<span class="hljs-number">2</span>	-p	指定服务器端口	                            <span class="hljs-number">6379</span>
<span class="hljs-number">3</span>	-s	指定服务器 socket	
<span class="hljs-number">4</span>	-c	指定并发连接数	                             <span class="hljs-number">50</span>
<span class="hljs-number">5</span>	-n	指定请求数	                             <span class="hljs-number">10000</span>
<span class="hljs-number">6</span>	-d	以字节的形式指定 SET/GET 值的数据大小	         <span class="hljs-number">2</span>
<span class="hljs-number">7</span>	-k	<span class="hljs-number">1</span>=keep alive <span class="hljs-number">0</span>=reconnect	              <span class="hljs-number">1</span>
<span class="hljs-number">8</span>	-r	SET/GET/INCR 使用随机 <span class="hljs-type">key</span>, SADD 使用随机值	
<span class="hljs-number">9</span>	-P	通过管道传输 &lt;numreq&gt; 请求	                 <span class="hljs-number">1</span>
<span class="hljs-number">10</span>	-q	强制退出 redis。仅显示 query/sec 值	
<span class="hljs-number">11</span>	--csv	以 CSV 格式输出	
<span class="hljs-number">12</span>	-l	生成循环，永久执行测试	
<span class="hljs-number">13</span>	-t	仅运行以逗号分隔的测试命令列表。	
<span class="hljs-number">14</span>	-I	Idle 模式。仅打开 N 个 idle 连接并等待。</code></pre>

<pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">以下实例使用了多个参数来测试 redis 性能：</span>

[hadoop@node02 redis-6.0.1]$ src/redis-benchmark -h node02 -p 6379 -t set,lpush -n 10000 -q
SET: 68493.15 requests per second
LPUSH: 67114.09 requests per second
以上实例中主机为 node01，端口号为 6379，执行的命令为 set,lpush，请求数为 10000，通过 -q 参数让结果只显示每秒执行的请求数。</code></pre>

<h3 id="redis的三种集群方式："><a href="#redis的三种集群方式：" class="headerlink" title="redis的三种集群方式："></a>redis的三种集群方式：</h3><h4 id="主从复制架构"><a href="#主从复制架构" class="headerlink" title="主从复制架构"></a>主从复制架构</h4><p>在Redis中，<br><code>SLAVEOF  命令或者设置</code>slaveof 选项，让一个服务器去复制（replicate）另一个服务器，被复制的服务器为主服务器（master），而对主服务器进行复制的服务器则被称为从服务器（slave）。<br><code>SLAVEOF no one</code>命令取消成为从节点。</p>
<p><img src="/images/redis/image-20200526181040434.png" srcset="/img/loading.gif"></p>
<p><img src="/images/redis/image-20200526181105914.png" srcset="/img/loading.gif"></p>
<p><img src="/images/redis/image-20200527001642571.png" srcset="/img/loading.gif"></p>
<h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><ul>
<li>读写分离:master写,slave读。</li>
<li>负载均衡:由slave分担master负载,并根据需求,改变slave的数量,通过多个从节点读取负载。</li>
<li>故障恢复:当master出现问题的时候,由slave提供服务,实现快速恢复。</li>
<li>数据冗余:实时备份。</li>
</ul>
<h5 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h5><pre><code class="hljs angelscript">三阶段:
 <span class="hljs-number">1.</span>建立连接
 <span class="hljs-number">2.</span>数据同步
 <span class="hljs-number">3.</span>命令传播阶段</code></pre>

<p><img src="/images/redis/image-20200526191458864.png" srcset="/img/loading.gif"></p>
<p><img src="/images/redis/image-20200527001702103.png" srcset="/img/loading.gif"></p>
<h5 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h5><p>使用主从复制这种模式，实现node01作为主节点，node02与node03作为从节点，并且将node01所有的数据全部都同步到node02与node03服务器</p>
<p>第一步: 将node01上的redis拷贝到node02和node03上</p>
<pre><code class="hljs shell">scp -r /weitrue/install/redis-6.0.1/ node02:/weitrue/install/
scp -r /weitrue/install/redis-6.0.1/ node03:/weitrue/instal/</code></pre>

<p>第二步：node02与node03服务器安装redis</p>
<pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> node02与node03服务器修改redis配置文件</span>
<span class="hljs-meta">#</span><span class="bash"> node02服务器修改配置文件命令如下</span>
<span class="hljs-meta">#</span><span class="bash">执行以下命令修改redis配置文件</span>
cd /weitrue/install/redis-6.0.1/
mkdir -p /weitrue/install/redis-6.0.1/logs
mkdir -p /weitrue/install/redis-6.0.1/redisdata
vim redis.conf
bind node02
daemonize yes
pidfile /weitrue/install/redis-6.0.1/redis_6379.pid
logfile &quot;/weitrue/install/redis-6.0.1/logs/redis.log&quot;
dir /weitrue/install/redis-6.0.1/redisdata
slaveof node01 6379
<span class="hljs-meta">#</span><span class="bash"> node03服务器修改配置文件命令如下</span>
<span class="hljs-meta">#</span><span class="bash">执行以下命令修改redis配置文件</span>
cd /weitrue/install/redis-6.0.1/
mkdir -p /weitrue/install/redis-6.0.1/logs
mkdir -p /weitrue/install/redis-6.0.1/redisdata
vim redis.conf
bind node03
daemonize yes
pidfile /var/run/redis_6379.pid
logfile &quot;/weitrue/install/redis-6.0.1/logs/redis.log&quot;
dir /weitrue/install/redis-6.0.1/redisdata
slaveof node01 6379</code></pre>

<p>第三步、启动node02与node03机器的redis服务</p>
<pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">node02执行以下命令启动redis服务</span>
cd  /weitrue/install/redis-6.0.1/
src/redis-server  redis.conf
<span class="hljs-meta">#</span><span class="bash">ode03执行以下命令启动redis服</span>
cd  /weitrue/install/redis-6.0.1/
src/redis-server  redis.conf</code></pre>

<p>启动成功便可以实现redis的主从复制，node01可以读写操作，node02与node03只支持读取操作。</p>
<pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">注意:务必关掉防火墙</span>
<span class="hljs-meta">#</span><span class="bash">连接node01</span>
src/redis-cli -h node01
set weitrue 1234
<span class="hljs-meta">#</span><span class="bash">连接node02</span>
src/redis-cli -h node02
get weitrue
<span class="hljs-meta">#</span><span class="bash">查看集群信息</span>
info
<span class="hljs-meta">#</span><span class="bash">主从断开连接</span>
slaveof no one</code></pre>

<h4 id="redis当中的Sentinel架构"><a href="#redis当中的Sentinel架构" class="headerlink" title="redis当中的Sentinel架构"></a>redis当中的Sentinel架构</h4><pre><code class="hljs plain">Sentinel（哨兵）是Redis 的高可用性解决方案：由一个或多个Sentinel 实例 组成的Sentinel 系统可以监视任意多个主服务器，以及这些主服务器属下的所有从服务器，并在被监视的主服务器进入下线状态时，自动将下线主服务器属下的某个从服务器升级为新的主服务器。</code></pre>

<p><img src="/images/redis/image-20200527141509519.png" srcset="/img/loading.gif"></p>
<p><img src="/images/redis/image-20200527141538252.png" srcset="/img/loading.gif"></p>
<p>作用:</p>
<pre><code class="hljs crmsh"> 监控:不断的检查<span class="hljs-literal">master</span>和<span class="hljs-literal">slave</span>是否正常运行.<span class="hljs-literal">master</span>存活检测,<span class="hljs-literal">master</span>与<span class="hljs-literal">slave</span>运行情况检测.

 通知:当被监控的服务器出现问题时,向其他的(哨兵间或者客户端)发送通知.

自动故障转移:断开<span class="hljs-literal">master</span>与<span class="hljs-literal">slave</span>连接,选取一个<span class="hljs-literal">slave</span>作为<span class="hljs-literal">master</span>,将其他的<span class="hljs-literal">slave</span>连接到新的<span class="hljs-literal">master</span>,并告知客户端新的服务器地址.
注意:哨兵通常也是一台服务器,但不提供服务,通常的哨兵配置为积数.</code></pre>

<p>配置:</p>
<p>第一步：三台机器修改哨兵配置文件</p>
<pre><code class="hljs angelscript">#三台机器执行以下命令修改redis的哨兵配置文件
cd /weitrue/install/redis<span class="hljs-number">-6.0</span><span class="hljs-number">.1</span>
vim sentinel.conf
# 配置监听的主服务器，这里sentinel monitor代表监控，mymaster代表服务器的名称，可以自定义，<span class="hljs-number">192.168</span><span class="hljs-number">.11</span><span class="hljs-number">.128</span>代表监控的主服务器，<span class="hljs-number">6379</span>代表端口，<span class="hljs-number">2</span>代表只有两个或两个以上的哨兵认为主服务器不可用的时候，才会进行failover操作。
#修改bind配置，每台机器修改为自己对应的主机名
bind node01  
#配置sentinel服务后台运行
daemonize yes
#修改三台机器监控的主节点，现在主节点是node01服务器
sentinel monitor mymaster <span class="hljs-number">192.168</span><span class="hljs-number">.8</span><span class="hljs-number">.100</span> <span class="hljs-number">6379</span> <span class="hljs-number">2</span>
# sentinel monitor代表监控，mymaster是服务名称,可以自定义;node01 代表监控的主服务器;<span class="hljs-number">6379</span>代表端口,<span class="hljs-number">2</span>代表只有两个或两个以上的哨兵认为主服务器不可用的时候，才会进行failover操作。</code></pre>

<p>第二步：三台机器启动哨兵服务</p>
<pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">三台机器执行以下命令启动哨兵服务</span>
cd /weitrue/install/redis-6.0.1/
src/redis-sentinel sentinel.conf</code></pre>

<p>第三步：node01服务器杀死redis服务进程</p>
<pre><code class="hljs gcode">使用kill  <span class="hljs-number">-9</span>命令杀死redis服务进程，模拟redis故障宕机情况
过一段时间之后，就会在<span class="hljs-symbol">node02</span>与<span class="hljs-symbol">node03</span>服务器选择一台服务器来切换为主节点</code></pre>

<p>原理:</p>
<p><img src="/images/redis/image-20200527175422937.png" srcset="/img/loading.gif"></p>
<p><img src="/images/redis/image-20200527181408612.png" srcset="/img/loading.gif"></p>
<p><img src="/images/redis/image-20200527182135500.png" srcset="/img/loading.gif"></p>
<p><img src="/images/redis/image-20200527184045802.png" srcset="/img/loading.gif"></p>
<h4 id="redis集群"><a href="#redis集群" class="headerlink" title="redis集群"></a>redis集群</h4><pre><code class="hljs angelscript">Redis 集群是一个提供在多个Redis节点之间共享数据的程序集。

Redis 集群并不支持同时处理多个键的 Redis 命令，因为这需要在多个节点间移动数据，这样会降低redis集群的性能，在高负载的情况下可能会导致不可预料的错误。

Redis 集群通过分区来提供一定程度的可用性，即使集群中有一部分节点失效或者无法进行通讯， 集群也可以继续处理命令请求。

 Redis 集群的优势:

<span class="hljs-number">1.</span>缓存永不宕机：启动集群，永远让集群的一部分起作用。主节点失效了子节点能迅速改变角色成为主节点，整个集群的部分节点失败或者不可达的情况下能够继续处理命令；

<span class="hljs-number">2.</span>迅速恢复数据：持久化数据，能在宕机后迅速解决数据丢失的问题；

<span class="hljs-number">3.</span>Redis可以使用所有机器的内存，变相扩展性能；

<span class="hljs-number">4.</span>使Redis的计算能力通过简单地增加服务器得到成倍提升,Redis的网络带宽也会随着计算机和网卡的增加而成倍增长；

<span class="hljs-number">5.</span>Redis集群没有中心节点，不会因为某个节点成为整个集群的性能瓶颈;
<span class="hljs-number">6.</span>异步处理数据，实现快速读写。</code></pre>

<p><img src="/images/redis/image-20200524161751571.png" srcset="/img/loading.gif"></p>
<h5 id="集群数据存储设计及通信原理"><a href="#集群数据存储设计及通信原理" class="headerlink" title="集群数据存储设计及通信原理"></a>集群数据存储设计及通信原理</h5><pre><code class="hljs plain">redis集群数据存储设计</code></pre>

<p><img src="/images/redis/image-20200524162113663.png" srcset="/img/loading.gif"></p>
<pre><code class="hljs plain">redis集群通信原理</code></pre>

<p><img src="/images/redis/1590146339566.png" srcset="/img/loading.gif"></p>
<h5 id="redis集群环境搭建"><a href="#redis集群环境搭建" class="headerlink" title="redis集群环境搭建"></a>redis集群环境搭建</h5><pre><code class="hljs angelscript">由于redis集群当中最少需要三个主节点，每个主节点，最少需要一个对应的从节点，所以搭建redis集群最少需要三主三从的配置，因此redis集群最少需要<span class="hljs-number">6</span>台redis的实例。我们这里用node01通过配置<span class="hljs-number">6</span>个端口，实现redis集群的环境搭建</code></pre>

<h6 id="node01服务器解压redis压缩包"><a href="#node01服务器解压redis压缩包" class="headerlink" title="node01服务器解压redis压缩包"></a>node01服务器解压redis压缩包</h6><pre><code class="hljs awk"><span class="hljs-comment">#node01执行以下命令重新解压redis压缩包到/weitrue路径下</span>
cd <span class="hljs-regexp">/weitrue/</span>soft/
tar -zxvf redis-<span class="hljs-number">6.0</span>.<span class="hljs-number">1</span>.tar.gz -C ..<span class="hljs-regexp">/instal/</span></code></pre>

<h6 id="安装redis必须依赖环境并进行编译"><a href="#安装redis必须依赖环境并进行编译" class="headerlink" title="安装redis必须依赖环境并进行编译"></a>安装redis必须依赖环境并进行编译</h6><pre><code class="hljs routeros"><span class="hljs-comment">#node01执行以下命令安装redis的依赖环境</span>
su root
yum -y install gcc-c++ tcl
<span class="hljs-comment"># 查看gcc版本是否在5.3以上，centos7.6默认安装4.8.5</span>
gcc -v
<span class="hljs-comment"># 升级gcc到5.3及以上,如下：</span>
升级到gcc 9.3：
yum -y install centos-release-scl
yum -y install devtoolset-9-gcc devtoolset-9-gcc-c++ devtoolset-9-binutils
scl <span class="hljs-builtin-name">enable</span> devtoolset-9 bash
需要注意的是scl命令启用只是临时的，退出shell或重启就会恢复原系统gcc版本。
如果要长期使用gcc 9.3的话：

echo <span class="hljs-string">&quot;source /opt/rh/devtoolset-9/enable&quot;</span> &gt;&gt;/etc/profile
<span class="hljs-comment">#这样退出shell重新打开就是新版的gcc了</span>
<span class="hljs-comment">#对redis进行编译</span>
cd /weitrue/redis-6.0.1
make &amp;&amp; make install</code></pre>

<h6 id="创建redis不同实例的配置文件夹"><a href="#创建redis不同实例的配置文件夹" class="headerlink" title="创建redis不同实例的配置文件夹"></a>创建redis不同实例的配置文件夹</h6><p>创建文件夹，并将redis的配置文件拷贝到以下这些目录</p>
<pre><code class="hljs apache"><span class="hljs-comment">#node01:</span>
<span class="hljs-attribute">cd</span> /weitrue/install/redis-<span class="hljs-number">6</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>
<span class="hljs-attribute">mkdir</span> -p /weitrue/install/redis-<span class="hljs-number">6</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>/clusters/<span class="hljs-number">7001</span>
<span class="hljs-attribute">mkdir</span> -p /weitrue/install/redis-<span class="hljs-number">6</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>/clusters/<span class="hljs-number">7002</span>
<span class="hljs-attribute">mkdir</span> -p /weitrue/install/redis-<span class="hljs-number">6</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>/clusters/<span class="hljs-number">7003</span>
<span class="hljs-attribute">mkdir</span> -p /weitrue/install/redis-<span class="hljs-number">6</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>/clusters/<span class="hljs-number">7004</span>
<span class="hljs-attribute">mkdir</span> -p /weitrue/install/redis-<span class="hljs-number">6</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>/clusters/<span class="hljs-number">7005</span>
<span class="hljs-attribute">mkdir</span> -p /weitrue/install/redis-<span class="hljs-number">6</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>/clusters/<span class="hljs-number">7006</span></code></pre>

<h6 id="修改redis的六个配置文件"><a href="#修改redis的六个配置文件" class="headerlink" title="修改redis的六个配置文件"></a>修改redis的六个配置文件</h6><pre><code class="hljs awk"><span class="hljs-comment">#node01执行以下命令修改redis的配置文件</span>
mkdir -p <span class="hljs-regexp">/weitrue/i</span>nstall<span class="hljs-regexp">/redis-6.0.1/</span>logs
mkdir -p <span class="hljs-regexp">/weitrue/i</span>nstall<span class="hljs-regexp">/redis-6.0.1/</span>redisdata/<span class="hljs-number">7001</span>
mkdir -p <span class="hljs-regexp">/weitrue/i</span>nstall<span class="hljs-regexp">/redis-6.0.1/</span>redisdata/<span class="hljs-number">7002</span>
mkdir -p <span class="hljs-regexp">/weitrue/i</span>nstall<span class="hljs-regexp">/redis-6.0.1/</span>redisdata/<span class="hljs-number">7003</span>
mkdir -p <span class="hljs-regexp">/weitrue/i</span>nstall<span class="hljs-regexp">/redis-6.0.1/</span>redisdata/<span class="hljs-number">7004</span>
mkdir -p <span class="hljs-regexp">/weitrue/i</span>nstall<span class="hljs-regexp">/redis-6.0.1/</span>redisdata/<span class="hljs-number">7005</span>
mkdir -p <span class="hljs-regexp">/weitrue/i</span>nstall<span class="hljs-regexp">/redis-6.0.1/</span>redisdata/<span class="hljs-number">7006</span></code></pre>

<p>分别修改6个配置文件</p>
<pre><code class="hljs java">vim  /weitrue/install/redis-<span class="hljs-number">6.0</span>.<span class="hljs-number">1</span>/redis.conf
bind node01
port <span class="hljs-number">7001</span>                                 <span class="hljs-comment">//默认ip为127.0.0.1 需要改为其他节点机器可访问的ip </span>
cluster-enabled yes                       <span class="hljs-comment">//开启集群把注释#去掉</span>
cluster-config-file nodes-<span class="hljs-number">7001.</span>conf      <span class="hljs-comment">//集群的配置  配置文件首次启动自动生成 7001,7002,7003</span>
cluster-node-timeout <span class="hljs-number">5000</span>                 <span class="hljs-comment">//请求超时  默认15秒，可自行设置</span>
appendonly yes                           <span class="hljs-comment">//aof日志开启  有需要就开启，它会每次写操作都记录一条日志</span>
daemonize yes
pidfile /<span class="hljs-keyword">var</span>/run/redis_7001.pid
logfile <span class="hljs-string">&quot;/weitrue/install/redis-6.0.1/logs/7001.log&quot;</span>
dir /weitrue/install/redis-<span class="hljs-number">6.0</span>.<span class="hljs-number">1</span>/redisdata/<span class="hljs-number">7001</span>
</code></pre>

<pre><code class="hljs angelscript">注意：port：对应的每台机器的端口号，
    第一台是：port <span class="hljs-number">7001</span>
    第二台：port  <span class="hljs-number">7002</span>
    ....
    第六台：port <span class="hljs-number">7006</span>
    
    第一台： cluster-config-file nodes<span class="hljs-number">-7001.</span>conf
    ....  
    第六台：cluster-config-file nodes<span class="hljs-number">-7006.</span>conf
    
    第一台： dir /weitrue/install/redis<span class="hljs-number">-6.0</span><span class="hljs-number">.1</span>/redisdata/<span class="hljs-number">7001</span>
    .... 
    第六台：dir /weitrue/install/redis<span class="hljs-number">-6.0</span><span class="hljs-number">.1</span>/redisdata/<span class="hljs-number">7006</span></code></pre>

<h6 id="启动redis进程"><a href="#启动redis进程" class="headerlink" title="启动redis进程"></a>启动redis进程</h6><p>node01执行以下命令来启动redis集群</p>
<pre><code class="hljs awk">cd <span class="hljs-regexp">/weitrue/</span>redis-<span class="hljs-number">6.0</span>.<span class="hljs-number">1</span>
src<span class="hljs-regexp">/redis-server clusters/</span><span class="hljs-number">7001</span>/redis.conf
src<span class="hljs-regexp">/redis-server clusters/</span><span class="hljs-number">7002</span>/redis.conf
src<span class="hljs-regexp">/redis-server clusters/</span><span class="hljs-number">7003</span>/redis.conf
src<span class="hljs-regexp">/redis-server clusters/</span><span class="hljs-number">7004</span>/redis.conf
src<span class="hljs-regexp">/redis-server clusters/</span><span class="hljs-number">7005</span>/redis.conf
src<span class="hljs-regexp">/redis-server clusters/</span><span class="hljs-number">7006</span>/redis.conf</code></pre>

<h6 id="创建redis集群"><a href="#创建redis集群" class="headerlink" title="创建redis集群"></a>创建redis集群</h6><p>node01执行以下命令创建redis集群</p>
<pre><code class="hljs angelscript">cd /weitrue/install/redis<span class="hljs-number">-6.0</span><span class="hljs-number">.1</span>

src/redis-cli --cluster create <span class="hljs-number">192.168</span><span class="hljs-number">.8</span><span class="hljs-number">.100</span>:<span class="hljs-number">7001</span> <span class="hljs-number">192.168</span><span class="hljs-number">.8</span><span class="hljs-number">.100</span>:<span class="hljs-number">7002</span> <span class="hljs-number">192.168</span><span class="hljs-number">.8</span><span class="hljs-number">.100</span>:<span class="hljs-number">7003</span> <span class="hljs-number">192.168</span><span class="hljs-number">.8</span><span class="hljs-number">.100</span>:<span class="hljs-number">7004</span> <span class="hljs-number">192.168</span><span class="hljs-number">.8</span><span class="hljs-number">.100</span>:<span class="hljs-number">7005</span> <span class="hljs-number">192.168</span><span class="hljs-number">.8</span><span class="hljs-number">.100</span>:<span class="hljs-number">7006</span> --cluster-replicas <span class="hljs-number">1</span></code></pre>

<p>注意：如果创建cluster集群出现以下这个错误</p>
<p><img src="/images/redis/2.png" srcset="/img/loading.gif"></p>
<p>那么我们需要清空所有redis节点的所有数据</p>
<p>执行以下命令连接到各个redis节点，然后清空数据</p>
<pre><code class="hljs angelscript">示例：
<span class="hljs-string">[root@node01 redis-6.0.1]</span># src/redis-cli  -h node01 -c -p <span class="hljs-number">7001</span>
node01:<span class="hljs-number">7001</span>&gt; flushall 
OK
node01:<span class="hljs-number">7001</span>&gt; cluster reset
OK
node01:<span class="hljs-number">7001</span>&gt; quit
#依次执行<span class="hljs-number">6</span>台机器</code></pre>

<p>重新创建redis集群</p>
<pre><code class="hljs angelscript">src/redis-cli --cluster create <span class="hljs-number">192.168</span><span class="hljs-number">.8</span><span class="hljs-number">.100</span>:<span class="hljs-number">7001</span> <span class="hljs-number">192.168</span><span class="hljs-number">.8</span><span class="hljs-number">.100</span>:<span class="hljs-number">7002</span> <span class="hljs-number">192.168</span><span class="hljs-number">.8</span><span class="hljs-number">.100</span>:<span class="hljs-number">7003</span> <span class="hljs-number">192.168</span><span class="hljs-number">.8</span><span class="hljs-number">.100</span>:<span class="hljs-number">7004</span> <span class="hljs-number">192.168</span><span class="hljs-number">.8</span><span class="hljs-number">.100</span>:<span class="hljs-number">7005</span> <span class="hljs-number">192.168</span><span class="hljs-number">.8</span><span class="hljs-number">.100</span>:<span class="hljs-number">7006</span> --cluster-replicas <span class="hljs-number">1</span></code></pre>

<h6 id="连接redis客户端-1"><a href="#连接redis客户端-1" class="headerlink" title="连接redis客户端"></a>连接redis客户端</h6><p>node01执行以下命令连接redis客户端</p>
<pre><code class="hljs apache"><span class="hljs-attribute">cd</span> /weitrue/redis-<span class="hljs-number">6</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>
<span class="hljs-attribute">src</span>/redis-cli  -h node<span class="hljs-number">01</span> -c -p <span class="hljs-number">7001</span></code></pre>

<h5 id="redis集群管理"><a href="#redis集群管理" class="headerlink" title="redis集群管理"></a>redis集群管理</h5><p>添加一个新节点作为主节点</p>
<p>启动新节点的redis服务，然后添加到集群当中去</p>
<pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">1.创建文件夹</span>
mkdir -p /weitrue/install/redis-6.0.1/redisdata/7007
mkdir -p /weitrue/install/redis-6.0.1/redisdata/7008
mkdir -p /weitrue/install/redis-6.0.1/clusters/7007
mkdir -p /weitrue/install/redis-6.0.1/clusters/7008
<span class="hljs-meta">#</span><span class="bash">2.修改redis.conf</span>
vim /weitrue/install/redis-6.0.1/clusters/7007/redis.conf
vim /weitrue/install/redis-6.0.1/clusters/7008/redis.conf</code></pre>

<pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">启动服务</span>
src/redis-server clusters/7007/redis.conf
<span class="hljs-meta">#</span><span class="bash">添加服务</span>
src/redis-cli --cluster add-node 192.168.8.100:7007 192.168.8.100:7001
<span class="hljs-meta">#</span><span class="bash">解释:</span>
192.168.8.100:7007 #服务器ip:端口;
192.168.8.100:7001 #集群中任意一台ip:端口</code></pre>

<pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">查看信息</span>
src/redis-cli --cluster info 192.168.8.100:7001</code></pre>

<pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">检测集群</span>
src/redis-cli --cluster check 192.168.8.100:7007</code></pre>

<pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">重新分片</span>
<span class="hljs-meta">#</span><span class="bash">命令格式</span>
src/redis-cli --cluster reshard --from &lt;node-id&gt; --to &lt;node-id&gt; --slots &lt;number of slots&gt; --yes &lt;host&gt;:&lt;port&gt;
<span class="hljs-meta">#</span><span class="bash">实例:</span>
src/redis-cli --cluster reshard 192.168.8.100:7001
<span class="hljs-meta">#</span><span class="bash">解释:</span>
192.168.8.100:7001 #集群中任务一个节点
<span class="hljs-meta">#</span><span class="bash">下面代表需要输入参数的提示</span>
1.How many slots do you want to move (from 1 to 16384)?4096　　　　 
<span class="hljs-meta">#</span><span class="bash">拿出4096个<span class="hljs-built_in">hash</span> 槽</span>
2.What is the receiving node ID? c5e0da48f335c46a2ec199faa99b830f537dd8a0 
<span class="hljs-meta">#</span><span class="bash">7007服务所在的节点的id值</span>
3.Source node #1: all 
<span class="hljs-meta">#</span><span class="bash">从当前所有master服务器获取<span class="hljs-built_in">hash</span>槽</span>
4.Do you want to proceed with the proposed reshard plan (yes/no)?yes　
<span class="hljs-meta">#</span><span class="bash"> 同意以上配置</span></code></pre>

<pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">查看集群信息</span>
src/redis-cli --cluster info 192.168.8.100:7001</code></pre>

<pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">添加slave角色到集群里</span>
<span class="hljs-meta">#</span><span class="bash">启动7008服务</span>
src/redis-server clusters/7008/redis.conf
<span class="hljs-meta">#</span><span class="bash">添加副本</span>
src/redis-cli --cluster add-node  --cluster-slave 192.168.8.100:7008 192.168.8.100:7001
<span class="hljs-meta">#</span><span class="bash">解释</span>
192.168.8.100:7008 #从服务器ip:端口;
192.168.8.100:7001 #集群中任意一台ip:端口</code></pre>

<pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">删除某一节点redis服务</span>
src/redis-cli --cluster del-node 192.168.8.100:7008 4bf2fc80931392c248a7ae359bd1bf540872c688</code></pre>

<h3 id="Redis击穿、穿透、雪崩、预热"><a href="#Redis击穿、穿透、雪崩、预热" class="headerlink" title="Redis击穿、穿透、雪崩、预热"></a>Redis击穿、穿透、雪崩、预热</h3><h4 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h4><pre><code class="hljs makefile"><span class="hljs-section">问题:</span>
Redis服务器命中率随时间逐步降低</code></pre>

<pre><code class="hljs gauss">缓存穿透的概念很简单，用户想要查询一个数据，发现redis内存数据库没有，也就是缓存没有命中，于是向持久层数据库查询。发现也没有，于是本次查询失败。当用户很多的时候，缓存都没有命中，于是都去请求了持久层数据库。这会给持久层数据库造成很大的压力，这时候就相当于出现了缓存穿透。

这里需要注意和缓存击穿的区别，缓存击穿，是指一个<span class="hljs-built_in">key</span>非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个<span class="hljs-built_in">key</span>在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞。

为了避免缓存穿透其实有很多种解决方案。下面介绍几种。

<span class="hljs-number">1.1</span> 白名单策略:</code></pre>

<pre><code class="hljs angelscript"><span class="hljs-number">1.1</span><span class="hljs-number">.1</span>
  将id放在bitmaps中,id作为bitmaps的offset
<span class="hljs-number">1.1</span><span class="hljs-number">.2</span> 布隆过滤器:
那这个布隆过滤器是如何解决redis中的缓存穿透呢？很简单首先也是对所有可能查询的参数以hash形式存储，当用户想要查询的时候，使用布隆过滤器发现不在集合中，就直接丢弃，不再对持久层查询。</code></pre>

<p>1.2 缓存空对象</p>
<pre><code class="hljs erlang">当存储层不命中后，即使返回的空对象也将其缓存起来，同时会设置一个过期时间，之后再访问这个数据将会从缓存中获取，保护了后端数据源；注意设置key的过期时间.</code></pre>

<p><img src="/images/redis/1589366209279.png" srcset="/img/loading.gif"></p>
<pre><code class="hljs plain">但是这种方法会存在一个问题：

即使对空值设置了过期时间，还是会存在缓存层和存储层的数据会有一段时间窗口的不一致，这对于需要保持一致性的业务会有影响。</code></pre>

<p>1.3 实施监控</p>
<pre><code class="hljs erlang">监控命中率(业务正常范围时,通常会有一个波动值),根据不同的情况,设置黑名单.</code></pre>

<h4 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h4><pre><code class="hljs angelscript">缓存雪崩是指，缓存层出现了错误，不能正常工作了。于是所有的请求都会达到存储层，存储层的调用量会暴增，造成存储层也会挂掉的情况。经常出现的情况是<span class="hljs-number">408</span>,<span class="hljs-number">500</span>的错误页面.</code></pre>

<p><img src="/images/redis/1589366273686.png" srcset="/img/loading.gif"></p>
<pre><code class="hljs lsl"><span class="hljs-number">2</span>、解决方案

（<span class="hljs-number">1</span>）redis高可用

这个思想的含义是，既然redis有可能挂掉，那我多增设几台redis，这样一台挂掉之后其他的还可以继续工作，其实就是搭建的集群。

（<span class="hljs-number">2</span>）限流降级

这个解决方案的思想是，在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个<span class="hljs-type">key</span>只允许一个线程查询数据和写缓存，其他线程等待。

（<span class="hljs-number">3</span>）数据预热

 在即将发生大并发访问前手动触发加载缓存不同的<span class="hljs-type">key</span>，设置不同的过期时间，让缓存失效的时间点尽量均匀。</code></pre>

<h4 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h4><pre><code class="hljs angelscript">  缓存击穿是在高并发的条件下读取缓存数据，多用户同时请求同一个缓存数据，如果缓存中没有这条数据，那么这些用户又会同时去数据库中查询这条数据，浪费了系统资源，有悖于缓存数据的初衷，严重的话可能会造成服务器宕机的风险。
  解决方案：
   <span class="hljs-number">1</span>）.使用同步锁 synchronized 关键字，修饰在获取缓存的方法里面，保证在多用户同时请求条件下，只有第一个进入的线程去判断是否要查询数据库并存入缓存，其他线程只需在第一个线程结束后，从缓存中读取数据即可，无需再查询数据库。
上面是对缓存穿透的再次优化，加入线程同步锁 以及 双重检查锁.
双重检查锁：<span class="hljs-number">1.</span>避免当缓存数据没有失效时，其他线程排队等待。
          <span class="hljs-number">2.</span>当第一个线程从数据库中获取到数据并存入缓存中时，其他线程直接从缓存获取数据即可。
<span class="hljs-number">2</span>)不设置缓存时间，由后台创建定时任务去维护这部分缓存数据。这种方法请求时直接从缓存中获取数据，无需再判断是否从数据库中获取，定时任务也可在请求较少的时间段分批更新缓存数据。
    当然代码量、代码复杂度增大，分批更新代表需要多个定时任务去维护缓存数据，同时更新有可能会造成缓存雪崩的情况。</code></pre>

<h4 id="数据预热"><a href="#数据预热" class="headerlink" title="数据预热"></a>数据预热</h4><pre><code>缓存预热:
  提前将相关的缓存数据直接加载到缓存系统,避免用户在请求的时候,先查询数据库,然后再将数据缓存的问题.

问题:
 1.主从之间数据吞吐量大
 2.数据同步操作频度高
方案:
 1.统计访问频度较高的热点数据,比如直接写个缓存刷新页面，上线时手工操作下
 2.数据量不大，可以在项目启动的时候自动进行加载
 3.定时刷新缓存</code></pre>

            </article>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/Datebase/">Datebase</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Datebase/">Datebase</a>
                    
                      <a class="hover-with-bg" href="/tags/Redis/">Redis</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <div class="post-prev col-6">
                    
                    
                      <a href="/2021/03/30/bloom-filter/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">【】bloom-filter</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </div>
                  <div class="post-next col-6">
                    
                    
                      <a href="/2021/03/21/mysql/">
                        <span class="hidden-mobile">【MySQL】学习笔记</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </div>
                </div>
              
            </div>

            
          </div>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Wei</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/weitrue" target="_blank" rel="nofollow noopener">
        <span>Trable</span></a>
    </div>
    

    
  <!-- 备案信息 -->
  <div class="beian">
    <a href="http://beian.miit.gov.cn/" target="_blank"
       rel="nofollow noopener">杭ICP证123456号</a>
    
      <a
        href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=12345678"
        rel="nofollow noopener"
        class="beian-police"
        target="_blank"
      >
        <span class="beian-police-sep">&nbsp;|&nbsp;</span>
        
          <img src="/images/img/police_beian.png" srcset="/img/loading.gif" alt="police-icon" />
        
        <span>杭公网安备12345678号</span>
      </a>
     
  </div>


    
     <div>
  	<span id="timeDate">载入天数...</span>
 	<span id="times">载入时分秒...</span>
 	<script>
          var now = new Date();
          function createtime(){
           var grt= new Date("02/14/2020 00:00:00");//此处修改你的建站时间或者网站上线时间
           now.setTime(now.getTime()+250);
           days = (now - grt ) / 1000 / 60 / 60 / 24;
           dnum = Math.floor(days);
           hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum);
           hnum = Math.floor(hours);
           if(String(hnum).length ==1 ){
                hnum = "0" + hnum;
           }
           minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
           mnum = Math.floor(minutes);
           if(String(mnum).length ==1 ){
                mnum = "0" + mnum;
           }
           seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
           snum = Math.round(seconds);
           if(String(snum).length ==1 ){
                snum = "0" + snum;
           }
           document.getElementById("timeDate").innerHTML = "本站安全运行&nbsp"+dnum+"&nbsp天";
           document.getElementById("times").innerHTML = hnum + "&nbsp小时&nbsp" + mnum + "&nbsp分&nbsp" + snum + "&nbsp秒";
          }
          setInterval("createtime()",250);
       </script>
    </div>
 </div>
 </footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/main.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>







  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: 'article.markdown-body',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "【Redis】学习笔记&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>







  
  
    <script type="text/javascript">
      //定义获取词语下标
      var a_idx = 0;
      jQuery(document).ready(function ($) {
        //点击body时触发事件
        $("body").click(function (e) {
          //需要显示的词语
          var a = new Array("富强", "民主", "文明", "和谐", "自由", "平等", "公正", "法治", "爱国", "敬业", "诚信", "友善");
          //设置词语给span标签
          var $i = $("<span/>").text(a[a_idx]);
          //下标等于原来下标+1  余 词语总数
          a_idx = (a_idx + 1) % a.length;
          //获取鼠标指针的位置，分别相对于文档的左和右边缘。
          //获取x和y的指针坐标
          var x = e.pageX, y = e.pageY;
          //在鼠标的指针的位置给$i定义的span标签添加css样式
          $i.css({
            "z-index": 999,
            "top": y - 20,
            "left": x,
            "position": "absolute",
            "font-weight": "bold",
            "color": rand_color()
          });
          // 随机颜色
          function rand_color() {
            return "rgb(" + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + ")"
          }
          //在body添加这个标签
          $("body").append($i);
          //animate() 方法执行 CSS 属性集的自定义动画。
          //该方法通过CSS样式将元素从一个状态改变为另一个状态。CSS属性值是逐渐改变的，这样就可以创建动画效果。
          //详情请看http://www.w3school.com.cn/jquery/effect_animate.asp
          $i.animate({
            //将原来的位置向上移动180
            "top": y - 180,
            "opacity": 0
            //1500动画的速度
          }, 1500, function () {
            //时间到了自动删除
            $i.remove();
          });
        });
      })
      ;
    </script>
  











  

  

  

  

  

  





<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
