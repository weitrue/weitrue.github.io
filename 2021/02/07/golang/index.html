<!DOCTYPE html>
<html lang="zh-CN">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/images/img/logo.png">
  <link rel="icon" type="image/png" href="/img/logo.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="我们相信，未来可期！">
  <meta name="author" content="嗯，我们是对的">
  <meta name="keywords" content="">
  <title>【Go】学习笔记 - weitrable</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/github-gist.min.css" />
  

  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_yg9cfy8wd6.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script  src="/js/utils.js" ></script>
<meta name="generator" content="Hexo 5.2.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>WeiTrable</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/book/">
                <i class="iconfont icon-books"></i>
                电子书
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background" parallax=true
         style="background: url('/images/img/banner.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
              
  <div class="mt-3 post-meta">
    <i class="iconfont icon-date-fill" aria-hidden="true"></i>
    <time datetime="2021-02-07 09:55">
      2021年2月7日 上午
    </time>
  </div>


<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      9.9k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      150
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <div class="post-content mx-auto" id="post">
            
            <article class="markdown-body">
              <blockquote>
<p> “Go has indeed become the language of cloud infrastructure” - Rob Pike interview<a id="more"></a></p>
</blockquote>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><h4 id="var与"><a href="#var与" class="headerlink" title="var与:="></a>var与:=</h4><ul>
<li>:=方式较为简洁，但只能在函数内使用该方式，var方式没有这个限制，var方式定义在汉书外的变量属于包内部的变量</li>
<li>函数中以:=方式定义变量为主</li>
</ul>
<h4 id="内建变量类型"><a href="#内建变量类型" class="headerlink" title="内建变量类型"></a>内建变量类型</h4><ul>
<li>bool,string</li>
<li>(u)int, (u)int8, (u)int16, (u)int32, (u)int, uintptr</li>
<li>byte, rune</li>
<li>float32, float64, complex64, complex128</li>
<li>变量类型写在变量名之后</li>
<li>编译器可推测变量类型</li>
<li>没有char, 只有rune</li>
<li>原生支持复数类型</li>
</ul>
<pre><code class="hljs golang"><span class="hljs-keyword">package</span> main

<span class="hljs-keyword">import</span> (
	<span class="hljs-string">&quot;fmt&quot;</span>
	<span class="hljs-string">&quot;math&quot;</span>
	<span class="hljs-string">&quot;math/cmplx&quot;</span>
)

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">euler</span><span class="hljs-params">()</span></span>  &#123;
	<span class="hljs-comment">// 欧拉公式 e^(i*Pi) + 1 = 0</span>
	fmt.Println(cmplx.Exp(<span class="hljs-number">1i</span> * math.Pi) + <span class="hljs-number">1</span>)
  fmt.Println(cmplx.Pow(math.E, <span class="hljs-number">1i</span> * math.Pi) + <span class="hljs-number">1</span>)
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;
	euler()
&#125;

<span class="hljs-comment">// 打印内容</span>
(<span class="hljs-number">0</span>+<span class="hljs-number">1.2246467991473515e-16i</span>)
(<span class="hljs-number">0</span>+<span class="hljs-number">1.2246467991473515e-16i</span>)</code></pre>

<h4 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h4><p>go语言需要开发时强制类型转换，不会自动隐式转换</p>
<pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">triangle</span><span class="hljs-params">()</span></span>  &#123;
	a, b := <span class="hljs-number">3</span>, <span class="hljs-number">4</span>
	<span class="hljs-keyword">var</span> c <span class="hljs-keyword">int</span> 
	c = math.Sqrt(a*a + b*b)                    <span class="hljs-comment">// 会在编译前idea便提示报错</span>
  c = <span class="hljs-keyword">int</span>(math.Sqrt(<span class="hljs-keyword">float64</span>(a * a + b * b)))  <span class="hljs-comment">// 正确写法</span>
	fmt.Println(c)
&#125;</code></pre>

<p>常量未声明类型，其类型是不确定的（数值可以作各种类型使用）</p>
<pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">consts</span><span class="hljs-params">()</span></span>  &#123;
	<span class="hljs-comment">// 强制类型转换</span>
	<span class="hljs-keyword">const</span> a, b = <span class="hljs-number">3</span>, <span class="hljs-number">4</span>
	<span class="hljs-keyword">var</span> c <span class="hljs-keyword">int</span>
	c = <span class="hljs-keyword">int</span>(math.Sqrt(a * a + b * b))    <span class="hljs-comment">// a * a + b * b 部分可以不用加上强制类型转换</span>
	fmt.Println(c)
&#125;</code></pre>

<p>可以利用常量申明枚举类型</p>
<pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">enums</span><span class="hljs-params">()</span></span>  &#123;
	<span class="hljs-keyword">const</span> (
		golang = <span class="hljs-literal">iota</span>
		_
		java
		python
		)
	fmt.Println(golang, java, python)
&#125;

<span class="hljs-comment">// 输出</span>
<span class="hljs-number">0</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span></code></pre>

<p>可以以<code>iota</code>为基础，生成一系列枚举数</p>
<pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">enums</span><span class="hljs-params">()</span></span>  &#123;
	<span class="hljs-keyword">const</span> (
		b = <span class="hljs-number">1</span> &lt;&lt; (<span class="hljs-number">10</span> * <span class="hljs-literal">iota</span>)
		kb
		mb
		gb
		tb
	)
	fmt.Println(b, kb, mb, gb, tb)
&#125;

<span class="hljs-comment">// 输出</span>
<span class="hljs-number">1</span> <span class="hljs-number">1024</span> <span class="hljs-number">1048576</span> <span class="hljs-number">1073741824</span> <span class="hljs-number">1099511627776</span></code></pre>

<p><a target="_blank" rel="noopener" href="https://github.com/weitrue/note/blob/master/go/variable.go">https://github.com/weitrue/note/blob/master/go/variable.go</a></p>
<h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p>指针不能运算</p>
<pre><code class="hljs go"><span class="hljs-keyword">package</span> main

<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span>

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;
	<span class="hljs-keyword">var</span> a <span class="hljs-keyword">int</span> = <span class="hljs-number">2</span>
	<span class="hljs-keyword">var</span> pa *<span class="hljs-keyword">int</span> = &amp;a
	*pa = <span class="hljs-number">3</span>
	fmt.Println(a)
&#125;

<span class="hljs-comment">// 运行结果</span>
<span class="hljs-number">3</span></code></pre>

<p>参数传递—只有<em>值传递</em>一种方式</p>
<pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">swapV</span><span class="hljs-params">(a, b <span class="hljs-keyword">int</span>)</span></span> &#123;
	b, a = a, b
	fmt.Println(<span class="hljs-string">&quot;in &quot;</span>, a, b, &amp;a, &amp;b)
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">swapRN</span><span class="hljs-params">(a, b *<span class="hljs-keyword">int</span>)</span></span> &#123;
	<span class="hljs-comment">// 局部变量交换值（地址）</span>
	b, a = a, b
	fmt.Println(<span class="hljs-string">&quot;in &quot;</span>, a, b, *a, *b)
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">swapR</span><span class="hljs-params">(a, b *<span class="hljs-keyword">int</span>)</span></span> &#123;
	<span class="hljs-comment">// 交换变量值（地址）指向的值</span>
	*b, *a = *a, *b
	fmt.Println(<span class="hljs-string">&quot;in &quot;</span>, a, b, *a, *b)
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">pointerSwap</span><span class="hljs-params">()</span></span>  &#123;
	a, b := <span class="hljs-number">3</span>, <span class="hljs-number">4</span>
	swapV(a, b)
	fmt.Println(<span class="hljs-string">&quot;out&quot;</span>, a, b, &amp;a, &amp;b)

	a, b = <span class="hljs-number">3</span>, <span class="hljs-number">4</span>
	swapRN(&amp;a, &amp;b)
	fmt.Println(<span class="hljs-string">&quot;out&quot;</span>, a, b, &amp;a, &amp;b)

	a, b = <span class="hljs-number">3</span>, <span class="hljs-number">4</span>
	swapR(&amp;a, &amp;b)
	fmt.Println(<span class="hljs-string">&quot;out&quot;</span>, a, b, &amp;a, &amp;b)

&#125;

<span class="hljs-comment">// 输出</span>
in  <span class="hljs-number">4</span> <span class="hljs-number">3</span> <span class="hljs-number">0xc00001e0c8</span> <span class="hljs-number">0xc00001e0d0</span>
out <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">0xc00001e0b8</span> <span class="hljs-number">0xc00001e0c0</span>
in  <span class="hljs-number">0xc00001e0c0</span> <span class="hljs-number">0xc00001e0b8</span> <span class="hljs-number">4</span> <span class="hljs-number">3</span>
out <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">0xc00001e0b8</span> <span class="hljs-number">0xc00001e0c0</span>
in  <span class="hljs-number">0xc00001e0b8</span> <span class="hljs-number">0xc00001e0c0</span> <span class="hljs-number">4</span> <span class="hljs-number">3</span>
out <span class="hljs-number">4</span> <span class="hljs-number">3</span> <span class="hljs-number">0xc00001e0b8</span> <span class="hljs-number">0xc00001e0c0</span></code></pre>

<p><a target="_blank" rel="noopener" href="https://github.com/weitrue/note/blob/master/go/pointer.go">https://github.com/weitrue/note/blob/master/go/pointer.go</a></p>
<h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>Go 语言的数组有两种不同的创建方式</p>
<ul>
<li><p>一种是显式的指定数组大小</p>
<ul>
<li>变量的类型在编译进行到<strong>类型检查</strong>阶段就会被提取出来，随后使用 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/cmd/compile/internal/types.NewArray"><code>cmd/compile/internal/types.NewArray</code></a>创建包含数组大小的 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/cmd/compile/internal/types.Array"><code>cmd/compile/internal/types.Array</code></a> 结构体。</li>
</ul>
</li>
<li><p>一种是使用 <code>[...]T</code> 声明数组</p>
<ul>
<li>Go 语言编译器会在的 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/cmd/compile/internal/gc.typecheckcomplit"><code>cmd/compile/internal/gc.typecheckcomplit</code></a> 函数中对该数组的大小进行推导</li>
<li><code>[...]T</code> 这种初始化方式也只是 Go 语言为我们提供的一种语法糖，当我们不想计算数组中的元素个数时可以通过这种方法减少一些工作量</li>
</ul>
</li>
</ul>
<pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">define</span><span class="hljs-params">()</span></span>  &#123;
	<span class="hljs-keyword">var</span> arr1 [<span class="hljs-number">5</span>]<span class="hljs-keyword">int</span>
	arr2 := [<span class="hljs-number">3</span>]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>&#125;
	arr3 := [...]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>, <span class="hljs-number">10</span>&#125;

	<span class="hljs-keyword">var</span> grid [<span class="hljs-number">4</span>][<span class="hljs-number">5</span>]<span class="hljs-keyword">bool</span>
	fmt.Println(arr1, arr2, arr3)
	fmt.Println(grid)
&#125;

<span class="hljs-comment">// 输出</span>
[<span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span>] [<span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span>] [<span class="hljs-number">2</span> <span class="hljs-number">4</span> <span class="hljs-number">6</span> <span class="hljs-number">8</span> <span class="hljs-number">10</span>]
[[<span class="hljs-literal">false</span> <span class="hljs-literal">false</span> <span class="hljs-literal">false</span> <span class="hljs-literal">false</span> <span class="hljs-literal">false</span>] [<span class="hljs-literal">false</span> <span class="hljs-literal">false</span> <span class="hljs-literal">false</span> <span class="hljs-literal">false</span> <span class="hljs-literal">false</span>] [<span class="hljs-literal">false</span> <span class="hljs-literal">false</span> <span class="hljs-literal">false</span> <span class="hljs-literal">false</span> <span class="hljs-literal">false</span>] [<span class="hljs-literal">false</span> <span class="hljs-literal">false</span> <span class="hljs-literal">false</span> <span class="hljs-literal">false</span> <span class="hljs-literal">false</span>]]
</code></pre>

<p>[5]int和[10]int是不同类型</p>
<p>调用func f(arr [10]int)会<em>拷贝</em>数组</p>
<pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printArr</span><span class="hljs-params">(arr [5]<span class="hljs-keyword">int</span>)</span></span>  &#123;
	arr[<span class="hljs-number">0</span>] = <span class="hljs-number">100</span>
	<span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> arr &#123;
		fmt.Println(i, v)
	&#125;
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">arrTest</span><span class="hljs-params">()</span></span>  &#123;
	<span class="hljs-keyword">var</span> arr1 [<span class="hljs-number">5</span>]<span class="hljs-keyword">int</span>
	arr2 := [...]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>, <span class="hljs-number">10</span>&#125;
	fmt.Println()
	printArr(arr2)
	fmt.Println()
	<span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> arr1 &#123;
		fmt.Println(i, v)
	&#125;
&#125;

<span class="hljs-comment">// 输出</span>
<span class="hljs-number">0</span> <span class="hljs-number">100</span>
<span class="hljs-number">1</span> <span class="hljs-number">0</span>
<span class="hljs-number">2</span> <span class="hljs-number">0</span>
<span class="hljs-number">3</span> <span class="hljs-number">0</span>
<span class="hljs-number">4</span> <span class="hljs-number">0</span>

<span class="hljs-number">0</span> <span class="hljs-number">100</span>
<span class="hljs-number">1</span> <span class="hljs-number">4</span>
<span class="hljs-number">2</span> <span class="hljs-number">6</span>
<span class="hljs-number">3</span> <span class="hljs-number">8</span>
<span class="hljs-number">4</span> <span class="hljs-number">10</span>

<span class="hljs-number">0</span> <span class="hljs-number">0</span>
<span class="hljs-number">1</span> <span class="hljs-number">0</span>
<span class="hljs-number">2</span> <span class="hljs-number">0</span>
<span class="hljs-number">3</span> <span class="hljs-number">0</span>
<span class="hljs-number">4</span> <span class="hljs-number">0</span></code></pre>

<p>若要改变数组的值 需要传入数组的地址，因此go语言一般不使用数组</p>
<pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printArrR</span><span class="hljs-params">(arr *[5]<span class="hljs-keyword">int</span>)</span></span>  &#123;
	arr[<span class="hljs-number">0</span>] = <span class="hljs-number">100</span>
	<span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> arr &#123;
		fmt.Println(i, v)
	&#125;
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">arrTest</span><span class="hljs-params">()</span></span>  &#123;
	<span class="hljs-keyword">var</span> arr1 [<span class="hljs-number">5</span>]<span class="hljs-keyword">int</span>
	printArrR(&amp;arr1)
	fmt.Println()
	fmt.Println(arr1)
&#125;
<span class="hljs-comment">// 输出</span>
<span class="hljs-number">0</span> <span class="hljs-number">100</span>
<span class="hljs-number">1</span> <span class="hljs-number">0</span>
<span class="hljs-number">2</span> <span class="hljs-number">0</span>
<span class="hljs-number">3</span> <span class="hljs-number">0</span>
<span class="hljs-number">4</span> <span class="hljs-number">0</span>

[<span class="hljs-number">100</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span>]</code></pre>

<p><a target="_blank" rel="noopener" href="https://github.com/weitrue/note/blob/master/go/collections/array.go">https://github.com/weitrue/note/blob/master/go/collections/array.go</a></p>
<h4 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h4><ul>
<li><p>slice可以向后扩展，但不能向前扩展</p>
</li>
<li><p>s[i]不可超越len(s)，向后扩展不可以超越底层数组cap(s)</p>
</li>
</ul>
<pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">slice</span><span class="hljs-params">()</span></span> &#123;
	arr := [...]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>&#125;
	s1 := arr[<span class="hljs-number">2</span>: <span class="hljs-number">6</span>]
	fmt.Println(s1)
	s2 := s1[<span class="hljs-number">3</span>: <span class="hljs-number">5</span>]
	fmt.Println(s2)
  s3 := s1[<span class="hljs-number">3</span>:<span class="hljs-number">6</span>]
	fmt.Println(s3)
&#125;
<span class="hljs-comment">//输出</span>
[<span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span>]
[<span class="hljs-number">6</span> <span class="hljs-number">7</span>]
<span class="hljs-built_in">panic</span>: runtime error: slice bounds out of <span class="hljs-keyword">range</span> [:<span class="hljs-number">6</span>] with capacity <span class="hljs-number">5</span>

goroutine <span class="hljs-number">1</span> [running]:
main.sliceDefine()
        ~/Projects/golang/src/offer/note/slices.<span class="hljs-keyword">go</span>:<span class="hljs-number">20</span> +<span class="hljs-number">0x164</span>
main.main()
        ~/Projects/golang/src/offer/note/ab_test_func.<span class="hljs-keyword">go</span>:<span class="hljs-number">28</span> +<span class="hljs-number">0x20</span>
</code></pre>

<p><img src="/images/golang/slice.png" srcset="/img/loading.gif"></p>
<ul>
<li><p>向slice添加元素，如果超越cap，系统会自动分配更大的底层数组</p>
</li>
<li><p>由于值传递的原因，必须接收append的返回值<code>s=append(s, val)</code></p>
</li>
</ul>
<pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sliceAppend</span><span class="hljs-params">()</span></span> &#123;
	arr := [...]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>&#125;
	s1 := arr[<span class="hljs-number">2</span>: <span class="hljs-number">6</span>]
	fmt.Println(s1, <span class="hljs-built_in">cap</span>(s1), <span class="hljs-built_in">len</span>(s1))
	s2 := s1[<span class="hljs-number">3</span>: <span class="hljs-number">5</span>]
	fmt.Println(s2)
	s3 := <span class="hljs-built_in">append</span>(s2, <span class="hljs-number">10</span>)
	s4 := <span class="hljs-built_in">append</span>(s3, <span class="hljs-number">11</span>)
	s5 := <span class="hljs-built_in">append</span>(s4, <span class="hljs-number">12</span>)
	fmt.Println(<span class="hljs-string">&quot;s3, s4, s5=&quot;</span>, s3, s4, s5)
	fmt.Println(arr)
  
  s6 := <span class="hljs-built_in">append</span>(s1, <span class="hljs-number">10</span>)
	s7 := <span class="hljs-built_in">append</span>(s6, <span class="hljs-number">11</span>)
	s8 := <span class="hljs-built_in">append</span>(s7, <span class="hljs-number">12</span>)
	fmt.Println(<span class="hljs-string">&quot;s6, s7, s8=&quot;</span>, s6, s7, s8)
	fmt.Println(<span class="hljs-string">&quot;cap(s6), cap(s7), cap(s8) =&quot;</span>, <span class="hljs-built_in">cap</span>(s6), <span class="hljs-built_in">cap</span>(s7), <span class="hljs-built_in">cap</span>(s8))
	fmt.Println(arr)
&#125;
<span class="hljs-comment">// 输出</span>
[<span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span>] <span class="hljs-number">6</span> <span class="hljs-number">4</span>
[<span class="hljs-number">6</span> <span class="hljs-number">7</span>]
s3, s4, s5= [<span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">10</span>] [<span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">10</span> <span class="hljs-number">11</span>] [<span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">10</span> <span class="hljs-number">11</span> <span class="hljs-number">12</span>]
<span class="hljs-built_in">cap</span>(s3), <span class="hljs-built_in">cap</span>(s4), <span class="hljs-built_in">cap</span>(s5) = <span class="hljs-number">3</span> <span class="hljs-number">6</span> <span class="hljs-number">6</span>
[<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">10</span>]

s6, s7, s8= [<span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">10</span>] [<span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">10</span> <span class="hljs-number">11</span>] [<span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">10</span> <span class="hljs-number">11</span> <span class="hljs-number">12</span>]
<span class="hljs-built_in">cap</span>(s6), <span class="hljs-built_in">cap</span>(s7), <span class="hljs-built_in">cap</span>(s8) = <span class="hljs-number">6</span> <span class="hljs-number">6</span> <span class="hljs-number">12</span>
[<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">10</span> <span class="hljs-number">11</span>]
</code></pre>

<ul>
<li>Zero value for slice is nil</li>
</ul>
<pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sliceDefine</span><span class="hljs-params">()</span></span> &#123;
	<span class="hljs-keyword">var</span> s []<span class="hljs-keyword">int</span>
	<span class="hljs-keyword">for</span> i :=<span class="hljs-number">0</span>; i &lt;<span class="hljs-number">10</span>; i++ &#123;
		fmt.Printf(<span class="hljs-string">&quot;%v, cap(s) = %d, len(s) = %d\n&quot;</span>, s, <span class="hljs-built_in">cap</span>(s), <span class="hljs-built_in">len</span>(s))
		s = <span class="hljs-built_in">append</span>(s, <span class="hljs-number">2</span>*i + <span class="hljs-number">1</span>)
	&#125;

	s1 := []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;
	fmt.Printf(<span class="hljs-string">&quot;%v, cap(s1) = %d, len(s1) = %d\n&quot;</span>, s1, <span class="hljs-built_in">cap</span>(s1), <span class="hljs-built_in">len</span>(s1))

	s2 := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">8</span>)
	fmt.Printf(<span class="hljs-string">&quot;%v, cap(s2) = %d, len(s2) = %d\n&quot;</span>, s2, <span class="hljs-built_in">cap</span>(s2), <span class="hljs-built_in">len</span>(s2))

	s3 := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">8</span>, <span class="hljs-number">32</span>)
	fmt.Printf(<span class="hljs-string">&quot;%v, cap(s3) = %d, len(s3) = %d\n&quot;</span>, s3, <span class="hljs-built_in">cap</span>(s3), <span class="hljs-built_in">len</span>(s3))

	<span class="hljs-comment">// 拷贝</span>
	<span class="hljs-built_in">copy</span>(s2, s1)
	fmt.Printf(<span class="hljs-string">&quot;%v, cap(s2) = %d, len(s2) = %d\n&quot;</span>, s2, <span class="hljs-built_in">cap</span>(s2), <span class="hljs-built_in">len</span>(s2))

	<span class="hljs-comment">// 删除 没有内建函数，只能通过截取+append</span>
	s4 := <span class="hljs-built_in">append</span>(s2[:<span class="hljs-number">2</span>], s2[<span class="hljs-number">3</span>:]...)
	fmt.Printf(<span class="hljs-string">&quot;%v, cap(s4) = %d, len(s4) = %d\n&quot;</span>, s4, <span class="hljs-built_in">cap</span>(s4), <span class="hljs-built_in">len</span>(s4))
&#125;

<span class="hljs-comment">//输出</span>
[], <span class="hljs-built_in">cap</span>(s) = <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(s) = <span class="hljs-number">0</span>
[<span class="hljs-number">1</span>], <span class="hljs-built_in">cap</span>(s) = <span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(s) = <span class="hljs-number">1</span>
[<span class="hljs-number">1</span> <span class="hljs-number">3</span>], <span class="hljs-built_in">cap</span>(s) = <span class="hljs-number">2</span>, <span class="hljs-built_in">len</span>(s) = <span class="hljs-number">2</span>
[<span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span>], <span class="hljs-built_in">cap</span>(s) = <span class="hljs-number">4</span>, <span class="hljs-built_in">len</span>(s) = <span class="hljs-number">3</span>
[<span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span> <span class="hljs-number">7</span>], <span class="hljs-built_in">cap</span>(s) = <span class="hljs-number">4</span>, <span class="hljs-built_in">len</span>(s) = <span class="hljs-number">4</span>
[<span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span> <span class="hljs-number">7</span> <span class="hljs-number">9</span>], <span class="hljs-built_in">cap</span>(s) = <span class="hljs-number">8</span>, <span class="hljs-built_in">len</span>(s) = <span class="hljs-number">5</span>
[<span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span> <span class="hljs-number">7</span> <span class="hljs-number">9</span> <span class="hljs-number">11</span>], <span class="hljs-built_in">cap</span>(s) = <span class="hljs-number">8</span>, <span class="hljs-built_in">len</span>(s) = <span class="hljs-number">6</span>
[<span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span> <span class="hljs-number">7</span> <span class="hljs-number">9</span> <span class="hljs-number">11</span> <span class="hljs-number">13</span>], <span class="hljs-built_in">cap</span>(s) = <span class="hljs-number">8</span>, <span class="hljs-built_in">len</span>(s) = <span class="hljs-number">7</span>
[<span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span> <span class="hljs-number">7</span> <span class="hljs-number">9</span> <span class="hljs-number">11</span> <span class="hljs-number">13</span> <span class="hljs-number">15</span>], <span class="hljs-built_in">cap</span>(s) = <span class="hljs-number">8</span>, <span class="hljs-built_in">len</span>(s) = <span class="hljs-number">8</span>
[<span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span> <span class="hljs-number">7</span> <span class="hljs-number">9</span> <span class="hljs-number">11</span> <span class="hljs-number">13</span> <span class="hljs-number">15</span> <span class="hljs-number">17</span>], <span class="hljs-built_in">cap</span>(s) = <span class="hljs-number">16</span>, <span class="hljs-built_in">len</span>(s) = <span class="hljs-number">9</span>
[<span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span>], <span class="hljs-built_in">cap</span>(s1) = <span class="hljs-number">3</span>, <span class="hljs-built_in">len</span>(s1) = <span class="hljs-number">3</span>
[<span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span>], <span class="hljs-built_in">cap</span>(s2) = <span class="hljs-number">8</span>, <span class="hljs-built_in">len</span>(s2) = <span class="hljs-number">8</span>
[<span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span>], <span class="hljs-built_in">cap</span>(s3) = <span class="hljs-number">32</span>, <span class="hljs-built_in">len</span>(s3) = <span class="hljs-number">8</span>
[<span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span>], <span class="hljs-built_in">cap</span>(s2) = <span class="hljs-number">8</span>, <span class="hljs-built_in">len</span>(s2) = <span class="hljs-number">8</span>
[<span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span>], <span class="hljs-built_in">cap</span>(s4) = <span class="hljs-number">8</span>, <span class="hljs-built_in">len</span>(s4) = <span class="hljs-number">7</span></code></pre>

<p><a target="_blank" rel="noopener" href="https://github.com/weitrue/note/blob/master/go/collections/slices.go">https://github.com/weitrue/note/blob/master/go/collections/slices.go</a></p>
<h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><ul>
<li><p>创建<code>make(map[type]type)</code></p>
</li>
<li><p>key不存在时，获取value类型的初始值，需要<code>if value, ok := m[key]; ok &#123;...&#125;</code> 判断是否存在key</p>
</li>
<li><p>map使用哈希表，必须可以比较相等</p>
</li>
<li><p>除了slice, map,function的内建类型都可以作为map的key,Struct类型不包含上述字段时，也可作为key</p>
</li>
</ul>
<pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mapDefine</span><span class="hljs-params">()</span></span>  &#123;
	m := <span class="hljs-keyword">map</span>[<span class="hljs-keyword">int</span>]<span class="hljs-keyword">string</span>&#123;
		<span class="hljs-number">1</span>: <span class="hljs-string">&quot;aa&quot;</span>,
		<span class="hljs-number">2</span>: <span class="hljs-string">&quot;bb&quot;</span>,
	&#125;
	<span class="hljs-keyword">if</span> v, ok := m[<span class="hljs-number">3</span>]; ok &#123;
		fmt.Println(v)
	&#125; <span class="hljs-keyword">else</span> &#123;
		<span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;key not exists&quot;</span>)
	&#125;
&#125;

<span class="hljs-comment">//输出</span>
<span class="hljs-built_in">panic</span>: key not exists

goroutine <span class="hljs-number">1</span> [running]:
main.mapDefine()
        /Users/wangpeng/Projects/golang/src/offer/note/maps.<span class="hljs-keyword">go</span>:<span class="hljs-number">20</span> +<span class="hljs-number">0x1f6</span>
main.main()
        /Users/wangpeng/Projects/golang/src/offer/note/ab_test_func.<span class="hljs-keyword">go</span>:<span class="hljs-number">32</span> +<span class="hljs-number">0x20</span></code></pre>

<p><a target="_blank" rel="noopener" href="https://github.com/weitrue/note/blob/master/go/collections/maps.go">https://github.com/weitrue/note/blob/master/go/collections/maps.go</a></p>
<h4 id="Rune"><a href="#Rune" class="headerlink" title="Rune"></a>Rune</h4><p>字符串在UTF-8编码中，一个中文占三个字节，</p>
<pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">strByte</span><span class="hljs-params">(s <span class="hljs-keyword">string</span>)</span></span>  &#123;
	<span class="hljs-keyword">if</span> s == <span class="hljs-string">&quot;&quot;</span> &#123;
		s = <span class="hljs-string">&quot;yes,我喜欢你！&quot;</span>
	&#125;
	<span class="hljs-keyword">for</span> i, ch := <span class="hljs-keyword">range</span> []<span class="hljs-keyword">byte</span>(s) &#123;
		fmt.Printf(<span class="hljs-string">&quot;(%d, %X)&quot;</span>, i, ch)
	&#125;
	fmt.Println()
  <span class="hljs-keyword">for</span> i, ch := <span class="hljs-keyword">range</span> s &#123; <span class="hljs-comment">// ch is a rune 其实是将s进行utf-8解码，解码后的字符会转成unicode,然后放入rune中</span>
		fmt.Printf(<span class="hljs-string">&quot;(%d, %X)&quot;</span>, i, ch)
	&#125;
	fmt.Println()
  bytes := []<span class="hljs-keyword">byte</span>(s)
	<span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(bytes) &gt;<span class="hljs-number">0</span> &#123;
		ch, size := utf8.DecodeRune(bytes)
		bytes = bytes[size:]
		fmt.Printf(<span class="hljs-string">&quot;%c &quot;</span>, ch)
	&#125;
	fmt.Println()
	<span class="hljs-keyword">for</span> i, ch := <span class="hljs-keyword">range</span> []<span class="hljs-keyword">rune</span>(s) &#123;
		fmt.Printf(<span class="hljs-string">&quot;(%d, %X)&quot;</span>, i, ch)
	&#125;
&#125;

<span class="hljs-comment">// 输出</span>
(<span class="hljs-number">0</span>, <span class="hljs-number">79</span>)(<span class="hljs-number">1</span>, <span class="hljs-number">65</span>)(<span class="hljs-number">2</span>, <span class="hljs-number">73</span>)(<span class="hljs-number">3</span>, <span class="hljs-number">2</span>C)(<span class="hljs-number">4</span>, E6)(<span class="hljs-number">5</span>, <span class="hljs-number">88</span>)(<span class="hljs-number">6</span>, <span class="hljs-number">91</span>)(<span class="hljs-number">7</span>, E5)(<span class="hljs-number">8</span>, <span class="hljs-number">96</span>)(<span class="hljs-number">9</span>, <span class="hljs-number">9</span>C)(<span class="hljs-number">10</span>, E6)(<span class="hljs-number">11</span>, AC)(<span class="hljs-number">12</span>, A2)(<span class="hljs-number">13</span>, E4)(<span class="hljs-number">14</span>, BD)(<span class="hljs-number">15</span>, A0)(<span class="hljs-number">16</span>, EF)(<span class="hljs-number">17</span>, BC)(<span class="hljs-number">18</span>, <span class="hljs-number">81</span>)
(<span class="hljs-number">0</span>, <span class="hljs-number">79</span>)(<span class="hljs-number">1</span>, <span class="hljs-number">65</span>)(<span class="hljs-number">2</span>, <span class="hljs-number">73</span>)(<span class="hljs-number">3</span>, <span class="hljs-number">2</span>C)(<span class="hljs-number">4</span>, <span class="hljs-number">6211</span>)(<span class="hljs-number">7</span>, <span class="hljs-number">559</span>C)(<span class="hljs-number">10</span>, <span class="hljs-number">6</span>B22)(<span class="hljs-number">13</span>, <span class="hljs-number">4</span>F60)(<span class="hljs-number">16</span>, FF01)
y e s , 我 喜 欢 你 ！
(<span class="hljs-number">0</span>, <span class="hljs-number">79</span>)(<span class="hljs-number">1</span>, <span class="hljs-number">65</span>)(<span class="hljs-number">2</span>, <span class="hljs-number">73</span>)(<span class="hljs-number">3</span>, <span class="hljs-number">2</span>C)(<span class="hljs-number">4</span>, <span class="hljs-number">6211</span>)(<span class="hljs-number">5</span>, <span class="hljs-number">559</span>C)(<span class="hljs-number">6</span>, <span class="hljs-number">6</span>B22)(<span class="hljs-number">7</span>, <span class="hljs-number">4</span>F60)(<span class="hljs-number">8</span>, FF01)
</code></pre>

<p>因此在需要使用rune</p>
<pre><code class="hljs go"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * Version: 1.0.0</span>
<span class="hljs-comment"> * Description: 获取字符串中不重复字串最大长度</span>
<span class="hljs-comment"> **/</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxNoRepeated</span><span class="hljs-params">(s <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">int</span></span> &#123;
  <span class="hljs-comment">// 仅支持英文字符</span>
	<span class="hljs-comment">// 字符下标映射</span>
  chNotRepeatIndex := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">byte</span>] <span class="hljs-keyword">int</span>)
	<span class="hljs-comment">// 最长串起始位置</span>
  start := <span class="hljs-number">0</span>
  <span class="hljs-comment">// 最长串长度</span>
	maxLength := <span class="hljs-number">0</span>
	 <span class="hljs-keyword">for</span> i, ch := <span class="hljs-keyword">range</span> []<span class="hljs-keyword">byte</span>(s) &#123;
	 	<span class="hljs-keyword">if</span> lastI, ok := chNotRepeatIndex[ch]; ok &amp;&amp; lastI &gt;= start &#123;
	 		start = lastI + <span class="hljs-number">1</span>
		&#125;
		<span class="hljs-keyword">if</span> i - start + <span class="hljs-number">1</span> &gt; maxLength &#123;
			maxLength = i - start + <span class="hljs-number">1</span>
		&#125;
		chNotRepeatIndex[ch] = i
	 &#125;
	 <span class="hljs-keyword">return</span> maxLength
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxNoRepeatedChn</span><span class="hljs-params">(s <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">int</span></span> &#123;
  <span class="hljs-comment">// 通过rune</span>
	chNotRepeatIndex := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">rune</span>] <span class="hljs-keyword">int</span>)
	start := <span class="hljs-number">0</span>
	maxLength := <span class="hljs-number">0</span>
	<span class="hljs-keyword">for</span> i, ch := <span class="hljs-keyword">range</span> []<span class="hljs-keyword">rune</span>(s) &#123;
		<span class="hljs-keyword">if</span> lastI, ok := chNotRepeatIndex[ch]; ok &amp;&amp; lastI &gt;= start &#123;
			start = lastI + <span class="hljs-number">1</span>
		&#125;
		<span class="hljs-keyword">if</span> i - start + <span class="hljs-number">1</span> &gt; maxLength &#123;
			maxLength = i - start + <span class="hljs-number">1</span>
		&#125;
		chNotRepeatIndex[ch] = i
	&#125;
	<span class="hljs-keyword">return</span> maxLength
&#125;</code></pre>

<p><a target="_blank" rel="noopener" href="https://github.com/weitrue/note/blob/master/go/collections/strings.go">https://github.com/weitrue/note/blob/master/go/collections/strings.go</a></p>
<h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><p>仅<em>支持封装</em>，不支持继承和多态</p>
<pre><code class="hljs go"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span>

<span class="hljs-keyword">type</span> Node <span class="hljs-keyword">struct</span> &#123;
	Value       <span class="hljs-keyword">int</span>
	Left, Right *Node
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(node Node)</span> <span class="hljs-title">Print</span><span class="hljs-params">()</span></span> &#123;
	fmt.Print(node.Value, <span class="hljs-string">&quot; &quot;</span>)
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(node *Node)</span> <span class="hljs-title">SetValue</span><span class="hljs-params">(value <span class="hljs-keyword">int</span>)</span></span> &#123;
  <span class="hljs-comment">// 接收者使用指针才可以改变结构内容</span>
	<span class="hljs-keyword">if</span> node == <span class="hljs-literal">nil</span> &#123;
		fmt.Println(<span class="hljs-string">&quot;Setting Value to nil node. Ignored.&quot;</span>)
		<span class="hljs-keyword">return</span>
	&#125;
	node.Value = value
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(node Node)</span> <span class="hljs-title">SetValueNotUpdate</span><span class="hljs-params">(value <span class="hljs-keyword">int</span>)</span></span> &#123;
  <span class="hljs-comment">// 值传递 node内容无法改变</span>
	<span class="hljs-keyword">if</span> &amp;node == <span class="hljs-literal">nil</span> &#123;
		fmt.Println(<span class="hljs-string">&quot;Setting Value to nil node. Ignored.&quot;</span>)
		<span class="hljs-keyword">return</span>
	&#125;
	node.Value = value
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">CreateNode</span><span class="hljs-params">(value <span class="hljs-keyword">int</span>)</span> *<span class="hljs-title">Node</span></span> &#123;
  <span class="hljs-comment">// 返回局部变量地址，这样变量会在堆中声明，可以传到外部</span>
	<span class="hljs-keyword">return</span> &amp;Node&#123;Value: value&#125;
&#125;</code></pre>

<p>方法有接收者（值/指针接收者），需要改变内容必须使用指针接收者，结构体过大考虑用指针接收者</p>
<pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;
  node := Node&#123;&#125;
	node.Print()
	node.SetValueNotUpdate(<span class="hljs-number">10</span>)
	node.Print()
	node.SetValue(<span class="hljs-number">10</span>)
	node.Print()
&#125;

<span class="hljs-comment">// 输出</span>
<span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">10</span></code></pre>

<p>nil也可以调用方法</p>
<pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;
  <span class="hljs-keyword">var</span> pNode *Node
	pNode.SetValue(<span class="hljs-number">30</span>)
&#125;

<span class="hljs-comment">// 输出</span>
Setting Value to <span class="hljs-literal">nil</span> node. Ignored.</code></pre>

<pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;
  <span class="hljs-keyword">var</span> pNode *Node
	pNode.SetValueNotUpdate(<span class="hljs-number">20</span>)
&#125;

<span class="hljs-comment">// 输出</span>
<span class="hljs-built_in">panic</span>: runtime error: invalid memory address or <span class="hljs-literal">nil</span> pointer dereference
[signal SIGSEGV: segmentation violation code=<span class="hljs-number">0x1</span> addr=<span class="hljs-number">0x0</span> pc=<span class="hljs-number">0x109d0af</span>]

goroutine <span class="hljs-number">1</span> [running]:
main.main()
        ～/Projects/golang/src/offer/note/ab_test_func.<span class="hljs-keyword">go</span>:<span class="hljs-number">50</span> +<span class="hljs-number">0x1f</span>
</code></pre>

<p><a target="_blank" rel="noopener" href="https://github.com/weitrue/note/blob/master/go/object/tree.go">https://github.com/weitrue/note/blob/master/go/object/tree.go</a></p>
<h4 id="封装与包"><a href="#封装与包" class="headerlink" title="封装与包"></a>封装与包</h4><p>首字母大写:public，首字母小写:private</p>
<p>为结构体定义的方法需要放在一个包下（可以是不同的文件）</p>
<p>扩充系统类型或者自定义类型方式：定义别名和使用组合</p>
<pre><code class="hljs go"><span class="hljs-keyword">type</span> Queue []<span class="hljs-keyword">int</span>

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(q *Queue)</span><span class="hljs-title">Push</span><span class="hljs-params">(val <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">error</span></span> &#123;
	*q = <span class="hljs-built_in">append</span>(*q, val)
	<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(q *Queue)</span><span class="hljs-title">Pop</span><span class="hljs-params">()</span> <span class="hljs-params">(<span class="hljs-keyword">int</span>,<span class="hljs-keyword">bool</span>)</span></span> &#123;
	<span class="hljs-keyword">if</span> q.IsEmpty() &#123;
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>, <span class="hljs-literal">false</span>
	&#125;
	head := (*q)[<span class="hljs-number">0</span>]
	*q = (*q)[<span class="hljs-number">1</span>:]
	<span class="hljs-keyword">return</span> head, <span class="hljs-literal">true</span>
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(q *Queue)</span><span class="hljs-title">IsEmpty</span><span class="hljs-params">()</span> <span class="hljs-title">bool</span></span> &#123;
	<span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(*q) == <span class="hljs-number">0</span>
&#125;</code></pre>

<pre><code class="hljs go"><span class="hljs-keyword">type</span> Node <span class="hljs-keyword">struct</span> &#123;
	Value       <span class="hljs-keyword">int</span>
	Left, Right *Node
&#125;

<span class="hljs-keyword">type</span> MyNode <span class="hljs-keyword">struct</span> &#123;
	node *Node
&#125;</code></pre>

<p><a target="_blank" rel="noopener" href="https://github.com/weitrue/note/blob/master/go/object/queue.go">https://github.com/weitrue/note/blob/master/go/object/queue.go</a></p>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><h4 id="鸭子类型"><a href="#鸭子类型" class="headerlink" title="鸭子类型"></a>鸭子类型</h4><h5 id="Duck-Typing"><a href="#Duck-Typing" class="headerlink" title="Duck Typing"></a>Duck Typing</h5><p>接口由使用者定义</p>
<p>​    Python的在运行时才能知道被调用的对象是否实现某个方法</p>
<p>​    Java中编译前，调用的对象就必须实现接口所有方法</p>
<p>接口变量自带指针（参数传递也是值传递），因此几乎不需要使用接口指针    </p>
<p><img src="/images/golang/interface.png" srcset="/img/loading.gif"></p>
<pre><code class="hljs go"><span class="hljs-comment">// offer/note/interfaces/mock/duck.go</span>
<span class="hljs-keyword">package</span> mock

<span class="hljs-keyword">type</span> Duck <span class="hljs-keyword">struct</span> &#123;
	Name <span class="hljs-keyword">string</span>
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d *Duck)</span> <span class="hljs-title">GetName</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span> &#123;
  <span class="hljs-comment">// 实现者没有指明实现了哪个接口</span>
	<span class="hljs-keyword">if</span> d.Name != <span class="hljs-string">&quot;&quot;</span> &#123;
		<span class="hljs-keyword">return</span> d.Name
	&#125; <span class="hljs-keyword">else</span> &#123;
		<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;这是一个鸭子！&quot;</span>
	&#125;
&#125;

<span class="hljs-comment">// offer/note/interfaces/duckI.go</span>
<span class="hljs-keyword">package</span> interfaces

<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span>

<span class="hljs-keyword">type</span> DuckI <span class="hljs-keyword">interface</span> &#123;
  <span class="hljs-comment">// 使用接口者 定义方法</span>
	GetName() <span class="hljs-keyword">string</span>
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">FindDuck</span><span class="hljs-params">(d DuckI)</span></span>  &#123; <span class="hljs-comment">// 接口变量自带指针</span>
	name := d.GetName()
	fmt.Println(name)
&#125;

<span class="hljs-comment">// offer/note/main.go</span>
<span class="hljs-keyword">package</span> main

<span class="hljs-keyword">import</span> (
	<span class="hljs-string">&quot;offer/note/interfaces&quot;</span>
	<span class="hljs-string">&quot;offer/note/interfaces/mock&quot;</span>
)

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;
  interfaces.FindDuck(&amp;mock.Duck&#123;&#125;)
  interfaces.FindDuck(&amp;mock.Duck&#123;Name:<span class="hljs-string">&quot;这是一只假鸭子&quot;</span>&#125;)
&#125;


<span class="hljs-comment">// 输出</span>
这是一个鸭子！
这是一只假鸭子</code></pre>

<h5 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h5><pre><code class="hljs go"><span class="hljs-keyword">type</span> MemberRights <span class="hljs-keyword">interface</span> &#123;
 Information () <span class="hljs-keyword">string</span>
&#125;

<span class="hljs-keyword">type</span> BronzeMember <span class="hljs-keyword">struct</span> &#123;
 Discount <span class="hljs-keyword">uint8</span>
&#125;

<span class="hljs-keyword">type</span> SilverMember <span class="hljs-keyword">struct</span> &#123;
 Discount <span class="hljs-keyword">uint8</span>
&#125;

<span class="hljs-keyword">type</span> GoldMember <span class="hljs-keyword">struct</span> &#123;
 Discount <span class="hljs-keyword">uint8</span>
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b *BronzeMember)</span> <span class="hljs-title">Information</span> <span class="hljs-params">()</span> <span class="hljs-title">string</span></span> &#123;
 <span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;Discount:%d&quot;</span>, b.Discount)
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *SilverMember)</span> <span class="hljs-title">Information</span> <span class="hljs-params">()</span> <span class="hljs-title">string</span></span> &#123;
 <span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;Discount:%d&quot;</span>, s.Discount)
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(g *GoldMember)</span> <span class="hljs-title">Information</span> <span class="hljs-params">()</span> <span class="hljs-title">string</span></span> &#123;
 <span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;Discount:%d&quot;</span>, g.Discount)
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Price</span> <span class="hljs-params">(m MemberRights)</span></span> &#123;
 fmt.Println(m.Information())
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span></span> &#123;
 b := &amp;BronzeMember&#123;Discount: <span class="hljs-number">9</span>&#125;
 Price(b)
 s := &amp;SilverMember&#123;<span class="hljs-number">8</span>&#125;
 Price(s)
 g := <span class="hljs-built_in">new</span>(GoldMember)
 g.Discount = <span class="hljs-number">7</span>
 Price(g)
&#125;</code></pre>

<h4 id="任何类型"><a href="#任何类型" class="headerlink" title="任何类型"></a>任何类型</h4><p><code>interface&#123;&#125;</code></p>
<pre><code class="hljs go"><span class="hljs-keyword">type</span> Queue []<span class="hljs-keyword">interface</span>&#123;&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(q *Queue)</span><span class="hljs-title">Push</span><span class="hljs-params">(val <span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">error</span></span> &#123;
	*q = <span class="hljs-built_in">append</span>(*q, val)
	<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(q *Queue)</span><span class="hljs-title">Pop</span><span class="hljs-params">()</span> <span class="hljs-params">(<span class="hljs-keyword">interface</span>&#123;&#125;,<span class="hljs-keyword">bool</span>)</span></span> &#123;
	<span class="hljs-keyword">if</span> q.IsEmpty() &#123;
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>, <span class="hljs-literal">false</span>
	&#125;
	head := (*q)[<span class="hljs-number">0</span>]
	*q = (*q)[<span class="hljs-number">1</span>:]
	<span class="hljs-keyword">return</span> head, <span class="hljs-literal">true</span>
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(q *Queue)</span><span class="hljs-title">IsEmpty</span><span class="hljs-params">()</span> <span class="hljs-title">bool</span></span> &#123;
	<span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(*q) == <span class="hljs-number">0</span>
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;
  q := interfaces.Queue&#123;&#125;
	_ = q.Push(<span class="hljs-string">&quot;asd&quot;</span>)
	_ = q.Push(<span class="hljs-number">123</span>)
	<span class="hljs-keyword">if</span> v, ok := q.Pop(); ok &#123;
		fmt.Println(v)
	&#125;
	<span class="hljs-keyword">if</span> v, ok := q.Pop(); ok &#123;
		fmt.Println(v)
	&#125;
&#125;

<span class="hljs-comment">// 输出</span>
asd
<span class="hljs-number">123</span></code></pre>

<h4 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h4><pre><code class="hljs go"><span class="hljs-comment">// offer/note/interfaces/animals.go</span>
<span class="hljs-keyword">package</span> animal

<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span>

<span class="hljs-keyword">type</span> AnimalsI <span class="hljs-keyword">interface</span> &#123;
	DuckI
	BehaviorI
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">DuckBehavior</span><span class="hljs-params">(a AnimalsI)</span></span>  &#123;
	name := a.GetName()
	dark := a.Shout(<span class="hljs-string">&quot;呱呱乱叫&quot;</span>)
	fmt.Println(name, dark)
  fmt.Println(a.String())
&#125;


<span class="hljs-comment">// offer/note/interfaces/behaviorI.go</span>
<span class="hljs-keyword">package</span> animal

<span class="hljs-keyword">type</span> BehaviorI <span class="hljs-keyword">interface</span> &#123;
	Shout(dark <span class="hljs-keyword">string</span>) <span class="hljs-keyword">string</span>
&#125;


<span class="hljs-comment">// offer/note/interfaces/duckI.go</span>
<span class="hljs-keyword">package</span> animal

<span class="hljs-keyword">type</span> DuckI <span class="hljs-keyword">interface</span> &#123;
	GetName() <span class="hljs-keyword">string</span>
&#125;


<span class="hljs-comment">// offer/note/interfaces/mock/duck.go</span>
<span class="hljs-keyword">package</span> mock

<span class="hljs-keyword">type</span> Duck <span class="hljs-keyword">struct</span> &#123;
	name <span class="hljs-keyword">string</span>
	bark <span class="hljs-keyword">string</span>
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d *Duck)</span> <span class="hljs-title">GetName</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span> &#123;
	<span class="hljs-keyword">if</span> d.name != <span class="hljs-string">&quot;&quot;</span> &#123;
		<span class="hljs-keyword">return</span> d.name
	&#125; <span class="hljs-keyword">else</span> &#123;
		<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;这是一个鸭子&quot;</span>
	&#125;
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d *Duck)</span> <span class="hljs-title">Shout</span><span class="hljs-params">(dark <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">string</span></span> &#123;
	<span class="hljs-keyword">if</span> d.bark == <span class="hljs-string">&quot;&quot;</span>&#123;
		<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;呱呱呱呱的叫&quot;</span>
	&#125;<span class="hljs-keyword">else</span> &#123;
		<span class="hljs-keyword">return</span> dark
	&#125;
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d *Duck)</span> <span class="hljs-title">String</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span> &#123;
	<span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;Duck: &#123; name = %s, bark = %s &#125;&quot;</span>, d.name, d.bark)
&#125;

<span class="hljs-comment">// 输出</span>
这是一个鸭子 呱呱呱呱的叫
Duck: &#123; name = , bark =  &#125;</code></pre>

<p><a target="_blank" rel="noopener" href="https://github.com/weitrue/note/tree/master/go/interfaces">https://github.com/weitrue/note/tree/master/go/interfaces</a></p>
<h4 id="常用接口"><a href="#常用接口" class="headerlink" title="常用接口"></a>常用接口</h4><ul>
<li><code>Stringer</code>相当于toString()</li>
</ul>
<pre><code class="hljs go"><span class="hljs-keyword">type</span> Stringer <span class="hljs-keyword">interface</span> &#123;
	String() <span class="hljs-keyword">string</span>
&#125;</code></pre>

<ul>
<li><code>Reader</code></li>
<li><code>Writer</code></li>
</ul>
<pre><code class="hljs go"><span class="hljs-comment">// io/io.go</span>

<span class="hljs-comment">// Reader is the interface that wraps the basic Read method.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Read reads up to len(p) bytes into p. It returns the number of bytes</span>
<span class="hljs-comment">// read (0 &lt;= n &lt;= len(p)) and any error encountered. Even if Read</span>
<span class="hljs-comment">// returns n &lt; len(p), it may use all of p as scratch space during the call.</span>
<span class="hljs-comment">// If some data is available but not len(p) bytes, Read conventionally</span>
<span class="hljs-comment">// returns what is available instead of waiting for more.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// When Read encounters an error or end-of-file condition after</span>
<span class="hljs-comment">// successfully reading n &gt; 0 bytes, it returns the number of</span>
<span class="hljs-comment">// bytes read. It may return the (non-nil) error from the same call</span>
<span class="hljs-comment">// or return the error (and n == 0) from a subsequent call.</span>
<span class="hljs-comment">// An instance of this general case is that a Reader returning</span>
<span class="hljs-comment">// a non-zero number of bytes at the end of the input stream may</span>
<span class="hljs-comment">// return either err == EOF or err == nil. The next Read should</span>
<span class="hljs-comment">// return 0, EOF.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Callers should always process the n &gt; 0 bytes returned before</span>
<span class="hljs-comment">// considering the error err. Doing so correctly handles I/O errors</span>
<span class="hljs-comment">// that happen after reading some bytes and also both of the</span>
<span class="hljs-comment">// allowed EOF behaviors.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Implementations of Read are discouraged from returning a</span>
<span class="hljs-comment">// zero byte count with a nil error, except when len(p) == 0.</span>
<span class="hljs-comment">// Callers should treat a return of 0 and nil as indicating that</span>
<span class="hljs-comment">// nothing happened; in particular it does not indicate EOF.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Implementations must not retain p.</span>
<span class="hljs-keyword">type</span> Reader <span class="hljs-keyword">interface</span> &#123;
	Read(p []<span class="hljs-keyword">byte</span>) (n <span class="hljs-keyword">int</span>, err error)
&#125;

<span class="hljs-comment">// Writer is the interface that wraps the basic Write method.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Write writes len(p) bytes from p to the underlying data stream.</span>
<span class="hljs-comment">// It returns the number of bytes written from p (0 &lt;= n &lt;= len(p))</span>
<span class="hljs-comment">// and any error encountered that caused the write to stop early.</span>
<span class="hljs-comment">// Write must return a non-nil error if it returns n &lt; len(p).</span>
<span class="hljs-comment">// Write must not modify the slice data, even temporarily.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Implementations must not retain p.</span>
<span class="hljs-keyword">type</span> Writer <span class="hljs-keyword">interface</span> &#123;
	Write(p []<span class="hljs-keyword">byte</span>) (n <span class="hljs-keyword">int</span>, err error)
&#125;

<span class="hljs-comment">// ReadWriter is the interface that groups the basic Read and Write methods.</span>
<span class="hljs-keyword">type</span> ReadWriter <span class="hljs-keyword">interface</span> &#123;
	Reader
	Writer
&#125;</code></pre>

<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><ul>
<li>函数可以有多个返回值，并且这些返回值可以起别名（别名多用于简单函数），别名与调用者的申明变量并无关联</li>
</ul>
<pre><code class="hljs go"><span class="hljs-keyword">package</span> main

<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span>

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">eval</span><span class="hljs-params">(a, b <span class="hljs-keyword">int</span>, op <span class="hljs-keyword">string</span>)</span> <span class="hljs-params">(<span class="hljs-keyword">int</span>, error)</span></span> &#123;
	<span class="hljs-keyword">switch</span> op &#123;
	<span class="hljs-keyword">case</span> <span class="hljs-string">&quot;+&quot;</span>:
		<span class="hljs-keyword">return</span>  a + b, <span class="hljs-literal">nil</span>
	<span class="hljs-keyword">case</span> <span class="hljs-string">&quot;-&quot;</span>:
		<span class="hljs-keyword">return</span> a - b, <span class="hljs-literal">nil</span>
	<span class="hljs-keyword">case</span> <span class="hljs-string">&quot;*&quot;</span>:
		<span class="hljs-keyword">return</span> a * b, <span class="hljs-literal">nil</span>
	<span class="hljs-keyword">case</span> <span class="hljs-string">&quot;/&quot;</span>:
		r, _ := div(a, b)
		<span class="hljs-keyword">return</span> r, <span class="hljs-literal">nil</span>
	<span class="hljs-keyword">default</span>:
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>, fmt.Errorf(<span class="hljs-string">&quot;unsupported operation&quot;</span>)
	&#125;
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">div</span><span class="hljs-params">(a, b <span class="hljs-keyword">int</span>)</span> <span class="hljs-params">(q, r <span class="hljs-keyword">int</span>)</span></span> &#123;
	<span class="hljs-keyword">return</span> a/b, a%b
&#125;</code></pre>

<ul>
<li><em>一等公民</em> :变量、参数、返回值均可以是函数</li>
</ul>
<pre><code class="hljs go"><span class="hljs-keyword">package</span> main

<span class="hljs-keyword">import</span> (
	<span class="hljs-string">&quot;fmt&quot;</span>
	<span class="hljs-string">&quot;math&quot;</span>
	<span class="hljs-string">&quot;reflect&quot;</span>
	<span class="hljs-string">&quot;runtime&quot;</span>
)
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">apply</span><span class="hljs-params">(op <span class="hljs-keyword">func</span>(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">float64</span>, <span class="hljs-title">a</span>, <span class="hljs-title">b</span> <span class="hljs-title">int</span>) <span class="hljs-title">float64</span></span> &#123;
	<span class="hljs-comment">//</span>
	p := reflect.ValueOf(op).Pointer()
	opName := runtime.FuncForPC(p).Name()
	fmt.Printf(<span class="hljs-string">&quot;Calling function %s with params (%d, %d)\n&quot;</span>, opName, a, b)
	<span class="hljs-keyword">return</span> op(<span class="hljs-keyword">int</span>(a), <span class="hljs-keyword">int</span>(b))
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">pow</span><span class="hljs-params">(a, b <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">float64</span></span> &#123;
	<span class="hljs-keyword">return</span> math.Pow(<span class="hljs-keyword">float64</span>(a), <span class="hljs-keyword">float64</span>(b))
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;
	fmt.Println(apply(pow, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>))

	<span class="hljs-comment">// 匿名函数方式</span>
	fmt.Println(apply(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(f, f2 <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">float64</span></span> &#123;
		<span class="hljs-keyword">return</span> math.Pow(<span class="hljs-keyword">float64</span>(f), <span class="hljs-keyword">float64</span>(f2))
	&#125;, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>))
&#125;

<span class="hljs-comment">// 打印结果</span>
Calling function main.pow with params (<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)
<span class="hljs-number">81</span>
Calling function main.main.func1 with params (<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)
<span class="hljs-number">81</span></code></pre>

<ul>
<li>可变参数列表，类似于Python中的*args</li>
</ul>
<pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sum</span><span class="hljs-params">(nums ...<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;
	<span class="hljs-comment">// 函数可变参数列表</span>
	sum := <span class="hljs-number">0</span>
	<span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> nums &#123;
		sum += nums[i]
	&#125;
	<span class="hljs-keyword">return</span> sum
&#125;</code></pre>

<p><a target="_blank" rel="noopener" href="https://github.com/weitrue/note/blob/master/go/functions/func.go">https://github.com/weitrue/note/blob/master/go/functions/func.go</a></p>
<h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><p><img src="/images/golang/func.png" srcset="/img/loading.gif"></p>
<p>其中，<code>func(i int)</code>中<code>i</code>为局部变量，<code>sum</code>为自由变量</p>
<pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">adder</span><span class="hljs-params">()</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;
	sum := <span class="hljs-number">0</span>
	<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;
		sum += i
		<span class="hljs-keyword">return</span> sum
	&#125;
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestAdder</span><span class="hljs-params">()</span></span>  &#123;
	a := adder()
	<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span> ; i++ &#123;
		fmt.Printf(<span class="hljs-string">&quot;0 + ... + %d = %d \n&quot;</span>, i, a(i))
	&#125;
&#125;

<span class="hljs-comment">// 输出</span>
<span class="hljs-number">0</span> + ... + <span class="hljs-number">0</span> = <span class="hljs-number">0</span> 
<span class="hljs-number">0</span> + ... + <span class="hljs-number">1</span> = <span class="hljs-number">1</span> 
<span class="hljs-number">0</span> + ... + <span class="hljs-number">2</span> = <span class="hljs-number">3</span> 
<span class="hljs-number">0</span> + ... + <span class="hljs-number">3</span> = <span class="hljs-number">6</span> 
<span class="hljs-number">0</span> + ... + <span class="hljs-number">4</span> = <span class="hljs-number">10</span> 
<span class="hljs-number">0</span> + ... + <span class="hljs-number">5</span> = <span class="hljs-number">15</span> 
<span class="hljs-number">0</span> + ... + <span class="hljs-number">6</span> = <span class="hljs-number">21</span> 
<span class="hljs-number">0</span> + ... + <span class="hljs-number">7</span> = <span class="hljs-number">28</span> 
<span class="hljs-number">0</span> + ... + <span class="hljs-number">8</span> = <span class="hljs-number">36</span> 
<span class="hljs-number">0</span> + ... + <span class="hljs-number">9</span> = <span class="hljs-number">45</span> 


<span class="hljs-comment">// 正统函数式编程</span>
<span class="hljs-keyword">type</span> iAdder <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span> <span class="hljs-params">(<span class="hljs-keyword">int</span>, iAdder)</span></span>

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">iAdd</span><span class="hljs-params">(base <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">iAdder</span></span> &#123;
	<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(v <span class="hljs-keyword">int</span>)</span> <span class="hljs-params">(<span class="hljs-keyword">int</span>, iAdder)</span></span> &#123;
		<span class="hljs-keyword">return</span> base +v, iAdd(base+v)
	&#125;
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestAdder</span><span class="hljs-params">()</span></span> &#123;
	a2 := iAdd(<span class="hljs-number">0</span>)
	<span class="hljs-keyword">var</span> s <span class="hljs-keyword">int</span>
	<span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;<span class="hljs-number">10</span>; i++ &#123;
		s, a2 = a2(i)
		fmt.Printf(<span class="hljs-string">&quot;0 + ... + %d = %d \n&quot;</span>, i, s)
	&#125;
&#125;

<span class="hljs-comment">// 输出</span>
<span class="hljs-number">0</span> + ... + <span class="hljs-number">1</span> = <span class="hljs-number">1</span> 
<span class="hljs-number">0</span> + ... + <span class="hljs-number">2</span> = <span class="hljs-number">3</span> 
<span class="hljs-number">0</span> + ... + <span class="hljs-number">3</span> = <span class="hljs-number">6</span> 
<span class="hljs-number">0</span> + ... + <span class="hljs-number">4</span> = <span class="hljs-number">10</span> 
<span class="hljs-number">0</span> + ... + <span class="hljs-number">5</span> = <span class="hljs-number">15</span> 
<span class="hljs-number">0</span> + ... + <span class="hljs-number">6</span> = <span class="hljs-number">21</span> 
<span class="hljs-number">0</span> + ... + <span class="hljs-number">7</span> = <span class="hljs-number">28</span> 
<span class="hljs-number">0</span> + ... + <span class="hljs-number">8</span> = <span class="hljs-number">36</span> 
<span class="hljs-number">0</span> + ... + <span class="hljs-number">9</span> = <span class="hljs-number">45</span></code></pre>

<p><a target="_blank" rel="noopener" href="https://github.com/weitrue/note/blob/master/go/functions/closure.go">https://github.com/weitrue/note/blob/master/go/functions/closure.go</a></p>
<h5 id="Python中的闭包"><a href="#Python中的闭包" class="headerlink" title="Python中的闭包"></a>Python中的闭包</h5><p>Python原生支持闭包</p>
<p><code>__closure__</code>可以查看闭包内容</p>
<pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">adder</span>():</span>
    s = <span class="hljs-number">0</span>

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span>(<span class="hljs-params">v: <span class="hljs-built_in">int</span></span>):</span>
        <span class="hljs-keyword">nonlocal</span> s
        s += v
        <span class="hljs-keyword">return</span> s

    <span class="hljs-keyword">return</span> f


<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:

    a = adder()
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):
        print(i, a(i), a.__closure__)
        
<span class="hljs-comment"># 输出</span>
<span class="hljs-number">0</span> <span class="hljs-number">0</span> (&lt;cell at <span class="hljs-number">0x7f9048e7d3d0</span>: <span class="hljs-built_in">int</span> <span class="hljs-built_in">object</span> at <span class="hljs-number">0x106eb6290</span>&gt;,)
<span class="hljs-number">1</span> <span class="hljs-number">1</span> (&lt;cell at <span class="hljs-number">0x7f9048e7d3d0</span>: <span class="hljs-built_in">int</span> <span class="hljs-built_in">object</span> at <span class="hljs-number">0x106eb62b0</span>&gt;,)
<span class="hljs-number">2</span> <span class="hljs-number">3</span> (&lt;cell at <span class="hljs-number">0x7f9048e7d3d0</span>: <span class="hljs-built_in">int</span> <span class="hljs-built_in">object</span> at <span class="hljs-number">0x106eb62f0</span>&gt;,)
<span class="hljs-number">3</span> <span class="hljs-number">6</span> (&lt;cell at <span class="hljs-number">0x7f9048e7d3d0</span>: <span class="hljs-built_in">int</span> <span class="hljs-built_in">object</span> at <span class="hljs-number">0x106eb6350</span>&gt;,)
<span class="hljs-number">4</span> <span class="hljs-number">10</span> (&lt;cell at <span class="hljs-number">0x7f9048e7d3d0</span>: <span class="hljs-built_in">int</span> <span class="hljs-built_in">object</span> at <span class="hljs-number">0x106eb63d0</span>&gt;,)
<span class="hljs-number">5</span> <span class="hljs-number">15</span> (&lt;cell at <span class="hljs-number">0x7f9048e7d3d0</span>: <span class="hljs-built_in">int</span> <span class="hljs-built_in">object</span> at <span class="hljs-number">0x106eb6470</span>&gt;,)
<span class="hljs-number">6</span> <span class="hljs-number">21</span> (&lt;cell at <span class="hljs-number">0x7f9048e7d3d0</span>: <span class="hljs-built_in">int</span> <span class="hljs-built_in">object</span> at <span class="hljs-number">0x106eb6530</span>&gt;,)
<span class="hljs-number">7</span> <span class="hljs-number">28</span> (&lt;cell at <span class="hljs-number">0x7f9048e7d3d0</span>: <span class="hljs-built_in">int</span> <span class="hljs-built_in">object</span> at <span class="hljs-number">0x106eb6610</span>&gt;,)
<span class="hljs-number">8</span> <span class="hljs-number">36</span> (&lt;cell at <span class="hljs-number">0x7f9048e7d3d0</span>: <span class="hljs-built_in">int</span> <span class="hljs-built_in">object</span> at <span class="hljs-number">0x106eb6710</span>&gt;,)
<span class="hljs-number">9</span> <span class="hljs-number">45</span> (&lt;cell at <span class="hljs-number">0x7f9048e7d3d0</span>: <span class="hljs-built_in">int</span> <span class="hljs-built_in">object</span> at <span class="hljs-number">0x106eb6830</span>&gt;,)</code></pre>

<h5 id="Java中的闭包"><a href="#Java中的闭包" class="headerlink" title="Java中的闭包"></a>Java中的闭包</h5><p>1.8以后，可以使用Function接口和Lambda表达式可以创建函数对象；</p>
<p>1.8之前，可以使用Lambda表达式或者匿名内部类也可以实现闭包；</p>
<pre><code class="hljs Java"><span class="hljs-keyword">import</span> javax.xml.ws.Holder;
<span class="hljs-keyword">import</span> java.util.function.Function;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyTest</span> </span>&#123;

    <span class="hljs-keyword">final</span> Holder&lt;Integer&gt; sum = <span class="hljs-keyword">new</span> Holder&lt;&gt;(<span class="hljs-number">0</span>);

    <span class="hljs-keyword">public</span>  Function&lt;Integer, Integer&gt;testClosure()&#123;
        <span class="hljs-comment">// 闭包  使用Function接口和Lambda表达式可以创建函数对象</span>
        <span class="hljs-keyword">return</span> (Integer value) -&gt; &#123;
            sum.value += value;
            <span class="hljs-keyword">return</span> sum.value;
        &#125;;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        MyTest mt = <span class="hljs-keyword">new</span> MyTest();
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;
            System.out.println(i +<span class="hljs-string">&quot;, &quot;</span>+ mt.testClosure().apply(<span class="hljs-keyword">new</span> Integer(i)));
        &#125;
    &#125;
&#125;</code></pre>

<h4 id="闭包应用"><a href="#闭包应用" class="headerlink" title="闭包应用"></a>闭包应用</h4><h6 id="为函数实现接口"><a href="#为函数实现接口" class="headerlink" title="为函数实现接口"></a>为函数实现接口</h6><h6 id="实现函数遍历二叉树"><a href="#实现函数遍历二叉树" class="headerlink" title="实现函数遍历二叉树"></a>实现函数遍历二叉树</h6><h3 id="defer-recover在简单web服务应用"><a href="#defer-recover在简单web服务应用" class="headerlink" title="defer/recover在简单web服务应用"></a>defer/recover在简单web服务应用</h3><p>代码结构<img src="/images/golang/web.jpg" srcset="/img/loading.gif"></p>
<p><a target="_blank" rel="noopener" href="https://github.com/weitrue/note/tree/master/go/web/">https://github.com/weitrue/note/tree/master/go/web/</a></p>
<h3 id="包管理"><a href="#包管理" class="headerlink" title="包管理"></a>包管理</h3><h4 id="gopm-获取无法下载的包"><a href="#gopm-获取无法下载的包" class="headerlink" title="gopm 获取无法下载的包"></a>gopm 获取无法下载的包</h4><p><code>go get -v github.com/gpmgo/gopm</code></p>
<p>github地址：<a target="_blank" rel="noopener" href="https://github.com/gpmgo/gopm">https://github.com/gpmgo/gopm</a></p>
<p>文档路径：<a target="_blank" rel="noopener" href="https://github.com/gpmgo/docs/tree/master/zh-CN">https://github.com/gpmgo/docs/tree/master/zh-CN</a></p>
<p>安装踩坑：</p>
<pre><code class="hljs zsh">github.com/codegangsta/cli: github.com/codegangsta/cli@v1.22.5: parsing go.mod:
		module declares its path as: github.com/urfave/cli
	        but was required as: github.com/codegangsta/cli</code></pre>

<p>关闭go mod即可成功安装</p>
<h3 id="笔试题"><a href="#笔试题" class="headerlink" title="笔试题"></a>笔试题</h3><h4 id="选择题"><a href="#选择题" class="headerlink" title="选择题"></a>选择题</h4><p>1.[primary] 下面属于关键字的是（）<br>A. func<br>B. def<br>C. struct<br>D. class​</p>
<p>AC</p>
<p>2.[primary] 定义一个包内全局字符串变量，下面语法正确的是 （）<br>A. var str string<br>B. str := “”<br>C. str = “”<br>D. var str = “”</p>
<p>AD</p>
<p>3.[primary] 通过指针变量 p 访问其成员变量 name，下面语法正确的是（）<br>A. p.name<br>B. (*p).name<br>C. (&amp;p).name<br>D. p-&gt;name</p>
<p>AB</p>
<p>4.[primary] 关于接口和类的说法，下面说法正确的是（）<br>A. 一个类只需要实现了接口要求的所有函数，我们就说这个类实现了该接口<br>B. 实现类的时候，只需要关心自己应该提供哪些方法，不用再纠结接口需要拆得多细才合理<br>C. 类实现接口时，需要导入接口所在的包<br>D. 接口由使用方按自身需求来定义，使用方无需关心是否有其他模块定义过类似的接口</p>
<p>ABD</p>
<p>5.[primary] 关于字符串连接，下面语法正确的是（）<br>A. str := ‘abc’ + ‘123’<br>B. str := “abc” + “123”<br>C. str ：= ‘123’ + “abc”<br>D. fmt.Sprintf(“abc%d”, 123)</p>
<p>BD</p>
<p>6.[primary] 关于协程，下面说法正确是（）<br>A. 协程和线程都可以实现程序的并发执行<br>B. 线程比协程更轻量级<br>C. 协程不存在死锁问题<br>D. 通过channel来进行协程间的通信</p>
<p>AD</p>
<p>7.[intermediate] 关于init函数，下面说法正确的是（）<br>A. 一个包中，可以包含多个init函数<br>B. 程序编译时，先执行导入包的init函数，再执行本包内的init函数<br>C. main包中，不能有init函数<br>D. init函数可以被其他函数调用</p>
<p>AB</p>
<p>8.[primary] 关于循环语句，下面说法正确的有（）<br>A. 循环语句既支持for关键字，也支持while和do-while<br>B. 关键字for的基本使用方法与C/C++中没有任何差异<br>C. for循环支持continue和break来控制循环，但是它提供了一个更高级的break，可以选择中断哪一个循环<br>D. for循环不支持以逗号为间隔的多个赋值语句，必须使用平行赋值的方式来初始化多个变量</p>
<p>CD</p>
<p>9.[intermediate] 对于函数定义：</p>
<pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">add</span><span class="hljs-params">(args ...<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;
        sum := <span class="hljs-number">0</span>
        <span class="hljs-keyword">for</span> _, arg := <span class="hljs-keyword">range</span> args &#123;
            sum += arg
        &#125;
        <span class="hljs-keyword">return</span> sum
&#125;</code></pre>


<p>下面对add函数调用正确的是（）</p>
<p> A. add(1, 2)<br> B. add(1, 3, 7)<br> C. add([]int{1, 2})<br> D. add([]int{1, 3, 7}…)</p>
<p>ABD</p>
<p>10.[primary] 关于类型转化，下面语法正确的是（）<br>A.</p>
<pre><code class="hljs go"><span class="hljs-keyword">type</span> MyInt <span class="hljs-keyword">int</span>
<span class="hljs-keyword">var</span> i <span class="hljs-keyword">int</span> = <span class="hljs-number">1</span>
<span class="hljs-keyword">var</span> j MyInt = i</code></pre>

<p>B.</p>
<pre><code class="hljs go"><span class="hljs-keyword">type</span> MyInt <span class="hljs-keyword">int</span>
<span class="hljs-keyword">var</span> i <span class="hljs-keyword">int</span> = <span class="hljs-number">1</span>
<span class="hljs-keyword">var</span> j MyInt = (MyInt)i</code></pre>

<p>C.</p>
<pre><code class="hljs go"><span class="hljs-keyword">type</span> MyInt <span class="hljs-keyword">int</span>
<span class="hljs-keyword">var</span> i <span class="hljs-keyword">int</span> = <span class="hljs-number">1</span>
<span class="hljs-keyword">var</span> j MyInt = MyInt(i)</code></pre>

<p>D.</p>
<pre><code class="hljs go"><span class="hljs-keyword">type</span> MyInt <span class="hljs-keyword">int</span>
<span class="hljs-keyword">var</span> i <span class="hljs-keyword">int</span> = <span class="hljs-number">1</span>
<span class="hljs-keyword">var</span> j MyInt = i.(MyInt)   <span class="hljs-comment">// Invalid type assertion: i.(MyInt) (non-interface type int on left)</span></code></pre>

<p>C</p>
<p>11.[primary] 关于局部变量的初始化，下面正确的使用方式是（）<br>A. var i int = 10<br>B. var i = 10<br>C. i := 10<br>D. i = 10</p>
<p>12.[primary] 关于const常量定义，下面正确的使用方式是（）<br>A.</p>
<pre><code class="hljs go"><span class="hljs-keyword">const</span> Pi <span class="hljs-keyword">float64</span> = <span class="hljs-number">3.14159265358979323846</span>
<span class="hljs-keyword">const</span> zero = <span class="hljs-number">0.0</span></code></pre>

<p>B.</p>
<pre><code class="hljs go"><span class="hljs-keyword">const</span> (
        size <span class="hljs-keyword">int64</span> = <span class="hljs-number">1024</span>
        eof = <span class="hljs-number">-1</span>
)</code></pre>

<p>C.</p>
<pre><code class="hljs go"><span class="hljs-keyword">const</span> (
        ERR_ELEM_EXIST error = errors.New(<span class="hljs-string">&quot;element already exists&quot;</span>)
        ERR_ELEM_NT_EXIST error = errors.New(<span class="hljs-string">&quot;element not exists&quot;</span>)
) <span class="hljs-comment">// Const initializer &#x27;errors.New(&quot;element already exists&quot;)&#x27; is not a constant</span></code></pre>

<p>D.</p>
<pre><code class="hljs go"><span class="hljs-keyword">const</span> u, v <span class="hljs-keyword">float32</span> = <span class="hljs-number">0</span>, <span class="hljs-number">3</span>
<span class="hljs-keyword">const</span> a, b, c = <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-string">&quot;foo&quot;</span></code></pre>

<p>ABD</p>
<p>13.[primary] 关于布尔变量b的赋值，下面错误的用法是（）<br>A. b = true<br>B. b = 1     //  Cannot use ‘1’ (type untyped int) as type bool in assignment<br>C. b = bool(1)   //Cannot convert expression of type int to type bool<br>D. b = (1 == 2)</p>
<p>BC</p>
<p>14.[intermediate] 下面的程序的运行结果是（）</p>
<pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) &#123;
            <span class="hljs-keyword">defer</span> fmt.Printf(<span class="hljs-string">&quot;1&quot;</span>)
        &#125; <span class="hljs-keyword">else</span> &#123;
            <span class="hljs-keyword">defer</span> fmt.Printf(<span class="hljs-string">&quot;2&quot;</span>)
        &#125;
        fmt.Printf(<span class="hljs-string">&quot;3&quot;</span>)
&#125;</code></pre>

<p>A. 321<br>B. 32<br>C. 31<br>D. 13</p>
<p>C</p>
<p>15.[primary] 关于switch语句，下面说法正确的有（）<br>A. 条件表达式必须为常量或者整数<br>B. 单个case中，可以出现多个结果选项<br>C. 需要用break来明确退出一个case<br>D. 只有在case中明确添加fallthrough关键字，才会继续执行紧跟的下一个case</p>
<p>BD</p>
<p>16.[intermediate] golang中没有隐藏的this指针，这句话的含义是（）<br>A. 方法施加的对象显式传递，没有被隐藏起来<br>B. golang沿袭了传统面向对象编程中的诸多概念，比如继承、虚函数和构造函数<br>C. golang的面向对象表达更直观，对于面向过程只是换了一种语法形式来表达<br>D. 方法施加的对象不需要非得是指针，也不用非得叫this</p>
<p>ACD</p>
<p>17.[intermediate] golang中的引用类型包括（）<br>A. 数组切片<br>B. map<br>C. channel<br>D. interface</p>
<p>ABCD</p>
<p>18.[intermediate] golang中的指针运算包括（）<br>A. 可以对指针进行自增或自减运算<br>B. 可以通过“&amp;”取指针的地址<br>C. 可以通过“*”取指针指向的数据<br>D. 可以对指针进行下标运算</p>
<p>BC</p>
<p>19.[primary] 关于main函数（可执行程序的执行起点），下面说法正确的是（）<br>A. main函数不能带参数<br>B. main函数不能定义返回值<br>C. main函数所在的包必须为main包<br>D. main函数中可以使用flag包来获取和解析命令行参数</p>
<p>ABCD</p>
<p>20.[intermediate] 下面赋值正确的是（）<br>A. var x = nil<br>B. var x interface{} = nil<br>C. var x string = nil<br>D. var x error = nil</p>
<p>BD</p>
<p>21.[intermediate] 关于整型切片的初始化，下面正确的是（）<br>A. s := make([]int)<br>B. s := make([]int, 0)<br>C. s := make([]int, 5, 10)<br>D. s := []int{1, 2, 3, 4, 5}</p>
<p>BCD</p>
<p>22.[intermediate] 从切片中删除一个元素，下面的算法实现正确的是（）<br>A.</p>
<pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *Slice)</span><span class="hljs-title">Remove</span><span class="hljs-params">(value <span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">error</span></span> &#123;
        <span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> *s &#123;
            <span class="hljs-keyword">if</span> isEqual(value, v) &#123;
                <span class="hljs-keyword">if</span> i== <span class="hljs-built_in">len</span>(*s) - <span class="hljs-number">1</span> &#123;
                    *s = (*s)[:i]
                &#125;<span class="hljs-keyword">else</span> &#123;
                    *s = <span class="hljs-built_in">append</span>((*s)[:i],(*s)[i + <span class="hljs-number">2</span>:]...)
                &#125;
                <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> ERR_ELEM_NT_EXIST
&#125;</code></pre>

<p>B.</p>
<pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *Slice)</span><span class="hljs-title">Remove</span><span class="hljs-params">(value <span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">error</span></span> &#123;
        <span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> *s &#123;
            <span class="hljs-keyword">if</span> isEqual(value, v) &#123;
                *s = <span class="hljs-built_in">append</span>((*s)[:i],(*s)[i + <span class="hljs-number">1</span>:])
                <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> ERR_ELEM_NT_EXIST
&#125;</code></pre>

<p>C.</p>
<pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *Slice)</span><span class="hljs-title">Remove</span><span class="hljs-params">(value <span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">error</span></span> &#123;
        <span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> *s &#123;
            <span class="hljs-keyword">if</span> isEqual(value, v) &#123;
                <span class="hljs-built_in">delete</span>(*s, v)
                <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> ERR_ELEM_NT_EXIST
&#125;</code></pre>

<p>D.</p>
<pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *Slice)</span><span class="hljs-title">Remove</span><span class="hljs-params">(value <span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">error</span></span> &#123;
        <span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> *s &#123;
            <span class="hljs-keyword">if</span> isEqual(value, v) &#123;
                *s = <span class="hljs-built_in">append</span>((*s)[:i],(*s)[i + <span class="hljs-number">1</span>:]...)
                <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> ERR_ELEM_NT_EXIST
&#125;</code></pre>

<p>D</p>
<p>23.[primary] 关于变量的自增和自减操作，下面语句正确的是（）<br>A.<br>i := 1<br>i++<br>B.</p>
<p>i := 1<br>j = i++      // ‘,’, ‘;’, new line or ‘}’ expected, got ‘++’<br>C.</p>
<p>i := 1<br>++i<br>D.</p>
<p>i := 1<br>i–</p>
<p>BD</p>
<p>24.[intermediate] 关于函数声明，下面语法错误的是（）<br>A. func f(a, b int) (value int, err error)<br>B. func f(a int, b int) (value int, err error)<br>C. func f(a, b int) (value int, error)<br>D. func f(a int, b int) (int, int, error)</p>
<p>C</p>
<p>25.[intermediate] 如果Add函数的调用代码为：</p>
<pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;
        <span class="hljs-keyword">var</span> a Integer = <span class="hljs-number">1</span>
        <span class="hljs-keyword">var</span> b Integer = <span class="hljs-number">2</span>
        <span class="hljs-keyword">var</span> i <span class="hljs-keyword">interface</span>&#123;&#125; = &amp;a
        sum := i.(*Integer).Add(b)
        fmt.Println(sum)
&#125;</code></pre>

<p>则Add函数定义正确的是（）<br>A.</p>
<pre><code class="hljs go"><span class="hljs-keyword">type</span> Integer <span class="hljs-keyword">int</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a Integer)</span> <span class="hljs-title">Add</span><span class="hljs-params">(b Integer)</span> <span class="hljs-title">Integer</span></span> &#123;
        <span class="hljs-keyword">return</span> a + b
&#125;</code></pre>

<p>B.</p>
<pre><code class="hljs go"><span class="hljs-keyword">type</span> Integer <span class="hljs-keyword">int</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a Integer)</span> <span class="hljs-title">Add</span><span class="hljs-params">(b *Integer)</span> <span class="hljs-title">Integer</span></span> &#123;
        <span class="hljs-keyword">return</span> a + *b
&#125;</code></pre>

<p>C.</p>
<pre><code class="hljs go"><span class="hljs-keyword">type</span> Integer <span class="hljs-keyword">int</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a *Integer)</span> <span class="hljs-title">Add</span><span class="hljs-params">(b Integer)</span> <span class="hljs-title">Integer</span></span> &#123;
        <span class="hljs-keyword">return</span> *a + b
&#125;</code></pre>

<p>D.</p>
<pre><code class="hljs go"><span class="hljs-keyword">type</span> Integer <span class="hljs-keyword">int</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a *Integer)</span> <span class="hljs-title">Add</span><span class="hljs-params">(b *Integer)</span> <span class="hljs-title">Integer</span></span> &#123;
        <span class="hljs-keyword">return</span> *a + *b
&#125;</code></pre>

<p>AC<br>26.[intermediate] 如果Add函数的调用代码为：</p>
<pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;
        <span class="hljs-keyword">var</span> a Integer = <span class="hljs-number">1</span>
        <span class="hljs-keyword">var</span> b Integer = <span class="hljs-number">2</span>
        <span class="hljs-keyword">var</span> i <span class="hljs-keyword">interface</span>&#123;&#125; = a
        sum := i.(Integer).Add(b)
        fmt.Println(sum)
&#125;</code></pre>

<p>则Add函数定义正确的是（）<br>A.</p>
<pre><code class="hljs go"><span class="hljs-keyword">type</span> Integer <span class="hljs-keyword">int</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a Integer)</span> <span class="hljs-title">Add</span><span class="hljs-params">(b Integer)</span> <span class="hljs-title">Integer</span></span> &#123;
        <span class="hljs-keyword">return</span> a + b
&#125;</code></pre>

<p>B.</p>
<pre><code class="hljs go"><span class="hljs-keyword">type</span> Integer <span class="hljs-keyword">int</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a Integer)</span> <span class="hljs-title">Add</span><span class="hljs-params">(b *Integer)</span> <span class="hljs-title">Integer</span></span> &#123;
        <span class="hljs-keyword">return</span> a + *b
&#125;</code></pre>

<p>C.</p>
<pre><code class="hljs go"><span class="hljs-keyword">type</span> Integer <span class="hljs-keyword">int</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a *Integer)</span> <span class="hljs-title">Add</span><span class="hljs-params">(b Integer)</span> <span class="hljs-title">Integer</span></span> &#123;
        <span class="hljs-keyword">return</span> *a + b
&#125;</code></pre>

<p>D.</p>
<pre><code class="hljs go"><span class="hljs-keyword">type</span> Integer <span class="hljs-keyword">int</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a *Integer)</span> <span class="hljs-title">Add</span><span class="hljs-params">(b *Integer)</span> <span class="hljs-title">Integer</span></span> &#123;
        <span class="hljs-keyword">return</span> *a + *b
&#125;</code></pre>

<p>AC</p>
<p>27.[intermediate] 关于GetPodAction定义，下面赋值正确的是（）</p>
<pre><code class="hljs go"><span class="hljs-keyword">type</span> Fragment <span class="hljs-keyword">interface</span> &#123;
        Exec(transInfo *TransInfo) error
&#125;
<span class="hljs-keyword">type</span> GetPodAction <span class="hljs-keyword">struct</span> &#123;
&#125;
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(g GetPodAction)</span> <span class="hljs-title">Exec</span><span class="hljs-params">(transInfo *TransInfo)</span> <span class="hljs-title">error</span></span> &#123;
        ...
        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>
&#125;</code></pre>

<p>A. var fragment Fragment = new(GetPodAction)<br>B. var fragment Fragment = GetPodAction<br>C. var fragment Fragment = &amp;GetPodAction{}<br>D. var fragment Fragment = GetPodAction{}</p>
<p>ACD</p>
<p>28.[intermediate] 关于GoMock，下面说法正确的是（）<br>A. GoMock可以对interface打桩<br>B. GoMock可以对类的成员函数打桩<br>C. GoMock可以对函数打桩<br>D. GoMock打桩后的依赖注入可以通过GoStub完成</p>
<p>[AD]</p>
<p>29.[intermediate] 关于接口，下面说法正确的是（）<br>A. 只要两个接口拥有相同的方法列表（次序不同不要紧），那么它们就是等价的，可以相互赋值<br>B. 如果接口A的方法列表是接口B的方法列表的子集，那么接口B可以赋值给接口A<br>C. 接口查询是否成功，要在运行期才能够确定<br>D. 接口赋值是否可行，要在运行期才能够确定</p>
<p>[ABC]</p>
<p>30.[primary] 关于channel，下面语法正确的是（）<br>A. var ch chan int<br>B. ch := make(chan int)<br>C. &lt;- ch<br>D. ch &lt;-<br>ABC</p>
<p>31.[primary] 关于同步锁，下面说法正确的是（）<br>A. 当一个goroutine获得了Mutex后，其他goroutine就只能乖乖的等待，除非该goroutine释放这个Mutex<br>B. RWMutex在读锁占用的情况下，会阻止写，但不阻止读<br>C. RWMutex在写锁占用情况下，会阻止任何其他goroutine（无论读和写）进来，整个锁相当于由该goroutine独占<br>D. Lock()操作需要保证有Unlock()或RUnlock()调用与之对应</p>
<p>ABC</p>
<p>32.[intermediate] golang中大多数数据类型都可以转化为有效的JSON文本，下面几种类型除外（）<br>A. 指针<br>B. channel<br>C. complex<br>D. 函数</p>
<p>BCD</p>
<p>33.[intermediate] 关于go vendor，下面说法正确的是（）<br>A. 基本思路是将引用的外部包的源代码放在当前工程的vendor目录下面<br>B. 编译go代码会优先从vendor目录先寻找依赖包<br>C. 可以指定引用某个特定版本的外部包<br>D. 有了vendor目录后，打包当前的工程代码到其他机器的$GOPATH/src下都可以通过编译</p>
<p>ABD</p>
<p>34.[primary] flag是bool型变量，下面if表达式符合编码规范的是（）<br>A. if flag == 1<br>B. if flag<br>C. if flag == false<br>D. if !flag</p>
<p>BD</p>
<p>35.[primary] value是整型变量，下面if表达式符合编码规范的是（）<br>A. if value == 0<br>B. if value<br>C. if value != 0<br>D. if !value</p>
<p>AC</p>
<p>36.[intermediate] 关于函数返回值的错误设计，下面说法正确的是（）<br>A. 如果失败原因只有一个，则返回bool<br>B. 如果失败原因超过一个，则返回error<br>C. 如果没有失败原因，则不返回bool或error<br>D. 如果重试几次可以避免失败，则不要立即返回bool或error</p>
<p>37.[intermediate] 关于异常设计，下面说法正确的是（）<br>A. 在程序开发阶段，坚持速错，让程序异常崩溃<br>B. 在程序部署后，应恢复异常避免程序终止<br>C. 一切皆错误，不用进行异常设计<br>D. 对于不应该出现的分支，使用异常处理</p>
<p>[intermediate] 关于slice或map操作，下面正确的是（）<br>A.</p>
<p>var s []int<br>s = append(s,1)<br>1<br>2<br>B.</p>
<p>var m map[string]int<br>m[“one”] = 1<br>1<br>2<br>C.</p>
<p>var s []int<br>s = make([]int, 0)<br>s = append(s,1)<br>1<br>2<br>3<br>D.</p>
<p>var m map[string]int<br>m = make(map[string]int)<br>m[“one”] = 1<br>1<br>2<br>3<br>[intermediate] 关于channel的特性，下面说法正确的是（）<br>A. 给一个 nil channel 发送数据，造成永远阻塞<br>B. 从一个 nil channel 接收数据，造成永远阻塞<br>C. 给一个已经关闭的 channel 发送数据，引起 panic<br>D. 从一个已经关闭的 channel 接收数据，如果缓冲区中为空，则返回一个零值</p>
<p>[intermediate] 关于无缓冲和有冲突的channel，下面说法正确的是（）<br>A. 无缓冲的channel是默认的缓冲为1的channel<br>B. 无缓冲的channel和有缓冲的channel都是同步的<br>C. 无缓冲的channel和有缓冲的channel都是非同步的<br>D. 无缓冲的channel是同步的，而有缓冲的channel是非同步的</p>
<p>答案下载链接 ：<a target="_blank" rel="noopener" href="https://wws.lanzous.com/ifgqgmunf8d">https://wws.lanzous.com/ifgqgmunf8d</a></p>
<p>[intermediate] 关于异常的触发，下面说法正确的是（）<br>A. 空指针解析<br>B. 下标越界<br>C. 除数为0<br>D. 调用panic函数</p>
<p>[intermediate] 关于cap函数的适用类型，下面说法正确的是（）<br>A. array<br>B. slice<br>C. map<br>D. channel</p>
<p>[intermediate] 关于beego框架，下面说法正确的是（）<br>A. beego是一个golang实现的轻量级HTTP框架<br>B. beego可以通过注释路由、正则路由等多种方式完成url路由注入<br>C. 可以使用bee new工具生成空工程，然后使用bee run命令自动热编译<br>D. beego框架只提供了对url路由的处理， 而对于MVC架构中的数据库部分未提供框架支持</p>
<p>[intermediate] 关于goconvey，下面说法正确的是（）<br>A. goconvey是一个支持golang的单元测试框架<br>B. goconvey能够自动监控文件修改并启动测试，并可以将测试结果实时输出到web界面<br>C. goconvey提供了丰富的断言简化测试用例的编写<br>D. goconvey无法与go test集成</p>
<p>[intermediate] 关于go vet，下面说法正确的是（）<br>A. go vet是golang自带工具go tool vet的封装<br>B. 当执行go vet database时，可以对database所在目录下的所有子文件夹进行递归检测<br>C. go vet可以使用绝对路径、相对路径或相对GOPATH的路径指定待检测的包<br>D. go vet可以检测出死代码</p>
<p>[intermediate] 关于map，下面说法正确的是（）<br>A. map反序列化时json.unmarshal的入参必须为map的地址<br>B. 在函数调用中传递map，则子函数中对map元素的增加不会导致父函数中map的修改<br>C. 在函数调用中传递map，则子函数中对map元素的修改不会导致父函数中map的修改<br>D. 不能使用内置函数delete删除map的元素</p>
<p>[intermediate] 关于GoStub，下面说法正确的是（）<br>A. GoStub可以对全局变量打桩<br>B. GoStub可以对函数打桩<br>C. GoStub可以对类的成员方法打桩<br>D. GoStub可以打动态桩，比如对一个函数打桩后，多次调用该函数会有不同的行为</p>
<p>[primary] 关于select机制，下面说法正确的是（）<br>A. select机制用来处理异步IO问题<br>B. select机制最大的一条限制就是每个case语句里必须是一个IO操作<br>C. golang在语言级别支持select关键字<br>D. select关键字的用法与switch语句非常类似，后面要带判断条件</p>
<p>[primary] 关于内存泄露，下面说法正确的是（）<br>A. golang有自动垃圾回收，不存在内存泄露<br>B. golang中检测内存泄露主要依靠的是pprof包<br>C. 内存泄露可以在编译阶段发现<br>D. 应定期使用浏览器来查看系统的实时内存信息，及时发现内存泄露问题</p>
<p>[primary] 对于局部变量整型切片x的赋值，下面定义正确的是（）<br>A.</p>
<p>x := []int{<br>        1, 2, 3,<br>        4, 5, 6,<br>}<br>1<br>2<br>3<br>4<br>B.</p>
<p>x := []int{<br>        1, 2, 3,<br>        4, 5, 6<br>}<br>1<br>2<br>3<br>4<br>C.</p>
<p>x := []int{<br>        1, 2, 3,<br>        4, 5, 6}<br>1<br>2<br>3<br>D.</p>
<p>x := []int{1, 2, 3, 4, 5, 6,}</p>
<p>[primary] 声明一个整型变量i ?</p>
<p>[primary] 声明一个含有10个元素的整型数组a ?</p>
<p>[primary] 声明一个整型数组切片s?</p>
<p>[primary] 声明一个整型指针变量p?</p>
<p>[primary] 声明一个key为字符串型value为整型的map变量m?</p>
<p>[primary] 声明一个入参和返回值均为整型的函数变量 f?</p>
<p>[primary] 声明一个只用于读取int数据的单向channel变量ch?</p>
<p>[primary] 假设源文件的命名为slice.go，则测试文件的命名为?</p>
<p>[primary] go test要求测试函数的前缀必须命名为?</p>
<p>[intermediate] 下面的程序的运行结果是?</p>
<p>for i := 0; i &lt; 5; i++ {<br>        defer fmt.Printf(“%d “, i)<br>}<br>1<br>2<br>3<br>[intermediate] 下面的程序的运行结果是?<br>func main() {<br>        x := 1<br>        {<br>            x := 2<br>            fmt.Print(x)<br>        }<br>        fmt.Println(x)<br>}<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>[intermediate] 下面的程序的运行结果是?<br>func main() {<br>        strs := []string{“one”, “two”, “three”}</p>
<pre><code>    for _, s := range strs &#123;
        go func() &#123;
            time.Sleep(1 * time.Second)
            fmt.Printf(&quot;%s &quot;, s)
        &#125;()
    &#125;
    time.Sleep(3 * time.Second)</code></pre>
<p>}<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>[intermediate] 下面的程序的运行结果是?<br>func main() {<br>        x := []string{“a”, “b”, “c”}<br>        for v := range x {<br>            fmt.Print(v)<br>        }<br>}<br>1<br>2<br>3<br>4<br>5<br>6<br>[intermediate] 下面的程序的运行结果是？<br>func main() {<br>        x := []string{“a”, “b”, “c”}<br>        for _, v := range x {<br>            fmt.Print(v)<br>        }<br>}<br>1<br>2<br>3<br>4<br>5<br>6<br>[primary] 下面的程序的运行结果是？<br>func main() {<br>       i := 1<br>       j := 2<br>       i, j = j, i<br>       fmt.Printf(“%d%d\n”, i, j)<br>}<br>1<br>2<br>3<br>4<br>5<br>6<br>[primary] 下面的程序的运行结果是？<br>func incr(p *int) int {<br>        *p++<br>        return *p<br>}<br>func main() {<br>        v := 1<br>        incr(&amp;v)<br>        fmt.Println(v)<br>}<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>[primary] 启动一个goroutine的关键字是？</p>
<p>[intermediate] 下面的程序的运行结果是？</p>
<p>type Slice []int<br>func NewSlice() Slice {<br>         return make(Slice, 0)<br>}<br>func (s* Slice) Add(elem int) *Slice {<br>         *s = append(*s, elem)<br>         fmt.Print(elem)<br>         return s<br>}<br>func main() {<br>         s := NewSlice()<br>         defer s.Add(1).Add(2)<br>         s.Add(3)<br>}</p>
<ol start="3">
<li>判断题<br>[primary] 数组是一个值类型（）</li>
</ol>
<p>[primary] 使用map不需要引入任何库（）</p>
<p>[intermediate] 内置函数delete可以删除数组切片内的元素（）</p>
<p>[primary] 指针是基础类型（）</p>
<p>[primary] interface{}是可以指向任意对象的Any类型（）</p>
<p>[intermediate] 下面关于文件操作的代码可能触发异常（）</p>
<p>file, err := os.Open(“test.go”)<br>defer file.Close()<br>if err != nil {<br>        fmt.Println(“open file failed:”, err)<br>        return<br>}<br>…<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>[primary] Golang不支持自动垃圾回收（）</p>
<p>[primary] Golang支持反射，反射最常见的使用场景是做对象的序列化（）</p>
<p>[primary] Golang可以复用C/C++的模块，这个功能叫Cgo（）</p>
<p>[primary] 下面代码中两个斜点之间的代码，比如json:”x”，作用是X字段在从结构体实例编码到JSON数据格式的时候，使用x作为名字，这可以看作是一种重命名的方式（）</p>
<p>type Position struct {<br>        X int <code>json:&quot;x&quot;</code><br>        Y int <code>json:&quot;y&quot;</code><br>        Z int <code>json:&quot;z&quot;</code><br>}<br>1<br>2<br>3<br>4<br>5<br>[primary] 通过成员变量或函数首字母的大小写来决定其作用域（）</p>
<p>[primary] 对于常量定义zero(const zero = 0.0)，zero是浮点型常量（）</p>
<p>[primary] 对变量x的取反操作是~x（）</p>
<p>[primary] 下面的程序的运行结果是xello（）</p>
<p>func main() {<br>        str := “hello”<br>        str[0] = ‘x’<br>        fmt.Println(str)<br>}<br>1<br>2<br>3<br>4<br>5<br>[primary] golang支持goto语句（）</p>
<p>[primary] 下面代码中的指针p为野指针，因为返回的栈内存在函数结束时会被释放（）</p>
<p>type TimesMatcher struct {<br>        base int<br>}<br>func NewTimesMatcher(base int) *TimesMatcher{<br>        return &amp;TimesMatcher{base:base}<br>}<br>func main() {<br>        p := NewTimesMatcher(3)<br>        …<br>}<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>[primary] 匿名函数可以直接赋值给一个变量或者直接执行（）</p>
<p>[primary] 如果调用方调用了一个具有多返回值的方法，但是却不想关心其中的某个返回值，可以简单地用一个下划线“_”来跳过这个返回值，该下划线对应的变量叫匿名变量（）</p>
<p>[primary] 在函数的多返回值中，如果有error或bool类型，则一般放在最后一个（）</p>
<p>[primary] 错误是业务过程的一部分，而异常不是（）</p>
<p>[primary] 函数执行时，如果由于panic导致了异常，则延迟函数不会执行（）</p>
<p>[intermediate] 当程序运行时，如果遇到引用空指针、下标越界或显式调用panic函数等情况，则先触发panic函数的执行，然后调用延迟函数。调用者继续传递panic，因此该过程一直在调用栈中重复发生：函数停止执行，调用延迟执行函数。如果一路在延迟函数中没有recover函数的调用，则会到达该携程的起点，该携程结束，然后终止其他所有携程，其他携程的终止过程也是重复发生：函数停止执行，调用延迟执行函数（）</p>
<p>[primary] 同级文件的包名不允许有多个（）</p>
<p>[intermediate] 可以给任意类型添加相应的方法（）</p>
<p>[primary] golang虽然没有显式的提供继承语法，但是通过匿名组合实现了继承（）</p>
<p>[primary] 使用for range迭代map时每次迭代的顺序可能不一样，因为map的迭代是随机的（）</p>
<p>[primary] switch后面可以不跟表达式（）</p>
<p>[intermediate] 结构体在序列化时非导出变量（以小写字母开头的变量名）不会被encode，因此在decode时这些非导出变量的值为其类型的零值（）</p>
<p>[primary] golang中没有构造函数的概念，对象的创建通常交由一个全局的创建函数来完成，以NewXXX来命名（）</p>
<p>[intermediate] 当函数deferDemo返回失败时，并不能destroy已create成功的资源（）</p>
<pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">deferDemo</span><span class="hljs-params">()</span> <span class="hljs-title">error</span></span> &#123;
        err := createResource1()
        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;
            <span class="hljs-keyword">return</span> ERR_CREATE_RESOURCE1_FAILED
        &#125;
        <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;
            <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;
                destroyResource1()
            &#125;
        &#125;()
    err = createResource2()
    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;
        <span class="hljs-keyword">return</span> ERR_CREATE_RESOURCE2_FAILED
    &#125;
    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;
        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;
            destroyResource2()
        &#125;
    &#125;()

    err = createResource3()
    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;
        <span class="hljs-keyword">return</span> ERR_CREATE_RESOURCE3_FAILED
    &#125;
    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>
&#125;</code></pre>
<p>[intermediate] channel本身必然是同时支持读写的，所以不存在单向channel（）</p>
<p>[primary] import后面的最后一个元素是包名（）</p>

            </article>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/Golang/">Golang</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Go/">Go</a>
                    
                      <a class="hover-with-bg" href="/tags/ADT/">ADT</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <div class="post-prev col-6">
                    
                    
                      <a href="/2021/03/05/lt-linkedList/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">【LeetCode】线性表相关问题</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </div>
                  <div class="post-next col-6">
                    
                    
                      <a href="/2021/01/11/ml/">
                        <span class="hidden-mobile">【ML】机器学习概述与简单应用</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </div>
                </div>
              
            </div>

            
          </div>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Wei</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/weitrue" target="_blank" rel="nofollow noopener">
        <span>Trable</span></a>
    </div>
    

    
  <!-- 备案信息 -->
  <div class="beian">
    <a href="http://beian.miit.gov.cn/" target="_blank"
       rel="nofollow noopener">杭ICP证123456号</a>
    
      <a
        href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=12345678"
        rel="nofollow noopener"
        class="beian-police"
        target="_blank"
      >
        <span class="beian-police-sep">&nbsp;|&nbsp;</span>
        
          <img src="/images/img/police_beian.png" srcset="/img/loading.gif" alt="police-icon" />
        
        <span>杭公网安备12345678号</span>
      </a>
     
  </div>


    
     <div>
  	<span id="timeDate">载入天数...</span>
 	<span id="times">载入时分秒...</span>
 	<script>
          var now = new Date();
          function createtime(){
           var grt= new Date("02/14/2020 00:00:00");//此处修改你的建站时间或者网站上线时间
           now.setTime(now.getTime()+250);
           days = (now - grt ) / 1000 / 60 / 60 / 24;
           dnum = Math.floor(days);
           hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum);
           hnum = Math.floor(hours);
           if(String(hnum).length ==1 ){
                hnum = "0" + hnum;
           }
           minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
           mnum = Math.floor(minutes);
           if(String(mnum).length ==1 ){
                mnum = "0" + mnum;
           }
           seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
           snum = Math.round(seconds);
           if(String(snum).length ==1 ){
                snum = "0" + snum;
           }
           document.getElementById("timeDate").innerHTML = "本站安全运行&nbsp"+dnum+"&nbsp天";
           document.getElementById("times").innerHTML = hnum + "&nbsp小时&nbsp" + mnum + "&nbsp分&nbsp" + snum + "&nbsp秒";
          }
          setInterval("createtime()",250);
       </script>
    </div>
 </div>
 </footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/main.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>







  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: 'article.markdown-body',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "【Go】学习笔记&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>







  
  
    <script type="text/javascript">
      //定义获取词语下标
      var a_idx = 0;
      jQuery(document).ready(function ($) {
        //点击body时触发事件
        $("body").click(function (e) {
          //需要显示的词语
          var a = new Array("富强", "民主", "文明", "和谐", "自由", "平等", "公正", "法治", "爱国", "敬业", "诚信", "友善");
          //设置词语给span标签
          var $i = $("<span/>").text(a[a_idx]);
          //下标等于原来下标+1  余 词语总数
          a_idx = (a_idx + 1) % a.length;
          //获取鼠标指针的位置，分别相对于文档的左和右边缘。
          //获取x和y的指针坐标
          var x = e.pageX, y = e.pageY;
          //在鼠标的指针的位置给$i定义的span标签添加css样式
          $i.css({
            "z-index": 999,
            "top": y - 20,
            "left": x,
            "position": "absolute",
            "font-weight": "bold",
            "color": rand_color()
          });
          // 随机颜色
          function rand_color() {
            return "rgb(" + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + ")"
          }
          //在body添加这个标签
          $("body").append($i);
          //animate() 方法执行 CSS 属性集的自定义动画。
          //该方法通过CSS样式将元素从一个状态改变为另一个状态。CSS属性值是逐渐改变的，这样就可以创建动画效果。
          //详情请看http://www.w3school.com.cn/jquery/effect_animate.asp
          $i.animate({
            //将原来的位置向上移动180
            "top": y - 180,
            "opacity": 0
            //1500动画的速度
          }, 1500, function () {
            //时间到了自动删除
            $i.remove();
          });
        });
      })
      ;
    </script>
  











  

  

  

  

  

  





<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
