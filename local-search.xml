<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>【ALL】ETCD键值存储系统</title>
    <link href="/2021/07/01/etcd/"/>
    <url>/2021/07/01/etcd/</url>
    
    <content type="html"><![CDATA[<blockquote><p>A highly-available key value store for shared configuration and service discovery.<a id="more"></a> </p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Develop</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Raft</tag>
      
      <tag>Etcd</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【LeetCode】查找与搜索</title>
    <link href="/2021/06/21/lt-search/"/>
    <url>/2021/06/21/lt-search/</url>
    
    <content type="html"><![CDATA[<h3 id="查找与搜索"><a href="#查找与搜索" class="headerlink" title="查找与搜索"></a><a id="more"></a>查找与搜索</h3><h4 id="二分算法"><a href="#二分算法" class="headerlink" title="二分算法"></a><strong>二分算法</strong></h4><h4 id="哈希与布隆过滤器"><a href="#哈希与布隆过滤器" class="headerlink" title="哈希与布隆过滤器"></a>哈希与布隆过滤器</h4><h4 id="DFS-amp-amp-BFS"><a href="#DFS-amp-amp-BFS" class="headerlink" title="DFS &amp;&amp; BFS"></a>DFS &amp;&amp; BFS</h4>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Go</tag>
      
      <tag>Java</tag>
      
      <tag>LeetCode</tag>
      
      <tag>scala</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Go】面试/笔试之道</title>
    <link href="/2021/06/02/golang-interview/"/>
    <url>/2021/06/02/golang-interview/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Go】使用之道</title>
    <link href="/2021/06/02/golang-src/"/>
    <url>/2021/06/02/golang-src/</url>
    
    <content type="html"><![CDATA[<h3 id="常见库-框架"><a href="#常见库-框架" class="headerlink" title="常见库/框架"></a>常见库/框架</h3><h4 id="原生库"><a href="#原生库" class="headerlink" title="原生库"></a>原生库</h4><h5 id="unsafe"><a href="#unsafe" class="headerlink" title="unsafe"></a>unsafe</h5><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Test</span><span class="hljs-params">(t *testing.T)</span></span>  &#123;<span class="hljs-comment">// 任何类型的指针值都可以转换为Pointer // unsafe.Pointer(&amp;a1)</span><span class="hljs-comment">// Pointer可以转换为任何类型的指针值 // (*float32)(unsafe.Pointer(numPointer))</span><span class="hljs-comment">// uintptr可以转换为 Pointer // unsafe.Pointer(uintptr(nPointer) + + unsafe.Sizeof(&amp;a) * 3)</span><span class="hljs-comment">// Pointer可以转换为 uintptr // uintptr(unsafe.Pointer(numPointer))</span><span class="hljs-comment">// uintptr 是一个整数类型，它足够大，可以存储. 只有将Pointer转换成uintptr才能进行指针的相关操作</span><span class="hljs-keyword">var</span> a <span class="hljs-keyword">int32</span> = <span class="hljs-number">10</span>tt := unsafe.Sizeof(a)fmt.Println(tt)  <span class="hljs-comment">// 4</span><span class="hljs-keyword">var</span> ab <span class="hljs-keyword">int64</span> = <span class="hljs-number">10</span>fmt.Println(unsafe.Sizeof(ab))  <span class="hljs-comment">// 8</span><span class="hljs-keyword">var</span> abc <span class="hljs-keyword">int</span> = <span class="hljs-number">10</span>fmt.Println(unsafe.Sizeof(abc))  <span class="hljs-comment">// 8</span><span class="hljs-keyword">var</span> b <span class="hljs-keyword">string</span> = <span class="hljs-string">&quot;test&quot;</span>fmt.Println(unsafe.Sizeof(b))   <span class="hljs-comment">// 16 Sizeof(string)占计算string header的大小, struct string &#123; uint8 *str; int len;&#125;</span><span class="hljs-keyword">var</span> bc <span class="hljs-keyword">string</span> = <span class="hljs-string">&quot;test-test-test-test-test-test-test-test-test-test-test-test-test-test&quot;</span>fmt.Println(unsafe.Sizeof(bc))  <span class="hljs-comment">// 16 Sizeof(string)占计算string header的大小, struct string &#123; uint8 *str; int len;&#125;</span><span class="hljs-keyword">type</span> aa <span class="hljs-keyword">struct</span> &#123;B <span class="hljs-keyword">bool</span>C <span class="hljs-keyword">uint64</span>&#125;c := aa&#123;&#125;fmt.Println(unsafe.Sizeof(c))  <span class="hljs-comment">// 16 涉及到内存对齐的问题</span><span class="hljs-comment">// 返回结构体中某个字段的偏移量, 这个字段必须是structValue.field形式. 也就是返回结构体变量的开始位置到那个字段的开始位置之间字节数.</span>fmt.Println(unsafe.Offsetof(c.B), unsafe.Offsetof(c.C)) <span class="hljs-comment">// 0 8</span>fmt.Println(unsafe.Sizeof(<span class="hljs-keyword">bool</span>(<span class="hljs-literal">true</span>)))           <span class="hljs-comment">// 1</span><span class="hljs-keyword">type</span> bb <span class="hljs-keyword">struct</span> &#123;B *<span class="hljs-keyword">bool</span>&#125;c1 := bb&#123;&#125;fmt.Println(unsafe.Sizeof(c1)) <span class="hljs-comment">// 指针占8个字节(64位机器)</span><span class="hljs-comment">// 内存对齐</span><span class="hljs-comment">// 就是为了加快内存的存取速度, 用空间换时间的做法</span>fmt.Printf(<span class="hljs-string">&quot;bool: %d\n&quot;</span>, unsafe.Alignof(<span class="hljs-keyword">bool</span>(<span class="hljs-literal">true</span>)))           <span class="hljs-comment">// 1</span>fmt.Printf(<span class="hljs-string">&quot;int32: %d\n&quot;</span>, unsafe.Alignof(<span class="hljs-keyword">int32</span>(<span class="hljs-number">0</span>)))            <span class="hljs-comment">// 4</span>fmt.Printf(<span class="hljs-string">&quot;int8: %d\n&quot;</span>, unsafe.Alignof(<span class="hljs-keyword">int8</span>(<span class="hljs-number">0</span>)))              <span class="hljs-comment">// 1</span>fmt.Printf(<span class="hljs-string">&quot;int64: %d\n&quot;</span>, unsafe.Alignof(<span class="hljs-keyword">int64</span>(<span class="hljs-number">0</span>)))            <span class="hljs-comment">// 8</span>fmt.Printf(<span class="hljs-string">&quot;byte: %d\n&quot;</span>, unsafe.Alignof(<span class="hljs-keyword">byte</span>(<span class="hljs-number">0</span>)))              <span class="hljs-comment">// 1</span>fmt.Printf(<span class="hljs-string">&quot;string: %d\n&quot;</span>, unsafe.Alignof(<span class="hljs-keyword">string</span>(<span class="hljs-string">&quot;true&quot;</span>)))     <span class="hljs-comment">// 8</span>fmt.Printf(<span class="hljs-string">&quot;map: %d\n&quot;</span>, unsafe.Alignof(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">string</span>&#123;&#125;))   <span class="hljs-comment">// 8</span><span class="hljs-comment">// 对齐规则</span><span class="hljs-comment">// 1.结构体的成员变量，第一个成员变量的偏移量为 0。往后的每个成员变量的对齐值必须为编译器默认对齐长度（#pragma pack(n)）或当前成员变量类型的长度（unsafe.Sizeof），取最小值作为当前类型的对齐值。其偏移量必须为对齐值的整数倍</span><span class="hljs-comment">// 2.结构体本身，对齐值必须为编译器默认对齐长度（#pragma pack(n)）或结构体的所有成员变量类型中的最大长度，取最大数的最小整数倍作为对齐值</span><span class="hljs-comment">// 3.结合以上两点，可得知若编译器默认对齐长度（#pragma pack(n)）超过结构体内成员变量的类型最大长度时，默认对齐长度是没有任何意义的</span><span class="hljs-keyword">type</span> Part1 <span class="hljs-keyword">struct</span> &#123;a <span class="hljs-keyword">bool</span>b <span class="hljs-keyword">int32</span>c <span class="hljs-keyword">int8</span>d <span class="hljs-keyword">int64</span>e <span class="hljs-keyword">byte</span>&#125;part := Part1&#123;&#125;fmt.Printf(<span class="hljs-string">&quot;Part1 Size: %d, align: %d\n&quot;</span>, unsafe.Sizeof(part), unsafe.Alignof(part))   <span class="hljs-comment">// 32 8</span><span class="hljs-keyword">type</span> Part2 <span class="hljs-keyword">struct</span> &#123;a <span class="hljs-keyword">bool</span>e <span class="hljs-keyword">byte</span>c <span class="hljs-keyword">int8</span>b <span class="hljs-keyword">int32</span>d <span class="hljs-keyword">int64</span>&#125;par2 := Part2&#123;&#125;fmt.Printf(<span class="hljs-string">&quot;Part1 Size: %d, align: %d\n&quot;</span>, unsafe.Sizeof(par2), unsafe.Alignof(par2))   <span class="hljs-comment">// 16 8</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestApply</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<span class="hljs-comment">// Float64的bits</span><span class="hljs-keyword">var</span> f <span class="hljs-keyword">float64</span> = <span class="hljs-number">0.1</span>fmt.Println(*(*<span class="hljs-keyword">uint64</span>)(unsafe.Pointer(&amp;f)))  <span class="hljs-comment">// 4591870180066957722</span><span class="hljs-comment">// 计算偏移量</span><span class="hljs-keyword">type</span> aa <span class="hljs-keyword">struct</span> &#123;B <span class="hljs-keyword">bool</span>C <span class="hljs-keyword">uint64</span>&#125;c := aa&#123;&#125;fmt.Println(c)  <span class="hljs-comment">// &#123;false 0&#125;</span>aac := (*<span class="hljs-keyword">uint64</span>)(unsafe.Pointer(<span class="hljs-keyword">uintptr</span>(unsafe.Pointer(&amp;c)) + unsafe.Offsetof(c.C)))*aac = <span class="hljs-number">10</span>fmt.Println(c)  <span class="hljs-comment">// &#123;false 10&#125;</span>&#125;</code></pre><h5 id="flag"><a href="#flag" class="headerlink" title="flag"></a>flag</h5><h5 id="sync"><a href="#sync" class="headerlink" title="sync"></a>sync</h5><h5 id="os-signal"><a href="#os-signal" class="headerlink" title="os/signal"></a>os/signal</h5><pre><code class="hljs go"><span class="hljs-comment">// Signals</span><span class="hljs-keyword">const</span> (SIGABRT   = Signal(<span class="hljs-number">0x6</span>)SIGALRM   = Signal(<span class="hljs-number">0xe</span>)SIGBUS    = Signal(<span class="hljs-number">0xa</span>)SIGCHLD   = Signal(<span class="hljs-number">0x14</span>)SIGCONT   = Signal(<span class="hljs-number">0x13</span>)SIGEMT    = Signal(<span class="hljs-number">0x7</span>)SIGFPE    = Signal(<span class="hljs-number">0x8</span>)SIGHUP    = Signal(<span class="hljs-number">0x1</span>)SIGILL    = Signal(<span class="hljs-number">0x4</span>)SIGINFO   = Signal(<span class="hljs-number">0x1d</span>)SIGINT    = Signal(<span class="hljs-number">0x2</span>)SIGIO     = Signal(<span class="hljs-number">0x17</span>)SIGIOT    = Signal(<span class="hljs-number">0x6</span>)SIGKILL   = Signal(<span class="hljs-number">0x9</span>)SIGPIPE   = Signal(<span class="hljs-number">0xd</span>)SIGPROF   = Signal(<span class="hljs-number">0x1b</span>)SIGQUIT   = Signal(<span class="hljs-number">0x3</span>)SIGSEGV   = Signal(<span class="hljs-number">0xb</span>)SIGSTOP   = Signal(<span class="hljs-number">0x11</span>)SIGSYS    = Signal(<span class="hljs-number">0xc</span>)SIGTERM   = Signal(<span class="hljs-number">0xf</span>)SIGTRAP   = Signal(<span class="hljs-number">0x5</span>)SIGTSTP   = Signal(<span class="hljs-number">0x12</span>)SIGTTIN   = Signal(<span class="hljs-number">0x15</span>)SIGTTOU   = Signal(<span class="hljs-number">0x16</span>)SIGURG    = Signal(<span class="hljs-number">0x10</span>)SIGUSR1   = Signal(<span class="hljs-number">0x1e</span>)SIGUSR2   = Signal(<span class="hljs-number">0x1f</span>)SIGVTALRM = Signal(<span class="hljs-number">0x1a</span>)SIGWINCH  = Signal(<span class="hljs-number">0x1c</span>)SIGXCPU   = Signal(<span class="hljs-number">0x18</span>)SIGXFSZ   = Signal(<span class="hljs-number">0x19</span>))<span class="hljs-comment">// Signal table</span><span class="hljs-keyword">var</span> signals = [...]<span class="hljs-keyword">string</span>&#123;<span class="hljs-number">1</span>:  <span class="hljs-string">&quot;hangup&quot;</span>,<span class="hljs-number">2</span>:  <span class="hljs-string">&quot;interrupt&quot;</span>,<span class="hljs-number">3</span>:  <span class="hljs-string">&quot;quit&quot;</span>,<span class="hljs-number">4</span>:  <span class="hljs-string">&quot;illegal instruction&quot;</span>,<span class="hljs-number">5</span>:  <span class="hljs-string">&quot;trace/BPT trap&quot;</span>,<span class="hljs-number">6</span>:  <span class="hljs-string">&quot;abort trap&quot;</span>,<span class="hljs-number">7</span>:  <span class="hljs-string">&quot;EMT trap&quot;</span>,<span class="hljs-number">8</span>:  <span class="hljs-string">&quot;floating point exception&quot;</span>,<span class="hljs-number">9</span>:  <span class="hljs-string">&quot;killed&quot;</span>,<span class="hljs-number">10</span>: <span class="hljs-string">&quot;bus error&quot;</span>,<span class="hljs-number">11</span>: <span class="hljs-string">&quot;segmentation fault&quot;</span>,<span class="hljs-number">12</span>: <span class="hljs-string">&quot;bad system call&quot;</span>,<span class="hljs-number">13</span>: <span class="hljs-string">&quot;broken pipe&quot;</span>,<span class="hljs-number">14</span>: <span class="hljs-string">&quot;alarm clock&quot;</span>,<span class="hljs-number">15</span>: <span class="hljs-string">&quot;terminated&quot;</span>,<span class="hljs-number">16</span>: <span class="hljs-string">&quot;urgent I/O condition&quot;</span>,<span class="hljs-number">17</span>: <span class="hljs-string">&quot;suspended (signal)&quot;</span>,<span class="hljs-number">18</span>: <span class="hljs-string">&quot;suspended&quot;</span>,<span class="hljs-number">19</span>: <span class="hljs-string">&quot;continued&quot;</span>,<span class="hljs-number">20</span>: <span class="hljs-string">&quot;child exited&quot;</span>,<span class="hljs-number">21</span>: <span class="hljs-string">&quot;stopped (tty input)&quot;</span>,<span class="hljs-number">22</span>: <span class="hljs-string">&quot;stopped (tty output)&quot;</span>,<span class="hljs-number">23</span>: <span class="hljs-string">&quot;I/O possible&quot;</span>,<span class="hljs-number">24</span>: <span class="hljs-string">&quot;cputime limit exceeded&quot;</span>,<span class="hljs-number">25</span>: <span class="hljs-string">&quot;filesize limit exceeded&quot;</span>,<span class="hljs-number">26</span>: <span class="hljs-string">&quot;virtual timer expired&quot;</span>,<span class="hljs-number">27</span>: <span class="hljs-string">&quot;profiling timer expired&quot;</span>,<span class="hljs-number">28</span>: <span class="hljs-string">&quot;window size changes&quot;</span>,<span class="hljs-number">29</span>: <span class="hljs-string">&quot;information request&quot;</span>,<span class="hljs-number">30</span>: <span class="hljs-string">&quot;user defined signal 1&quot;</span>,<span class="hljs-number">31</span>: <span class="hljs-string">&quot;user defined signal 2&quot;</span>,&#125;</code></pre><h5 id="encoding-json"><a href="#encoding-json" class="headerlink" title="encoding/json"></a>encoding/json</h5><p>实现了程序命令行参数的解析。</p><h4 id="爬虫相关"><a href="#爬虫相关" class="headerlink" title="爬虫相关"></a>爬虫相关</h4><ul><li>henrylee2cn/pholcus</li><li>gocrawl</li><li>colly</li><li>hu17889/go_spider</li></ul><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul><li><a href="https://github.com/spf13/viper">https://github.com/spf13/viper</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Go】文档之道</title>
    <link href="/2021/06/02/golang-doc/"/>
    <url>/2021/06/02/golang-doc/</url>
    
    <content type="html"><![CDATA[<h3 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h3><p><code>godoc -http :6060</code>,生成网页文档</p><p><img src="/images/golang/doc.jpg"></p><p><img src="/images/golang/doc1.jpg"></p><p><code>go doc 方法名（包括包名）</code>,查看方法注释</p><p><img src="/images/golang/doc2.jpg"></p><p><code>xxx_test.go</code>生成示例</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ExampleQueue_Pop</span><span class="hljs-params">()</span></span> &#123;q := Queue&#123;&#125;_ = q.Push(<span class="hljs-string">&quot;asd&quot;</span>)_ = q.Push(<span class="hljs-number">123</span>)<span class="hljs-keyword">if</span> v, ok := q.Pop(); ok &#123;fmt.Println(v)&#125;<span class="hljs-keyword">if</span> v, ok := q.Pop(); ok &#123;fmt.Println(v)&#125;<span class="hljs-comment">//Output:</span><span class="hljs-comment">//asd</span><span class="hljs-comment">//123</span>&#125;</code></pre><p><img src="/images/golang/doc_output.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Go】测试之道</title>
    <link href="/2021/06/02/golang-test/"/>
    <url>/2021/06/02/golang-test/</url>
    
    <content type="html"><![CDATA[<blockquote><a id="more"></a></blockquote><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p><em>表格驱动</em>测试</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestMaxNoRepeatedZhn</span><span class="hljs-params">(t *testing.T)</span></span> &#123;tests := []<span class="hljs-keyword">struct</span>&#123;s <span class="hljs-keyword">string</span>ans <span class="hljs-keyword">int</span>&#125;&#123;&#123;<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-string">&quot;yes, 我爱gogogo&quot;</span>, <span class="hljs-number">9</span>&#125;,&#123;<span class="hljs-string">&quot;abcadcb&quot;</span>, <span class="hljs-number">4</span>&#125;,&#123;<span class="hljs-string">&quot;黑化肥挥发发灰会花飞灰化肥挥发发黑会飞花&quot;</span>, <span class="hljs-number">8</span>&#125;,&#125;<span class="hljs-keyword">for</span> _, tt := <span class="hljs-keyword">range</span> tests &#123;act := MaxNoRepeatedZhn(tt.s)<span class="hljs-keyword">if</span> act != tt.ans &#123;t.Errorf(<span class="hljs-string">&quot;get %d for input %s , but expect %d&quot;</span>, act, tt.s, tt.ans)&#125;&#125;&#125;<span class="hljs-comment">// 输出</span>=== RUN   TestMaxNoRepeatedZhn--- PASS: TestMaxNoRepeatedZhn (<span class="hljs-number">0.00</span>s)PASS</code></pre><h4 id="覆盖测试"><a href="#覆盖测试" class="headerlink" title="覆盖测试"></a>覆盖测试</h4><p><code>go tool cover</code></p><pre><code class="hljs shell">Usage of &#x27;go tool cover&#x27;:Given a coverage profile produced by &#x27;go test&#x27;:        go test -coverprofile=c.outOpen a web browser displaying annotated source code:        go tool cover -html=c.out    # 常用Write out an HTML file instead of launching a web browser:        go tool cover -html=c.out -o coverage.htmlDisplay coverage percentages to stdout for each function:        go tool cover -func=c.outFinally, to generate modified source code with coverage annotations(what go test -cover does):        go tool cover -mode=set -var=CoverageVariableName program.goFlags:  -V    print version and exit  -func string        output coverage profile information for each function  -html string        generate HTML representation of coverage profile  -mode string        coverage mode: set, count, atomic  -o string        file for output; default: stdout  -var string        name of coverage variable to generate (default &quot;GoCover&quot;)  Only one of -html, -func, or -mode may be set.</code></pre><h4 id="Benchmark"><a href="#Benchmark" class="headerlink" title="Benchmark"></a><code>Benchmark</code></h4><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkMaxNoRepeatedZhn</span><span class="hljs-params">(b *testing.B)</span></span> &#123;s := <span class="hljs-string">&quot;黑化肥挥发发灰会花飞灰化肥挥发发黑会飞花&quot;</span>ans := <span class="hljs-number">8</span><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; b.N; i++ &#123;act := MaxNoRepeatedZhn(s)<span class="hljs-keyword">if</span> act != ans &#123;b.Errorf(<span class="hljs-string">&quot;get %d for input %s , but expect %d&quot;</span>, act, s, ans)&#125;&#125;&#125;<span class="hljs-comment">// 输出</span>goos: darwingoarch: amd64pkg: offer/note/collectionsBenchmarkMaxNoRepeatedZhnBenchmarkMaxNoRepeatedZhn<span class="hljs-number">-8</span>    <span class="hljs-number">1097594</span>      <span class="hljs-number">1024</span> ns/opPASS</code></pre><p><a href="https://github.com/weitrue/note/collections/strings_test.go">https://github.com/weitrue/note/collections/strings_test.go</a></p><h4 id="pprof性能测试"><a href="#pprof性能测试" class="headerlink" title="pprof性能测试"></a>pprof性能测试</h4><pre><code class="hljs shell">xxx@xxxdeMacBook-Pro  ~/Projects/golang/src/offer/note/collections master ±✚ go test -bench . -cpuprofile cpu.outgoos: darwingoarch: amd64pkg: offer/note/collectionsBenchmarkMaxNoRepeatedZhn-8      1286594               934 ns/opPASSok      offer/note/collections  2.656sxxx@xxxdeMacBook-Pro  ~/Projects/golang/src/offer/note/collections master ±✚ go tool pprof cpu.out               Type: cpuTime: Mar 2, 2021 at 6:03pm (CST)Duration: 2.34s, Total samples = 2.05s (87.57%)Entering interactive mode (type &quot;help&quot; for commands, &quot;o&quot; for options)(pprof) webfailed to execute dot. Is Graphviz installed? Error: exec: &quot;dot&quot;: executable file not found in $PATH(pprof)</code></pre><p>☞<code>failed to execute dot. Is Graphviz installed? Error: exec: &quot;dot&quot;: executable file not found in $PATH</code>是因为电脑未安装生成.svg文件的工具<code>Graphviz</code></p><h5 id="安装Graphviz"><a href="#安装Graphviz" class="headerlink" title="安装Graphviz"></a>安装<code>Graphviz</code></h5><pre><code class="hljs shell">brew install graphvizxxx@xxxdeMacBook-Pro  ~/Projects/golang/src/github.com  brew install graphvizError:  homebrew-core is a shallow clone.  homebrew-cask is a shallow clone.To `brew update`, first run:  git -C /usr/local/Homebrew/Library/Taps/homebrew/homebrew-core fetch --unshallow  git -C /usr/local/Homebrew/Library/Taps/homebrew/homebrew-cask fetch --unshallowThese commands may take a few minutes to run due to the large size of the repositories.This restriction has been made on GitHub&#x27;s request because updating shallowclones is an extremely expensive operation due to the tree layout and traffic ofHomebrew/homebrew-core and Homebrew/homebrew-cask. We don&#x27;t do this for youautomatically to avoid repeatedly performing an expensive unshallow operation inCI systems (which should instead be fixed to not use shallow clones). Sorry forthe inconvenience!==&gt; Downloading https://mirrors.tuna.tsinghua.edu.cn/homebrew-bottles/bottles/libpng-1.6.37.big_sur.bottle.tar.gz<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">####################################################################### 100.0%</span></span>==&gt; Downloading https://mirrors.tuna.tsinghua.edu.cn/homebrew-bottles/bottles/freetype-2.10.4.big_sur.bottle.tar.gz<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">####################################################################### 100.0%</span></span>==&gt; Downloading https://mirrors.tuna.tsinghua.edu.cn/homebrew-bottles/bottles/fontconfig-2.13.1.big_sur.bottle.tar.gz<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">####################################################################### 100.0%</span></span>==&gt; Downloading https://mirrors.tuna.tsinghua.edu.cn/homebrew-bottles/bottles/jpeg-9d.big_sur.bottle.tar.gz<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">####################################################################### 100.0%</span></span>==&gt; Downloading https://mirrors.tuna.tsinghua.edu.cn/homebrew-bottles/bottles/libtiff-4.1.0_1.big_sur.bottle.tar.gz<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">########################################                                 58.1%</span></span>curl: (56) LibreSSL SSL_read: SSL_ERROR_SYSCALL, errno 54Error: Failed to download resource &quot;libtiff&quot;Download failed: https://mirrors.tuna.tsinghua.edu.cn/homebrew-bottles/bottles/libtiff-4.1.0_1.big_sur.bottle.tar.gzWarning: Bottle installation failed: building from source.==&gt; Downloading https://download.osgeo.org/libtiff/tiff-4.1.0.tar.gz<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">####################################################################### 100.0%</span></span>==&gt; Downloading https://mirrors.tuna.tsinghua.edu.cn/homebrew-bottles/bottles/webp-1.1.0.big_sur.bottle.tar.gz<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">####################################################################### 100.0%</span></span>==&gt; Downloading https://mirrors.tuna.tsinghua.edu.cn/homebrew-bottles/bottles/gd-2.3.0.big_sur.bottle.tar.gz<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">####################################################################### 100.0%</span></span>==&gt; Downloading https://mirrors.tuna.tsinghua.edu.cn/homebrew-bottles/bottles/libffi-3.3.big_sur.bottle.tar.gz<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">####################################################################### 100.0%</span></span>==&gt; Downloading https://mirrors.tuna.tsinghua.edu.cn/homebrew-bottles/bottles/pcre-8.44.big_sur.bottle.tar.gz<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">####################################################################### 100.0%</span></span>==&gt; Downloading https://mirrors.tuna.tsinghua.edu.cn/homebrew-bottles/bottles/glib-2.66.2_1.big_sur.bottle.tar.gz<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#########                                                                14.5%</span></span>curl: (56) LibreSSL SSL_read: SSL_ERROR_SYSCALL, errno 54Error: Failed to download resource &quot;glib&quot;Download failed: https://mirrors.tuna.tsinghua.edu.cn/homebrew-bottles/bottles/glib-2.66.2_1.big_sur.bottle.tar.gzWarning: Bottle installation failed: building from source.==&gt; Downloading https://raw.githubusercontent.com/Homebrew/formula-patches/6164294a75541c278f3863b111791376caa3ad26/glib/hardcoded-paths.diff<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">####################################################################### 100.0%</span></span>==&gt; Downloading https://download.gnome.org/sources/glib/2.66/glib-2.66.2.tar.xz==&gt; Downloading from https://mirrors.ustc.edu.cn/gnome/sources/glib/2.66/glib-2.66.2.tar.xz<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">####################################################################### 100.0%</span></span>==&gt; Downloading https://mirrors.tuna.tsinghua.edu.cn/homebrew-bottles/bottles/jasper-2.0.22.big_sur.bottle.tar.gz==&gt; Downloading from https://d29vzk4ow07wi7.cloudfront.net/ad3715537b3001b9a8924896e5c4e7eb90b21bb37e7171d964de2008edb13910?response-content-disposition=attachment%3Bfilename%3D%22jasper-2.0.22.big_sur.bo<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">####################################################################### 100.0%</span></span>==&gt; Downloading https://mirrors.tuna.tsinghua.edu.cn/homebrew-bottles/bottles/netpbm-10.86.17.big_sur.bottle.tar.gz==&gt; Downloading from https://d29vzk4ow07wi7.cloudfront.net/3540b31b88e9d8fc7288de5dac7b96be6f1c6652c604cfd167113bdf07738ca7?response-content-disposition=attachment%3Bfilename%3D%22netpbm-10.86.17.big_sur.<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">####################################################################### 100.0%</span></span>==&gt; Downloading https://mirrors.tuna.tsinghua.edu.cn/homebrew-bottles/bottles/gts-0.7.6_2.big_sur.bottle.tar.gz<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">####################################################################### 100.0%</span></span>==&gt; Downloading https://mirrors.tuna.tsinghua.edu.cn/homebrew-bottles/bottles/lzo-2.10.big_sur.bottle.tar.gz<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">####################################################################### 100.0%</span></span>==&gt; Downloading https://mirrors.tuna.tsinghua.edu.cn/homebrew-bottles/bottles/pixman-0.40.0.big_sur.bottle.tar.gz<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">####################################################################### 100.0%</span></span>==&gt; Downloading https://mirrors.tuna.tsinghua.edu.cn/homebrew-bottles/bottles/cairo-1.16.0_3.big_sur.bottle.tar.gz<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">####################################################################### 100.0%</span></span>==&gt; Downloading https://mirrors.tuna.tsinghua.edu.cn/homebrew-bottles/bottles/gdk-pixbuf-2.42.0.big_sur.bottle.tar.gz==&gt; Downloading from https://d29vzk4ow07wi7.cloudfront.net/1819bb48f7487d522a69c564dca6fe5dff4da658269f067e47edccddfaab9440?response-content-disposition=attachment%3Bfilename%3D%22gdk-pixbuf-2.42.0.big_su<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">####################################################################### 100.0%</span></span>==&gt; Downloading https://mirrors.tuna.tsinghua.edu.cn/homebrew-bottles/bottles/fribidi-1.0.10.big_sur.bottle.tar.gz<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">####################################################################### 100.0%</span></span>==&gt; Downloading https://mirrors.tuna.tsinghua.edu.cn/homebrew-bottles/bottles/pkg-config-0.29.2_3.big_sur.bottle.tar.gz<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">####################################################################### 100.0%</span></span>==&gt; Downloading https://mirrors.tuna.tsinghua.edu.cn/homebrew-bottles/bottles/gobject-introspection-1.66.1_1.big_sur.bottle.tar.gz<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">####################################################################### 100.0%</span></span>==&gt; Downloading https://mirrors.tuna.tsinghua.edu.cn/homebrew-bottles/bottles/graphite2-1.3.14.big_sur.bottle.tar.gz<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">####################################################################### 100.0%</span></span>==&gt; Downloading https://mirrors.tuna.tsinghua.edu.cn/homebrew-bottles/bottles/icu4c-67.1.big_sur.bottle.tar.gz<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">####################################################################### 100.0%</span></span>==&gt; Downloading https://mirrors.tuna.tsinghua.edu.cn/homebrew-bottles/bottles/harfbuzz-2.7.2.big_sur.bottle.tar.gz<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">####################################################################### 100.0%</span></span>==&gt; Downloading https://mirrors.tuna.tsinghua.edu.cn/homebrew-bottles/bottles/pango-1.48.0.big_sur.bottle.tar.gz<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">####################################################################### 100.0%</span></span>==&gt; Downloading https://mirrors.tuna.tsinghua.edu.cn/homebrew-bottles/bottles/librsvg-2.50.2.big_sur.bottle.tar.gz<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">####################                                                     29.6%</span></span>curl: (18) transfer closed with 28187304 bytes remaining to readError: Failed to download resource &quot;librsvg&quot;Download failed: https://mirrors.tuna.tsinghua.edu.cn/homebrew-bottles/bottles/librsvg-2.50.2.big_sur.bottle.tar.gzWarning: Bottle installation failed: building from source.==&gt; Downloading https://download.gnome.org/sources/librsvg/2.50/librsvg-2.50.2.tar.xz==&gt; Downloading from https://mirrors.ustc.edu.cn/gnome/sources/librsvg/2.50/librsvg-2.50.2.tar.xz<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">####################################################################### 100.0%</span></span>==&gt; Downloading https://mirrors.tuna.tsinghua.edu.cn/homebrew-bottles/bottles/libtool-2.4.6_2.big_sur.bottle.tar.gz<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">####################################################################### 100.0%</span></span>==&gt; Downloading https://mirrors.tuna.tsinghua.edu.cn/homebrew-bottles/bottles/graphviz-2.44.1.big_sur.bottle.1.tar.gz<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#####################################                                    52.9%</span></span>curl: (18) transfer closed with 6363689 bytes remaining to readError: Failed to download resource &quot;graphviz&quot;Download failed: https://mirrors.tuna.tsinghua.edu.cn/homebrew-bottles/bottles/graphviz-2.44.1.big_sur.bottle.1.tar.gzWarning: Bottle installation failed: building from source.==&gt; Downloading https://mirrors.tuna.tsinghua.edu.cn/homebrew-bottles/bottles/autoconf-2.69.big_sur.bottle.4.tar.gz<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">####################################################################### 100.0%</span></span>==&gt; Downloading https://mirrors.tuna.tsinghua.edu.cn/homebrew-bottles/bottles/automake-1.16.3.big_sur.bottle.tar.gz<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">####################################################################### 100.0%</span></span>==&gt; Downloading https://mirrors.tuna.tsinghua.edu.cn/homebrew-bottles/bottles/pkg-config-0.29.2_3.big_sur.bottle.tar.gzAlready downloaded: /Users/wangpeng/Library/Caches/Homebrew/downloads/c393e3a39326eab27929f0f2ce40cb425e78bd8812166e6d835a08a8bf0c5f56--pkg-config-0.29.2_3.big_sur.bottle.tar.gz==&gt; Downloading https://mirrors.tuna.tsinghua.edu.cn/homebrew-bottles/bottles/libpng-1.6.37.big_sur.bottle.tar.gzAlready downloaded: /Users/wangpeng/Library/Caches/Homebrew/downloads/3bd2e2a75fbfc893d9acc20eeafc5274e260ed2ca39483ccbb1450a734bc6775--libpng-1.6.37.big_sur.bottle.tar.gz==&gt; Downloading https://mirrors.tuna.tsinghua.edu.cn/homebrew-bottles/bottles/freetype-2.10.4.big_sur.bottle.tar.gzAlready downloaded: /Users/wangpeng/Library/Caches/Homebrew/downloads/1399fc577f7998623378e7bb01f8a716a43eff701304059936d592a76d5a4d31--freetype-2.10.4.big_sur.bottle.tar.gz==&gt; Downloading https://mirrors.tuna.tsinghua.edu.cn/homebrew-bottles/bottles/fontconfig-2.13.1.big_sur.bottle.tar.gzAlready downloaded: /Users/wangpeng/Library/Caches/Homebrew/downloads/3790f4e94c8e7c868307933e3445a1244aadd794adaa6ed5f743533334489f93--fontconfig-2.13.1.big_sur.bottle.tar.gz==&gt; Downloading https://mirrors.tuna.tsinghua.edu.cn/homebrew-bottles/bottles/jpeg-9d.big_sur.bottle.tar.gzAlready downloaded: /Users/wangpeng/Library/Caches/Homebrew/downloads/7ed5b41c2937740eca747a8077502454971fbbe02cfb5cfbd9b9e7379345d0cd--jpeg-9d.big_sur.bottle.tar.gz==&gt; Downloading https://mirrors.tuna.tsinghua.edu.cn/homebrew-bottles/bottles/libtiff-4.1.0_1.big_sur.bottle.tar.gz<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">####################################################################### 100.0%</span></span>==&gt; Downloading https://mirrors.tuna.tsinghua.edu.cn/homebrew-bottles/bottles/webp-1.1.0.big_sur.bottle.tar.gzAlready downloaded: /Users/wangpeng/Library/Caches/Homebrew/downloads/1ae441623b4c63d896b5566300b24c06d772ff9f2676d7c9bd692ff6b8e22edb--webp-1.1.0.big_sur.bottle.tar.gz==&gt; Downloading https://mirrors.tuna.tsinghua.edu.cn/homebrew-bottles/bottles/gd-2.3.0.big_sur.bottle.tar.gzAlready downloaded: /Users/wangpeng/Library/Caches/Homebrew/downloads/d71eed744db212a24cc7f607842253aacf0e1d25cd7891c884ec7ffc969162ac--gd-2.3.0.big_sur.bottle.tar.gz==&gt; Downloading https://mirrors.tuna.tsinghua.edu.cn/homebrew-bottles/bottles/libffi-3.3.big_sur.bottle.tar.gzAlready downloaded: /Users/wangpeng/Library/Caches/Homebrew/downloads/49892306006d42a1f69ae4b36ff44b37c8e7170f6cf73a20e97f10bf9fa10e72--libffi-3.3.big_sur.bottle.tar.gz==&gt; Downloading https://mirrors.tuna.tsinghua.edu.cn/homebrew-bottles/bottles/pcre-8.44.big_sur.bottle.tar.gzAlready downloaded: /Users/wangpeng/Library/Caches/Homebrew/downloads/9998b74590fa558f4c346e9770a62495d4aca8e992d0e883435e3574303ee241--pcre-8.44.big_sur.bottle.tar.gz==&gt; Downloading https://mirrors.tuna.tsinghua.edu.cn/homebrew-bottles/bottles/glib-2.66.2_1.big_sur.bottle.tar.gz<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">####################################################################### 100.0%</span></span>==&gt; Downloading https://mirrors.tuna.tsinghua.edu.cn/homebrew-bottles/bottles/jasper-2.0.22.big_sur.bottle.tar.gzAlready downloaded: /Users/wangpeng/Library/Caches/Homebrew/downloads/86ba13e63264cbcafb0dbec9e35960e2662f9e4bde0306bd52984bf487e6581a--jasper-2.0.22.big_sur.bottle.tar.gz==&gt; Downloading https://mirrors.tuna.tsinghua.edu.cn/homebrew-bottles/bottles/netpbm-10.86.17.big_sur.bottle.tar.gzAlready downloaded: /Users/wangpeng/Library/Caches/Homebrew/downloads/9f8fa63491038e9bb811b03f09660342641c7f8132169bdb3800631d8d2b189e--netpbm-10.86.17.big_sur.bottle.tar.gz==&gt; Downloading https://mirrors.tuna.tsinghua.edu.cn/homebrew-bottles/bottles/gts-0.7.6_2.big_sur.bottle.tar.gzAlready downloaded: /Users/wangpeng/Library/Caches/Homebrew/downloads/eab94b3870ce0c63232e9a992963c8a32ea53a7efa8a09e639066b40ae0a132b--gts-0.7.6_2.big_sur.bottle.tar.gz==&gt; Downloading https://mirrors.tuna.tsinghua.edu.cn/homebrew-bottles/bottles/lzo-2.10.big_sur.bottle.tar.gzAlready downloaded: /Users/wangpeng/Library/Caches/Homebrew/downloads/0020e09d8a2c473efa8db2af4b402358f5184578c801c7a7650de6c8bedca06a--lzo-2.10.big_sur.bottle.tar.gz==&gt; Downloading https://mirrors.tuna.tsinghua.edu.cn/homebrew-bottles/bottles/pixman-0.40.0.big_sur.bottle.tar.gzAlready downloaded: /Users/wangpeng/Library/Caches/Homebrew/downloads/ddf94c89d763f2c63c00ce2090ff16d5abd832ca0e1e9beb2245da3cc159ce41--pixman-0.40.0.big_sur.bottle.tar.gz==&gt; Downloading https://mirrors.tuna.tsinghua.edu.cn/homebrew-bottles/bottles/cairo-1.16.0_3.big_sur.bottle.tar.gzAlready downloaded: /Users/wangpeng/Library/Caches/Homebrew/downloads/8ad096f68fcc70615ff77f14b50eafbed94e4a261c7860dcda41ba25c7d12f52--cairo-1.16.0_3.big_sur.bottle.tar.gz==&gt; Downloading https://mirrors.tuna.tsinghua.edu.cn/homebrew-bottles/bottles/gdk-pixbuf-2.42.0.big_sur.bottle.tar.gzAlready downloaded: /Users/wangpeng/Library/Caches/Homebrew/downloads/fb191d15b537de812241fe664f4149209c4d58ce3fbdd5e98a292fe495420f39--gdk-pixbuf-2.42.0.big_sur.bottle.tar.gz==&gt; Downloading https://mirrors.tuna.tsinghua.edu.cn/homebrew-bottles/bottles/fribidi-1.0.10.big_sur.bottle.tar.gzAlready downloaded: /Users/wangpeng/Library/Caches/Homebrew/downloads/9013c8a0aeb1d2fee9a999ef14adfb2416fef4e8399d87a65d753d44a586427b--fribidi-1.0.10.big_sur.bottle.tar.gz==&gt; Downloading https://mirrors.tuna.tsinghua.edu.cn/homebrew-bottles/bottles/gobject-introspection-1.66.1_1.big_sur.bottle.tar.gzAlready downloaded: /Users/wangpeng/Library/Caches/Homebrew/downloads/a7f9a1bcb83a7d322e495d163f15b4b8f4d0c05649eeacfcef2681a23b3eb8dd--gobject-introspection-1.66.1_1.big_sur.bottle.tar.gz==&gt; Downloading https://mirrors.tuna.tsinghua.edu.cn/homebrew-bottles/bottles/graphite2-1.3.14.big_sur.bottle.tar.gzAlready downloaded: /Users/wangpeng/Library/Caches/Homebrew/downloads/5ce053636ab73845d956142cfd518a21701d3ec972e73367d204b81619b8b845--graphite2-1.3.14.big_sur.bottle.tar.gz==&gt; Downloading https://mirrors.tuna.tsinghua.edu.cn/homebrew-bottles/bottles/icu4c-67.1.big_sur.bottle.tar.gzAlready downloaded: /Users/wangpeng/Library/Caches/Homebrew/downloads/ddca8d436054c0f9c8c333d2e8dd957ccd3902680baf619e4baed434c9806998--icu4c-67.1.big_sur.bottle.tar.gz==&gt; Downloading https://mirrors.tuna.tsinghua.edu.cn/homebrew-bottles/bottles/harfbuzz-2.7.2.big_sur.bottle.tar.gzAlready downloaded: /Users/wangpeng/Library/Caches/Homebrew/downloads/1aead0f1ab97b4307a9c487a3191213ff63fd200d5eb9be947a11e8ca78df24a--harfbuzz-2.7.2.big_sur.bottle.tar.gz==&gt; Downloading https://mirrors.tuna.tsinghua.edu.cn/homebrew-bottles/bottles/pango-1.48.0.big_sur.bottle.tar.gzAlready downloaded: /Users/wangpeng/Library/Caches/Homebrew/downloads/eded163bf136aa7a73e07f22c8b16f3a406bbd849b865246a95ee89ecd60aa4e--pango-1.48.0.big_sur.bottle.tar.gz==&gt; Downloading https://mirrors.tuna.tsinghua.edu.cn/homebrew-bottles/bottles/librsvg-2.50.2.big_sur.bottle.tar.gz<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">##################################################                       71.3%</span></span>curl: (18) transfer closed with 11492026 bytes remaining to readError: Failed to download resource &quot;librsvg&quot;Download failed: https://mirrors.tuna.tsinghua.edu.cn/homebrew-bottles/bottles/librsvg-2.50.2.big_sur.bottle.tar.gzWarning: Bottle installation failed: building from source.==&gt; Downloading https://download.gnome.org/sources/librsvg/2.50/librsvg-2.50.2.tar.xzAlready downloaded: /Users/wangpeng/Library/Caches/Homebrew/downloads/0388827e738392e3705cbb8800e43f279723caf5126ba50c7cd4e1ca5e2af872--librsvg-2.50.2.tar.xz==&gt; Downloading https://mirrors.tuna.tsinghua.edu.cn/homebrew-bottles/bottles/libtool-2.4.6_2.big_sur.bottle.tar.gzAlready downloaded: /Users/wangpeng/Library/Caches/Homebrew/downloads/59a8e4e9bff6153b4cb25fda4de99648330e04fefdd7e9c98f92fa4d049a9f30--libtool-2.4.6_2.big_sur.bottle.tar.gz==&gt; Downloading https://www2.graphviz.org/Packages/stable/portable_source/graphviz-2.44.1.tar.gz<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">###################                                                      28.5%</span></span><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">####################################################################### 100.0%</span></span>==&gt; Installing dependencies for graphviz: autoconf, automake, pkg-config, libpng, freetype, fontconfig, jpeg, libtiff, webp, gd, libffi, pcre, glib, jasper, netpbm, gts, lzo, pixman, cairo, gdk-pixbuf, fribidi, gobject-introspection, graphite2, icu4c, harfbuzz, pango, librsvg and libtool==&gt; Installing graphviz dependency: autoconf==&gt; Pouring autoconf-2.69.big_sur.bottle.4.tar.gz🍺  /usr/local/Cellar/autoconf/2.69: 68 files, 3.0MB==&gt; Installing graphviz dependency: automake==&gt; Pouring automake-1.16.3.big_sur.bottle.tar.gz🍺  /usr/local/Cellar/automake/1.16.3: 131 files, 3.4MB==&gt; Installing graphviz dependency: pkg-config==&gt; Pouring pkg-config-0.29.2_3.big_sur.bottle.tar.gz🍺  /usr/local/Cellar/pkg-config/0.29.2_3: 11 files, 656.6KB==&gt; Installing graphviz dependency: libpng==&gt; Pouring libpng-1.6.37.big_sur.bottle.tar.gz🍺  /usr/local/Cellar/libpng/1.6.37: 27 files, 1.3MB==&gt; Installing graphviz dependency: freetype==&gt; Pouring freetype-2.10.4.big_sur.bottle.tar.gz🍺  /usr/local/Cellar/freetype/2.10.4: 64 files, 2.3MB==&gt; Installing graphviz dependency: fontconfig==&gt; Pouring fontconfig-2.13.1.big_sur.bottle.tar.gz==&gt; Regenerating font cache, this may take a while==&gt; /usr/local/Cellar/fontconfig/2.13.1/bin/fc-cache -frv🍺  /usr/local/Cellar/fontconfig/2.13.1: 531 files, 3.6MB==&gt; Installing graphviz dependency: jpeg==&gt; Pouring jpeg-9d.big_sur.bottle.tar.gz🍺  /usr/local/Cellar/jpeg/9d: 21 files, 953.8KB==&gt; Installing graphviz dependency: libtiff==&gt; Pouring libtiff-4.1.0_1.big_sur.bottle.tar.gz🍺  /usr/local/Cellar/libtiff/4.1.0_1: 247 files, 4.2MB==&gt; Installing graphviz dependency: webp==&gt; Pouring webp-1.1.0.big_sur.bottle.tar.gz🍺  /usr/local/Cellar/webp/1.1.0: 39 files, 2.4MB==&gt; Installing graphviz dependency: gd==&gt; Pouring gd-2.3.0.big_sur.bottle.tar.gz🍺  /usr/local/Cellar/gd/2.3.0: 34 files, 1.4MB==&gt; Installing graphviz dependency: libffi==&gt; Pouring libffi-3.3.big_sur.bottle.tar.gz==&gt; Caveatslibffi is keg-only, which means it was not symlinked into /usr/local,because macOS already provides this software and installing another version inparallel can cause all kinds of trouble.For compilers to find libffi you may need to set:  export LDFLAGS=&quot;-L/usr/local/opt/libffi/lib&quot;  export CPPFLAGS=&quot;-I/usr/local/opt/libffi/include&quot;For pkg-config to find libffi you may need to set:  export PKG_CONFIG_PATH=&quot;/usr/local/opt/libffi/lib/pkgconfig&quot;==&gt; Summary🍺  /usr/local/Cellar/libffi/3.3: 17 files, 540.2KB==&gt; Installing graphviz dependency: pcre==&gt; Pouring pcre-8.44.big_sur.bottle.tar.gz🍺  /usr/local/Cellar/pcre/8.44: 204 files, 5.8MB==&gt; Installing graphviz dependency: glib==&gt; Pouring glib-2.66.2_1.big_sur.bottle.tar.gz🍺  /usr/local/Cellar/glib/2.66.2_1: 436 files, 15.5MB==&gt; Installing graphviz dependency: jasper==&gt; Pouring jasper-2.0.22.big_sur.bottle.tar.gz🍺  /usr/local/Cellar/jasper/2.0.22: 42 files, 1.5MB==&gt; Installing graphviz dependency: netpbm==&gt; Pouring netpbm-10.86.17.big_sur.bottle.tar.gz🍺  /usr/local/Cellar/netpbm/10.86.17: 410 files, 17.7MB==&gt; Installing graphviz dependency: gts==&gt; Pouring gts-0.7.6_2.big_sur.bottle.tar.gz🍺  /usr/local/Cellar/gts/0.7.6_2: 27 files, 1.4MB==&gt; Installing graphviz dependency: lzo==&gt; Pouring lzo-2.10.big_sur.bottle.tar.gz🍺  /usr/local/Cellar/lzo/2.10: 31 files, 570.7KB==&gt; Installing graphviz dependency: pixman==&gt; Pouring pixman-0.40.0.big_sur.bottle.tar.gz🍺  /usr/local/Cellar/pixman/0.40.0: 14 files, 1.3MB==&gt; Installing graphviz dependency: cairo==&gt; Pouring cairo-1.16.0_3.big_sur.bottle.tar.gz🍺  /usr/local/Cellar/cairo/1.16.0_3: 119 files, 5.9MB==&gt; Installing graphviz dependency: gdk-pixbuf==&gt; Pouring gdk-pixbuf-2.42.0.big_sur.bottle.tar.gz==&gt; /usr/local/Cellar/gdk-pixbuf/2.42.0/bin/gdk-pixbuf-query-loaders --update-cache🍺  /usr/local/Cellar/gdk-pixbuf/2.42.0: 149 files, 3.8MB==&gt; Installing graphviz dependency: fribidi==&gt; Pouring fribidi-1.0.10.big_sur.bottle.tar.gz🍺  /usr/local/Cellar/fribidi/1.0.10: 67 files, 669.0KB==&gt; Installing graphviz dependency: gobject-introspection==&gt; Pouring gobject-introspection-1.66.1_1.big_sur.bottle.tar.gz🍺  /usr/local/Cellar/gobject-introspection/1.66.1_1: 191 files, 12.7MB==&gt; Installing graphviz dependency: graphite2==&gt; Pouring graphite2-1.3.14.big_sur.bottle.tar.gz🍺  /usr/local/Cellar/graphite2/1.3.14: 18 files, 291.7KB==&gt; Installing graphviz dependency: icu4c==&gt; Pouring icu4c-67.1.big_sur.bottle.tar.gz==&gt; Caveatsicu4c is keg-only, which means it was not symlinked into /usr/local,because macOS provides libicucore.dylib (but nothing else).If you need to have icu4c first in your PATH run:  echo &#x27;export PATH=&quot;/usr/local/opt/icu4c/bin:$PATH&quot;&#x27; &gt;&gt; ~/.zshrc  echo &#x27;export PATH=&quot;/usr/local/opt/icu4c/sbin:$PATH&quot;&#x27; &gt;&gt; ~/.zshrcFor compilers to find icu4c you may need to set:  export LDFLAGS=&quot;-L/usr/local/opt/icu4c/lib&quot;  export CPPFLAGS=&quot;-I/usr/local/opt/icu4c/include&quot;For pkg-config to find icu4c you may need to set:  export PKG_CONFIG_PATH=&quot;/usr/local/opt/icu4c/lib/pkgconfig&quot;==&gt; Summary🍺  /usr/local/Cellar/icu4c/67.1: 258 files, 71.8MB==&gt; Installing graphviz dependency: harfbuzz==&gt; Pouring harfbuzz-2.7.2.big_sur.bottle.tar.gz🍺  /usr/local/Cellar/harfbuzz/2.7.2: 68 files, 6.4MB==&gt; Installing graphviz dependency: pango==&gt; Pouring pango-1.48.0.big_sur.bottle.tar.gz🍺  /usr/local/Cellar/pango/1.48.0: 64 files, 3MB==&gt; Installing graphviz dependency: librsvg==&gt; Pouring librsvg-2.50.2.big_sur.bottle.tar.gztar: Error opening archive: Failed to open &#x27;/Users/wangpeng/Library/Caches/Homebrew/downloads/3eb605900a29b02eb026199f14474efc43e313ee2b9de389706c795eebdc24f5--librsvg-2.50.2.big_sur.bottle.tar.gz&#x27;Error: Failure while executing; `tar xof /Users/wangpeng/Library/Caches/Homebrew/downloads/3eb605900a29b02eb026199f14474efc43e313ee2b9de389706c795eebdc24f5--librsvg-2.50.2.big_sur.bottle.tar.gz -C /var/folders/zs/2875szcx7jn6lbmqd0jfbprr0000gn/T/d20210302-22554-102pbtw` exited with 1. Here&#x27;s the output:tar: Error opening archive: Failed to open &#x27;/Users/wangpeng/Library/Caches/Homebrew/downloads/3eb605900a29b02eb026199f14474efc43e313ee2b9de389706c795eebdc24f5--librsvg-2.50.2.big_sur.bottle.tar.gz&#x27;Warning: Bottle installation failed: building from source.==&gt; Installing dependencies for librsvg: libssh2 and rust==&gt; Installing librsvg dependency: libssh2==&gt; Pouring libssh2-1.9.0_1.big_sur.bottle.tar.gztar: Error opening archive: Failed to open &#x27;/Users/wangpeng/Library/Caches/Homebrew/downloads/45db0c196aa97bf6c0a9c6e7787ad2cd0d14d563c03d0f4e0d52392a0f3a1c81--libssh2-1.9.0_1.big_sur.bottle.tar.gz&#x27;Error: Failure while executing; `tar xof /Users/wangpeng/Library/Caches/Homebrew/downloads/45db0c196aa97bf6c0a9c6e7787ad2cd0d14d563c03d0f4e0d52392a0f3a1c81--libssh2-1.9.0_1.big_sur.bottle.tar.gz -C /var/folders/zs/2875szcx7jn6lbmqd0jfbprr0000gn/T/d20210302-22554-qzrgbb` exited with 1. Here&#x27;s the output:tar: Error opening archive: Failed to open &#x27;/Users/wangpeng/Library/Caches/Homebrew/downloads/45db0c196aa97bf6c0a9c6e7787ad2cd0d14d563c03d0f4e0d52392a0f3a1c81--libssh2-1.9.0_1.big_sur.bottle.tar.gz&#x27;Warning: Bottle installation failed: building from source.==&gt; Downloading https://libssh2.org/download/libssh2-1.9.0.tar.gz<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">####################################################################### 100.0%</span></span>==&gt; ./configure --prefix=/usr/local/Cellar/libssh2/1.9.0_1 --disable-examples-build --with-openssl --with-libz --with-libssl-prefix=/usr/local/opt/openssl@1.1==&gt; make install🍺  /usr/local/Cellar/libssh2/1.9.0_1: 184 files, 969.9KB, built in 33 seconds==&gt; Installing librsvg dependency: rust==&gt; Pouring rust-1.47.0.big_sur.bottle.tar.gztar: Error opening archive: Failed to open &#x27;/Users/wangpeng/Library/Caches/Homebrew/downloads/f1482d118ddb120ff152e8f8aa88afa9bebc5674cc42aebca96249cffbdd8bdb--rust-1.47.0.big_sur.bottle.tar.gz&#x27;Error: Failure while executing; `tar xof /Users/wangpeng/Library/Caches/Homebrew/downloads/f1482d118ddb120ff152e8f8aa88afa9bebc5674cc42aebca96249cffbdd8bdb--rust-1.47.0.big_sur.bottle.tar.gz -C /var/folders/zs/2875szcx7jn6lbmqd0jfbprr0000gn/T/d20210302-22554-16tqegl` exited with 1. Here&#x27;s the output:tar: Error opening archive: Failed to open &#x27;/Users/wangpeng/Library/Caches/Homebrew/downloads/f1482d118ddb120ff152e8f8aa88afa9bebc5674cc42aebca96249cffbdd8bdb--rust-1.47.0.big_sur.bottle.tar.gz&#x27;Warning: Bottle installation failed: building from source.==&gt; Downloading https://static.rust-lang.org/dist/rustc-1.47.0-src.tar.gz<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">####################################################################### 100.0%</span></span>==&gt; ./configure --prefix=/usr/local/Cellar/rust/1.47.0 --release-channel=stable==&gt; makeLast 15 lines from /Users/wangpeng/Library/Logs/Homebrew/rust/02.make:error: failed to get `cc` as a dependency of package `bootstrap v0.0.0 (/private/tmp/rust-20210302-29879-dftrmf/rustc-1.47.0-src/src/bootstrap)`Caused by:  failed to fetch `https://github.com/rust-lang/crates.io-index`Caused by:  network failure seems to have happened  if a proxy or similar is necessary `net.git-fetch-with-cli` may help here  https://doc.rust-lang.org/cargo/reference/config.html#netgit-fetch-with-cliCaused by:  http parser error: stream ended at an unexpected time; class=Http (34)failed to run: /private/tmp/rust-20210302-29879-dftrmf/rustc-1.47.0-src/build/x86_64-apple-darwin/stage0/bin/cargo build --manifest-path /private/tmp/rust-20210302-29879-dftrmf/rustc-1.47.0-src/src/bootstrap/Cargo.tomlBuild completed unsuccessfully in 0:33:17make: *** [all] Error 1READ THIS: https://docs.brew.sh/TroubleshootingThese open issues may also help:rust 1.50.0 https://github.com/Homebrew/homebrew-core/pull/70922Rust-dependent formulae on Apple Silicon - upstream issue tracker https://github.com/Homebrew/homebrew-core/issues/68301</code></pre>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【All】bloom-filter</title>
    <link href="/2021/03/30/bloom-filter/"/>
    <url>/2021/03/30/bloom-filter/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>【Redis】学习笔记</title>
    <link href="/2021/03/22/redis/"/>
    <url>/2021/03/22/redis/</url>
    
    <content type="html"><![CDATA[<blockquote><p>Remote DictIOnary Server（远程数据服务），是一个基于内存且支持持久化的高性能 key-value 数据库<a id="more"></a></p></blockquote><p><img src="/images/redis/top.png"></p><h3 id="Redis安装"><a href="#Redis安装" class="headerlink" title="Redis安装"></a>Redis安装</h3><h4 id="单机版redis环境安装"><a href="#单机版redis环境安装" class="headerlink" title="单机版redis环境安装"></a>单机版redis环境安装</h4><p>环境准备:</p><p>  系统：centos7 </p><h5 id="下载redis安装包"><a href="#下载redis安装包" class="headerlink" title="下载redis安装包"></a>下载redis安装包</h5><p>node01服务器执行以下命令下载redis安装包</p><pre><code class="hljs zsh"><span class="hljs-built_in">cd</span> /weitrue/softwget http://download.redis.io/releases/redis-6.0.1.tar.gz</code></pre><h5 id="解压redis压缩包到指定目录"><a href="#解压redis压缩包到指定目录" class="headerlink" title="解压redis压缩包到指定目录"></a>解压redis压缩包到指定目录</h5><pre><code class="hljs zsh"><span class="hljs-comment">#node01执行以下命令进行解压redis</span><span class="hljs-built_in">cd</span> /weitrue/softtar -zxvf redis-6.0.1.tar.gz -C ../install/</code></pre><h5 id="安装C程序运行环境"><a href="#安装C程序运行环境" class="headerlink" title="安装C程序运行环境"></a>安装C程序运行环境</h5><p>node01执行以下命令安装C程序运行环境</p><pre><code class="hljs shell">su rootyum -y install gcc-c++<span class="hljs-meta">#</span><span class="bash"> 查看gcc版本是否在5.3以上，centos7.6默认安装4.8.5</span>gcc -v<span class="hljs-meta">#</span><span class="bash"> 升级gcc到5.3及以上,如下：</span><span class="hljs-meta">#</span><span class="bash">升级到gcc 9.3：</span>yum -y install centos-release-sclyum -y install devtoolset-9-gcc devtoolset-9-gcc-c++ devtoolset-9-binutilsscl enable devtoolset-9 bash需要注意的是scl命令启用只是临时的，退出shell或重启就会恢复原系统gcc版本。如果要长期使用gcc 9.3的话：echo &quot;source /opt/rh/devtoolset-9/enable&quot; &gt;&gt;/etc/profile<span class="hljs-meta">#</span><span class="bash">这样退出shell重新打开就是新版的gcc了</span></code></pre><h5 id="安装较新版本的tcl"><a href="#安装较新版本的tcl" class="headerlink" title="安装较新版本的tcl"></a>安装较新版本的tcl</h5><p>下载安装较新版本的tcl</p><h6 id="使用压缩包进行安装（不推荐）"><a href="#使用压缩包进行安装（不推荐）" class="headerlink" title="使用压缩包进行安装（不推荐）"></a>使用压缩包进行安装（不推荐）</h6><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">node01执行以下命令下载tcl安装包</span>cd /weitrue/softwget http://downloads.sourceforge.net/tcl/tcl8.6.1-src.tar.gz<span class="hljs-meta">#</span><span class="bash">解压tcl</span>tar -zxvf tcl8.6.1-src.tar.gz -C ../install/<span class="hljs-meta">#</span><span class="bash">进入指定目录</span>cd ../install/tcl8.6.1/unix/./configuremake  &amp;&amp; make  install</code></pre><h6 id="在线安装tcl（墙裂推荐）"><a href="#在线安装tcl（墙裂推荐）" class="headerlink" title="在线安装tcl（墙裂推荐）"></a>在线安装tcl（墙裂推荐）</h6><p>node01执行以下命令在线安装tcl</p><pre><code class="hljs shell">sudo yum  -y  install  tcl</code></pre><h5 id="进行编译redis"><a href="#进行编译redis" class="headerlink" title="进行编译redis"></a>进行编译redis</h5><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> node01执行以下命令进行编译：</span>cd /weitrue/install/redis-6.0.1/<span class="hljs-meta">#</span><span class="bash"> make MALLOC=libc   或者使用命令  make  进行编译</span>make test &amp;&amp; make install</code></pre><h5 id="修改redis配置文件"><a href="#修改redis配置文件" class="headerlink" title="修改redis配置文件"></a>修改redis配置文件</h5><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> node01执行以下命令修改redis配置文件</span>cd /weitrue/install/redis-6.0.1/mkdir -p /weitrue/install/redis-6.0.1/logsmkdir -p /weitrue/install/redis-6.0.1/redisdatavim redis.confbind node01daemonize yespidfile /weitrue/install/redis-6.0.1/redis_6379.pidlogfile &quot;/weitrue/install/redis-6.0.1/logs/redis.log&quot;dir /weitrue/install/redis-6.0.1/redisdata</code></pre><p><code>daemonize yes</code>: redis采用的是单进程多线程的模式。<br>当redis.conf中选项daemonize设置成yes时，代表开启守护进程模式。在该模式下，redis会在后台运行，并将进程pid号写入至redis.conf选项pidfile设置的文件中，此时redis将一直运行，除非手动kill该进程。<br><code>daemonize no</code>: 当daemonize选项设置成no时，当前界面将进入redis的命令行界面，exit强制退出或者关闭连接工具(putty,xshell等)都会导致redis进程退出。</p><h5 id="启动redis"><a href="#启动redis" class="headerlink" title="启动redis"></a>启动redis</h5><p>node01执行以下命令启动redis</p><pre><code class="hljs shell">cd  /weitrue/install/redis-6.0.1src/redis-server  redis.conf<span class="hljs-meta">#</span><span class="bash"> 查看进程</span>ps aux|grep redis或者ps -ef | grep redis | grep -v &quot;grep&quot;  # 加上| grep -v &quot;grep&quot;，是指不看grep进程</code></pre><h5 id="连接redis客户端"><a href="#连接redis客户端" class="headerlink" title="连接redis客户端"></a>连接redis客户端</h5><p>node01执行以下命令连接redis客户端</p><pre><code class="hljs shell">cd /weitrue/install/redis-6.0.1src/redis-cli -h node01</code></pre><h4 id="redis的操作命令"><a href="#redis的操作命令" class="headerlink" title="redis的操作命令"></a>redis的操作命令</h4><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">检测redis服务是否启动</span>PING<span class="hljs-meta">#</span><span class="bash">设置key、value</span>SET KEY_NAME VALUE<span class="hljs-meta">#</span><span class="bash">删除</span>del key<span class="hljs-meta">#</span><span class="bash">获取key是否存在</span>exists key<span class="hljs-meta">#</span><span class="bash">获取key的类型</span>type key<span class="hljs-meta">#</span><span class="bash">为key改名</span>rename key newkeyrenamenx key newkey<span class="hljs-meta">#</span><span class="bash">切换数据库</span>select index<span class="hljs-meta">#</span><span class="bash">退出客户端</span>quit</code></pre><h3 id="redis的数据类型"><a href="#redis的数据类型" class="headerlink" title="redis的数据类型"></a><strong>redis的数据类型</strong></h3><p>Redis支持的常用5种数据类型指的是value类型，分别为：<strong>字符串String、列表List、哈希Hash、集合Set、有序集合Zset</strong>，但是Redis后续又丰富了几种数据类型分别是Bitmaps、HyperLogLogs、GEO。</p><p> 由于Redis是基于标准C写的，只有最基础的数据类型，因此Redis为了满足对外使用的5种数据类型，开发了属于自己<strong>独有的一套基础数据结构</strong>，使用这些数据结构来实现5种数据类型。</p><p>Redis为了平衡空间和时间效率，针对value的具体类型在底层会采用不同的数据结构来实现，其中哈希表和压缩列表是复用比较多的数据结构，如下图展示了对外数据类型和底层数据结构之间的映射关系：</p><p><img src="/images/redis/wps4.jpg"></p><p>从图中可以看到ziplist压缩列表可以作为Zset、Set、List三种数据类型的底层实现，看来很强大，压缩列表是一种为了节约内存而开发的且经过特殊编码之后的连续内存块顺序型数据结构，底层结构还是比较复杂的。</p><h4 id="redis当中各种数据类型的操作"><a href="#redis当中各种数据类型的操作" class="headerlink" title="redis当中各种数据类型的操作"></a>redis当中各种数据类型的操作</h4><p>redis自身是一个Map，其中所有的数据都是采用key : value 的形式存储</p><p><img src="/images/redis/image-20200529015634835.png"></p><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><pre><code class="hljs plain">存储的数据：单个数据，最简单的数据存储类型，也是最常用的数据存储类型存储数据的格式：一个存储空间保存一个数据存储内容：通常使用字符串，如果字符串以整数的形式展示，可以作为数字操作使用</code></pre><p><img src="/images/redis/image-20200529020001463.png"></p><p>下表列出了常用的 redis 字符串命令</p><pre><code class="hljs shell">1.SET key value: 设置指定`key`的值,O(1)。示例：`SET hello world`2.GET key:获取指定`key`的值,O(1)。示例：`GET hello`3.GETRANGE key start end:返回`key`中字符串值的子字符,包含end。示例：`GETRANGE hello 0 3`4.GETSET key value:将给定`key`的值设为`value`，并返回`key`的旧值(old value)。示例：`GETSET hello world2`5.MGET key1 [key2...]:获取所有(一个或多个)给定`key`的值。示例：`MGET hello world`6.SETEX key seconds value:将值`value`关联到`key`，并将`key`的过期时间设为 seconds (以秒为单位)。示例：`SETEX hello 10 world3`7.SETNX key value: 只有在`key`不存在时设置`key`的值。示例：`SETNX weitrue 1`8.SETRANGE key offset value: 用 value 参数覆写给定 key 所储存的字符串值，从偏移量`offset`开始。示例：`SETRANGE weitrue 0 helloredis`9.STRLEN key: 返回`key所储存的字符串值的长度,O(1)。示例：`STRLEN weitrue`10.MSET key value [key value ...]:同时设置一个或多个`key-value`对，原子操作。示例：`MSET weitrue2 weitruevalue2 weitrue3 weitruevalue3`11.MSETNX key value [key value ...]:同时设置一个或多个`key-value`对，当且仅当所有给定 key 都不存在。示例：`MSETNX weitrue4 weitruevalue4 weitrue5 weitruevalue5`12.PSETEX key milliseconds value:这个命令和 SETEX 命令相似，但它以毫秒为单位设置`key`的生存时间，而不是像`SETEX`命令那样，以秒为单位。示例：`PSETEX weitrue6 6000 weitrue6value`13.INCR key:将 key 中储存的数字值增一, 可用于分布式id等。示例：`set weitrue 1`,`INCR weitrue`,`GET weitrue` 14.INCRBY key increment:将`key`所储存的值加上给定的增量值（increment）。示例：`INCRBY weitrue 2`, `get weitrue`15.INCRBYFLOAT key increment: 将`key`所储存的值加上给定的浮点增量值（increment）。示例：`INCRBYFLOAT weitrue 0.8`16.DECR key:将`key`中储存的数字值减一。示例：`set weitrue 1`, `DECR weitrue`, `GET weitrue`17.DECRBY key: `key`所储存的值减去给定的减量值（decrement） 。示例：`DECRBY weitrue 3`18.APPEND key value: 如果`key`已经存在并且是一个字符串， APPEND 命令将指定的`value`追加到该`key`原来值（value）的末尾。示例：`APPEND weitrue hello`</code></pre><h4 id="对key的操作"><a href="#对key的操作" class="headerlink" title="对key的操作"></a>对key的操作</h4><p>下表给出了与 Redis 键相关的基本命令：</p><ul><li><code>dbsize</code>：计算key的总数，O(1)</li></ul><pre><code class="hljs shell">DEL key: 该命令用于在`key`存在时删除`key`。示例：`del weitrue`DUMP key: 序列化给定`key`，并返回被序列化的值。示例：`DUMP key`EXISTS key: 检查给定 key 是否存在。示例：`exists weitrue`EXPIRE key seconds: 为给定`key`设置过期时间，以秒计。示例：`expire weitrue 5`PEXPIRE key milliseconds: 设置`key`的过期时间以毫秒计。示例：`PEXPIRE set2 3000000`KEYS pattern: 查找所有符合给定模式(pattern)的`key`。示例：`keys *`PERSIST key: 移除`key`的过期时间，`key`将持久保持。示例：`persist set2`PTTL key: 以毫秒为单位返回`key`的剩余的过期时间。示例：`pttl  set2`TTL key: 以秒为单位，返回给定`key`的剩余生存时间(TTL, time to live)。示例：`ttl set2`RANDOMKEY: 从当前数据库中随机返回一个`key`。示例： `randomkey`RENAME key newkey: 修改`key`的名称示例：`rename set5 set8`RENAMENX key newkey: 仅当`newkey`不存在时，将`key`改名为`newkey`。示例：`renamenx  set8 set10`TYPE key: 返回`key`所储存的值的类型。示例：`type  set10`</code></pre><h4 id="hash列表的操作"><a href="#hash列表的操作" class="headerlink" title="hash列表的操作"></a>hash列表的操作</h4><pre><code class="hljs angelscript">Redis hash 是一个<span class="hljs-built_in">string</span>类型的field和value的映射表，hash特别适合用于存储对象。Redis 中每个 hash 可以存储 <span class="hljs-number">232</span> - <span class="hljs-number">1</span> 键值对（<span class="hljs-number">40</span>多亿）</code></pre><p>下表列出了 redis hash 基本的相关命令：</p><pre><code class="hljs shell">HSET key field value: 将哈希表 `key` 中的字段 `field` 的值设为 `value` 。示例：`HSET key1 field1 value1`HSETNX key field value: 只有在字段 `field` 不存在时，设置哈希表字段的值。示例：`HSETNX key1 field2 value2`HMSET key field1 value1 [field2 value2 ...]: 同时将多个`field-value`(域-值)对设置到哈希表`key`中, O(n)。示例：`HMSET key1 field3 value3 field4 value4`HEXISTS key field: 查看哈希表`key`中，指定的字段是否存在。示例：`HEXISTS key1 field4HEXISTS key1 field6`HGET key field: 获取存储在哈希表中指定字段的值。示例：`HGET key1 field4`HGETALL key: 获取在哈希表中指定 `key` 的所有字段和值。示例：`HGETALL key1`HKEYS key: 获取所有哈希表中的字段。示例：`HKEYS key1`HLEN key: 获取哈希表中字段的数量。示例：`HLEN key1`HMGET key field1 [field2 ...]: 获取所有给定字段的值, O(n)。示例：`HMGET key1 field1 field2`HINCRBY key field increment: 为哈希表`key`中的指定字段的整数值加上增量`increment`。示例：`HSET key2 field1 1HINCRBY key2 field1 1HGET key2 field1`HINCRBYFLOAT key field increment: 为哈希表`key`中的指定字段的浮点数值加上增量`increment`。示例：`HINCRBYFLOAT key2 field1 0.8`HVALS key: 获取哈希表中所有值。示例：`HVALS key1`HDEL key field1 [field2 ...]: 删除一个或多个哈希表字段。示例：`HDEL key1 field1HVALS key1`</code></pre> <pre><code class="hljs shell">node01:6379&gt; HSET app:mytest1 test1 &quot;123&quot;OKnode01:6379&gt; HGET app:mytest test1&quot;123&quot;</code></pre><h4 id="list列表的操作"><a href="#list列表的操作" class="headerlink" title="list列表的操作"></a>list列表的操作</h4> <pre><code class="hljs angelscript">Redis列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）一个列表最多可以包含 <span class="hljs-number">232</span> - <span class="hljs-number">1</span> 个元素 (<span class="hljs-number">4294967295</span>, 每个列表超过<span class="hljs-number">40</span>亿个元素)。</code></pre><p>下表列出了列表相关的基本命令:</p><pre><code class="hljs shell">LPUSH key value1 [value2]: 将一个或多个值插入到列表头部。示例：`LPUSH list1 value1 value2`LRANGE key start stop: 查看list当中指定范围（包含stop）的数据。示例：`LRANGE list1 0 -1`LPUSHX key value: 将一个值插入到已存在的列表头部。示例：`LPUSHX list1 value3` `LINDEX list1 0`RPUSH key value1 [value2]: 在列表中添加一个或多个值。示例：`RPUSH list1 value4 value5` `LRANGE list1 0 -1`RPUSHX key value: 为已存在的列表添加值。示例：`RPUSHX list1 value6`LINSERT key BEFORE|AFTER pivot value: 在列表的元素前或者后插入元素。示例：`LINSERT list1 BEFORE value3 beforevalue3`LINDEX key index: 通过索引获取列表中的元素, O(n)。示例：`LINDEX list1 0`LSET key index value: 通过索引设置列表元素的值, O(n)。示例：`LSET list1 0 hello`LLEN key: 获取列表长度。示例：`LLEN list1`LPOP key: 移出并获取列表的第一个元素。示例：`LPOP list1`RPOP key: 移除列表的最后一个元素，返回值为移除的元素。示例：`RPOP list1`BLPOP key1 [key2 ...] timeout: 移出并获取列表的第一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。示例：`BLPOP list1 2000`BRPOP key1 [key2 ...] timeout: 移出并获取列表的最后一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。示例：`BRPOP list1 2000`RPOPLPUSH source destination: 移除列表的最后一个元素，并将该元素添加到另一个列表并返回。示例：`RPOPLPUSH list1 list2`BRPOPLPUSH source destination timeout: 从列表中弹出一个值，将弹出的元素插入到另外一个列表中并返回它； 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。示例：`BRPOPLPUSH list1 list2 2000`LTRIM key start stop: 对一个列表进行修剪(trim)，就是说，让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除。示例：`LTRIM list1 0 2`DEL key1 key2: 删除指定key的列表。示例：`DEL list2`</code></pre><pre><code class="hljs routeros">Tips:LPUSH + LPOP = STACKLPUSH + RPOP = QUEUELPUSH + LTRIM = 固定大小集合或者LRULPUSH + BRPOP = 消息队列</code></pre><h4 id="set集合"><a href="#set集合" class="headerlink" title="set集合"></a>set集合</h4> <pre><code class="hljs angelscript">redis 的 Set 是 String 类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。Redis 中集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(<span class="hljs-number">1</span>)。集合中最大的成员数为 <span class="hljs-number">232</span> - <span class="hljs-number">1</span> (<span class="hljs-number">4294967295</span>, 每个集合可存储<span class="hljs-number">40</span>多亿个成员)。</code></pre><p>下表列出了 Redis 集合基本命令：</p><pre><code class="hljs shell">SADD key member1 [member2 ...]: 向集合添加一个或多个成员。示例：`SADD set1 setvalue1 setvalue2`SMEMBERS key: 返回集合中的所有成员。示例：`SMEMBERS set1`SCARD key: 获取集合的成员数。示例：`SCARD set1`SDIFF key1 [key2 ...]: 返回给定所有集合的差集。示例：`SADD set2 setvalue2 setvalue3SDIFF set1 set2`SDIFFSTORE destkey key1 [key2 ...]: 返回给定所有集合的差集并存储在 destkey 中。示例：`SDIFFSTORE set3 set1 set2`SINTER key1 [key2 ...]: 返回给定所有集合的交集。示例：`SINTER set1 set2`SINTERSTORE destkey key1 [key2 ...]: 返回给定所有集合的交集并存储在`destkey`中。示例：`SINTERSTORE set4 set1 set2`SISMEMBER key member: 判断 member 元素是否是集合`key`的成员。示例：`SISMEMBER set1 setvalue1`SMOVE sourcekey destkey member: 将`member`元素从`sourcekey`集合移动到`destkey`集合。示例：`SMOVE set1 set2 setvalue1`SPOP key: 移除并返回集合中的一个随机元素。示例：`SPOP set2`SRANDMEMBER key [count ...]: 返回集合中一个或多个随机数。示例：`SRANDMEMBER set2 2`SREM key member1 [member2 ...]: 移除集合中一个或多个成员。示例：`SREM set2 setvalue1`SUNION key1 [key2 ...]: 返回所有给定集合的并集。示例：`SUNION set1 set2`SUNIONSTORE destkey key1 [key2 ...]: 所有给定集合的并集存储在`destkey`集合中。示例：`SUNIONSTORE set5 set1 set2`</code></pre><h4 id="zset集合"><a href="#zset集合" class="headerlink" title="zset集合"></a>zset集合</h4><p>下表列出了 redis 有序集合的基本命令:</p><pre><code class="hljs shell">ZADD key score1 member1 [score2 member2 ...]: 向有序集合添加一个或多个成员，或者更新已存在成员的分数。例如：`ADD zset1 90 ze1`ZCARD key: 获取有序集合的成员数。例如：`zcard zset1`ZCOUNT key min max: 计算在有序集合中指定区间分数的成员数。例如：`zcount zset1 90 91`ZINCRBY key increment member: 有序集合中对指定成员的分数加上增量`increment`。例如：`zincrby zset1 1 ze1`ZINTERSTORE destkey numkeys key [key ...]: 计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合 destkey 中。例如：`ZINTERSTORE destkey 1 zset1`ZLEXCOUNT key min max: 在有序集合中计算指定字典区间内成员数量。例如：``ZRANGE key start stop [WITHSCORES]: 通过索引区间返回有序集合指定区间内的成员。例如：`ZRANGE destkey 0 -1`ZRANGEBYLEX key min max [LIMIT offset count]: 通过字典区间返回有序集合的成员。例如：node02:15&gt;ZADD myzset 0 a 0 b 0 c 0 d 0 e 0 f 0 g&quot;7&quot;node02:15&gt;ZRANGEBYLEX myzset - [c 1)  &quot;a&quot; 2)  &quot;b&quot; 3)  &quot;c&quot;ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT]: 通过分数返回有序集合指定区间内的成员。例如：`ZRANGEBYSCORE zset1 90 99`ZRANK key member: 返回有序集合中指定成员的索引。例如：`ZRANK zset1 ze1`ZREM key member [member ...]: 移除有序集合中的一个或多个成员。例如：`ZREM destkey ze2`ZREMRANGEBYLEX key min max]: 移除有序集合中给定的字典区间的所有成员。例如：node02:15&gt;ZRANGE myzset 0 -1 1)  &quot;d&quot; 2)  &quot;e&quot; 3)  &quot;f&quot; 4)  &quot;g&quot;ZREMRANGEBYRANK key start stop: 移除有序集合中给定的排名区间的所有成员。例如：node02:15&gt;ZADD salary 2000 jack 5000 tom 3500 peter&quot;3&quot;node02:15&gt;ZREMRANGEBYRANK salary 0 1&quot;2&quot;ZREMRANGEBYSCORE key min max: 移除有序集合中给定的分数区间的所有成员。例如：node02:15&gt;ZREMRANGEBYSCORE salary 1500 3500&quot;2&quot;node02:15&gt;ZRANGE salary 0 -1 WITHSCORES 1)  &quot;tom&quot; 2)  &quot;5000&quot;ZREVRANGE key start stop [WITHSCORES]: 返回有序集中指定区间内的成员，通过索引，分数从高到低。例如：node02:15&gt;ZRANGE salary 0 -1 WITHSCORES 1)  &quot;jack&quot; 2)  &quot;2000&quot; 3)  &quot;peter&quot; 4)  &quot;3500&quot; 5)  &quot;tom&quot; 6)  &quot;5000&quot;node02:15&gt;ZREVRANGE salary 0 -1 WITHSCORES 1)  &quot;tom&quot; 2)  &quot;5000&quot; 3)  &quot;peter&quot; 4)  &quot;3500&quot; 5)  &quot;jack&quot; 6)  &quot;2000&quot;ZREVRANGEBYSCORE key max min [WITHSCORES]: 返回有序集中指定分数区间内的成员，分数从高到低排序。例如：node02:15&gt;ZREVRANGEBYSCORE salary 10000 2000 1)  &quot;tom&quot; 2)  &quot;peter&quot; 3)  &quot;jack&quot;ZREVRANK key member: 返回有序集合中指定成员的排名，有序集成员按分数值递减(从大到小)排序。例如：node02:15&gt;ZREVRANK salary peter&quot;1&quot;ZSCORE key member: 返回有序集中，成员的分数值。例如：node02:15&gt;ZSCORE salary peter&quot;3500&quot;ZUNIONSTORE destkey numkeys key [key ...]: 计算给定的一个或多个有序集的并集，并存储在新的 key 中。例如：node02:15&gt;ZADD zset1 1 &quot;one&quot;&quot;1&quot;node02:15&gt;ZADD zset1 2 &quot;two&quot;&quot;1&quot;node02:15&gt;ZADD zset2 1 &quot;one&quot;&quot;1&quot;node02:15&gt;ZADD zset2 2 &quot;two&quot;&quot;1&quot;node02:15&gt;ZADD zset2 3 &quot;three&quot;&quot;1&quot;node02:15&gt;ZUNIONSTORE out 2 zset1 zset2 WEIGHTS 2 3&quot;5&quot;node02:15&gt;ZRANGE out 0 -1 WITHSCORES 1)  &quot;one&quot; 2)  &quot;5&quot; 3)  &quot;three&quot; 4)  &quot;9&quot; 5)  &quot;two&quot; 6)  &quot;10&quot; 7)  &quot;ze1&quot; 8)  &quot;182&quot; 9)  &quot;ze2&quot; 10)  &quot;198&quot;ZSCAN key cursor [MATCH pattern] [COUNT count]: 迭代有序集合中的元素（包括元素成员和元素分值）。例如：node02:15&gt;ZSCAN out 0 match z* 1)  &quot;0&quot; 2)     1)   &quot;ze1&quot; 2)   &quot;182&quot; 3)   &quot;ze2&quot; 4)   &quot;198&quot;</code></pre><h5 id="Redis有序集合zset底层怎么实现的"><a href="#Redis有序集合zset底层怎么实现的" class="headerlink" title="Redis有序集合zset底层怎么实现的"></a>Redis有序集合zset底层怎么实现的</h5><p>Redis中的set数据结构底层用的是跳表实现的.</p><p>跳表是一个随机化的数据结构，实质就是一种可以进行二分查找的有序链表。</p><p>跳表在原有的有序链表上面增加了多级索引，通过索引来实现快速查找。</p><p>跳表不仅能提高搜索性能，同时也可以提高插入和删除操作的性能。</p><p>(1)跳表是可以实现二分查找的有序链表； (2)每个元素插入时随机生成它的level； (3)最低层包含所有的元素； (4)如果一个元素出现在level(x)，那么它肯定出现在x以下的level中； (5)每个索引节点包含两个指针，一个向下，一个向右； (6)跳表查询、插入、删除的时间复杂度为O(log n)，与平衡二叉树接近；</p><p>为什么Redis选择使用跳表而不是红黑树来实现有序集合？(O(logN))</p><p>首先，我们来分析下Redis的有序集合支持的操作：</p><ul><li>插入元素</li><li>删除元素</li><li>查找元素</li><li>有序输出所有元素</li><li>查找区间内所有元素</li></ul><p>其中，前4项红黑树都可以完成，且时间复杂度与跳表一致。但是，最后一项，红黑树的效率就没有跳表高了。 在跳表中，要查找区间的元素，我们只要定位到两个区间端点在最低层级的位置，然后按顺序遍历元素就可以了，非常高效。</p><p>而红黑树只能定位到端点后，再从首位置开始每次都要查找后继节点，相对来说是比较耗时的。 此外，跳表实现起来很容易且易读，红黑树实现起来相对困难，所以Redis选择使用跳表来实现有序集合。</p><h3 id="瑞士军刀"><a href="#瑞士军刀" class="headerlink" title="瑞士军刀"></a>瑞士军刀</h3><h4 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h4> <pre><code class="hljs shell">Redis 在 2.8.9 版本添加了 HyperLogLog 结构。Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的。在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。但是，因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。什么是基数?比如数据集 &#123;1, 3, 5, 7, 5, 7, 8&#125;， 那么这个数据集的基数集为 &#123;1, 3, 5 ,7, 8&#125;, 基数(不重复元素)为5。 基数估计就是在误差可接受的范围内，快速计算基数。</code></pre> <pre><code class="hljs shell">Redis HyperLogLog 命令下表列出了 redis HyperLogLog 的基本命令：1PFADD key element [element ...] node01:6379&gt;PFADD test 123添加指定元素到 HyperLogLog 中。2PFCOUNT key [key ...] node01:6379&gt;PFCOUNT test 返回给定 HyperLogLog 的基数估算值。3PFMERGE destkey sourcekey [sourcekey ...] node01:6379&gt;PFCOUNT kbv weitrue kkv   将多个 HyperLogLog 合并为一个 HyperLogLog</code></pre><h6 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h6><p><img src="/images/redis/hyperloglog.png"></p><p> 但是，这个统计是不准确的，官方给出错误率为0.81%</p><h4 id="pipeline"><a href="#pipeline" class="headerlink" title="pipeline"></a>pipeline</h4><ul><li><p>1次pipeline(n条命令) = 1次网络事件+n次命令时间.</p></li><li><p>pipeline命令 非<strong>原子</strong>原子命令,而原生批量命令<strong>m操作</strong>是原子命令。</p><p><img src="/images/redis/pipem.png"></p><p><img src="/images/redis/pipeline.png"></p></li><li><p>pipeline每次只能坐拥在一个redis节点。</p></li></ul><p>Java代码执行对比</p><pre><code class="hljs Java">        Jedis jedis = <span class="hljs-keyword">null</span>;        <span class="hljs-comment">// 连接池大小设置</span>        GenericObjectPoolConfig genericObjectPoolConfig = <span class="hljs-keyword">new</span> GenericObjectPoolConfig();        JedisPool jedisPool = <span class="hljs-keyword">new</span> JedisPool(genericObjectPoolConfig, <span class="hljs-string">&quot;node02&quot;</span>, <span class="hljs-number">6379</span>);        <span class="hljs-keyword">long</span> startTime = System.currentTimeMillis();        <span class="hljs-keyword">try</span>&#123;            jedis = jedisPool.getResource();            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;<span class="hljs-number">10000</span> ; i++) &#123;                jedis.hset(<span class="hljs-string">&quot;pip_test&quot;</span>, <span class="hljs-string">&quot;field&quot;</span>+i, <span class="hljs-string">&quot;value&quot;</span>+i);            &#125;        &#125;<span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125; <span class="hljs-keyword">finally</span> &#123;            <span class="hljs-keyword">if</span> (jedis != <span class="hljs-keyword">null</span>) &#123;                jedis.close();            &#125;        &#125;        System.out.println(System.currentTimeMillis() - startTime);        startTime = System.currentTimeMillis();        <span class="hljs-comment">// 使用pipeline</span><span class="hljs-keyword">try</span>&#123;            jedis = jedisPool.getResource();            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;                Pipeline pipelined = jedis.pipelined();                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i * <span class="hljs-number">100</span> ; j &lt;(i + <span class="hljs-number">1</span>) * <span class="hljs-number">100</span> ; j++) &#123;                    pipelined.hset(<span class="hljs-string">&quot;pip_test&quot;</span>, <span class="hljs-string">&quot;field&quot;</span>+j, <span class="hljs-string">&quot;value&quot;</span>+j);                &#125;                pipelined.syncAndReturnAll();            &#125;        &#125;<span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125; <span class="hljs-keyword">finally</span> &#123;            <span class="hljs-keyword">if</span> (jedis != <span class="hljs-keyword">null</span>) &#123;                jedis.close();            &#125;        &#125;        System.out.println(System.currentTimeMillis() - startTime);<span class="hljs-comment">// 输出</span><span class="hljs-number">12126</span><span class="hljs-number">165</span></code></pre><h4 id="bitmap-位图"><a href="#bitmap-位图" class="headerlink" title="bitmap(位图)"></a>bitmap(位图)</h4><p>redis可以直接操作位</p><p><img src="/images/redis/bitmap-big.png"></p><pre><code class="hljs shell">node02:15&gt;set bitkey big&quot;OK&quot;node02:15&gt;get bitkey&quot;big&quot;node02:15&gt;getbit bitkey 0&quot;0&quot;node02:15&gt;getbit bitkey 1&quot;1&quot;node02:15&gt;getbit bitkey 2&quot;1&quot;node02:15&gt;</code></pre><p>操作命令：</p><pre><code class="hljs shell">setbit key offset value            # 给位图指定索引位置设置值，value只能是0或1getbit key offset                  # 位图指定索引位置二进制值bitcount key [start end]           # 获取位图指定范围（start 到 end，单位为字节，不指定的话获取全部）位值为1的个数bitop op destkey key [key ...]     # 做多个bitmap的and（交集） or（并集） not（非） xor（异或）操作并将结果结果保存在destkey中bitpos key targetBit [start] [end] # 计算位图指定范围（start 到 end，单位为字节，不指定的话获取全部）第一个便宜量对应位置的值等于targetBit的位置</code></pre><p><img src="/images/redis/bitc.png"></p><p><img src="/images/redis/bit2.png"></p><h4 id="GEO"><a href="#GEO" class="headerlink" title="GEO"></a>GEO</h4><p>GEO: 地理信息定位。存储经纬度，计算距离、位置等。</p><p><code>type getKey = zset</code></p><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 增加地理位置信息</span>geoadd key longitude latitude member [longitude latitude member ...]node02:15&gt;geoadd cities:locations 116.28 39.55 beijing&quot;1&quot;node02:15&gt;geoadd cities:locations 117.12 39.08 tianjin&quot;1&quot;node02:15&gt;geoadd cities:locations 114.29 38.02 shijiazhuang 118.01 39.38 tangshan&quot;2&quot;<span class="hljs-meta">#</span><span class="bash"> 获取地理位置信息</span>geopos key member [member ...]node02:15&gt;geopos cities:locations beijing 1)     1)   &quot;116.28000229597091675&quot; 2)   &quot;39.5500007245470826&quot;<span class="hljs-meta">#</span><span class="bash"> 计算距离 unit:m(米),km(千米),mi(英里),ft(尺)</span>geodist key member1 member2 [unit]node02:15&gt;geodist cities:locations beijing tianjin&quot;89206.0576&quot;</code></pre><p><img src="/images/redis/georadius.png"></p><h3 id="redis的持久化"><a href="#redis的持久化" class="headerlink" title="redis的持久化"></a>redis的持久化</h3><p>由于redis是一个内存数据库，所有的数据都是保存在内存当中的，内存当中的数据极易丢失，所以redis的数据持久化就显得尤为重要。</p><p>什么是持久化呢?<br>利用永久性存储介质将数据进行保存，在特定的时间将保存的数据进行恢复的工作机制称为持久化。</p><p>为什么要进行持久化?<br>防止数据的意外丢失，确保数据安全性。</p><pre><code class="hljs angelscript">持久化过程:<span class="hljs-number">1.</span>将当前数据状态进行保存，快照形式，存储数据结果，存储格式简单，关注点在数据<span class="hljs-number">2.</span>将数据的操作过程进行保存，日志形式，存储操作过程，存储格式复杂，关注点在数据的操作过程</code></pre><p><img src="/images/redis/image-20200528230621178.png"></p><h4 id="RDB持久化"><a href="#RDB持久化" class="headerlink" title="RDB持久化"></a>RDB持久化</h4><pre><code class="hljs plain">Redis会定期保存数据快照至一个rbd文件中，并在启动时自动加载rdb文件，恢复之前保存的数据。</code></pre><h5 id="RDB的启动方式"><a href="#RDB的启动方式" class="headerlink" title="RDB的启动方式"></a>RDB的启动方式</h5><h6 id="save"><a href="#save" class="headerlink" title="save"></a>save</h6><pre><code class="hljs shell">save<span class="hljs-meta">#</span><span class="bash">手动执行一次保存操作</span>dbfilename dump-端口号.rdb说明：设置本地数据库文件名，默认值为dump.rdb经验：通常设置为dump-端口号.rdbdir说明：设置存储.rdb文件的路径经验：通常设置成存储空间较大的目录中,目录名称data.rdbcompression yes说明：设置存储至本地数据库时是否压缩数据，默认为yes，采用LZF 压缩经验：通常默认为开启状态，如果设置为no，可以节省CPU 运行时间，但会使存储的文件变大（巨大）rdbchecksum  yes说明：设置是否进行RDB文件格式校验，该校验过程在写文件和读文件过程均进行经验：通常默认为开启状态，如果设置为no，可以节约读写性过程约10%时间消耗，但是存在一定的数据损坏风险<span class="hljs-meta">#</span><span class="bash">注意:</span>save指令的执行会阻塞当前Redis服务器，直到当前RDB过程完成为止，有可能会造成长时间阻塞，线上环境不建议使用</code></pre><p>save的工作原理</p><p><img src="/images/redis/image-20200529114206278.png"></p><h6 id="bgsave"><a href="#bgsave" class="headerlink" title="bgsave"></a>bgsave</h6><pre><code class="hljs shell">bgsave<span class="hljs-meta">#</span><span class="bash">手动启动后台保存操作，但不是立即执行</span>dbfilename dump-端口号.rdbdirrdbcompression yesrdbchecksum yesstop-writes-on-bgsave-error yes说明：后台存储过程中如果出现错误现象，是否停止保存操作经验：通常默认为开启状态</code></pre><p><img src="/images/redis/image-20200528232539204.png"></p><pre><code class="hljs shell">可以在配置文件中配置Redis进行快照保存的时机：<span class="hljs-meta">#</span><span class="bash">save [seconds] [changes]</span><span class="hljs-meta">#</span><span class="bash">second：监控时间范围</span><span class="hljs-meta">#</span><span class="bash">changes：监控key的变化量</span><span class="hljs-meta">#</span><span class="bash">意为在[seconds]秒内如果发生了[changes]次数据修改，则进行一次RDB快照保存</span></code></pre><p><img src="/images/redis/save&bgsave.png"></p><h6 id="save自动保存配置"><a href="#save自动保存配置" class="headerlink" title="save自动保存配置"></a>save自动保存配置</h6><p>修改redis的配置文件</p><pre><code class="hljs shell">cd /weitrue/install/redis-6.0.1/cat clusters/redis.confsave 900 1save 300 10save 60 10000<span class="hljs-meta">#</span><span class="bash">save 5 1</span>dbfilename &quot;dump.rdb&quot; dir &quot;/weitrue/install/redis-6.0.1/rdbstro&quot;</code></pre><pre><code class="hljs lsl">前三个选项是redis的配置文件默认自带的存储机制。表示每隔多少秒，有多少个<span class="hljs-type">key</span>发生变化就生成一份dump.rdb文件，作为redis的快照文件。例如：save  <span class="hljs-number">60</span>  <span class="hljs-number">10000</span> 表示在<span class="hljs-number">60</span>秒内，有<span class="hljs-number">10000</span>个<span class="hljs-type">key</span>发生变化，就会生成一份redis的快照第四行表示：每隔五秒钟，有一条数据发生变化都需要重新生成redis的快照，需要自己根据实际情况指定。第五行dbfilename指定了把内存里的数据库写入本地文件的名称，该文件是进行压缩后的二进制文件；第六行dir指定了RDB二进制文件存放目录 ；</code></pre><p><img src="/images/redis/1589191932950.png"></p><p> 修改RDB配置</p><pre><code class="hljs zsh"><span class="hljs-comment"># 在命令行里进行配置,服务器重启才会生效:</span>node01:6379&gt; CONFIG GET save 1) <span class="hljs-string">&quot;save&quot;</span>2) <span class="hljs-string">&quot;900 1 300 10 60 10000&quot;</span>node01:6379&gt; CONFIG SET save <span class="hljs-string">&quot;21600 1000&quot;</span>OK</code></pre><p>注意：</p><pre><code class="hljs css">重新启动<span class="hljs-selector-tag">redis</span>服务每次生成新的<span class="hljs-selector-tag">dump</span><span class="hljs-selector-class">.rdb</span>都会覆盖掉之前的老的快照</code></pre><p>save配置原理</p><p><img src="/images/redis/image-20200528234120923.png"></p><pre><code class="hljs shell">save配置要根据实际业务情况进行设置，频度过高或过低都会出现性能问题，结果可能是灾难性的save配置中对于second与changes设置通常具有互补对应关系，尽量不要设置成包含性关系save配置启动后执行的是bgsave操作<span class="hljs-meta">#</span><span class="bash">save配置:</span>1.dbfilename dump-端口.rdb2.dir3.rdbcompression yes4.rdbchecksum yes</code></pre><h5 id="rdb特殊启动形式"><a href="#rdb特殊启动形式" class="headerlink" title="rdb特殊启动形式"></a>rdb特殊启动形式</h5><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">全量复制</span>  在主从复制中详细讲解<span class="hljs-meta">#</span><span class="bash">服务器运行过程中重启</span>  debug reload<span class="hljs-meta">#</span><span class="bash">关闭服务器时指定保存数据</span>  shutdown save默认情况下执行shutdown命令时，自动执行bgsave(如果没有开启AOF持久化功能)</code></pre><h5 id="RDB优缺点"><a href="#RDB优缺点" class="headerlink" title="RDB优缺点"></a>RDB优缺点</h5><pre><code class="hljs angelscript">优:<span class="hljs-number">1.</span>RDB是一个紧凑压缩的二进制文件，存储效率较高<span class="hljs-number">2.</span>RDB内部存储的是redis在某个时间点的数据快照，非常适合用于数据备份，全量复制等场景<span class="hljs-number">3.</span>RDB恢复数据的速度要比AOF快很多<span class="hljs-number">4.</span>应用：服务器中每X小时执行bgsave备份，并将RDB文件拷贝到远程机器中，用于灾难恢复。缺:<span class="hljs-number">1.</span>RDB方式无论是执行指令还是利用配置，无法做到实时持久化，具有较大的可能性丢失数据<span class="hljs-number">2.</span>bgsave指令每次运行要执行fork操作创建子进程，要牺牲掉一些性能<span class="hljs-number">3.</span>Redis的众多版本中未进行RDB文件格式的版本统一，有可能出现各版本服务之间数据格式无法兼容现象</code></pre><h4 id="AOF持久化"><a href="#AOF持久化" class="headerlink" title="AOF持久化"></a>AOF持久化</h4><pre><code class="hljs erlang">   以独立日志的方式记录每次写命令，重启时再重新执行AOF文件中命令达到恢复数据的目的。与RDB相比可以简单描述为改记录数据为记录数据产生的过程.AOF的主要作用是解决了数据持久化的实时性，目前已经是Redis持久化的主流方式</code></pre><h5 id="AOF的读写原理"><a href="#AOF的读写原理" class="headerlink" title="AOF的读写原理"></a>AOF的读写原理</h5><p><img src="/images/redis/image-20200530231955448.png"></p><h5 id="AOF写数据三种策略"><a href="#AOF写数据三种策略" class="headerlink" title="AOF写数据三种策略"></a>AOF写数据三种策略</h5><pre><code class="hljs vala"><span class="hljs-meta"># always(每次）</span>  每次写入操作均同步到AOF文件中，数据零误差，性能较低,不建议使用<span class="hljs-meta"># everysec（每秒）</span>  每秒将缓冲区中的指令同步到AOF文件中，数据准确性较高，性能较高,建议使用，也是默认配置   在系统突然宕机的情况下丢失<span class="hljs-number">1</span>秒内的数据<span class="hljs-meta"># no（系统控制）</span>    由操作系统控制每次同步到AOF文件的周期，整体过程不可控</code></pre><h5 id="AOF功能开启"><a href="#AOF功能开启" class="headerlink" title="AOF功能开启"></a>AOF功能开启</h5><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">配置</span>appendonly yes|no                # 是否开启AOF持久化功能，默认为不开启状态appendfsync  always|everysec|no  # AOF写数据策略</code></pre><h5 id="AOF相关配置"><a href="#AOF相关配置" class="headerlink" title="AOF相关配置"></a>AOF相关配置</h5><pre><code class="hljs shell">cd /weitrue/install/redis-6.0.1vim redis.confappendonly yesappendfsync everysec    # appendfsync always / appendfsync noappendfilename filename # AOF持久化文件名，默认文件名未appendonly.aof，建议配置为appendonly-端口号.aofdir                     # AOF持久化文件保存路径，与RDB持久化文件保持一致即可</code></pre><h5 id="AOF重写"><a href="#AOF重写" class="headerlink" title="AOF重写"></a>AOF重写</h5><pre><code class="hljs shell">随着命令不断写入AOF，文件会越来越大，为了解决这个问题，Redis引入了AOF重写机制压缩文件体积。AOF文件重写是将Redis进程内的数据转化为写命令同步到新AOF文件的过程。简单说就是将对同一个数据的若干条命令执行结果转化成最终结果数据对应的指令进行记录。<span class="hljs-meta">#</span><span class="bash">AOF重写作用</span>降低磁盘占用量，提高磁盘利用率提高持久化效率，降低持久化写时间，提高IO性能降低数据恢复用时间，提高数据恢复效率。<span class="hljs-meta">#</span><span class="bash">AOF重写规则</span>  1.进程内已超时的数据不再写入文件  2.忽略无效指令，重写时使用进程内数据直接生成，这样新的AOF文件只保留最终数据的写入命令     如del key1、hdelkey2、sremkey3、set key4 111、set key4 222等  3.对同一数据的多条写命令合并为一条命令    如lpushlist1 a、lpushlist1 b、lpushlist1 c 可以转化为：lpushlist1 a b c。    为防止数据量过大造成客户端缓冲区溢出，对list、set、hash、zset等类型，每条指令最多写入64个元素</code></pre><h6 id="AOF重写方式"><a href="#AOF重写方式" class="headerlink" title="AOF重写方式"></a>AOF重写方式</h6><ul><li>手动重写</li></ul><pre><code class="hljs shell">bgrewriteaof</code></pre><ul><li>自动重写</li></ul><pre><code class="hljs shell">auto-aof-rewrite-min-size sizeauto-aof-rewrite-percentage percentage</code></pre><h6 id="AOF自动重写方式"><a href="#AOF自动重写方式" class="headerlink" title="AOF自动重写方式"></a>AOF自动重写方式</h6><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 自动重写触发条件设置</span>auto-aof-rewrite-min-size （达到某一内存开始重写）sizeauto-aof-rewrite-percentage percent   （达到某一%）<span class="hljs-meta">#</span><span class="bash"> 自动重写触发比对参数（运行指令info Persistence获取具体信息) </span>aof_current_size  （设置内存）aof_base_size      （基础尺寸）</code></pre><h5 id="AOF工作流程"><a href="#AOF工作流程" class="headerlink" title="AOF工作流程"></a>AOF工作流程</h5><p><img src="/images/redis/image-20200531004807324.png"></p><h5 id="AOF重写流程"><a href="#AOF重写流程" class="headerlink" title="AOF重写流程"></a>AOF重写流程</h5><p><img src="/images/redis/image-20200531004404062.png"></p><h5 id="AOF优点："><a href="#AOF优点：" class="headerlink" title="AOF优点："></a>AOF优点：</h5><pre><code class="hljs angelscript"><span class="hljs-number">1</span>、 最安全，在启用appendfsync always时，任何已写入的数据都不会丢失，使用在启用appendfsync everysec也至多只会丢失<span class="hljs-number">1</span>秒的数据<span class="hljs-number">2</span>、 AOF文件在发生断电等问题时也不会损坏，即使出现了某条日志只写入了一半的情况，也可以使用redis-check-aof工具轻松修复。<span class="hljs-number">3</span>、 AOF文件易读，可修改，在进行了某些错误的数据清除操作后，只要AOF文件没有rewrite，就可以把AOF文件备份出来，把错误的命令删除，然后恢复数据。</code></pre><h5 id="AOF的缺点："><a href="#AOF的缺点：" class="headerlink" title="AOF的缺点："></a>AOF的缺点：</h5><pre><code class="hljs angelscript"><span class="hljs-number">1</span>、 AOF文件通常比RDB文件更大<span class="hljs-number">2</span>、 性能消耗比RDB高<span class="hljs-number">3</span>、 数据恢复速度比RDB慢Redis的数据持久化工作本身就会带来延迟，需要根据数据的安全级别和性能要求制定合理的持久化策略：AOF + fsync always的设置虽然能够绝对确保数据安全，但每个操作都会触发一次fsync，会对Redis的性能有比较明显的影响AOF + fsync every second是比较好的折中方案，每秒fsync一次AOF + fsync never会提供AOF持久化方案下的最优性能使用RDB持久化通常会提供比使用AOF更高的性能，但需要注意RDB的策略配置每一次RDB快照和AOF Rewrite都需要Redis主进程进行fork操作。fork操作本身可能会产生较高的耗时，与CPU和Redis占用的内存大小有关。根据具体的情况合理配置RDB快照和AOF Rewrite时机，避免过于频繁的fork带来的延迟Redis在fork子进程时需要将内存分页表拷贝至子进程，以占用了<span class="hljs-number">24</span>GB内存的Redis实例为例，共需要拷贝<span class="hljs-number">24</span>GB / <span class="hljs-number">4</span>kB * <span class="hljs-number">8</span> = <span class="hljs-number">48</span>MB的数据。在使用单Xeon <span class="hljs-number">2.27</span>Ghz的物理机上，这一fork操作耗时<span class="hljs-number">216</span>ms。</code></pre><h4 id="RDB与AOF"><a href="#RDB与AOF" class="headerlink" title="RDB与AOF"></a>RDB与AOF</h4><p><img src="/images/redis/rdb&aof.png"></p><h4 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h4><ul><li><p>同步操作</p></li><li><p>虽然fork同步操作是非常快的，但是如果需要同步的数据量过大(比如超过20G)，fork就会阻塞redis主进程。</p></li><li><p>与内存量息息相关</p></li><li><p>内存越大，fork同步数据耗时越长，当然也跟服务器有关，服务器有物理机，也有虚拟机。</p></li><li><p>info:latest_fork_usec</p><ul><li>使用此命令可以查看持久化花费的时间，如果持久化时间过长，就会造成卡顿。</li><li>例如：如果redis此时QPS上万，此时redis正在持久化，而且持久化时间比较长（1s或者10几秒），此时就会严重阻塞redis。</li></ul><pre><code class="hljs shell">node02:0&gt;info Stats&quot;# Statstotal_connections_received:5total_commands_processed:13instantaneous_ops_per_sec:0total_net_input_bytes:346total_net_output_bytes:7191instantaneous_input_kbps:0.00instantaneous_output_kbps:0.00rejected_connections:0sync_full:0sync_partial_ok:0sync_partial_err:0expired_keys:0evicted_keys:0keyspace_hits:0keyspace_misses:0pubsub_channels:0pubsub_patterns:0latest_fork_usec:0   # &lt;-------migrate_cached_sockets:0&quot;node02:0&gt;info&quot;# Serverredis_version:3.2.8redis_git_sha1:00000000redis_git_dirty:0redis_build_id:3a7af52404e97f38redis_mode:standaloneos:Linux 3.10.0-957.el7.x86_64 x86_64arch_bits:64multiplexing_api:epollgcc_version:4.8.5process_id:26189run_id:2cf1aa7e1893ae1b5427ae9e1963e30e10716673tcp_port:6379uptime_in_seconds:122uptime_in_days:0hz:10lru_clock:6488420executable:/weitrue/install/redis-6.0.1/src/redis-serverconfig_file:/weitrue/install/redis-6.0.1/redis.conf<span class="hljs-meta">#</span><span class="bash"> Clients</span>connected_clients:2client_longest_output_list:0client_biggest_input_buf:0blocked_clients:0<span class="hljs-meta">#</span><span class="bash"> Memory</span>used_memory:2168928used_memory_human:2.07Mused_memory_rss:4009984used_memory_rss_human:3.82Mused_memory_peak:2201664used_memory_peak_human:2.10Mtotal_system_memory:1907941376total_system_memory_human:1.78Gused_memory_lua:37888used_memory_lua_human:37.00Kmaxmemory:0maxmemory_human:0Bmaxmemory_policy:noevictionmem_fragmentation_ratio:1.85mem_allocator:libc<span class="hljs-meta">#</span><span class="bash"> Persistence</span>loading:0rdb_changes_since_last_save:0rdb_bgsave_in_progress:0rdb_last_save_time:1617101034rdb_last_bgsave_status:okrdb_last_bgsave_time_sec:-1rdb_current_bgsave_time_sec:-1aof_enabled:0aof_rewrite_in_progress:0aof_rewrite_scheduled:0aof_last_rewrite_time_sec:-1aof_current_rewrite_time_sec:-1aof_last_bgrewrite_status:okaof_last_write_status:ok<span class="hljs-meta">#</span><span class="bash"> Stats</span>total_connections_received:5total_commands_processed:11instantaneous_ops_per_sec:0total_net_input_bytes:298total_net_output_bytes:4947instantaneous_input_kbps:0.00instantaneous_output_kbps:0.00rejected_connections:0sync_full:0sync_partial_ok:0sync_partial_err:0expired_keys:0evicted_keys:0keyspace_hits:0keyspace_misses:0pubsub_channels:0pubsub_patterns:0latest_fork_usec:0migrate_cached_sockets:0<span class="hljs-meta">#</span><span class="bash"> Replication</span>role:masterconnected_slaves:0master_repl_offset:0repl_backlog_active:0repl_backlog_size:1048576repl_backlog_first_byte_offset:0repl_backlog_histlen:0<span class="hljs-meta">#</span><span class="bash"> CPU</span>used_cpu_sys:0.18used_cpu_user:0.11used_cpu_sys_children:0.00used_cpu_user_children:0.00<span class="hljs-meta">#</span><span class="bash"> Cluster</span>cluster_enabled:0<span class="hljs-meta">#</span><span class="bash"> Keyspace</span>db0:keys=79,expires=0,avg_ttl=0db15:keys=12,expires=0,avg_ttl=0&quot;</code></pre></li></ul><h5 id="改善fork"><a href="#改善fork" class="headerlink" title="改善fork"></a>改善fork</h5><p><img src="/images/redis/improve-fork.png"></p><h3 id="Redis-发布订阅"><a href="#Redis-发布订阅" class="headerlink" title="Redis 发布订阅"></a>Redis 发布订阅</h3><p><img src="/images/redis/pub-sub.png"></p><pre><code class="hljs angelscript">Redis 的发布与订阅功能可以让用户将消息同时发送给多个客户端。 这个功能由几个不同的角色 协作组成： <span class="hljs-number">1.</span>发布者（publisher）：发布消息的客户端。 <span class="hljs-number">2.</span>频道（channel）：构建在服务器内部，负责接收发布者发送的消息，并将消息转发给频道的订阅者。 <span class="hljs-number">3.</span>模式（pattern）：构建在服务器内部，负责对频道进行匹配，当被匹配的频道接到消息时，模式也会 将消息转发给模式的订阅者。 <span class="hljs-number">4.</span>订阅者（subscriber）：通过订阅频道或者模式来获取消息的客户端。每个频道或者模式都可以有任 意多个订阅者(仅能获得开始订阅以后的消息，订阅前的消息无法获得)。</code></pre><h5 id="订阅命令"><a href="#订阅命令" class="headerlink" title="订阅命令"></a>订阅命令</h5> <pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">订阅频道</span>SUBSCRIBE channel [channel ...]订阅给定的一个或多个频道。node02:15&gt;SUBSCRIBE woSwitch to Pub/Sub mode. Close console tab to stop listen for messages. 1)  &quot;subscribe&quot; 2)  &quot;wo&quot; 3)  &quot;1&quot; 1)  &quot;message&quot; 2)  &quot;wo&quot; 3)  &quot;hello&quot; 1)  &quot;message&quot; 2)  &quot;wo&quot; 3)  &quot;test&quot;</code></pre><h6 id="消息发布"><a href="#消息发布" class="headerlink" title="消息发布"></a>消息发布</h6><pre><code class="hljs shell">node02:15&gt;PUBLISH wo hello&quot;1&quot;</code></pre><h6 id="订阅多个"><a href="#订阅多个" class="headerlink" title="订阅多个"></a>订阅多个</h6><pre><code class="hljs shell">通配符*<span class="hljs-meta">redis&gt;</span><span class="bash"> PSUBSCRIBE new*</span></code></pre><h6 id="消息发布-1"><a href="#消息发布-1" class="headerlink" title="消息发布"></a>消息发布</h6><pre><code class="hljs shell"><span class="hljs-meta">redis&gt;</span><span class="bash">PUBLISH new1 hello</span></code></pre><h6 id="列出指定频道订阅着数量"><a href="#列出指定频道订阅着数量" class="headerlink" title="列出指定频道订阅着数量"></a>列出指定频道订阅着数量</h6><pre><code class="hljs shell"><span class="hljs-meta">redis&gt;</span><span class="bash"> PUBSUB numsub [channel...]</span></code></pre><h3 id="Redis-事务"><a href="#Redis-事务" class="headerlink" title="Redis 事务"></a>Redis 事务</h3><pre><code class="hljs nginx"><span class="hljs-attribute">Redis</span> 的事务功能允许用户将多个命令包裹起来，然后一次性地、按 顺序地执行被包裹的所有命令。在事务执行的过程中，服务器不会中断事务而改去执行其他命令请求，只有在事务包裹的所有命令都被执行完毕之后，服务器才会去处理其他命令请求。</code></pre><h4 id="事务命令"><a href="#事务命令" class="headerlink" title="事务命令"></a>事务命令</h4><pre><code class="hljs plain">为了避免遇上以上所说的情况， 我们需要用到 Redis 的事务功能， 通过事务， 我们可以让 Redis 一次性地执行多个命令， 并且确保事务中的命令要么就全部都 执行，要么就一个都不执行。</code></pre><p><strong>事务命令</strong>：                                                     作用： </p><p>MULTI                                                             开始一个新的事务。    </p><p>DISCARD                                                         放弃事务。</p><p>EXEC                                                                 执行事务中的所有命令。</p><p><strong>开始事务</strong></p><pre><code class="hljs shell">MULTI开始一个事务。 在这个命令执行之后，客户端发送的所有针对数据库或者数据库键的命令都不会被立即执行，而是被放入到一个事务队列里面，并返回 QUEUED 表示命令已入队。<span class="hljs-meta">redis&gt;</span><span class="bash"> MULTI <span class="hljs-comment"># 开始一个事务</span></span>OK<span class="hljs-meta">redis&gt;</span><span class="bash"> SET msg <span class="hljs-string">&quot;hello world&quot;</span> <span class="hljs-comment"># 将这个 SET 命令放入事务队列</span></span>QUEUED</code></pre><p><strong>放弃事务：</strong></p><pre><code class="hljs shell">DISCARD取消事务，放弃执行事务队列中的所有命令。<span class="hljs-meta"> redis&gt;</span><span class="bash"> MULTI</span> OK<span class="hljs-meta"> redis&gt;</span><span class="bash"> SET msg <span class="hljs-string">&quot;hello world&quot;</span></span> QUEUED<span class="hljs-meta"> redis&gt;</span><span class="bash"> DISCARD <span class="hljs-comment"># 事务已被取消</span></span> OK</code></pre><p><strong>执行事务</strong></p><pre><code class="hljs shell">EXEC按照命令被入队到事务队列中的顺序，执行事务队列中的所有命令。<span class="hljs-meta">redis&gt;</span><span class="bash"> MULTI </span>OK<span class="hljs-meta">redis&gt;</span><span class="bash"> SET msg <span class="hljs-string">&quot;hello world&quot;</span></span>QUEUED<span class="hljs-meta">redis&gt;</span><span class="bash"> SET msg <span class="hljs-string">&quot;hello world&quot;</span></span>QUEUED<span class="hljs-meta">redis&gt;</span><span class="bash"> EXEC</span></code></pre><h3 id="Redis-安全"><a href="#Redis-安全" class="headerlink" title="Redis 安全"></a>Redis 安全</h3><p>我们可以通过 redis 的配置文件设置密码参数，这样客户端连接到 redis 服务就需要密码验证，这样可以让你的 redis 服务更安全。 </p><pre><code class="hljs shell">实例我们可以通过以下命令查看是否设置了密码验证：127.0.0.1:6379&gt; CONFIG get requirepass1) &quot;requirepass&quot;2) &quot;&quot;默认情况下 requirepass 参数是空的，这就意味着你无需通过密码验证就可以连接到 redis 服务。你可以通过以下命令来修改该参数：127.0.0.1:6379&gt; CONFIG set requirepass &quot;weitrue&quot;OK127.0.0.1:6379&gt; CONFIG get requirepass1) &quot;requirepass&quot;2) &quot;weitrue&quot;</code></pre><p>设置密码后，客户端连接 redis 服务就需要密码验证，否则无法执行命令。</p><pre><code class="hljs shell">语法AUTH 命令基本语法格式如下：127.0.0.1:6379&gt; AUTH password实例127.0.0.1:6379&gt; AUTH &quot;weitrue&quot;OK</code></pre><p>取消密码 —重启服务</p><pre><code class="hljs plain">AUTH命令跟其他redis命令一样，是没有加密的；阻止不了攻击者在网络上窃取你的密码；</code></pre><h3 id="Redis-性能测试"><a href="#Redis-性能测试" class="headerlink" title="Redis 性能测试"></a>Redis 性能测试</h3><p>Redis 性能测试是通过同时执行多个命令实现的。</p><pre><code class="hljs shell">语法redis 性能测试的基本命令如下：redis-benchmark [option] [option value]注意：该命令是在 redis 的目录下执行的，而不是 redis 客户端的内部指令。实例以下实例同时执行 10000 个请求来检测性能：[hadoop@node02 redis-6.0.1]$ src/redis-benchmark  -h node02 -p 6379  -n 10000 -qPING_INLINE: 72992.70 requests per secondPING_BULK: 70921.98 requests per secondSET: 66666.66 requests per secondGET: 73529.41 requests per secondINCR: 75187.97 requests per secondLPUSH: 68493.15 requests per secondRPUSH: 76923.08 requests per secondLPOP: 74626.87 requests per secondRPOP: 75757.58 requests per secondSADD: 76335.88 requests per secondSPOP: 76923.08 requests per secondLPUSH (needed to benchmark LRANGE): 75757.58 requests per secondLRANGE_100 (first 100 elements): 40983.61 requests per secondLRANGE_300 (first 300 elements): 19120.46 requests per secondLRANGE_500 (first 450 elements): 13605.44 requests per secondLRANGE_600 (first 600 elements): 10672.36 requests per secondMSET (10 keys): 59880.24 requests per second</code></pre><pre><code class="hljs lsl">redis 性能测试工具可选参数如下所示：序号选项描述                                 默认值<span class="hljs-number">1</span>-h指定服务器主机名                     <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">2</span>-p指定服务器端口                            <span class="hljs-number">6379</span><span class="hljs-number">3</span>-s指定服务器 socket<span class="hljs-number">4</span>-c指定并发连接数                             <span class="hljs-number">50</span><span class="hljs-number">5</span>-n指定请求数                             <span class="hljs-number">10000</span><span class="hljs-number">6</span>-d以字节的形式指定 SET/GET 值的数据大小         <span class="hljs-number">2</span><span class="hljs-number">7</span>-k<span class="hljs-number">1</span>=keep alive <span class="hljs-number">0</span>=reconnect              <span class="hljs-number">1</span><span class="hljs-number">8</span>-rSET/GET/INCR 使用随机 <span class="hljs-type">key</span>, SADD 使用随机值<span class="hljs-number">9</span>-P通过管道传输 &lt;numreq&gt; 请求                 <span class="hljs-number">1</span><span class="hljs-number">10</span>-q强制退出 redis。仅显示 query/sec 值<span class="hljs-number">11</span>--csv以 CSV 格式输出<span class="hljs-number">12</span>-l生成循环，永久执行测试<span class="hljs-number">13</span>-t仅运行以逗号分隔的测试命令列表。<span class="hljs-number">14</span>-IIdle 模式。仅打开 N 个 idle 连接并等待。</code></pre><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">以下实例使用了多个参数来测试 redis 性能：</span>[hadoop@node02 redis-6.0.1]$ src/redis-benchmark -h node02 -p 6379 -t set,lpush -n 10000 -qSET: 68493.15 requests per secondLPUSH: 67114.09 requests per second以上实例中主机为 node01，端口号为 6379，执行的命令为 set,lpush，请求数为 10000，通过 -q 参数让结果只显示每秒执行的请求数。</code></pre><h3 id="redis的三种集群方式："><a href="#redis的三种集群方式：" class="headerlink" title="redis的三种集群方式："></a>redis的三种集群方式：</h3><h4 id="主从复制架构"><a href="#主从复制架构" class="headerlink" title="主从复制架构"></a>主从复制架构</h4><p>在Redis中，<br><code>SLAVEOF  命令或者设置</code>slaveof 选项，让一个服务器去复制（replicate）另一个服务器，被复制的服务器为主服务器（master），而对主服务器进行复制的服务器则被称为从服务器（slave）。<br><code>SLAVEOF no one</code>命令取消成为从节点。</p><p><img src="/images/redis/image-20200526181040434.png"></p><p><img src="/images/redis/image-20200526181105914.png"></p><p><img src="/images/redis/image-20200527001642571.png"></p><h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><ul><li>读写分离:master写,slave读。</li><li>负载均衡:由slave分担master负载,并根据需求,改变slave的数量,通过多个从节点读取负载。</li><li>故障恢复:当master出现问题的时候,由slave提供服务,实现快速恢复。</li><li>数据冗余:实时备份。</li></ul><h5 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h5><pre><code class="hljs angelscript">三阶段: <span class="hljs-number">1.</span>建立连接 <span class="hljs-number">2.</span>数据同步 <span class="hljs-number">3.</span>命令传播阶段</code></pre><p><img src="/images/redis/image-20200526191458864.png"></p><p><img src="/images/redis/image-20200527001702103.png"></p><h5 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h5><p>使用主从复制这种模式，实现node01作为主节点，node02与node03作为从节点，并且将node01所有的数据全部都同步到node02与node03服务器</p><p>第一步: 将node01上的redis拷贝到node02和node03上</p><pre><code class="hljs shell">scp -r /weitrue/install/redis-6.0.1/ node02:/weitrue/install/scp -r /weitrue/install/redis-6.0.1/ node03:/weitrue/instal/</code></pre><p>第二步：node02与node03服务器安装redis</p><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> node02与node03服务器修改redis配置文件</span><span class="hljs-meta">#</span><span class="bash"> node02服务器修改配置文件命令如下</span><span class="hljs-meta">#</span><span class="bash">执行以下命令修改redis配置文件</span>cd /weitrue/install/redis-6.0.1/mkdir -p /weitrue/install/redis-6.0.1/logsmkdir -p /weitrue/install/redis-6.0.1/redisdatavim redis.confbind node02daemonize yespidfile /weitrue/install/redis-6.0.1/redis_6379.pidlogfile &quot;/weitrue/install/redis-6.0.1/logs/redis.log&quot;dir /weitrue/install/redis-6.0.1/redisdataslaveof node01 6379<span class="hljs-meta">#</span><span class="bash"> node03服务器修改配置文件命令如下</span><span class="hljs-meta">#</span><span class="bash">执行以下命令修改redis配置文件</span>cd /weitrue/install/redis-6.0.1/mkdir -p /weitrue/install/redis-6.0.1/logsmkdir -p /weitrue/install/redis-6.0.1/redisdatavim redis.confbind node03daemonize yespidfile /var/run/redis_6379.pidlogfile &quot;/weitrue/install/redis-6.0.1/logs/redis.log&quot;dir /weitrue/install/redis-6.0.1/redisdataslaveof node01 6379</code></pre><p>第三步、启动node02与node03机器的redis服务</p><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">node02执行以下命令启动redis服务</span>cd  /weitrue/install/redis-6.0.1/src/redis-server  redis.conf<span class="hljs-meta">#</span><span class="bash">ode03执行以下命令启动redis服</span>cd  /weitrue/install/redis-6.0.1/src/redis-server  redis.conf</code></pre><p>启动成功便可以实现redis的主从复制，node01可以读写操作，node02与node03只支持读取操作。</p><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">注意:务必关掉防火墙</span><span class="hljs-meta">#</span><span class="bash">连接node01</span>src/redis-cli -h node01set weitrue 1234<span class="hljs-meta">#</span><span class="bash">连接node02</span>src/redis-cli -h node02get weitrue<span class="hljs-meta">#</span><span class="bash">查看集群信息</span>info<span class="hljs-meta">#</span><span class="bash">主从断开连接</span>slaveof no one</code></pre><h4 id="redis当中的Sentinel架构"><a href="#redis当中的Sentinel架构" class="headerlink" title="redis当中的Sentinel架构"></a>redis当中的Sentinel架构</h4><pre><code class="hljs plain">Sentinel（哨兵）是Redis 的高可用性解决方案：由一个或多个Sentinel 实例 组成的Sentinel 系统可以监视任意多个主服务器，以及这些主服务器属下的所有从服务器，并在被监视的主服务器进入下线状态时，自动将下线主服务器属下的某个从服务器升级为新的主服务器。</code></pre><p><img src="/images/redis/image-20200527141509519.png"></p><p><img src="/images/redis/image-20200527141538252.png"></p><p>作用:</p><pre><code class="hljs crmsh"> 监控:不断的检查<span class="hljs-literal">master</span>和<span class="hljs-literal">slave</span>是否正常运行.<span class="hljs-literal">master</span>存活检测,<span class="hljs-literal">master</span>与<span class="hljs-literal">slave</span>运行情况检测. 通知:当被监控的服务器出现问题时,向其他的(哨兵间或者客户端)发送通知.自动故障转移:断开<span class="hljs-literal">master</span>与<span class="hljs-literal">slave</span>连接,选取一个<span class="hljs-literal">slave</span>作为<span class="hljs-literal">master</span>,将其他的<span class="hljs-literal">slave</span>连接到新的<span class="hljs-literal">master</span>,并告知客户端新的服务器地址.注意:哨兵通常也是一台服务器,但不提供服务,通常的哨兵配置为积数.</code></pre><p>配置:</p><p>第一步：三台机器修改哨兵配置文件</p><pre><code class="hljs angelscript">#三台机器执行以下命令修改redis的哨兵配置文件cd /weitrue/install/redis<span class="hljs-number">-6.0</span><span class="hljs-number">.1</span>vim sentinel.conf# 配置监听的主服务器，这里sentinel monitor代表监控，mymaster代表服务器的名称，可以自定义，<span class="hljs-number">192.168</span><span class="hljs-number">.11</span><span class="hljs-number">.128</span>代表监控的主服务器，<span class="hljs-number">6379</span>代表端口，<span class="hljs-number">2</span>代表只有两个或两个以上的哨兵认为主服务器不可用的时候，才会进行failover操作。#修改bind配置，每台机器修改为自己对应的主机名bind node01  #配置sentinel服务后台运行daemonize yes#修改三台机器监控的主节点，现在主节点是node01服务器sentinel monitor mymaster <span class="hljs-number">192.168</span><span class="hljs-number">.8</span><span class="hljs-number">.100</span> <span class="hljs-number">6379</span> <span class="hljs-number">2</span># sentinel monitor代表监控，mymaster是服务名称,可以自定义;node01 代表监控的主服务器;<span class="hljs-number">6379</span>代表端口,<span class="hljs-number">2</span>代表只有两个或两个以上的哨兵认为主服务器不可用的时候，才会进行failover操作。</code></pre><p>第二步：三台机器启动哨兵服务</p><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">三台机器执行以下命令启动哨兵服务</span>cd /weitrue/install/redis-6.0.1/src/redis-sentinel sentinel.conf</code></pre><p>第三步：node01服务器杀死redis服务进程</p><pre><code class="hljs gcode">使用kill  <span class="hljs-number">-9</span>命令杀死redis服务进程，模拟redis故障宕机情况过一段时间之后，就会在<span class="hljs-symbol">node02</span>与<span class="hljs-symbol">node03</span>服务器选择一台服务器来切换为主节点</code></pre><p>原理:</p><p><img src="/images/redis/image-20200527175422937.png"></p><p><img src="/images/redis/image-20200527181408612.png"></p><p><img src="/images/redis/image-20200527182135500.png"></p><p><img src="/images/redis/image-20200527184045802.png"></p><h4 id="redis集群"><a href="#redis集群" class="headerlink" title="redis集群"></a>redis集群</h4><pre><code class="hljs angelscript">Redis 集群是一个提供在多个Redis节点之间共享数据的程序集。Redis 集群并不支持同时处理多个键的 Redis 命令，因为这需要在多个节点间移动数据，这样会降低redis集群的性能，在高负载的情况下可能会导致不可预料的错误。Redis 集群通过分区来提供一定程度的可用性，即使集群中有一部分节点失效或者无法进行通讯， 集群也可以继续处理命令请求。 Redis 集群的优势:<span class="hljs-number">1.</span>缓存永不宕机：启动集群，永远让集群的一部分起作用。主节点失效了子节点能迅速改变角色成为主节点，整个集群的部分节点失败或者不可达的情况下能够继续处理命令；<span class="hljs-number">2.</span>迅速恢复数据：持久化数据，能在宕机后迅速解决数据丢失的问题；<span class="hljs-number">3.</span>Redis可以使用所有机器的内存，变相扩展性能；<span class="hljs-number">4.</span>使Redis的计算能力通过简单地增加服务器得到成倍提升,Redis的网络带宽也会随着计算机和网卡的增加而成倍增长；<span class="hljs-number">5.</span>Redis集群没有中心节点，不会因为某个节点成为整个集群的性能瓶颈;<span class="hljs-number">6.</span>异步处理数据，实现快速读写。</code></pre><p><img src="/images/redis/image-20200524161751571.png"></p><h5 id="集群数据存储设计及通信原理"><a href="#集群数据存储设计及通信原理" class="headerlink" title="集群数据存储设计及通信原理"></a>集群数据存储设计及通信原理</h5><pre><code class="hljs plain">redis集群数据存储设计</code></pre><p><img src="/images/redis/image-20200524162113663.png"></p><pre><code class="hljs plain">redis集群通信原理</code></pre><p><img src="/images/redis/1590146339566.png"></p><h5 id="redis集群环境搭建"><a href="#redis集群环境搭建" class="headerlink" title="redis集群环境搭建"></a>redis集群环境搭建</h5><pre><code class="hljs angelscript">由于redis集群当中最少需要三个主节点，每个主节点，最少需要一个对应的从节点，所以搭建redis集群最少需要三主三从的配置，因此redis集群最少需要<span class="hljs-number">6</span>台redis的实例。我们这里用node01通过配置<span class="hljs-number">6</span>个端口，实现redis集群的环境搭建</code></pre><h6 id="node01服务器解压redis压缩包"><a href="#node01服务器解压redis压缩包" class="headerlink" title="node01服务器解压redis压缩包"></a>node01服务器解压redis压缩包</h6><pre><code class="hljs awk"><span class="hljs-comment">#node01执行以下命令重新解压redis压缩包到/weitrue路径下</span>cd <span class="hljs-regexp">/weitrue/</span>soft/tar -zxvf redis-<span class="hljs-number">6.0</span>.<span class="hljs-number">1</span>.tar.gz -C ..<span class="hljs-regexp">/instal/</span></code></pre><h6 id="安装redis必须依赖环境并进行编译"><a href="#安装redis必须依赖环境并进行编译" class="headerlink" title="安装redis必须依赖环境并进行编译"></a>安装redis必须依赖环境并进行编译</h6><pre><code class="hljs routeros"><span class="hljs-comment">#node01执行以下命令安装redis的依赖环境</span>su rootyum -y install gcc-c++ tcl<span class="hljs-comment"># 查看gcc版本是否在5.3以上，centos7.6默认安装4.8.5</span>gcc -v<span class="hljs-comment"># 升级gcc到5.3及以上,如下：</span>升级到gcc 9.3：yum -y install centos-release-sclyum -y install devtoolset-9-gcc devtoolset-9-gcc-c++ devtoolset-9-binutilsscl <span class="hljs-builtin-name">enable</span> devtoolset-9 bash需要注意的是scl命令启用只是临时的，退出shell或重启就会恢复原系统gcc版本。如果要长期使用gcc 9.3的话：echo <span class="hljs-string">&quot;source /opt/rh/devtoolset-9/enable&quot;</span> &gt;&gt;/etc/profile<span class="hljs-comment">#这样退出shell重新打开就是新版的gcc了</span><span class="hljs-comment">#对redis进行编译</span>cd /weitrue/redis-6.0.1make &amp;&amp; make install</code></pre><h6 id="创建redis不同实例的配置文件夹"><a href="#创建redis不同实例的配置文件夹" class="headerlink" title="创建redis不同实例的配置文件夹"></a>创建redis不同实例的配置文件夹</h6><p>创建文件夹，并将redis的配置文件拷贝到以下这些目录</p><pre><code class="hljs apache"><span class="hljs-comment">#node01:</span><span class="hljs-attribute">cd</span> /weitrue/install/redis-<span class="hljs-number">6</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span><span class="hljs-attribute">mkdir</span> -p /weitrue/install/redis-<span class="hljs-number">6</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>/clusters/<span class="hljs-number">7001</span><span class="hljs-attribute">mkdir</span> -p /weitrue/install/redis-<span class="hljs-number">6</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>/clusters/<span class="hljs-number">7002</span><span class="hljs-attribute">mkdir</span> -p /weitrue/install/redis-<span class="hljs-number">6</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>/clusters/<span class="hljs-number">7003</span><span class="hljs-attribute">mkdir</span> -p /weitrue/install/redis-<span class="hljs-number">6</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>/clusters/<span class="hljs-number">7004</span><span class="hljs-attribute">mkdir</span> -p /weitrue/install/redis-<span class="hljs-number">6</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>/clusters/<span class="hljs-number">7005</span><span class="hljs-attribute">mkdir</span> -p /weitrue/install/redis-<span class="hljs-number">6</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>/clusters/<span class="hljs-number">7006</span></code></pre><h6 id="修改redis的六个配置文件"><a href="#修改redis的六个配置文件" class="headerlink" title="修改redis的六个配置文件"></a>修改redis的六个配置文件</h6><pre><code class="hljs awk"><span class="hljs-comment">#node01执行以下命令修改redis的配置文件</span>mkdir -p <span class="hljs-regexp">/weitrue/i</span>nstall<span class="hljs-regexp">/redis-6.0.1/</span>logsmkdir -p <span class="hljs-regexp">/weitrue/i</span>nstall<span class="hljs-regexp">/redis-6.0.1/</span>redisdata/<span class="hljs-number">7001</span>mkdir -p <span class="hljs-regexp">/weitrue/i</span>nstall<span class="hljs-regexp">/redis-6.0.1/</span>redisdata/<span class="hljs-number">7002</span>mkdir -p <span class="hljs-regexp">/weitrue/i</span>nstall<span class="hljs-regexp">/redis-6.0.1/</span>redisdata/<span class="hljs-number">7003</span>mkdir -p <span class="hljs-regexp">/weitrue/i</span>nstall<span class="hljs-regexp">/redis-6.0.1/</span>redisdata/<span class="hljs-number">7004</span>mkdir -p <span class="hljs-regexp">/weitrue/i</span>nstall<span class="hljs-regexp">/redis-6.0.1/</span>redisdata/<span class="hljs-number">7005</span>mkdir -p <span class="hljs-regexp">/weitrue/i</span>nstall<span class="hljs-regexp">/redis-6.0.1/</span>redisdata/<span class="hljs-number">7006</span></code></pre><p>分别修改6个配置文件</p><pre><code class="hljs java">vim  /weitrue/install/redis-<span class="hljs-number">6.0</span>.<span class="hljs-number">1</span>/redis.confbind node01port <span class="hljs-number">7001</span>                                 <span class="hljs-comment">//默认ip为127.0.0.1 需要改为其他节点机器可访问的ip </span>cluster-enabled yes                       <span class="hljs-comment">//开启集群把注释#去掉</span>cluster-config-file nodes-<span class="hljs-number">7001.</span>conf      <span class="hljs-comment">//集群的配置  配置文件首次启动自动生成 7001,7002,7003</span>cluster-node-timeout <span class="hljs-number">5000</span>                 <span class="hljs-comment">//请求超时  默认15秒，可自行设置</span>appendonly yes                           <span class="hljs-comment">//aof日志开启  有需要就开启，它会每次写操作都记录一条日志</span>daemonize yespidfile /<span class="hljs-keyword">var</span>/run/redis_7001.pidlogfile <span class="hljs-string">&quot;/weitrue/install/redis-6.0.1/logs/7001.log&quot;</span>dir /weitrue/install/redis-<span class="hljs-number">6.0</span>.<span class="hljs-number">1</span>/redisdata/<span class="hljs-number">7001</span></code></pre><pre><code class="hljs angelscript">注意：port：对应的每台机器的端口号，    第一台是：port <span class="hljs-number">7001</span>    第二台：port  <span class="hljs-number">7002</span>    ....    第六台：port <span class="hljs-number">7006</span>        第一台： cluster-config-file nodes<span class="hljs-number">-7001.</span>conf    ....      第六台：cluster-config-file nodes<span class="hljs-number">-7006.</span>conf        第一台： dir /weitrue/install/redis<span class="hljs-number">-6.0</span><span class="hljs-number">.1</span>/redisdata/<span class="hljs-number">7001</span>    ....     第六台：dir /weitrue/install/redis<span class="hljs-number">-6.0</span><span class="hljs-number">.1</span>/redisdata/<span class="hljs-number">7006</span></code></pre><h6 id="启动redis进程"><a href="#启动redis进程" class="headerlink" title="启动redis进程"></a>启动redis进程</h6><p>node01执行以下命令来启动redis集群</p><pre><code class="hljs awk">cd <span class="hljs-regexp">/weitrue/</span>redis-<span class="hljs-number">6.0</span>.<span class="hljs-number">1</span>src<span class="hljs-regexp">/redis-server clusters/</span><span class="hljs-number">7001</span>/redis.confsrc<span class="hljs-regexp">/redis-server clusters/</span><span class="hljs-number">7002</span>/redis.confsrc<span class="hljs-regexp">/redis-server clusters/</span><span class="hljs-number">7003</span>/redis.confsrc<span class="hljs-regexp">/redis-server clusters/</span><span class="hljs-number">7004</span>/redis.confsrc<span class="hljs-regexp">/redis-server clusters/</span><span class="hljs-number">7005</span>/redis.confsrc<span class="hljs-regexp">/redis-server clusters/</span><span class="hljs-number">7006</span>/redis.conf</code></pre><h6 id="创建redis集群"><a href="#创建redis集群" class="headerlink" title="创建redis集群"></a>创建redis集群</h6><p>node01执行以下命令创建redis集群</p><pre><code class="hljs angelscript">cd /weitrue/install/redis<span class="hljs-number">-6.0</span><span class="hljs-number">.1</span>src/redis-cli --cluster create <span class="hljs-number">192.168</span><span class="hljs-number">.8</span><span class="hljs-number">.100</span>:<span class="hljs-number">7001</span> <span class="hljs-number">192.168</span><span class="hljs-number">.8</span><span class="hljs-number">.100</span>:<span class="hljs-number">7002</span> <span class="hljs-number">192.168</span><span class="hljs-number">.8</span><span class="hljs-number">.100</span>:<span class="hljs-number">7003</span> <span class="hljs-number">192.168</span><span class="hljs-number">.8</span><span class="hljs-number">.100</span>:<span class="hljs-number">7004</span> <span class="hljs-number">192.168</span><span class="hljs-number">.8</span><span class="hljs-number">.100</span>:<span class="hljs-number">7005</span> <span class="hljs-number">192.168</span><span class="hljs-number">.8</span><span class="hljs-number">.100</span>:<span class="hljs-number">7006</span> --cluster-replicas <span class="hljs-number">1</span></code></pre><p>注意：如果创建cluster集群出现以下这个错误</p><p><img src="/images/redis/2.png"></p><p>那么我们需要清空所有redis节点的所有数据</p><p>执行以下命令连接到各个redis节点，然后清空数据</p><pre><code class="hljs angelscript">示例：<span class="hljs-string">[root@node01 redis-6.0.1]</span># src/redis-cli  -h node01 -c -p <span class="hljs-number">7001</span>node01:<span class="hljs-number">7001</span>&gt; flushall OKnode01:<span class="hljs-number">7001</span>&gt; cluster resetOKnode01:<span class="hljs-number">7001</span>&gt; quit#依次执行<span class="hljs-number">6</span>台机器</code></pre><p>重新创建redis集群</p><pre><code class="hljs angelscript">src/redis-cli --cluster create <span class="hljs-number">192.168</span><span class="hljs-number">.8</span><span class="hljs-number">.100</span>:<span class="hljs-number">7001</span> <span class="hljs-number">192.168</span><span class="hljs-number">.8</span><span class="hljs-number">.100</span>:<span class="hljs-number">7002</span> <span class="hljs-number">192.168</span><span class="hljs-number">.8</span><span class="hljs-number">.100</span>:<span class="hljs-number">7003</span> <span class="hljs-number">192.168</span><span class="hljs-number">.8</span><span class="hljs-number">.100</span>:<span class="hljs-number">7004</span> <span class="hljs-number">192.168</span><span class="hljs-number">.8</span><span class="hljs-number">.100</span>:<span class="hljs-number">7005</span> <span class="hljs-number">192.168</span><span class="hljs-number">.8</span><span class="hljs-number">.100</span>:<span class="hljs-number">7006</span> --cluster-replicas <span class="hljs-number">1</span></code></pre><h6 id="连接redis客户端-1"><a href="#连接redis客户端-1" class="headerlink" title="连接redis客户端"></a>连接redis客户端</h6><p>node01执行以下命令连接redis客户端</p><pre><code class="hljs apache"><span class="hljs-attribute">cd</span> /weitrue/redis-<span class="hljs-number">6</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span><span class="hljs-attribute">src</span>/redis-cli  -h node<span class="hljs-number">01</span> -c -p <span class="hljs-number">7001</span></code></pre><h5 id="redis集群管理"><a href="#redis集群管理" class="headerlink" title="redis集群管理"></a>redis集群管理</h5><p>添加一个新节点作为主节点</p><p>启动新节点的redis服务，然后添加到集群当中去</p><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">1.创建文件夹</span>mkdir -p /weitrue/install/redis-6.0.1/redisdata/7007mkdir -p /weitrue/install/redis-6.0.1/redisdata/7008mkdir -p /weitrue/install/redis-6.0.1/clusters/7007mkdir -p /weitrue/install/redis-6.0.1/clusters/7008<span class="hljs-meta">#</span><span class="bash">2.修改redis.conf</span>vim /weitrue/install/redis-6.0.1/clusters/7007/redis.confvim /weitrue/install/redis-6.0.1/clusters/7008/redis.conf</code></pre><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">启动服务</span>src/redis-server clusters/7007/redis.conf<span class="hljs-meta">#</span><span class="bash">添加服务</span>src/redis-cli --cluster add-node 192.168.8.100:7007 192.168.8.100:7001<span class="hljs-meta">#</span><span class="bash">解释:</span>192.168.8.100:7007 #服务器ip:端口;192.168.8.100:7001 #集群中任意一台ip:端口</code></pre><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">查看信息</span>src/redis-cli --cluster info 192.168.8.100:7001</code></pre><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">检测集群</span>src/redis-cli --cluster check 192.168.8.100:7007</code></pre><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">重新分片</span><span class="hljs-meta">#</span><span class="bash">命令格式</span>src/redis-cli --cluster reshard --from &lt;node-id&gt; --to &lt;node-id&gt; --slots &lt;number of slots&gt; --yes &lt;host&gt;:&lt;port&gt;<span class="hljs-meta">#</span><span class="bash">实例:</span>src/redis-cli --cluster reshard 192.168.8.100:7001<span class="hljs-meta">#</span><span class="bash">解释:</span>192.168.8.100:7001 #集群中任务一个节点<span class="hljs-meta">#</span><span class="bash">下面代表需要输入参数的提示</span>1.How many slots do you want to move (from 1 to 16384)?4096　　　　 <span class="hljs-meta">#</span><span class="bash">拿出4096个<span class="hljs-built_in">hash</span> 槽</span>2.What is the receiving node ID? c5e0da48f335c46a2ec199faa99b830f537dd8a0 <span class="hljs-meta">#</span><span class="bash">7007服务所在的节点的id值</span>3.Source node #1: all <span class="hljs-meta">#</span><span class="bash">从当前所有master服务器获取<span class="hljs-built_in">hash</span>槽</span>4.Do you want to proceed with the proposed reshard plan (yes/no)?yes　<span class="hljs-meta">#</span><span class="bash"> 同意以上配置</span></code></pre><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">查看集群信息</span>src/redis-cli --cluster info 192.168.8.100:7001</code></pre><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">添加slave角色到集群里</span><span class="hljs-meta">#</span><span class="bash">启动7008服务</span>src/redis-server clusters/7008/redis.conf<span class="hljs-meta">#</span><span class="bash">添加副本</span>src/redis-cli --cluster add-node  --cluster-slave 192.168.8.100:7008 192.168.8.100:7001<span class="hljs-meta">#</span><span class="bash">解释</span>192.168.8.100:7008 #从服务器ip:端口;192.168.8.100:7001 #集群中任意一台ip:端口</code></pre><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">删除某一节点redis服务</span>src/redis-cli --cluster del-node 192.168.8.100:7008 4bf2fc80931392c248a7ae359bd1bf540872c688</code></pre><h3 id="Redis击穿、穿透、雪崩、预热"><a href="#Redis击穿、穿透、雪崩、预热" class="headerlink" title="Redis击穿、穿透、雪崩、预热"></a>Redis击穿、穿透、雪崩、预热</h3><h4 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h4><pre><code class="hljs makefile"><span class="hljs-section">问题:</span>Redis服务器命中率随时间逐步降低</code></pre><pre><code class="hljs gauss">缓存穿透的概念很简单，用户想要查询一个数据，发现redis内存数据库没有，也就是缓存没有命中，于是向持久层数据库查询。发现也没有，于是本次查询失败。当用户很多的时候，缓存都没有命中，于是都去请求了持久层数据库。这会给持久层数据库造成很大的压力，这时候就相当于出现了缓存穿透。这里需要注意和缓存击穿的区别，缓存击穿，是指一个<span class="hljs-built_in">key</span>非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个<span class="hljs-built_in">key</span>在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞。为了避免缓存穿透其实有很多种解决方案。下面介绍几种。<span class="hljs-number">1.1</span> 白名单策略:</code></pre><pre><code class="hljs angelscript"><span class="hljs-number">1.1</span><span class="hljs-number">.1</span>  将id放在bitmaps中,id作为bitmaps的offset<span class="hljs-number">1.1</span><span class="hljs-number">.2</span> 布隆过滤器:那这个布隆过滤器是如何解决redis中的缓存穿透呢？很简单首先也是对所有可能查询的参数以hash形式存储，当用户想要查询的时候，使用布隆过滤器发现不在集合中，就直接丢弃，不再对持久层查询。</code></pre><p>1.2 缓存空对象</p><pre><code class="hljs erlang">当存储层不命中后，即使返回的空对象也将其缓存起来，同时会设置一个过期时间，之后再访问这个数据将会从缓存中获取，保护了后端数据源；注意设置key的过期时间.</code></pre><p><img src="/images/redis/1589366209279.png"></p><pre><code class="hljs plain">但是这种方法会存在一个问题：即使对空值设置了过期时间，还是会存在缓存层和存储层的数据会有一段时间窗口的不一致，这对于需要保持一致性的业务会有影响。</code></pre><p>1.3 实施监控</p><pre><code class="hljs erlang">监控命中率(业务正常范围时,通常会有一个波动值),根据不同的情况,设置黑名单.</code></pre><h4 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h4><pre><code class="hljs angelscript">缓存雪崩是指，缓存层出现了错误，不能正常工作了。于是所有的请求都会达到存储层，存储层的调用量会暴增，造成存储层也会挂掉的情况。经常出现的情况是<span class="hljs-number">408</span>,<span class="hljs-number">500</span>的错误页面.</code></pre><p><img src="/images/redis/1589366273686.png"></p><pre><code class="hljs lsl"><span class="hljs-number">2</span>、解决方案（<span class="hljs-number">1</span>）redis高可用这个思想的含义是，既然redis有可能挂掉，那我多增设几台redis，这样一台挂掉之后其他的还可以继续工作，其实就是搭建的集群。（<span class="hljs-number">2</span>）限流降级这个解决方案的思想是，在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个<span class="hljs-type">key</span>只允许一个线程查询数据和写缓存，其他线程等待。（<span class="hljs-number">3</span>）数据预热 在即将发生大并发访问前手动触发加载缓存不同的<span class="hljs-type">key</span>，设置不同的过期时间，让缓存失效的时间点尽量均匀。</code></pre><h4 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h4><pre><code class="hljs angelscript">  缓存击穿是在高并发的条件下读取缓存数据，多用户同时请求同一个缓存数据，如果缓存中没有这条数据，那么这些用户又会同时去数据库中查询这条数据，浪费了系统资源，有悖于缓存数据的初衷，严重的话可能会造成服务器宕机的风险。  解决方案：   <span class="hljs-number">1</span>）.使用同步锁 synchronized 关键字，修饰在获取缓存的方法里面，保证在多用户同时请求条件下，只有第一个进入的线程去判断是否要查询数据库并存入缓存，其他线程只需在第一个线程结束后，从缓存中读取数据即可，无需再查询数据库。上面是对缓存穿透的再次优化，加入线程同步锁 以及 双重检查锁.双重检查锁：<span class="hljs-number">1.</span>避免当缓存数据没有失效时，其他线程排队等待。          <span class="hljs-number">2.</span>当第一个线程从数据库中获取到数据并存入缓存中时，其他线程直接从缓存获取数据即可。<span class="hljs-number">2</span>)不设置缓存时间，由后台创建定时任务去维护这部分缓存数据。这种方法请求时直接从缓存中获取数据，无需再判断是否从数据库中获取，定时任务也可在请求较少的时间段分批更新缓存数据。    当然代码量、代码复杂度增大，分批更新代表需要多个定时任务去维护缓存数据，同时更新有可能会造成缓存雪崩的情况。</code></pre><h4 id="数据预热"><a href="#数据预热" class="headerlink" title="数据预热"></a>数据预热</h4><pre><code>缓存预热:  提前将相关的缓存数据直接加载到缓存系统,避免用户在请求的时候,先查询数据库,然后再将数据缓存的问题.问题: 1.主从之间数据吞吐量大 2.数据同步操作频度高方案: 1.统计访问频度较高的热点数据,比如直接写个缓存刷新页面，上线时手工操作下 2.数据量不大，可以在项目启动的时候自动进行加载 3.定时刷新缓存</code></pre>]]></content>
    
    
    <categories>
      
      <category>Datebase</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Datebase</tag>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【MySQL】学习笔记</title>
    <link href="/2021/03/21/mysql/"/>
    <url>/2021/03/21/mysql/</url>
    
    <content type="html"><![CDATA[<blockquote><p>最流行的<a href="https://baike.baidu.com/item/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/696511">关系型数据库管理系统</a>之一。在 WEB 应用方面，是最好的 <a href="https://baike.baidu.com/item/RDBMS/1048260">RDBMS</a>。<a id="more"></a></p></blockquote><p><img src="/images/mysql/top.jpg"></p><h3 id="磁盘文件"><a href="#磁盘文件" class="headerlink" title="磁盘文件"></a><strong>磁盘文件</strong></h3><p><img src="/images/mysql/logfile.png"></p><p>MySQL的文件主要分为两大类，MySQl服务的文件和存储引擎的文件，主要分为三类：</p><ul><li>日志文件：MySQL实例写入的各种日志文件。</li><li>表结构文件：存放表结构定义的文件，.frm后缀文件，与存储引擎无关。</li><li>存储引擎数据文件：存储引擎负责对表中的数据进行读取和写入，每个存储引擎以自己的方式来保存表中的数据，在不同的存储引擎中数据存放的方式一般不同。 </li></ul><h4 id="日志文件"><a href="#日志文件" class="headerlink" title="日志文件"></a>日志文件</h4><p>记录数据库操作信息和错误信息，主要包括<em>错误日志</em>，<em>二进制日志</em>， <em>查询日志</em>， <em>慢查询日志</em>， <em>中继日志</em>等。</p><p>InnoBD相关的日志有：事务重做日志（redo log）和回滚日志（undo log）</p><p>查看命令：</p><pre><code class="hljs mysql">show variables like &#39;log_%&#39;;</code></pre><h4 id="错误日志（errorlog）"><a href="#错误日志（errorlog）" class="headerlink" title="错误日志（errorlog）"></a>错误日志（errorlog）</h4><p>​        用来记录 MySQL 服务器运行过程中遇到的所有严重错误信息以及MySQL每次启动和关闭的详细信息。比如，无法加载 MySQL 数据库的数据文件，或权限不正确等都会被记录在此，还有复制环境下，从服务器进程的信息也会被记录进错误日志。默认情况下，错误日志是开启的，从5.5.7开始无法关闭错误日志。</p><p>​      错误日志是存储在数据库的数据文件目录中，名称为 hostname.err，其中 hostname 为服务器主机名。在 MySQL 5.5.7 之前，数据库管理员可以删除很长时间之前的错误日志，以节省服务器上的硬盘空间， MySQL 5.5.7 之后，服务器将关闭此项功能，只能使用重命名原来的错误日志文件，手动冲洗日志创建一个新的，命令为：</p><p><code>mv hostname.err  hostname.err.old mysqladmin flush-logs</code></p><p>默认的错误日志名称为 hostname.err，其中 hostname 为服务器主机名。</p><p>错误日志所记录的信息是可以通过log-error和log-warnings来定义的，其中log-error是定义是否启用错误日志功能和错误日志的存储位置，log-warnings是定义是否将警告信息也定义至错误日志中。</p><pre><code class="hljs zsh"><span class="hljs-comment"># 可以直接定义为文件路径也可以为ON|OFF</span>log_error=/var/<span class="hljs-built_in">log</span>/mysqld.log<span class="hljs-comment"># 定义警告信息，默认为开启状态，默认2， 关闭设置为0</span>log_warnings=2</code></pre><p><code>log_warnings=0</code>,不记录警告信息，只记录错误信息</p><p><code>log_warnings=1</code>,记录警告信息，错误日志包含错误信息和警告信息</p><p><code>log_warnings&gt;1</code>,记录警告信息，访问时报错和访问拒接的连接错误信息也会被记录到错误日志中</p><p>MySQL 5.7.2之前默认为1， 5.7.2起默认值为2。</p><h4 id="查询日志"><a href="#查询日志" class="headerlink" title="查询日志"></a>查询日志</h4><p>查询日志在 MySQL 中被称为 general log(通用日志)，查询日志里面记录了<strong>数据库执行的所有命令</strong>。不管语句是否正确，都会被记录，具体原因如下:</p><ul><li><p>insert 查询为了避免数据冲突，如果此前插入过数据，当前插入的数据如果跟主键或唯一键的数据重复肯定会报错；</p></li><li><p>update 时也会查询因为更新的时候很可能会更新某一块数据；</p></li><li><p>delete 查询，只删除符合条件的数据；</p></li></ul><p>因此都会产生日志，在并发操作非常多的场景下，查询信息会非常多，那么如果都记录下来会导致 IO 非常大，影响 MySQL 性能。因此如果不是在调试环境下，是不建议开启查询日志功能的。</p><p>查询日志的开启有助于帮助我们分析哪些语句执行密集，执行密集的 select 语句对应的数据是否能够被缓存，同时也可以帮助我们分析问题。所以，可以根据实际情况来决定是否开启查询日志。</p><p>查询日志模式是关闭的，可以通过以下命令开启查询日志：</p><p><code>set global generallog=1 set global logoutput=&#39;table&#39;;</code></p><p><code>general_log=1</code> 为开启查询日志，0 为关闭查询日志，这个设置命令即时生效，不用重启 MySQL 服务器。</p><h4 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h4><p>慢查询会导致 CPU、IOPS、内存消耗过高，当数据库遇到性能瓶颈时，大部分时间都是由于慢查询导致的。开启慢查询日志，可以让 MySQL 记录下查询超过指定时间的语句，之后运维人员通过定位分析，能够很好的优化数据库性能。默认情况下，慢查询日志是不开启的，只有手动开启了，慢查询才会被记录到慢查询日志中。使用如下命令记录当前数据库的慢查询语句：</p><pre><code class="hljs zsh"><span class="hljs-comment"># 开启慢查询日志</span>slowquerylog=ON<span class="hljs-comment"># 慢查询阈值，单位秒</span>long_query_time=10<span class="hljs-comment"># 慢查询日志文件名</span><span class="hljs-comment"># 没有指定，默认名为 hostname-slow.log hostname为主机名</span><span class="hljs-comment"># 需要指定，不是绝对路径</span>slow_query_files=file_name</code></pre><p>使用命令 <code>set global slowquerylog=&#39;ON&#39;</code> 开启慢查询日志，只是对当前数据库有效，如果 MySQL 数据库重启后就会失效。所以如果要永久生效，就要修改配置文件<code> my.cnf</code>，设置<code> slowquerylog=ON</code> 并重启 MySQL 服务器。</p><h4 id="二进制日志（bin-log）"><a href="#二进制日志（bin-log）" class="headerlink" title="二进制日志（bin log）"></a>二进制日志（bin log）</h4><p>通过以下命令来查询 binlog 是否开启：</p><p><code>show variables like &#39;log_%&#39;;</code></p><p><img src="/images/mysql/binlog.png"> </p><p>默认是关闭的。</p><pre><code class="hljs zsh">log-bin=OFF</code></pre><p>需要通过配置进行开启</p><pre><code class="hljs zsh">log-bin=mysql-bin</code></pre><p>其中<code>mysql-bin</code>是<code>bin log</code>日志文件的文件名前缀，<code>bin log</code>日志文件的完整名称：<code>mysql-bin-000001.log</code></p><p><code>bin log</code>是一个二进制文件，主要记录数据库所有的<code>DDL</code>语句和<code>DML</code>语句，但不包含<code>SELECT、SHOW</code>语句内容。<code>DDL</code>语句直接记录到<code>bin log</code>日志中，<code>DML</code>语句必须通过事务提交才能记录到<code>bin log</code>日志中。<code>bin log</code> 中记录了对 MySQL 数据库执行更改的所有操作，并且记录了语句发生时间、执行时长、操作数据等其它额外信息。</p><p><code>bin log</code>主要用于实现mysql<strong>主从复制、数据备份、数据恢复</strong>。</p><ul><li><p>恢复（<code>recovery</code>）：某些数据的恢复需要二进制日志。比如，在一个数据库全备文件恢复后，用户可以通过二进制日志进行 <code>point-in-time</code> 的恢复；</p></li><li><p>复制（<code>replication</code>）：其原理与恢复类似，通过复制和执行二进制日志使一台远程的MySQL数据库（一般称为 <code>slave</code> 或者 <code>standby</code>）与一台 MySQL 数据库（一般称为 <code>master</code> 或者 <code>primary</code>）进行实时同步；</p></li><li><p>审计（<code>audit</code>）：用户可以通过二进制日志中的信息来进行审计，判断是否有对数据库进行注入攻击。</p></li></ul><p>除了上面介绍的几个作用外，<code>binlog</code> 对于事务存储引擎的崩溃恢复也有非常重要的作用，在开启 <code>binlog</code> 的情况下，为了保证 <code>binlog</code> 与 <code>redo</code> 的一致性，MySQL 将采用事务的两阶段提交协议。当 MySQL 系统发生崩溃时，事务在存储引擎内部的状态可能为 <code>prepared</code>（准备状态）和 <code>commit</code>（提交状态）两种，对于 <code>prepared</code> 状态的事务，是进行提交操作还是进行回滚操作，这时需要参考<code> binlog</code>，如果事务在 <code>binlog</code> 中存在，那么将其提交；如果不在 <code>binlog</code> 中存在，那么将其回滚，这样就保证了数据在主库和从库之间的一致性。</p><p>binlog 格式分为: STATEMENT、ROW 和 MIXED 三种：</p><ul><li><p>STATEMENT 格式的 binlog 记录的是数据库上执行的原生 SQL 语句。这种格式的优点是简单，简单地记录和执行这些语句，能够让主备保持同步，在主服务器上执行的 SQL 语句，在从服务器上执行同样的语句。另一个好处是二进制日志里的时间更加紧凑，所以相对而言，基于语句的复制模式不会使用太多带宽，同时也节约磁盘空间。并且通过 mysqlbinlog 工具容易读懂其中的内容。缺点就是同一条 SQL 在主库和从库上执行的时间可能稍微或很大不相同，因此在传输的二进制日志中，除了查询语句，还包括了一些元数据信息，如当前的时间戳。即便如此，还存在着一些无法被正确复制的 SQL。比如，使用 <code>INSERT INTO TB1 VALUE(CUURENT_DATE()) </code>这一条使用函数的语句插入的数据复制到当前从服务器上来就会发生变化，存储过程和触发器在使用基于语句的复制模式时也可能存在问题；另外一个问题就是基于语句的复制必须是串行化的，比如：InnoDB 的 next-key 锁等，并不是所有的存储引擎都支持基于语句的复制；</p></li><li><p>ROW 格式是从 MySQL 5.1 开始支持基于行的复制，也就是基于数据的复制，基于行的更改。这种方式会将实际数据记录在二进制日志中，它有其自身的一些优点和缺点，最大的好处是可以正确地复制每一行数据，一些语句可以被更加有效地复制，另外就是几乎没有基于行的复制模式无法处理的场景，对于所有的 SQL 构造、触发器、存储过程等都能正确执行；它的缺点就是二进制日志可能会很大，而且不直观，所以，你不能使用 mysqlbinlog 来查看二进制日志，也无法通过看二进制日志判断当前执行到那一条 SQL 语句。现在对于 ROW 格式的二进制日志基本是标配了，主要是因为它的优势远远大于缺点，并且由于 ROW 格式记录行数据，所以可以基于这种模式做一些 DBA 工具，比如数据恢复，不同数据库之间数据同步等；</p></li><li><p>MIXED 也是 MySQL 默认使用的二进制日志记录方式，但 MIXED 格式默认采用基于语句的复制，一旦发现基于语句的无法精确的复制时，就会采用基于行的复制。比如用到 UUID()、USER()、CURRENTUSER()、ROWCOUNT() 等无法确定的函数。</p></li></ul><h4 id="回滚日志-undo-log"><a href="#回滚日志-undo-log" class="headerlink" title="回滚日志(undo log)"></a><strong>回滚日志(<code>undo log</code>)</strong></h4><p>用于存储日志被修改前的值，从而保证如果修改出现异常，可以使用 <code>undo log </code>日志来实现回滚操作。<code>undo log </code>和<code> redo log</code> 记录物理日志不一样，它是逻辑日志，可以认为当 <code>delete</code> 一条记录时，<code>undo log</code> 中会记录一条对应的<code> insert</code> 记录，反之亦然，当 <code>update</code> 一条记录时，它记录一条对应相反的 <code>update</code> 记录，当执行 rollback 时，就可以从 <code>undo log</code> 中的逻辑记录读取到相应的内容并进行回滚。<code>undo log </code>默认存放在共享表空间中，在 <code>mySQL 5.6</code> 中，<code>undo log</code> 的存放位置还可以通过变量<code>innodbundodirectory</code>来自定义存放目录，默认值为“.”表示 <code>datadir </code>目录。</p><p>作用：</p><pre><code class="hljs plain">保存事务发生前数据的一个版本，可以用于回滚，同时可以提供多版本并发控制下的读（MVCC），即非锁定读</code></pre><p>内容：</p><pre><code class="hljs mel">逻辑格式的体制。在执行<span class="hljs-keyword">undo</span>的时候，仅仅是将数据从逻辑上恢复之事务之前的状态，而不是从物理页面上操作实现的，这一点是不同于<span class="hljs-keyword">redo</span> <span class="hljs-keyword">log</span></code></pre><p>什么时候产生</p><pre><code class="hljs mel">事务开始前，将当前的版本生成<span class="hljs-keyword">undo</span> <span class="hljs-keyword">log</span>. <span class="hljs-keyword">undo</span>也会产生<span class="hljs-keyword">redo</span>来保证<span class="hljs-keyword">undo</span> <span class="hljs-keyword">log</span>的可靠性</code></pre><p>什么时候释放</p><pre><code class="hljs mel">当事务提交之后，<span class="hljs-keyword">undo</span> <span class="hljs-keyword">log</span>不能立马被删掉，而是放入待清理的链表，由purge线程判断是否有其他事务在使用<span class="hljs-keyword">undo</span>段中表的上一个事务之前的版本信息，决定是否可以清理<span class="hljs-keyword">undo</span> <span class="hljs-keyword">log</span>的日志空间</code></pre><p>对应物理文件：</p><pre><code class="hljs mel">mysql5<span class="hljs-number">.6</span>之前，<span class="hljs-keyword">undo</span>表空间位于共享表空间的回滚段中，共享表空间默认的名称为ibdata,位于数据文件目录中。mysql5<span class="hljs-number">.6</span>之后，可以配置独立文件，完成数据库初始化后生效且不能改变<span class="hljs-keyword">undo</span> <span class="hljs-keyword">log</span>文件的个数，如果初始化数据库之前没有进行相关的配置，就无法配置独立的表空间。</code></pre><h4 id="重做日志-redo-log"><a href="#重做日志-redo-log" class="headerlink" title="重做日志(redo log)"></a><strong>重做日志(<code>redo log</code>)</strong></h4><p>为了最大程度的避免数据写入时，因为 IO 瓶颈造成的性能问题，MySQL 采用了这样一种缓存机制，先将数据写入内存中，再批量把内存中的数据统一刷回磁盘。为了避免将数据刷回磁盘过程中，因为掉电或系统故障带来的数据丢失问题，InnoDB 采用 <code>redo log</code> 来解决此问题。</p><p>作用：</p><pre><code class="hljs mel">确保事务的持久性。防止发生故障的时间，尚有脏页为写入磁盘。在重启mysql服务是，根据<span class="hljs-keyword">redo</span> <span class="hljs-keyword">log</span>进行重做，从而达到事务的持久性。</code></pre><p>内容：</p><pre><code class="hljs mel">物理格式的日志，激励物理数据页面的修改信息，其<span class="hljs-keyword">redo</span> <span class="hljs-keyword">log</span>是顺序写入<span class="hljs-keyword">redo</span> <span class="hljs-keyword">log</span> <span class="hljs-keyword">file</span>的物理文件中去的。</code></pre><p>什么时候产生</p><pre><code class="hljs mel">事务开始之后就产生<span class="hljs-keyword">redo</span> <span class="hljs-keyword">log</span>. <span class="hljs-keyword">redo</span> <span class="hljs-keyword">log</span>的落盘并不是随着事务的提交才写入的，而是在事务的执行过程中便开始写入<span class="hljs-keyword">redo</span> <span class="hljs-keyword">log</span>文件中的。</code></pre><p>什么时候释放</p><pre><code class="hljs mel">当对应事务的脏页写入到磁盘之后，<span class="hljs-keyword">redo</span> <span class="hljs-keyword">log</span> 的使命也就完成了，重做日志占用的空间就可以冲用（被覆盖）。</code></pre><h4 id="SQL语句的交互流程"><a href="#SQL语句的交互流程" class="headerlink" title="SQL语句的交互流程"></a>SQL语句的交互流程</h4><blockquote><p>说一下SQL语句的交互流程，包括客户端与服务端之间的交互以及服务内部的整体流程</p></blockquote><pre><code class="hljs MySQL">-- id是主键BEGINUPDATE user SET name&#x3D;&#39;aa&#39; WHERE id &#x3D; 1 FOR UPDATE;COMMIT;</code></pre><p><img src="/images/mysql/sqlquery.png"></p><p><img src="/images/mysql/querylogic.png"></p><h5 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h5><p>当客户端登陆MySQL的时候，对身份认证和权限判断。</p><h5 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h5><p>执行查询语句的时候，会先查询缓存(MySQL 8.0 版本后移除)。</p><h5 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a>分析器</h5><p>假设在没有命中查询缓存的情况下，SQL请求就会来到分析器。分析器负责明确SQL要完成的功能，以及检查SQL的语法是否正确。</p><h5 id="查询优化器"><a href="#查询优化器" class="headerlink" title="查询优化器"></a>查询优化器</h5><p>优化器会计算「IO 成本 + CPU」成本最小的那个索引来执行。优化器执行选出最优索引生成执行计划后，调用存储引擎接口被优化过的SQL语句。</p><h5 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h5><p>执行 SQL 的动作是在存储引擎中完成的，数据是被存放在内存或者是磁盘中的。</p><h5 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h5><p>执行器从准备更新一条数据到事务的提交的流程</p><ol><li>首先执行器根据 MySQL 的执行计划来查询数据，先是从缓存池中查询数据，如果没有就会去数据库中查询，如果查询到了就将其放到缓存池中。</li><li>在数据被缓存到缓存池的同时，会写入 undo log 日志文件。</li><li>更新的动作是在 BufferPool 中完成的，同时会将更新后的数据添加到 redo log buffer 中。</li><li>完成以后就可以提交事务，在提交的同时会做以下三件事。</li><li>（第一件事）将redo log buffer中的数据刷入到 redo log 文件中。</li><li>（第二件事）将本次操作记录写入到 bin log文件中。</li><li>（第三件事）将 bin log 文件名字和更新内容在 bin log 中的位置记录到redo log中，同时在 redo log 最后添加 commit 标记。</li></ol><p><img src="/images/mysql/sqllog.png"></p><h3 id="MySQL索引原理及优化"><a href="#MySQL索引原理及优化" class="headerlink" title="MySQL索引原理及优化"></a><strong>MySQL索引原理及优化</strong></h3><h4 id="索引介绍"><a href="#索引介绍" class="headerlink" title="索引介绍"></a>索引介绍</h4><h5 id="什么是索引"><a href="#什么是索引" class="headerlink" title="什么是索引"></a>什么是索引</h5><p>索引是一种能帮助 MySQL 提高查询效率的数据结构。</p><h5 id="索引优点和缺点"><a href="#索引优点和缺点" class="headerlink" title="索引优点和缺点"></a>索引优点和缺点</h5><p>索引的优点如下：</p><ul><li><p>快速访问数据表中的特定信息，提高检索速度。</p></li><li><p>创建唯一性索引，保证数据表中每一行数据的唯一性。</p></li><li><p>加速表与表之间的连接。</p></li><li><p>使用分组和排序进行数据检索时，可以显著减少查询中分组和排序的时间。</p></li></ul><p>索引的缺点：</p><ul><li><p>虽然提高了的查询速度，但却降低了更新表的速度，比如 update、insert，因为更新数据时，MySQL 不仅要更新数据，还要更新索引文件；</p></li><li><p>建立索引会占用磁盘文件的索引文件。</p></li></ul><p>使用索引注意事项：</p><ul><li><p>使用短索引，短索引不仅可以提高查询速度，更能节省磁盘空间和 I/O 操作；</p></li><li><p>索引列排序，MySQL 查询只使用一个索引，因此如果 where 子句中已经使用了索引的话，那么 order by 中的列是不会使用索引的，因此数据库默认排序可以符合要求的情况下，不要进行排序操作；尽量不要包含多个列的排序，如果需要最好给这些列创建复合索引；</p></li><li><p>like 语句操作，一般情况下不鼓励使用 like 操作，如果非使用不可， 注意 like “%aaa%” 不会使用索引，而like “aaa%”可以使用索引；</p></li><li><p>不要在列上进行运算；</p></li><li><p>不适用 NOT IN 和 &lt;&gt; 操作。</p></li></ul><h4 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h4><p>MySQL 的索引有两种分类方式：逻辑分类和物理分类。 按照逻辑分类，索引可分为：</p><h6 id="单列索引"><a href="#单列索引" class="headerlink" title="单列索引"></a>单列索引</h6><ul><li><p>主键索引：一张表只能有一个主键索引，不允许重复、不允许为 NULL；</p></li><li><p>唯一索引：数据列不允许重复，允许为 NULL 值，一张表可有多个唯一索引，但是一个唯一索引只能包含一列，比如身份证号码、卡号等都可以作为唯一索引；</p></li><li><p>普通索引：一张表可以创建多个普通索引，一个普通索引可以包含多个字段，允许数据重复，允许 NULL 值插入；</p></li></ul><h6 id="组合索引"><a href="#组合索引" class="headerlink" title="组合索引"></a>组合索引</h6><ul><li>在表中多个字段组合上创建的索引</li><li>组合索引的使用需要遵循<strong>最左前缀原则</strong></li><li>一般情况建议组合索引代替单列索引</li></ul><h6 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h6><ul><li>让搜索关键词更高效的一种索引，只有在MyISAM引擎、InnoDB（5.6以后）才能使用，而且只能在CHAR, VARCHAR, TEXT类型才能使用。</li><li>优先级最高 先执行 不会执行其他索引</li><li>存储引擎决定只执行一个索引</li></ul><h6 id="空间索引"><a href="#空间索引" class="headerlink" title="空间索引"></a>空间索引</h6><p>按照物理分类，索引可分为：</p><ul><li><p>聚集索引</p></li><li><p>非聚集索引</p></li></ul><h4 id="索引使用"><a href="#索引使用" class="headerlink" title="索引使用"></a>索引使用</h4><h5 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h5><p>各种索引的创建脚本如下：</p><pre><code class="hljs mysql">-- 创建主键索引 alter table t add primary key add (&#96;id&#96;); -- 创建唯一索引 alter table t add unique (&#96;username&#96;); -- 创建普通索引 alter table t add index index_name (&#96;username&#96;); -- 创建组合索引 alter table t add index index_name (&#96;username&#96;, &#96;age&#96;); -- 创建全文索引 alter table t add fulltext (&#96;username&#96;);</code></pre><h5 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h5><pre><code class="hljs mysql">DROP INDEX index_name ON table;</code></pre><h5 id="查看索引"><a href="#查看索引" class="headerlink" title="查看索引"></a>查看索引</h5><pre><code class="hljs mysql">SHOW INDEX FROM tablename</code></pre><h4 id="索引存储结构"><a href="#索引存储结构" class="headerlink" title="索引存储结构"></a>索引存储结构</h4><h5 id="InnoDB存储引擎逻辑结构"><a href="#InnoDB存储引擎逻辑结构" class="headerlink" title="InnoDB存储引擎逻辑结构"></a>InnoDB存储引擎逻辑结构</h5><p><img src="/images/mysql/tablespace.png"></p><p>InnoDB存储引擎逻辑存储结构可分为五级：表空间、段、区、页、行。</p><h5 id="索引存储结构-1"><a href="#索引存储结构-1" class="headerlink" title="索引存储结构"></a>索引存储结构</h5><p>索引在存储引擎中实现，不同的存储引擎使用不同的索引</p><p><strong>MyISAM和InnoDB</strong>存储引擎只支持<strong>B+TREE</strong>索引，即默认使用B+TREE,不能更换</p><p>MEMORY和HEAP存储引擎：执行HASH和BTREE</p><h5 id="B树与B-树"><a href="#B树与B-树" class="headerlink" title="B树与B+树"></a>B树与B+树</h5><h6 id="B树与B-树的区别"><a href="#B树与B-树的区别" class="headerlink" title="B树与B+树的区别"></a>B树与B+树的区别</h6><p>非叶子结点是否存储数据</p><pre><code class="hljs mipsasm"><span class="hljs-keyword">B树叶子结点和非叶子结点都会存储数据</span><span class="hljs-keyword">B+树只有叶子结点才会存储数据，而且存储的数据都在一行上，这些数据是由指针指向的，顺序的</span></code></pre><h5 id="非聚集索引（MyISAM）"><a href="#非聚集索引（MyISAM）" class="headerlink" title="非聚集索引（MyISAM）"></a>非聚集索引（MyISAM）</h5><ul><li><p>B+树叶子结点只存储数据行的指针。简单的说，<strong>数据跟索引不在一起</strong>。</p></li><li><p><strong>非聚集索引包含的主键索引和辅助索引都会存储指针的值</strong></p></li></ul><h6 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h6><p><img src="/images/mysql/prindex.png"></p><h6 id="辅助索引（次要索引）"><a href="#辅助索引（次要索引）" class="headerlink" title="辅助索引（次要索引）"></a>辅助索引（次要索引）</h6><p>在MyISAM中主键索引与辅助索引在结构上没有区别，只是主键索引要求key是唯一的，辅助索引的key是可以重复的。</p><p><img src="/images/mysql/secondkey.png"></p><h5 id="聚集索引（InnoDB）"><a href="#聚集索引（InnoDB）" class="headerlink" title="聚集索引（InnoDB）"></a>聚集索引（InnoDB）</h5><ul><li>主键索引的叶子结点都会存储数据，即<strong>数据和索引在一起</strong></li><li>辅助索引只存储主键值</li><li>如果没有主键索引，则使用唯一索引建立聚集索引；如果没有唯一索引，MySQL会按照一定规则创建聚集索引。</li></ul><h6 id="主键索引-1"><a href="#主键索引-1" class="headerlink" title="主键索引"></a>主键索引</h6><p>InnoDB要求<strong>必须有主键</strong>（MyISAM可以没有）。如果没有，MySQL会自动选择一个可以唯一标识数据记录的列作为主键；如果没有，MySQL会自动为InnoDB生成一个隐含字段作为主键，类型为长整型。</p><p><img src="/images/mysql/pkey.png"></p><h6 id="辅助索引"><a href="#辅助索引" class="headerlink" title="辅助索引"></a>辅助索引</h6><p>聚集索引这种实现方式按照主键搜索非常高效，但是辅助索引需要查询两遍：辅助索引获得主键，然后主键到索引中检索获取记录。这也就是<strong>回表查询</strong>。</p><pre><code class="hljs mysql">select * from user where name&#x3D;&#39;Alice&#39;;  回表查询，检索两次 辅助索引——&gt;主键索引——&gt;数据select id, name from user where name&#x3D;&#39;Alice&#39;; 不需要回表，辅助索引树上便可查到  覆盖索引（多用组合索引）</code></pre><p><img src="/images/mysql/spk.png"></p><h4 id="组合索引-1"><a href="#组合索引-1" class="headerlink" title="组合索引"></a>组合索引</h4><h5 id="哪些情况要创建索引"><a href="#哪些情况要创建索引" class="headerlink" title="哪些情况要创建索引"></a>哪些情况要创建索引</h5><ol><li>主键自动创建索引</li><li>频繁作为查询条件需要创建索引</li><li>多表关联查询中，关联字段应该创建索引 on 两边都需要创建索引</li><li>查询中排序字段，需要创建索引</li><li>频繁查找字短 覆盖索引</li><li>查询中统计或者分组字段 需要创建索引</li></ol><h5 id="哪些情况不需要创建索引"><a href="#哪些情况不需要创建索引" class="headerlink" title="哪些情况不需要创建索引"></a>哪些情况不需要创建索引</h5><ol><li>表记录太少</li><li>经常进行增删改查的表</li><li>频繁更新的字段</li><li>where条件里使用频率不高的字段</li></ol><h5 id="为什么使用组合索引"><a href="#为什么使用组合索引" class="headerlink" title="为什么使用组合索引"></a>为什么使用组合索引</h5><p>组合索引根据<strong>最左原则</strong>进行排序，为了节省索引空间和提升搜索性能，可以使用组合索引。</p><p>查询遵循最左前缀原则</p><ol><li><p>前缀索引 where like a%  可以使用索引</p><p>​                where like %a  不能使用索引</p></li><li><p>从左向右匹配 直到遇到范围查询 &gt; &lt; between like</p></li></ol><p>建立索引（a, b, c, d）</p><p>​    where a=1 and b=3 and c&gt;4 and d=2     到了c&gt;4时听了，d=2用不到索引</p><p>​    可以通过键索引构建为（a, b, d, c）进行优化</p><h4 id="索引失效与分析"><a href="#索引失效与分析" class="headerlink" title="索引失效与分析"></a>索引失效与分析</h4><h5 id="执行计划"><a href="#执行计划" class="headerlink" title="执行计划"></a>执行计划</h5><p><code>EXPALIN</code>命令, 可以对select语句的执行计划进行分析</p><h5 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h5><pre><code class="hljs pgsql">id, select_type, <span class="hljs-keyword">table</span>, <span class="hljs-keyword">type</span>, possible_keys, key, key_len, <span class="hljs-keyword">ref</span>, <span class="hljs-keyword">rows</span>, Extra</code></pre><h6 id="id"><a href="#id" class="headerlink" title="id"></a>id</h6><ul><li>每个select语句都会自动分配一个唯一标识</li><li>表示查询中操作表的顺序<ul><li>id相同：执行顺序由上而下</li><li>id不同：如果是子查询，id会自增；id越大，优先级越高</li><li>id相同的不同的同时存在</li></ul></li><li>id列尾NULL表示这是个结果集，不需要用来进行查询</li></ul><h6 id="select-type（重要）"><a href="#select-type（重要）" class="headerlink" title="select_type（重要）"></a>select_type（重要）</h6><p>查询类型，主要用于区分普通查询、联合查询（union,union all）、子查询。</p><ul><li>simple:不需要使用union操作或者包含子查询的简单select查询。有连接查询时，外层的查询也是simple，有且只有一个。</li></ul><ul><li>primary:需要union插座或者含有子查询，位于最外层的单位查询的select_type是primary</li></ul><pre><code class="hljs mysql">mysql&gt; explain select (select name from user where name&#x3D;&#39;xxxx&#39;) from user;+----+-------------+-------+------------+-------+---------------+-----------+---------+-------+------+----------+-------------+| id | select_type | table | partitions | type  | possible_keys | key       | key_len | ref   | rows | filtered | Extra       |+----+-------------+-------+------------+-------+---------------+-----------+---------+-------+------+----------+-------------+|  1 | PRIMARY     | user  | NULL       | index | NULL          | index_com | 198     | NULL  |    9 |   100.00 | Using index ||  2 | SUBQUERY    | user  | NULL       | ref   | index_com     | index_com | 99      | const |    1 |   100.00 | Using index |+----+-------------+-------+------------+-------+---------------+-----------+---------+-------+------+----------+-------------+2 rows in set (0.00 sec)</code></pre><ul><li>subquery：除了from子句中包含的子查询外，其他地方出现的子查询都可能是subquery</li></ul><pre><code class="hljs mysql">mysql&gt; explain select * from user where id&#x3D;(select max(id) from user);+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+------------------------------+| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref   | rows | filtered | Extra                        |+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+------------------------------+|  1 | PRIMARY     | user  | NULL       | const | PRIMARY       | PRIMARY | 4       | const |    1 |   100.00 | NULL                         ||  2 | SUBQUERY    | NULL  | NULL       | NULL  | NULL          | NULL    | NULL    | NULL  | NULL |     NULL | Select tables optimized away |+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+------------------------------+2 rows in set (0.00 sec)</code></pre><ul><li>dependent subquery:与dependent union类似，表示这个subquery的查询受外部查询的影响</li></ul><pre><code class="hljs mysql">mysql&gt; explain select id, name,(select name from dep d where d.dep&#x3D;u.id) from user u;+----+--------------------+-------+------------+-------+---------------+-----------+---------+------+------+----------+-------------+| id | select_type        | table | partitions | type  | possible_keys | key       | key_len | ref  | rows | filtered | Extra       |+----+--------------------+-------+------------+-------+---------------+-----------+---------+------+------+----------+-------------+|  1 | PRIMARY            | u     | NULL       | index | NULL          | index_com | 198     | NULL |    9 |   100.00 | Using index ||  2 | DEPENDENT SUBQUERY | d     | NULL       | ALL   | NULL          | NULL      | NULL    | NULL |    2 |    50.00 | Using where |+----+--------------------+-------+------------+-------+---------------+-----------+---------+------+------+----------+-------------+2 rows in set (0.00 sec)</code></pre><ul><li>union:union连接的两个查询，第一个是primary，除第一个外的，都是union</li></ul><pre><code class="hljs mysql">mysql&gt; explain select * from user where name&#x3D;&#39;xxxx&#39; union select * from user where name&#x3D;&#39;zhangsan&#39;;+----+--------------+------------+------------+------+---------------+-----------+---------+-------+------+----------+-----------------+| id | select_type  | table      | partitions | type | possible_keys | key       | key_len | ref   | rows | filtered | Extra           |+----+--------------+------------+------------+------+---------------+-----------+---------+-------+------+----------+-----------------+|  1 | PRIMARY      | user       | NULL       | ref  | index_com     | index_com | 99      | const |    1 |   100.00 | Using index     ||  2 | UNION        | user       | NULL       | ref  | index_com     | index_com | 99      | const |    1 |   100.00 | Using index     || NULL | UNION RESULT | &lt;union1,2&gt; | NULL       | ALL  | NULL          | NULL      | NULL    | NULL  | NULL |     NULL | Using temporary |+----+--------------+------------+------------+------+---------------+-----------+---------+-------+------+----------+-----------------+3 rows in set (0.00 sec)</code></pre><ul><li><p>dependent union:与union一样，出现union或者union all语句中，表示查询受外部表查询的影响</p></li><li><p>union result:包含union的结果集，id为NULL</p></li><li><p>Derived:from子句中出现的子查询，也叫做派生表</p></li></ul><h6 id="table"><a href="#table" class="headerlink" title="table"></a>table</h6><p>表名 ，查询中使用了别名，这里就显示别名</p><h6 id="type（重要）"><a href="#type（重要）" class="headerlink" title="type（重要）"></a>type（重要）</h6><p>依次由好到差</p><pre><code class="hljs pgsql"><span class="hljs-keyword">system</span>, const, eq_ref, <span class="hljs-keyword">ref</span>, fulltext, ref_or_null, unique_subquery, index_subquery, range, index_merge, <span class="hljs-keyword">index</span>, <span class="hljs-keyword">ALL</span></code></pre><p>除了ALL，其他类型都可以用到索引；</p><p>除了index_merge，其他type值可以用到一个索引</p><ul><li>system：表中只有一行或者是空表</li><li>const（重要）：使用唯一索引或者主键索引</li></ul><pre><code class="hljs mysql">mysql&gt; explain select * from user where id&#x3D;1;+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref   | rows | filtered | Extra |+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+|  1 | SIMPLE      | user  | NULL       | const | PRIMARY       | PRIMARY | 4       | const |    1 |   100.00 | NULL  |+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+</code></pre><ul><li>eq_ref（重要）： 连接字段主键或者唯一索引</li></ul><p>通常出现在多表的join查询，表示对于前表的每一个结果，都<strong>只能匹配到后表的一行结果</strong>，并且查询到额比较操作通常是“=”，效率更高</p><pre><code class="hljs mysql">mysql&gt; explain select a.id from user a left join dep b on a.dep&#x3D;b.id;+----+-------------+-------+------------+--------+---------------+---------+---------+------------+------+----------+-------------+| id | select_type | table | partitions | type   | possible_keys | key     | key_len | ref        | rows | filtered | Extra       |+----+-------------+-------+------------+--------+---------------+---------+---------+------------+------+----------+-------------+|  1 | SIMPLE      | a     | NULL       | ALL    | NULL          | NULL    | NULL    | NULL       |    9 |   100.00 | NULL        ||  1 | SIMPLE      | b     | NULL       | eq_ref | PRIMARY       | PRIMARY | 4       | test.a.dep |    1 |   100.00 | Using index |+----+-------------+-------+------------+--------+---------------+---------+---------+------------+------+----------+-------------+</code></pre><ul><li>ref（重要）：针对非唯一索引，使用等值（=）查询非主键，或者使用了最左前缀原则索引的查询</li></ul><pre><code class="hljs mysql">mysql&gt; explain select * from user where name&#x3D;&#39;xxx&#39;;+----+-------------+-------+------------+------+---------------+-----------+---------+-------+------+----------+-------+| id | select_type | table | partitions | type | possible_keys | key       | key_len | ref   | rows | filtered | Extra |+----+-------------+-------+------------+------+---------------+-----------+---------+-------+------+----------+-------+|  1 | SIMPLE      | user  | NULL       | ref  | index_com     | index_com | 99      | const |    2 |   100.00 | NULL  |+----+-------------+-------+------------+------+---------------+-----------+---------+-------+------+----------+-------+1 row in set (0.00 sec)mysql&gt; explain select * from user where name&#x3D;&#39;xxx&#39; and age&#x3D;2;+----+-------------+-------+------------+------+---------------+-----------+---------+-------+------+----------+-----------------------+| id | select_type | table | partitions | type | possible_keys | key       | key_len | ref   | rows | filtered | Extra                 |+----+-------------+-------+------------+------+---------------+-----------+---------+-------+------+----------+-----------------------+|  1 | SIMPLE      | user  | NULL       | ref  | index_com     | index_com | 99      | const |    2 |    11.11 | Using index condition |+----+-------------+-------+------------+------+---------------+-----------+---------+-------+------+----------+-----------------------+1 row in set (0.01 sec)</code></pre><ul><li>fulltext：全文索引检索</li><li>ref_or_null：与ref类似，只是增加了null值的比较，实际上用的不多</li><li>unique_subquery：用于where中的in形式子查询，子查询返回不重复唯一值</li><li>index_subquery：用于in形式子查询使用到辅助索引或者in常数列表，子查询可能返回重复值，可以使用索引将子查询去重</li><li>range（重要）：<strong>索引范围扫描</strong>，常见于&gt;, &lt;, is null, between, in, like等运算符的查询</li></ul><pre><code class="hljs mysql">mysql&gt; explain select * from user where name&#x3D;&#39;xxx&#39; and age&gt;3;+----+-------------+-------+------------+-------+---------------+-----------+---------+------+------+----------+-----------------------+| id | select_type | table | partitions | type  | possible_keys | key       | key_len | ref  | rows | filtered | Extra                 |+----+-------------+-------+------------+-------+---------------+-----------+---------+------+------+----------+-----------------------+|  1 | SIMPLE      | user  | NULL       | range | index_com     | index_com | 104     | NULL |    1 |   100.00 | Using index condition |+----+-------------+-------+------------+-------+---------------+-----------+---------+------+------+----------+-----------------------+1 row in set (0.00 sec)</code></pre><ul><li>index_merge：表示使用两个以上的索引，最后去交集或者并集。常见and, or的条件使用不同的索引。官方排序这个在ref_or_null之后，但实际上由于要读取所有索引，性能大部分时间不如range</li><li>index（重要）：<strong>关键字：条件是出现在索引树中的节点。可能没有完全匹配索引</strong></li></ul><p><strong>索引全表扫描</strong>，把索引从头到尾扫一遍，常见于使用索引列就可以处理，不需要读取文件查询，可以使用索引排序或者分组的查询。</p><pre><code class="hljs mysql">mysql&gt; explain select * from user order by id;+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------+| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra |+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------+|  1 | SIMPLE      | user  | NULL       | index | NULL          | PRIMARY | 4       | NULL |    9 |   100.00 | NULL  |+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------+1 row in set (0.00 sec)</code></pre><ul><li>ALL：全表扫描</li></ul><h6 id="possible-keys"><a href="#possible-keys" class="headerlink" title="possible_keys"></a>possible_keys</h6><p>此次查询中可能选用的索引，一个或多个</p><h6 id="key"><a href="#key" class="headerlink" title="key"></a>key</h6><p>查询真正使用到的索引。select_type为index_merge时，这里可能会出现两个以上索引；其他情况，select_type只会出现一个</p><h6 id="key-len"><a href="#key-len" class="headerlink" title="key_len"></a>key_len</h6><ul><li>用于处理查询的索引长度。如果是单列索引，那就整个索引算进去；如果是多列索引，那么查询不一定是所有的列。</li><li>另外，<em>key_len</em>指极端<em>where</em>条件中用到的索引长度，而排序和分组苦短用到了索引，也不会计算到<em>key_len</em>中。</li><li>不是准确值</li></ul><pre><code class="hljs mysql">mysql&gt; explain select * from user where id&#x3D;1;+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref   | rows | filtered | Extra |+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+|  1 | SIMPLE      | user  | NULL       | const | PRIMARY       | PRIMARY | 4       | const |    1 |   100.00 | NULL  |+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+1 row in set (0.01 sec)int为4</code></pre><h6 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h6><ul><li>如果使用的是常数等值，这里回现实const</li><li>如果是链接查询，被驱动表的执行计划这里会显示驱动表的关联字段</li><li>如果是条件使用表达式或者函数，或者条件列发生内部隐式转换，这里可能会显示func</li></ul><h6 id="rows"><a href="#rows" class="headerlink" title="rows"></a>rows</h6><p>这里是执行计划中估算的扫描行数，不是精确值（InnoDB不是精确值，MyISAM是精确值，主要原因是InnoDB里面使用了MVCC并发机制）</p><h6 id="Extra（重要）"><a href="#Extra（重要）" class="headerlink" title="Extra（重要）"></a>Extra（重要）</h6><p>这一列包含不适合其他列显示但非常重要的额外信息。</p><p><strong>using temporary</strong></p><ul><li>表示使用了临时表</li><li>MySQL在对比查询结果<em>order by</em> 和<em>group by</em></li><li>临时表可以是内存临时表和磁盘临时表，执行计划中看不出来，需要查看status变量（used_tmp_table, used_tmp_disk_table）才能看出来</li></ul><pre><code class="hljs mysql">mysql&gt; explain select distinct a.id from user a,dep b where a.dep&#x3D;b.id;+----+-------------+-------+------------+-------+-------------------+---------+---------+------+------+----------+----------------------------------------------------+| id | select_type | table | partitions | type  | possible_keys     | key     | key_len | ref  | rows | filtered | Extra                                              |+----+-------------+-------+------------+-------+-------------------+---------+---------+------+------+----------+----------------------------------------------------+|  1 | SIMPLE      | b     | NULL       | index | PRIMARY           | PRIMARY | 4       | NULL |    2 |   100.00 | Using index; Using temporary                       ||  1 | SIMPLE      | a     | NULL       | ALL   | PRIMARY,index_com | NULL    | NULL    | NULL |    9 |    11.11 | Using where; Using join buffer (Block Nested Loop) |+----+-------------+-------+------------+-------+-------------------+---------+---------+------+------+----------+----------------------------------------------------+2 rows in set (0.03 sec)</code></pre><p><strong>no tables used</strong></p><p>不带from子句的查询或者From dual查询（oracle操作）</p><p><em>使用not in()形式子查询或者not exists运算符的连接查询（反连接）</em></p><p>即，一般链接查询是先查询哪表，再查询外表；反连接是先查询外表，再查询内表。</p><pre><code class="hljs mysql">mysql&gt; explain select now();+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra          |+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+|  1 | SIMPLE      | NULL  | NULL       | NULL | NULL          | NULL | NULL    | NULL | NULL |     NULL | No tables used |+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+1 row in set (0.00 sec)</code></pre><p><strong>using filesort(重要)</strong></p><ul><li>排序时无法使用到索引会出现这个，常见于order by 和group by语句中</li><li>说明MySQL会使用一个外部的索引排序，而不是按照索引顺序进行读取</li><li>MySQL中无法利用索引完成的排序操作称为“文件排序”</li></ul><pre><code class="hljs mysql">mysql&gt; explain select * from user order by dep;+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra          |+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+|  1 | SIMPLE      | user  | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    9 |   100.00 | Using filesort |+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+1 row in set (0.00 sec)</code></pre><p><strong>using index(重要)</strong></p><p>查询时<em>不需要回表查询</em>,直接通过索引就可以获取查询的数据</p><ul><li>表示想醒的select查询中使用到了覆盖索引，避免访问表的数据行，效率不错</li><li>如果同时使用Using where，说明索引被用来查找索引键值</li><li>如果没有同时出现Using where，表明索引用来读取数据而非执行查找动作</li></ul><pre><code class="hljs mysql">mysql&gt; explain select name, age from user where name&#x3D;&#39;xxx&#39;;+----+-------------+-------+------------+------+---------------+-----------+---------+-------+------+----------+-------------+| id | select_type | table | partitions | type | possible_keys | key       | key_len | ref   | rows | filtered | Extra       |+----+-------------+-------+------------+------+---------------+-----------+---------+-------+------+----------+-------------+|  1 | SIMPLE      | user  | NULL       | ref  | index_com     | index_com | 99      | const |    2 |   100.00 | Using index |+----+-------------+-------+------------+------+---------------+-----------+---------+-------+------+----------+-------------+1 row in set, (0.01 sec)</code></pre><p><strong>using where(重要)</strong></p><p>表示存储引擎返回的记录并不是所有都满足查询条件，需要server层进行过滤。效率比较低</p><pre><code class="hljs mysql">mysql&gt; explain select * from user where age&#x3D;23;+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+|  1 | SIMPLE      | user  | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    9 |    11.11 | Using where |+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+1 row in set (0.00 sec)mysql&gt; explain select name, age from user where name&#x3D;&#39;xxx&#39; order by id;+----+-------------+-------+------------+------+---------------+-----------+---------+-------+------+----------+------------------------------------------+| id | select_type | table | partitions | type | possible_keys | key       | key_len | ref   | rows | filtered | Extra                                    |+----+-------------+-------+------------+------+---------------+-----------+---------+-------+------+----------+------------------------------------------+|  1 | SIMPLE      | user  | NULL       | ref  | index_com     | index_com | 99      | const |    2 |   100.00 | Using where; Using index; Using filesort |+----+-------------+-------+------------+------+---------------+-----------+---------+-------+------+----------+------------------------------------------+1 row in set (0.00 sec)</code></pre><p>查询条件中氛围限制条件和检查条件。5.6之前，存储引擎只能使用限定条件扫描数据并返回，然后server层根据检查条件进行过滤返回真正符合查询的数据。5.6.x之后支持<em>ICP</em>特性，可以把检查条件页下推倒存储引擎层，不符合检查条件和限制条件的数据，直接不读取，这样就大大减少了存储引擎层扫描的记录数量。Extra列显示using index condition。</p><pre><code class="hljs mysql">mysql&gt; explain select * from user where name&#x3D;&#39;xxx&#39; and age&gt;3;+----+-------------+-------+------------+-------+---------------+-----------+---------+------+------+----------+-----------------------+| id | select_type | table | partitions | type  | possible_keys | key       | key_len | ref  | rows | filtered | Extra                 |+----+-------------+-------+------------+-------+---------------+-----------+---------+------+------+----------+-----------------------+|  1 | SIMPLE      | user  | NULL       | range | index_com     | index_com | 104     | NULL |    1 |   100.00 | Using index condition |+----+-------------+-------+------------+-------+---------------+-----------+---------+------+------+----------+-----------------------+1 row in set (0.00 sec)mysql&gt; explain select * from user where name like &#39;xx%&#39;;+----+-------------+-------+------------+-------+---------------+-----------+---------+------+------+----------+-----------------------+| id | select_type | table | partitions | type  | possible_keys | key       | key_len | ref  | rows | filtered | Extra                 |+----+-------------+-------+------------+-------+---------------+-----------+---------+------+------+----------+-----------------------+|  1 | SIMPLE      | user  | NULL       | range | index_com     | index_com | 99      | NULL |    3 |   100.00 | Using index condition |+----+-------------+-------+------------+-------+---------------+-----------+---------+------+------+----------+-----------------------+1 row in set (0.00 sec)</code></pre><p><strong>firstmatch(tb_name)</strong></p><p>5.6.x开始引入的优化子查询的新特性之一，常见于where子句含有in()类型的子查询。如果内表的数据量比较大，就可能出现这个。</p><p><strong>loosescan(m..n)</strong></p><p>5.6.x之后引入的优化子查询的新特性之一，在in()类型的子查询中，子查询返回的可能有重复记录时，就可能出现这个.</p><p>除此之外，还有很多查询数据字典库，执行计划过程中发现不可能存在结果的一些提示信息</p><h6 id="filtered"><a href="#filtered" class="headerlink" title="filtered"></a>filtered</h6><p>使用explain extended时会出现这个。5.7之后的版本默认会有这个字段（不需要使用explain extended）。这个字段表示存储引擎返回的数据在server层过滤后，剩下多少满足查询的记录比例（100%不是具体记录数）。</p><h4 id="相关面试题"><a href="#相关面试题" class="headerlink" title="相关面试题"></a>相关面试题</h4><h5 id="什么是索引？"><a href="#什么是索引？" class="headerlink" title="什么是索引？"></a>什么是索引？</h5><p>索引是一种能帮助 MySQL 提高查询效率的数据结构。</p><h5 id="索引分别有哪些优点和缺点？"><a href="#索引分别有哪些优点和缺点？" class="headerlink" title="索引分别有哪些优点和缺点？"></a>索引分别有哪些优点和缺点？</h5><p>索引的优点如下：</p><ul><li><p>快速访问数据表中的特定信息，提高检索速度。</p></li><li><p>创建唯一性索引，保证数据表中每一行数据的唯一性。</p></li><li><p>加速表与表之间的连接。</p></li><li><p>使用分组和排序进行数据检索时，可以显著减少查询中分组和排序的时间。</p></li></ul><p>索引的缺点：</p><ul><li><p>虽然提高了的查询速度，但却降低了更新表的速度，比如 update、insert，因为更新数据时，MySQL 不仅要更新数据，还要更新索引文件；</p></li><li><p>建立索引会占用磁盘文件的索引文件。</p></li></ul><p>使用索引注意事项：</p><ul><li><p>使用短索引，短索引不仅可以提高查询速度，更能节省磁盘空间和 I/O 操作；</p></li><li><p>索引列排序，MySQL 查询只使用一个索引，因此如果 where 子句中已经使用了索引的话，那么 order by 中的列是不会使用索引的，因此数据库默认排序可以符合要求的情况下，不要进行排序操作；尽量不要包含多个列的排序，如果需要最好给这些列创建复合索引；</p></li><li><p>like 语句操作，一般情况下不鼓励使用 like 操作，如果非使用不可， 注意 like “%aaa%” 不会使用索引，而like “aaa%”可以使用索引；</p></li><li><p>不要在列上进行运算；</p></li><li><p>不适用 NOT IN 和 &lt;&gt; 操作。</p></li></ul><h5 id="索引有几种类型？分别如何创建？"><a href="#索引有几种类型？分别如何创建？" class="headerlink" title="索引有几种类型？分别如何创建？"></a>索引有几种类型？分别如何创建？</h5><p>MySQL 的索引有两种分类方式：逻辑分类和物理分类。 按照逻辑分类，索引可分为：</p><ul><li><p>主键索引：一张表只能有一个主键索引，不允许重复、不允许为 NULL；</p></li><li><p>唯一索引：数据列不允许重复，允许为 NULL 值，一张表可有多个唯一索引，但是一个唯一索引只能包含一列，比如身份证号码、卡号等都可以作为唯一索引；</p></li><li><p>普通索引：一张表可以创建多个普通索引，一个普通索引可以包含多个字段，允许数据重复，允许 NULL 值插入；</p></li><li><p>全文索引：让搜索关键词更高效的一种索引。</p></li></ul><p>按照物理分类，索引可分为：</p><ul><li><p>聚集索引：一般是表中的主键索引，如果表中没有显示指定主键，则会选择表中的第一个不允许为 NULL 的唯一索引，如果还是没有的话，就采用 Innodb 存储引擎为每行数据内置的 6 字节 ROWID 作为聚集索引。每张表只有一个聚集索引，因为聚集索引的键值的逻辑顺序决定了表中相应行的物理顺序。聚集索引在精确查找和范围查找方面有良好的性能表现（相比于普通索引和全表扫描），聚集索引就显得弥足珍贵，聚集索引选择还是要慎重的（一般不会让没有语义的自增 id 充当聚集索引）；</p></li><li><p>非聚集索引：该索引中索引的逻辑顺序与磁盘上行的物理存储顺序不同（非主键的那一列），一个表中可以拥有多个非聚集索引。</p></li></ul><p>各种索引的创建脚本如下：</p><pre><code class="hljs mysql">-- 创建主键索引 alter table t add primary key add (&#96;id&#96;); -- 创建唯一索引 alter table t add unique (&#96;username&#96;); -- 创建普通索引 alter table t add index index_name (&#96;username&#96;); -- 创建全文索引 alter table t add fulltext (&#96;username&#96;);</code></pre><h5 id="能否给手机号的前-6-位创建索引？如何创建？"><a href="#能否给手机号的前-6-位创建索引？如何创建？" class="headerlink" title="能否给手机号的前 6 位创建索引？如何创建？"></a>能否给手机号的前 6 位创建索引？如何创建？</h5><p>可以，创建方式有两种：</p><ul><li><p><code>alter table t add index index_phone(phone(6));</code></p></li><li><p><code>create index index_phone on t(phone(6));</code></p></li></ul><h5 id="如何查询一张表的所有索引？"><a href="#如何查询一张表的所有索引？" class="headerlink" title="如何查询一张表的所有索引？"></a>如何查询一张表的所有索引？</h5><p><code>SHOW INDEX FROM T</code> 查询表 T 所有索引。</p><h5 id="主索引和唯一索引有什么区别？"><a href="#主索引和唯一索引有什么区别？" class="headerlink" title="主索引和唯一索引有什么区别？"></a>主索引和唯一索引有什么区别？</h5><ul><li><p>主索引不能重复且不能为空，唯一索引不能重复，但可以为空；</p></li><li><p>一张表只能有一个主索引，但可以有多个唯一索引；</p></li><li><p>主索引的查询性能要高于唯一索引。</p></li></ul><h5 id="主索引和非主索引有什么区别？"><a href="#主索引和非主索引有什么区别？" class="headerlink" title="主索引和非主索引有什么区别？"></a>主索引和非主索引有什么区别？</h5><p>存储结构上</p><p>​    主键索引：叶子节点存储整行数据</p><p>​    非主键索引：叶子节点存储主键值</p><p>检索上</p><p>​    主键索引：直接通过索引获取数据</p><p>​    非主键索引：可能会有回表查询</p><p>创建方式上</p><p>​    主键索引：表中主键自动创建；若无主键，唯一索引+NotNull主键；若没有，自重创建隐士列rowid做主键</p><p>​    非主键索引：主动创建</p><h5 id="辅助索引为什么只存主键？"><a href="#辅助索引为什么只存主键？" class="headerlink" title="辅助索引为什么只存主键？"></a>辅助索引为什么只存主键？</h5><p>空间上：成本高</p><p>时间上：查询成本少了，插入成本不变，更新成本高</p><h5 id="在-InnDB-中主键索引为什么比普通索引的查询性能高？"><a href="#在-InnDB-中主键索引为什么比普通索引的查询性能高？" class="headerlink" title="在 InnDB 中主键索引为什么比普通索引的查询性能高？"></a>在 InnDB 中主键索引为什么比普通索引的查询性能高？</h5><p>因为普通索引的查询会多执行一次检索操作。</p><p>比如主键查询 select * from t where id=10 只需要搜索 id 的这棵 B+ 树。</p><p>普通索引查询 select * from t where f=3 会先查询 f 索引树，得到 id 的值之后再去搜索 id 的 B+ 树，因为多执行了一次检索，所以执行效率就比主键索引要低。</p><h5 id="唯一索引和普通索引哪个性能更好？"><a href="#唯一索引和普通索引哪个性能更好？" class="headerlink" title="唯一索引和普通索引哪个性能更好？"></a>唯一索引和普通索引哪个性能更好？</h5><ul><li><p>对于查询操作来说：普通索引和唯一索引的性能相近，都是从索引树中进行查询；</p></li><li><p>对于更新操作来说：唯一索引要比普通索引执行的慢，因为唯一索引需要先将数据读取到内存中，再在内存中进行数据的唯一效验，所以执行起来要比普通索引更慢。</p></li></ul><h5 id="什么叫回表查询？"><a href="#什么叫回表查询？" class="headerlink" title="什么叫回表查询？"></a>什么叫回表查询？</h5><p>普通索引查询到主键索引后，回到主键索引树搜索的过程，我们称为回表查询。</p><p>参考SQL：</p><pre><code class="hljs mysql">mysql&gt; create table T( id int primary key, k int not null, name varchar(16), index (k))engine&#x3D;InnoDB;</code></pre><p>如果语句是 select * from T where ID=500，即主键查询方式，则只需要检索主键 ID 字段。</p><pre><code class="hljs mysql">mysql&gt; select * from T where ID&#x3D;500; +-----+---+-------+ | id | k | name | +-----+---+-------+ | 500 | 5 | name5 | +-----+---+-------+</code></pre><p>如果语句是 select * from T where k=5，即普通索引查询方式，则需要先搜索 k 索引树，得到 ID 的值为 500，再到 ID 索引树搜索一次，这个过程称为回表查询。</p><pre><code class="hljs mysql">mysql&gt; select * from T where k&#x3D;5; +-----+---+-------+ | id | k | name | +-----+---+-------+ | 500 | 5 | name5 | +-----+---+-------+</code></pre><p>也就是说，基于非主键索引的查询需要多扫描一棵索引树。因此，我们在应用中应该尽量使用主键查询。</p><h5 id="以下-SQL-有什么问题？该如何优化？"><a href="#以下-SQL-有什么问题？该如何优化？" class="headerlink" title="以下 SQL 有什么问题？该如何优化？"></a>以下 SQL 有什么问题？该如何优化？</h5><pre><code class="hljs mysql">select * from t where f&#x2F;2&#x3D;100;</code></pre><p>该 SQL 会导致引擎放弃索引而全表扫描，尽量避免在索引列上计算。可改为：</p><pre><code class="hljs mysql">select * from t where f&#x3D;100*2;</code></pre><h5 id="为什么-MySQL-官方建议使用自增主键作为表的主键？"><a href="#为什么-MySQL-官方建议使用自增主键作为表的主键？" class="headerlink" title="为什么 MySQL 官方建议使用自增主键作为表的主键？"></a>为什么 MySQL 官方建议使用自增主键作为表的主键？</h5><p>因为自增主键是连续的，在插入过程中尽量减少页分裂，即使要进行页分裂，也只会分裂很少一部分；并且自增主键也能减少数据的移动，每次插入都是插入到最后，所以自增主键作为表的主键，对于表的操作来说性能是最高的。</p><p>InnoDB存储引擎逻辑存储结构可分为五级：表空间、段（索引段+数据段）、区（1M=64个页）、页(默认16K)、行。</p><p><img src="/images/mysql/tablespace.png"></p><p>假设一页有4条数据</p><p>非自增情况</p><p><img src="/images/mysql/page1.png"></p><p><img src="/images/mysql/page2.png"></p><p><img src="/images/mysql/page3.png"></p><p>自增情况</p><p><img src="/images/mysql/page4.png"></p><h5 id="自增主键有哪些优缺点"><a href="#自增主键有哪些优缺点" class="headerlink" title="自增主键有哪些优缺点?"></a>自增主键有哪些优缺点?</h5><p>优点：</p><ul><li><p>数据存储空间很小；</p></li><li><p>性能最好；</p></li><li><p>减少页分裂。</p></li></ul><p>缺点：</p><ul><li><p>数据量过大，可能会超出自增长取值范围；</p></li><li><p>无法满足分布式存储，分库分表的情况下无法合并表；</p></li><li><p>主键有自增规律，容易被破解；</p></li></ul><p>综上所述：是否需要使用自增主键，需要根据自己的业务场景来设计。如果是单表单库，则优先考虑自增主键，如果是分布式存储，分库分表，则需要考虑数据合并的业务场景来做数据库设计方案。</p><h5 id="MySQL-最多可以创建多少个索引列？"><a href="#MySQL-最多可以创建多少个索引列？" class="headerlink" title="MySQL 最多可以创建多少个索引列？"></a>MySQL 最多可以创建多少个索引列？</h5><p>MySQL 中最多可以创建 16 个索引列。</p><h5 id="以下-like-查询会使用索引的是哪一个选项？为什么？"><a href="#以下-like-查询会使用索引的是哪一个选项？为什么？" class="headerlink" title="以下 like 查询会使用索引的是哪一个选项？为什么？"></a>以下 like 查询会使用索引的是哪一个选项？为什么？</h5><p>A.like ‘%A%’  B.like ‘%A’  C.like ‘A%’  D.以上都不是 </p><p>答：C 题目解析：like 查询要走索引，查询字符不能以通配符（%）开始。</p><h5 id="如何让-like-abc-走索引查询？"><a href="#如何让-like-abc-走索引查询？" class="headerlink" title="如何让 like %abc 走索引查询？"></a>如何让 like %abc 走索引查询？</h5><p>我们知道如果要让 like 查询要走索引，查询字符不能以通配符（%）开始，如果要让 like %abc 也走索引，可以使用 REVERSE() 函数来创建一个函数索引，查询脚本如下：</p><pre><code class="hljs mysql">select * from t where reverse(f) like reverse(&#39;%abc&#39;);</code></pre><h5 id="列值为-NULL-时，查询会使用到索引吗？"><a href="#列值为-NULL-时，查询会使用到索引吗？" class="headerlink" title="列值为 NULL 时，查询会使用到索引吗？"></a>列值为 NULL 时，查询会使用到索引吗？</h5><p>在 MySQL 5.6 以上的 InnoDB 存储引擎会正常触发索引。但为了兼容低版本的 MySQL 和兼容其他数据库存储引擎，不建议使用 NULL 值来存储和查询数据，建议设置列为 NOT NULL，并设置一个默认值，比如 0 和空字符串等，如果是 datetime 类型，可以设置成 1970-01-01 00:00:00 这样的特殊值。</p><h5 id="以下语句会走索引么？"><a href="#以下语句会走索引么？" class="headerlink" title="以下语句会走索引么？"></a>以下语句会走索引么？</h5><p><code>select * from t where year(date)&gt;2018;</code></p><p>不会，因为在索引列上涉及到了运算。</p><h5 id="MySQL-联合索引应该注意什么？"><a href="#MySQL-联合索引应该注意什么？" class="headerlink" title="MySQL 联合索引应该注意什么？"></a>MySQL 联合索引应该注意什么？</h5><p>联合索引又叫复合索引，MySQL 中的联合索引，遵循最左匹配原则，比如，联合索引为 key(a,b,c)，则能触发索引的搜索组合是 a|ab|abc 这三种查询。</p><h5 id="联合索引的作用是什么？"><a href="#联合索引的作用是什么？" class="headerlink" title="联合索引的作用是什么？"></a>联合索引的作用是什么？</h5><p>联合索引的作用如下：</p><ul><li><p>用于多字段查询，比如，建了一个 key(a,b,c) 的联合索引，那么实际等于建了 key(a)、key(a,b)、key(a,b,c) 等三个索引，我们知道，每多一个索引，就会多一些写操作和占用磁盘空间的开销，尤其是对大数据量的表来说，这可以减少一部分不必要的开销；</p></li><li><p>覆盖索引，比如，对于联合索引 key(a,b,c) 来说，如果使用 SQL：select a,b,c from table where a=1 and b = 1 ，就可以直接通过遍历索引取得数据，而无需回表查询，这就减少了随机的 IO 操作，减少随机的 IO 操作，可以有效的提升数据库查询的性能，是非常重要的数据库优化手段之一；</p></li><li><p>索引列越多，通过索引筛选出的数据越少。</p></li></ul><h5 id="什么是最左匹配原则？它的生效原则有哪些？"><a href="#什么是最左匹配原则？它的生效原则有哪些？" class="headerlink" title="什么是最左匹配原则？它的生效原则有哪些？"></a>什么是最左匹配原则？它的生效原则有哪些？</h5><p>最左匹配原则也叫最左前缀原则，是 MySQL 中的一个重要原则，说的是索引以最左边的为起点任何连续的索引都能匹配上，当遇到范围查询（&gt;、&lt;、between、like）就会停止匹配。 生效原则来看以下示例，比如表中有一个联合索引字段 index(a,b,c)：</p><ul><li>where a=1 只使用了索引 a；</li><li>where a=1 and b=2 只使用了索引 a,b；</li><li>where a=1 and b=2 and c=3 使用a,b,c；</li><li>where b=1 or where c=1 不使用索引；</li><li>where a=1 and c=3 只使用了索引 a；</li><li>where a=3 and b like ‘xx%’ and c=3 只使用了索引 a,b。</li></ul><h5 id="什么是前缀索引？"><a href="#什么是前缀索引？" class="headerlink" title="什么是前缀索引？"></a>什么是前缀索引？</h5><p>前缀索引也叫局部索引，比如给身份证的前 10 位添加索引，类似这种给某列部分信息添加索引的方式叫做前缀索引。</p><h5 id="为什么要用前缀索引？"><a href="#为什么要用前缀索引？" class="headerlink" title="为什么要用前缀索引？"></a>为什么要用前缀索引？</h5><p>前缀索引能有效减小索引文件的大小，让每个索引页可以保存更多的索引值，从而提高了索引查询的速度。但前缀索引也有它的缺点，不能在 order by 或者 group by 中触发前缀索引，也不能把它们用于覆盖索引。</p><h5 id="什么情况下适合使用前缀索引？"><a href="#什么情况下适合使用前缀索引？" class="headerlink" title="什么情况下适合使用前缀索引？"></a>什么情况下适合使用前缀索引？</h5><p>当字符串本身可能比较长，而且前几个字符就开始不相同，适合使用前缀索引；相反情况下不适合使用前缀索引，比如，整个字段的长度为 20，索引选择性为 0.9，而我们对前 10 个字符建立前缀索引其选择性也只有 0.5，那么我们需要继续加大前缀字符的长度，但是这个时候前缀索引的优势已经不明显，就没有创建前缀索引的必要了。</p><h5 id="什么是覆盖索引？"><a href="#什么是覆盖索引？" class="headerlink" title="什么是覆盖索引？"></a>什么是覆盖索引？</h5><p>覆盖索引是指，索引上的信息足够满足查询请求，不需要再回到主键上去取数据。</p><h5 id="什么是页？"><a href="#什么是页？" class="headerlink" title="什么是页？"></a>什么是页？</h5><p>页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页。主存和磁盘以页为单位交换数据。数据库系统的设计者巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次磁盘 IO 就可以完全载入。</p><h5 id="索引的常见存储算法有哪些？"><a href="#索引的常见存储算法有哪些？" class="headerlink" title="索引的常见存储算法有哪些？"></a>索引的常见存储算法有哪些？</h5><ul><li><p>哈希存储法：以 key、value 方式存储，把值存入数组中使用哈希值确认数据的位置，如果发生哈希冲突，使用链表存储数据；</p></li><li><p>有序数组存储法：按顺序存储，优点是可以使用二分法快速找到数据，缺点是更新效率，适合静态数据存储；</p></li><li><p>搜索树：以树的方式进行存储，查询性能好，更新速度快。</p></li></ul><h5 id="InnoDB-为什么要使用-B-树，而不是-B-树、Hash、红黑树或二叉树？"><a href="#InnoDB-为什么要使用-B-树，而不是-B-树、Hash、红黑树或二叉树？" class="headerlink" title="InnoDB 为什么要使用 B+ 树，而不是 B 树、Hash、红黑树或二叉树？"></a>InnoDB 为什么要使用 B+ 树，而不是 B 树、Hash、红黑树或二叉树？</h5><p>因为 B 树、Hash、红黑树或二叉树存在以下问题：</p><ul><li><p>B 树：不管叶子节点还是非叶子节点，都会保存数据，这样导致在非叶子节点中能保存的指针数量变少（有些资料也称为扇出），指针少的情况下要保存大量数据，只能增加树的高度，导致IO操作变多，查询性能变低；</p></li><li><p>Hash：虽然可以快速定位，但是没有顺序，IO 复杂度高；</p></li><li><p>二叉树：树的高度不均匀，不能自平衡，查找效率跟数据有关（树的高度），并且 IO 代价高；</p></li><li><p>红黑树：树的高度随着数据量增加而增加，IO 代价高。</p></li></ul><h5 id="为什么-InnoDB-要使用-B-树来存储索引？"><a href="#为什么-InnoDB-要使用-B-树来存储索引？" class="headerlink" title="为什么 InnoDB 要使用 B+ 树来存储索引？"></a>为什么 InnoDB 要使用 B+ 树来存储索引？</h5><p>B+Tree 中的 B 是 Balance，是平衡的意思，它在经典 B Tree 的基础上进行了优化，增加了顺序访问指针，在B+Tree 的每个叶子节点增加一个指向相邻叶子节点的指针，就形成了带有顺序访问指针的 B+Tree，这样就提高了区间访问性能：如果要查询 key 为从 18 到 49 的所有数据记录，当找到 18 后，只需顺着节点和指针顺序遍历就可以一次性访问到所有数据节点，极大提到了区间查询效率（无需返回上层父节点重复遍历查找减少 IO 操作）。</p><p>索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上，这样的话，索引查找过程中就要产生磁盘 IO 消耗，相对于内存存取，IO 存取的消耗要高几个数量级，所以索引的结构组织要尽量减少查找过程中磁盘 IO 的存取次数，从而提升索引效率。 综合所述，InnDB 只有采取 B+ 树的数据结构存储索引，才能提供数据库整体的操作性能。</p><h5 id="优化器选择查询索引的影响因素有哪些？"><a href="#优化器选择查询索引的影响因素有哪些？" class="headerlink" title="优化器选择查询索引的影响因素有哪些？"></a>优化器选择查询索引的影响因素有哪些？</h5><p>优化器的目的是使用最小的代价选择最优的执行方案，影响优化器选择索引的因素如下：</p><ul><li><p>扫描行数，扫描的行数越少，执行代价就越少，执行效率就会越高；</p></li><li><p>是否使用了临时表；</p></li><li><p>是否排序。</p></li></ul><h5 id="MySQL-是如何判断索引扫描行数的多少？"><a href="#MySQL-是如何判断索引扫描行数的多少？" class="headerlink" title="MySQL 是如何判断索引扫描行数的多少？"></a>MySQL 是如何判断索引扫描行数的多少？</h5><p>MySQL 的扫描行数是通过索引统计列（cardinality）大致得到并且判断的，而索引统计列（cardinality）可以通过查询命令 show index 得到，索引扫描行数的多少就是通过这个值进行判断的。</p><h5 id="MySQL-是如何得到索引基数的？它准确吗？"><a href="#MySQL-是如何得到索引基数的？它准确吗？" class="headerlink" title="MySQL 是如何得到索引基数的？它准确吗？"></a>MySQL 是如何得到索引基数的？它准确吗？</h5><p>MySQL 的索引基数并不准确，因为 MySQL 的索引基数是通过采样统计得到的，比如 InnoDb 默认会有 N 个数据页，采样统计会统计这些页面上的不同值得到一个平均值，然后除以这个索引的页面数就得到了这个索引基数。</p><h5 id="MySQL-如何指定查询的索引？"><a href="#MySQL-如何指定查询的索引？" class="headerlink" title="MySQL 如何指定查询的索引？"></a>MySQL 如何指定查询的索引？</h5><p>在 MySQL 中可以使用 force index 强行选择一个索引，具体查询语句如下：</p><pre><code class="hljs mysql">select * from t force index(index_t);</code></pre><h5 id="在-MySQL-中指定了查询索引，为什么没有生效？"><a href="#在-MySQL-中指定了查询索引，为什么没有生效？" class="headerlink" title="在 MySQL 中指定了查询索引，为什么没有生效？"></a>在 MySQL 中指定了查询索引，为什么没有生效？</h5><p>我们知道在 MySQL 中使用 force index 可以指定查询的索引，但并不是一定会生效，原因是 MySQL 会根据优化器自己选择索引，如果 force index 指定的索引出现在候选索引上，这个时候 MySQL 不会在判断扫描的行数的多少直接使用指定的索引，如果没在候选索引中，即使 force index 指定了索引也是不会生效的。</p><h5 id="以下-or-查询有什么问题吗？该如何优化？"><a href="#以下-or-查询有什么问题吗？该如何优化？" class="headerlink" title="以下 or 查询有什么问题吗？该如何优化？"></a>以下 or 查询有什么问题吗？该如何优化？</h5><p><code>select * from t where num=10 or num=20;</code></p><p>答：如果使用 or 查询会使 MySQL 放弃索引而全表扫描，可以改为：</p><pre><code class="hljs mysql">select * from t where num&#x3D;10 union select * from t where num&#x3D;20;</code></pre><h5 id="以下查询要如何优化？"><a href="#以下查询要如何优化？" class="headerlink" title="以下查询要如何优化？"></a>以下查询要如何优化？</h5><p>表中包含索引：</p><ul><li><p>KEY mid (mid)</p></li><li><p>KEY begintime (begintime)</p></li><li><p>KEY dg (day,group)</p></li></ul><p>使用以下 SQL 进行查询：</p><p><code>select f from t where day=&#39;2010-12-31&#39; and group=18 and begintime&lt;&#39;2019-12-31 12:14:28&#39; order by begintime limit 1;</code></p><p>答：此查询理论上是使用 dg 索引效率更高，通过 explain 可以对比查询扫描次数。由于使用了 order by begintime 则使查询放弃了 dg 索引，而使用 begintime 索引，从侧面印证 order by 关键字会影响查询使用索引，这时可以使查询强制使用索引，改为以下SQL：</p><pre><code class="hljs mysql">select f from t use index(dg) where day&#x3D;&#39;2010-12-31&#39; and group&#x3D;18 and begintime&lt; &#39;2019-12-31 12:14:28&#39; order by begintime limit 1;</code></pre><h5 id="MySQL-会错选索引吗？"><a href="#MySQL-会错选索引吗？" class="headerlink" title="MySQL 会错选索引吗？"></a>MySQL 会错选索引吗？</h5><p>MySQL 会错选索引，比如 k 索引的速度更快，但是 MySQL 并没有使用而是采用了 v 索引，这种就叫错选索引，因为索引选择是 MySQL 的服务层的优化器来自动选择的，但它在复杂情况下也和人写程序一样出现缺陷。</p><h5 id="如何解决-MySQL-错选索引的问题？"><a href="#如何解决-MySQL-错选索引的问题？" class="headerlink" title="如何解决 MySQL 错选索引的问题？"></a>如何解决 MySQL 错选索引的问题？</h5><ul><li><p>删除错选的索引，只留下对的索引；</p></li><li><p>使用 force index 指定索引；</p></li><li><p>修改 SQL 查询语句引导 MySQL 使用我们期望的索引，比如把 order by b limit 1 改为 order by b,a limit 1 语义是相同的，但 MySQL 查询的时候会考虑使用 a 键上的索引。</p></li></ul><h5 id="如何优化身份证的索引？"><a href="#如何优化身份证的索引？" class="headerlink" title="如何优化身份证的索引？"></a>如何优化身份证的索引？</h5><p>在中国因为前 6 位代表的是地区，所以很多人的前六位都是相同的，如果我们使用前缀索引为 6 位的话，性能提升也并不是很明显，但如果设置的位数过长，那么占用的磁盘空间也越大，数据页能放下的索引值就越少，搜索效率也越低。针对这种情况优化方案有以下两种：</p><ul><li><p>使用身份证倒序存储，这样设置前六位的意义就很大了；</p></li><li><p>使用 hash 值，新创建一个字段用于存储身份证的 hash 值。</p></li></ul><h3 id="MySQL锁原理及案"><a href="#MySQL锁原理及案" class="headerlink" title="MySQL锁原理及案"></a><strong>MySQL锁原理及案</strong></h3><h4 id="锁基础"><a href="#锁基础" class="headerlink" title="锁基础"></a>锁基础</h4><p>按照所里的粒度分类，MySQL主要包含三种类型（级别）的锁定机制：</p><ul><li>全局锁：锁的是整个datebase，由MySQL的SQL layer层实现</li><li>表级锁：锁的是某个table，由MySQL的SQL layer层实现</li><li>行级锁：锁的是某行数据，也可能是行之间的间隙，由某些存储引擎实现，比如InnoDB</li></ul><p>按照锁的功能可以分为：共享读锁和排它写锁</p><p>按照锁的实现方式分为：悲观锁和乐观锁</p><p>表级锁与行级锁区别</p><ul><li>表级锁：开销小，加锁块；不会出现死锁；锁粒度大，发生冲突的概率高，并发度低</li><li>行级锁：开销大，加锁慢；会出现死锁；锁粒度小，发生锁冲突的概率低，并发度高</li></ul><p><img src="/images/mysql/lock.png"></p><h4 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h4><p>表级锁有两种：</p><ul><li>表锁</li><li>与数据锁（meta data lock, MDL）</li></ul><p>查看锁状态</p><pre><code class="hljs mysql">mysql&gt;  +----------------------------+-------+| Variable_name              | Value |+----------------------------+-------+| Table_locks_immediate      | 172   || Table_locks_waited         | 0     || Table_open_cache_hits      | 61    || Table_open_cache_misses    | 10    || Table_open_cache_overflows | 0     |+----------------------------+-------+5 rows in set (0.05 sec)</code></pre><p>表现形式：</p><ul><li>表共享读锁（Table Read Lock）</li><li>表独占写锁（Table Write Lock）</li></ul><p>手动加锁</p><pre><code class="hljs mysql">lock table 表名称 read(write), 表名称2 read(write), 其他；</code></pre><p>查看表锁情况</p><pre><code class="hljs mysql">show open tables;</code></pre><p>删除表锁</p><pre><code class="hljs mysql">unlock tables;</code></pre><h5 id="操作演示"><a href="#操作演示" class="headerlink" title="操作演示"></a>操作演示</h5><pre><code class="hljs mysql">-- 新建表 CREATE TABLE mylock (id INT(11) NOT NULL AUTO_INCREMENT,name VARCHAR(20) DEFAULT NULL,PRIMARY KEY (id));INSERT INTO mylock VALUES(1, &#39;a&#39;);INSERT INTO mylock VALUES(2, &#39;b&#39;);INSERT INTO mylock VALUES(3, &#39;c&#39;);INSERT INTO mylock VALUES(4, &#39;d&#39;);INSERT INTO mylock VALUES(5, &#39;e&#39;);</code></pre><p><img src="/images/mysql/tlock.png"></p><pre><code class="hljs mysql">-- session1mysql&gt; lock table mylock read;Query OK, 0 rows affected (0.00 sec)mysql&gt; select * from mylock;+----+------+| id | name |+----+------+|  1 | a    ||  2 | b    ||  3 | c    ||  4 | d    ||  5 | e    |+----+------+5 rows in set (0.00 sec)mysql&gt; select * from dept;ERROR 1100 (HY000): Table &#39;dept&#39; was not locked with LOCK TABLES-- session2mysql&gt; select * from mylock;+----+------+| id | name |+----+------+|  1 | a    ||  2 | b    ||  3 | c    ||  4 | d    ||  5 | e    |+----+------+5 rows in set (0.00 sec)mysql&gt; update mylock set name&#x3D;&#39;bb&#39; where id&#x3D;2;  -- 修改阻塞，自动加上行写锁-- session1mysql&gt; unlock tables;Query OK, 0 rows affected (0.00 sec)-- session2Query OK, 1 row affected (1 min 35.08 sec)Rows matched: 1  Changed: 1  Warnings: 0        -- session1解锁后立刻执行mysql&gt; update mylock set name&#x3D;&#39;b&#39; where id&#x3D;2;    Query OK, 1 row affected (0.01 sec)Rows matched: 1  Changed: 1  Warnings: 0-- session1mysql&gt; select * from dept;                      -- session1可以访问其他表+----+------+| id | name |+----+------+|  1 | a    ||  2 | b    ||  3 | c    ||  4 | d    ||  5 | e    |+----+------+5 rows in set (0.00 sec)</code></pre><p><img src="/images/mysql/twlock.png"></p><pre><code class="hljs mysql">-- session1mysql&gt; lock table mylock read;Query OK, 0 rows affected (0.00 sec)mysql&gt; select * from mylock;+----+------+| id | name |+----+------+|  1 | a    ||  2 | b    ||  3 | c    ||  4 | d    ||  5 | e    |+----+------+5 rows in set (0.00 sec)mysql&gt; select * from dept;ERROR 1100 (HY000): Table &#39;dept&#39; was not locked with LOCK TABLESmysql&gt; update mylock set name&#x3D;&#39;b&#39; where id&#x3D;2;   -- session可以修改Query OK, 1 row affected (0.01 sec)Rows matched: 1  Changed: 1  Warnings: 0-- session2mysql&gt; select * from mylock;                    -- 查询阻塞-- session1mysql&gt; unlock tables;Query OK, 0 rows affected (0.00 sec)-- session2+----+------+| id | name |+----+------+|  1 | a    ||  2 | b    ||  3 | c    ||  4 | d    ||  5 | e    |+----+------+5 rows in set (0.00 sec)</code></pre><h4 id="元数据锁-MDL"><a href="#元数据锁-MDL" class="headerlink" title="元数据锁(MDL)"></a>元数据锁(MDL)</h4><p><strong>MDL不需要显示使用，在访问一个表的时候会自动加上</strong>。**MDL的锁作用是保证写的正确性，可以想像一下：如果一个查询正在遍历表中的数据，而执行期间另一个线程对这个表结构做变更删除一行，那么查询县城拿到的结果便可能跟当前的表结构对应不上。</p><p>因此，在MySQ L5.5版本中引入MDL，<strong>当对一个表中做增删改查操作时，加MDL读锁；当要对表结构变更操作时，加MDL写锁</strong>。</p><ul><li>读锁之间不互斥，因此可以有多个线程对一行表增删改查</li><li>读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性。因此，如果有两个线程同时要给一个表加字段，其中一个要等另一个执行完才能执行。</li></ul><p><img src="/images/mysql/tmlock.png"></p><pre><code class="hljs mysql">-- session1mysql&gt; begin;Query OK, 0 rows affected (0.00 sec)mysql&gt; select * from mylock;+----+------+| id | name |+----+------+|  1 | a    ||  2 | b    ||  3 | c    ||  4 | d    ||  5 | e    |+----+------+5 rows in set (0.00 sec)-- session2mysql&gt; alter table mylock add dep int;        -- 阻塞-- session1mysql&gt; commit;                                -- 释放锁Query OK, 0 rows affected (0.00 sec)-- session2Query OK, 0 rows affected (12.80 sec)         -- 完成修改Records: 0  Duplicates: 0  Warnings: 0mysql&gt; desc mylock;+-------+-------------+------+-----+---------+----------------+| Field | Type        | Null | Key | Default | Extra          |+-------+-------------+------+-----+---------+----------------+| id    | int(11)     | NO   | PRI | NULL    | auto_increment || name  | varchar(20) | YES  |     | NULL    |                || dep   | int(11)     | YES  |     | NULL    |                |+-------+-------------+------+-----+---------+----------------+3 rows in set (0.00 sec)</code></pre><h4 id="MySQL行级锁"><a href="#MySQL行级锁" class="headerlink" title="MySQL行级锁"></a>MySQL行级锁</h4><h5 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h5><p>由存储引擎实现，利用存储引擎锁住索引项来实现。</p><p>InnoDB的行级锁，按照锁定范围来说，分为三种：</p><pre><code class="hljs mysql">- 记录锁（Record locks）:锁定索引中一条记录- 间隙锁（Gap Locks）:要么锁索引中间的值，要么锁住第一个索引记录前面的值或者最后一个索引后面的值。- Next-key Locks:是索引记录上的记录锁在索引记录之前的间隙锁的组合</code></pre><p>InnoDB的行级锁，按照功能分为两种：</p><pre><code class="hljs mysql">- 共享锁（S）:允许一个事务去读一行，阻止其他事务获得相同数据集的排它锁- 排它锁（S）:允许获得排它锁的事务更新数据，阻止其他事务获得相同数据集的共享读锁(不是读)和排它锁</code></pre><p>对于UPDATE、DELETE、INSERT语句，InnoDB会自动给设计数据集加排它锁（X）;</p><p>对于普通SELECT语句，InnoDB不回家任何锁，事务可以通过以下语句显示给记录集加共享锁和排它锁。</p><p><strong>手动添加共享锁(S)</strong></p><pre><code class="hljs mysql">select * from table_name where ... lock in share mode;</code></pre><p><strong>手动添加排它锁(X)</strong></p><pre><code class="hljs mysql">select * from table_name where ... for update;</code></pre><p>InnoDB也实现了表级锁，也就是意向锁。意向锁是mysql内部使用的，不需要用户干预。</p><pre><code class="hljs mysql">- 意向共享锁（IS）:事务打算给数据行加行共享锁，事务给一个数据行加行共享锁必须先去的该表的IS锁。- 意向排它锁（IX）:事务打算给数据行加行排它锁，事务给一个数据行加行排它锁必须先去的该表的IX锁。</code></pre><p>意向锁和行锁可以共存，意向锁的主要作用是为了【全表更新数据】是的性能提升。否则在全表更新数据时，需要先检索该表是否有某系记录上面有行锁。</p><table><thead><tr><th></th><th>共享锁(S)</th><th>排它锁(X)</th><th>意向共享锁（IS）</th><th>意向排它锁（IX）</th></tr></thead><tbody><tr><td>共享锁(S)</td><td>兼容</td><td>冲突</td><td>兼容</td><td>冲突</td></tr><tr><td>排它锁(X)</td><td>冲突</td><td>冲突</td><td>冲突</td><td>冲突</td></tr><tr><td>意向共享锁（IS）</td><td>兼容</td><td>冲突</td><td>兼容</td><td>兼容</td></tr><tr><td>意向排它锁（IX）</td><td>冲突</td><td>冲突</td><td>兼容</td><td>兼容</td></tr></tbody></table><p><strong>InnoDB行锁</strong>是通过给索引上的<strong>索引项加锁来实现</strong>的，因此InnoDB这种行锁的实现特点意味着：只有通过<strong>索引条件检索的数据</strong>，InnoDB才使用<strong>行级锁</strong>；否则，InnoDB将使用<strong>表级锁</strong></p><p>InnoDB锁使用<strong>行级锁</strong>争用状态查看命令</p><pre><code class="hljs mysql">mysql&gt; show status like &#39;innodb_row_lock%&#39;;+-------------------------------+-------+| Variable_name                 | Value |+-------------------------------+-------+| Innodb_row_lock_current_waits | 0     |  -- 当前正在等待锁定的数量| Innodb_row_lock_time          | 0     |  -- +从系统启动到现在锁定总时间长度| Innodb_row_lock_time_avg      | 0     |  -- +每次等待锁话平均时间| Innodb_row_lock_time_max      | 0     |  -- 从系统启动到现在等待最长那次时间| Innodb_row_lock_waits         | 0     |  -- +从系统启动到现在总共等待的次数+-------------------------------+-------+5 rows in set (0.00 sec)</code></pre><h5 id="两阶段锁"><a href="#两阶段锁" class="headerlink" title="两阶段锁"></a>两阶段锁</h5><p>传统的RDMS加锁原则就是2PL（Two-Phase Locking,两阶段锁）。相对而言，2PL比较容易理解：加锁阶段与解锁阶段，并且保证加锁阶段与解锁阶段不相交。</p><p><img src="/images/mysql/2pll.png"></p><pre><code class="hljs plain">加锁阶段：只加锁，不放锁解锁阶段：只放锁，不加锁</code></pre><h5 id="行读锁"><a href="#行读锁" class="headerlink" title="行读锁"></a>行读锁</h5><pre><code class="hljs mysql">-- session1mysql&gt; begin;Query OK, 0 rows affected (0.00 sec)mysql&gt; select * from mylock where id&#x3D;1 lock in share mode; -- 手动id&#x3D;1加行读锁+----+------+------+| id | name | dep  |+----+------+------+|  1 | a    | NULL |+----+------+------+1 row in set (0.00 sec)-- session2mysql&gt; update mylock set name&#x3D;&#39;bb&#39; where id&#x3D;2;  -- 未锁定可以修改mysql&gt; update mylock set name&#x3D;&#39;aa&#39; where id&#x3D;1;  -- 锁定不可修改ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction   -- 锁定超时Query OK, 1 row affected (0.01 sec) Rows matched: 1  Changed: 1  Warnings: 0-- session1mysql&gt; commit;  -- 提交事务&#x2F;rollback释放锁Query OK, 0 rows affected (0.00 sec)-- session2Query OK, 1 row affected (12.06 sec)Rows matched: 1  Changed: 1  Warnings: 0</code></pre><h5 id="行读锁升级为表锁"><a href="#行读锁升级为表锁" class="headerlink" title="行读锁升级为表锁"></a>行读锁升级为表锁</h5><pre><code class="hljs mysql">-- session1mysql&gt; begin;Query OK, 0 rows affected (0.00 sec)mysql&gt; select * from mylock where name&#x3D;&#39;a&#39; lock in share mode; -- 手动name&#x3D;&#39;a&#39;非索引 行读锁升级表锁+----+------+------+| id | name | dep  |+----+------+------+|  1 | a    | NULL |+----+------+------+1 row in set (0.00 sec)-- session2mysql&gt; update mylock set name&#x3D;&#39;b&#39; where id&#x3D;2;  -- 阻塞 不可修改ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transactionmysql&gt; update mylock set name&#x3D;&#39;a&#39; where id&#x3D;1;   -- 阻塞 不可修改ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction-- session1mysql&gt; commit;  -- 提交事务&#x2F;rollback释放锁Query OK, 0 rows affected (0.00 sec)-- session2mysql&gt; update mylock set name&#x3D;&#39;b&#39; where id&#x3D;2;Query OK, 1 row affected (0.00 sec)Rows matched: 1  Changed: 1  Warnings: 0mysql&gt; update mylock set name&#x3D;&#39;a&#39; where id&#x3D;1;Query OK, 0 rows affected (0.00 sec)Rows matched: 1  Changed: 0  Warnings: 0</code></pre><h5 id="行写锁"><a href="#行写锁" class="headerlink" title="行写锁"></a>行写锁</h5><pre><code class="hljs mysql">-- session1mysql&gt; begin;Query OK, 0 rows affected (0.00 sec)mysql&gt; select * from mylock where id&#x3D;1 for update;-- session2mysql&gt; update mylock set name&#x3D;&#39;bb&#39; where id&#x3D;2;  -- 未锁定可以修改Query OK, 1 row affected (0.01 sec) Rows matched: 1  Changed: 1  Warnings: 0mysql&gt; select * from mylock where id&#x3D;1;  -- select本身不加锁 可以访问+----+------+------+| id | name | dep  |+----+------+------+|  1 | a    | NULL |+----+------+------+1 row in set (0.00 sec)mysql&gt; select * from mylock where id&#x3D;1 lock in share mode; -- 共享读锁不可获得ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction mysql&gt; update mylock set name&#x3D;&#39;aa&#39; where id&#x3D;1;  -- 锁定不可修改ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction -- session1mysql&gt; commit;  -- 提交事务&#x2F;rollback释放锁Query OK, 0 rows affected (0.00 sec)-- session2Query OK, 1 row affected (12.06 sec)Rows matched: 1  Changed: 1  Warnings: 0</code></pre><h5 id="行写锁升级为表锁"><a href="#行写锁升级为表锁" class="headerlink" title="行写锁升级为表锁"></a>行写锁升级为表锁</h5><pre><code class="hljs mysql">-- session1mysql&gt; begin;Query OK, 0 rows affected (0.00 sec)mysql&gt; select * from mylock where name&#x3D;&#39;a&#39; for update; -- 手动name&#x3D;&#39;a&#39;非索引 行读锁升级表锁+----+------+------+| id | name | dep  |+----+------+------+|  1 | a    | NULL |+----+------+------+1 row in set (0.00 sec)-- session2mysql&gt; select * from mylock;+----+------+------+| id | name | dep  |+----+------+------+|  1 | a    | NULL ||  2 | b    | NULL ||  3 | c    | NULL ||  4 | d    | NULL ||  5 | e    | NULL |+----+------+------+5 rows in set (0.00 sec)mysql&gt; select * from mylock where id&#x3D;1;+----+------+------+| id | name | dep  |+----+------+------+|  1 | a    | NULL |+----+------+------+1 row in set (0.00 sec)mysql&gt; select * from mylock where id&#x3D;1 lock in share mode; -- 阻塞 不可获得锁ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transactionmysql&gt; update mylock set name&#x3D;&#39;b&#39; where id&#x3D;2;  -- 阻塞 不可修改ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transactionmysql&gt; update mylock set name&#x3D;&#39;a&#39; where id&#x3D;1;   -- 阻塞 不可修改ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction-- session1mysql&gt; commit;  -- 提交事务&#x2F;rollback释放锁Query OK, 0 rows affected (0.00 sec)-- session2mysql&gt; update mylock set name&#x3D;&#39;b&#39; where id&#x3D;2;Query OK, 1 row affected (0.00 sec)Rows matched: 1  Changed: 1  Warnings: 0mysql&gt; update mylock set name&#x3D;&#39;a&#39; where id&#x3D;1;Query OK, 0 rows affected (0.00 sec)Rows matched: 1  Changed: 0  Warnings: 0</code></pre><h5 id="间隙锁"><a href="#间隙锁" class="headerlink" title="间隙锁"></a>间隙锁</h5><pre><code class="hljs mysql">create table news(id int, number int, primary key(id), index idx_num(number));insert into news values(1,2);insert into news values(3,4);insert into news values(6,5);insert into news values(8,5);insert into news values(10,5);insert into news values(13,11);mysql&gt; select * from news;+----+--------+| id | number |  # id主键 索引 number+----+--------+|  1 |      2 ||  3 |      4 ||  6 |      5 ||  8 |      5 || 10 |      5 || 13 |     11 |+----+--------+6 rows in set (0.01 sec)-- session1mysql&gt; start transaction;Query OK, 0 rows affected (0.00 sec)mysql&gt; select * from news where number&#x3D;4 for update;-- id在2、5之间和3-5之间且number2-6在均被锁住+----+--------+| id | number |+----+--------+|  3 |      4 |+----+--------+1 row in set (0.01 sec)-- session2mysql&gt; start transaction;mysql&gt; insert into news values(2,4);  -- 阻塞ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transactionmysql&gt; insert into news values(2,2);  -- 阻塞ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transactionmysql&gt; insert into news values(4,4);  -- 阻塞ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transactionmysql&gt; insert into news values(4,5);  -- 阻塞ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transactionmysql&gt; insert into news values(5,7);Query OK, 1 row affected (0.00 sec)mysql&gt; insert into news values(7,5);Query OK, 1 row affected (0.01 sec)mysql&gt; insert into news values(9,5);Query OK, 1 row affected (0.01 sec)mysql&gt; insert into news values(11,5);Query OK, 1 row affected (0.01 sec)insert into news values(13,11);mysql&gt; select * from news;mysql&gt; select * from news;+----+--------+| id | number |+----+--------+|  1 |      2 ||  3 |      4 ||  6 |      5 ||  8 |      5 || 10 |      5 || 13 |     11 |+----+--------+6 rows in set (0.01 sec)-- session1mysql&gt; start transaction;Query OK, 0 rows affected (0.00 sec)mysql&gt; select * from news where number&#x3D;13 for update;      （select * from news where id&gt;1 and id&lt;4 for update;）mysql&gt; start transaction;mysql&gt; insert into news values(11,5);Query OK, 1 row affected (0.00 sec)mysql&gt; insert into news values(12,11);Query OK, 1 row affected (0.00 sec)mysql&gt; insert into news values(14,11);ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transactionmysql&gt; insert into news values(15,12);ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction检索条件number&#x3D;13，想做取得最靠近的值11作为作区间，向右由于没有记录因此取得无穷大作为右区间，即session1间隙锁区间（11，无穷大）</code></pre><h5 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h5><p>两个session互相等待对方的释放资源之后，才能释放自己的资源</p><pre><code class="hljs mysql">-- session1mysql&gt;begin;Query OK, 0 rows affected (0.00 sec)mysql&gt;update mylock set name&#x3D;&#39;m&#39; where id&#x3D;1;  -- 手动加行写锁 id&#x3D;1,使用索引Query OK, 1 row affected (0.00 sec)Rows matched: 1  Changed: 1  Warnings: 0-- session2mysql&gt;begin;Query OK, 0 rows affected (0.00 sec)mysql&gt;update mylock set name&#x3D;&#39;m&#39; where id&#x3D;2;  -- 手动加行写锁 id&#x3D;2,使用索引Query OK, 1 row affected (0.00 sec)Rows matched: 1  Changed: 1  Warnings: 0-- session1mysql&gt;update mylock set name&#x3D;&#39;nn&#39; where id&#x3D;2; -- 加写锁被阻塞-- session2mysql&gt;update mylock set name&#x3D;&#39;nn&#39; where id&#x3D;1; -- 加写锁会死锁 不允许操作ERROR 1213 (40001): Deadlock found when trying to get lock; try restarting transaction</code></pre><h4 id="相关面试题-1"><a href="#相关面试题-1" class="headerlink" title="相关面试题"></a>相关面试题</h4><h5 id="什么是锁？MySQL-中提供了几类锁？"><a href="#什么是锁？MySQL-中提供了几类锁？" class="headerlink" title="什么是锁？MySQL 中提供了几类锁？"></a>什么是锁？MySQL 中提供了几类锁？</h5><p>锁是实现数据库并发控制的重要手段，可以保证数据库在多人同时操作时能够正常运行。MySQL 提供了全局锁、行级锁、表级锁。其中 InnoDB 支持表级锁和行级锁，MyISAM 只支持表级锁。</p><h5 id="什么是全局锁？它的应用场景有哪些？"><a href="#什么是全局锁？它的应用场景有哪些？" class="headerlink" title="什么是全局锁？它的应用场景有哪些？"></a>什么是全局锁？它的应用场景有哪些？</h5><p>全局锁就是对整个数据库实例加锁，它的典型使用场景就是做全库逻辑备份。 这个命令可以使整个库处于只读状态。使用该命令之后，数据更新语句、数据定义语句、更新类事务的提交语句等操作都会被阻塞。</p><h5 id="什么是共享锁？"><a href="#什么是共享锁？" class="headerlink" title="什么是共享锁？"></a>什么是共享锁？</h5><p>共享锁又称读锁 (read lock)，是读取操作创建的锁。其他用户可以并发读取数据，但任何事务都不能对数据进行修改（获取数据上的排他锁），直到已释放所有共享锁。当如果事务对读锁进行修改操作，很可能会造成死锁。</p><h5 id="什么是排它锁？"><a href="#什么是排它锁？" class="headerlink" title="什么是排它锁？"></a>什么是排它锁？</h5><p>排他锁 exclusive lock（也叫 writer lock）又称写锁。</p><p>若某个事物对某一行加上了排他锁，只能这个事务对其进行读写，在此事务结束之前，其他事务不能对其进行加任何锁，其他进程可以读取,不能进行写操作，需等待其释放。</p><p>排它锁是悲观锁的一种实现，在上面悲观锁也介绍过。</p><p>若事务 1 对数据对象 A 加上 X 锁，事务 1 可以读 A 也可以修改 A，其他事务不能再对 A 加任何锁，直到事物 1 释放 A 上的锁。这保证了其他事务在事物 1 释放 A 上的锁之前不能再读取和修改 A。排它锁会阻塞所有的排它锁和共享锁。</p><h5 id="InnoDB-存储引擎有几种锁算法？"><a href="#InnoDB-存储引擎有几种锁算法？" class="headerlink" title="InnoDB 存储引擎有几种锁算法？"></a>InnoDB 存储引擎有几种锁算法？</h5><ul><li><p>Record Lock — 单个行记录上的锁；</p></li><li><p> Gap Lock — 间隙锁，锁定一个范围，不包括记录本身；</p></li><li><p>Next-Key Lock — 锁定一个范围，包括记录本身。</p></li></ul><h5 id="使用全局锁会导致什么问题？"><a href="#使用全局锁会导致什么问题？" class="headerlink" title="使用全局锁会导致什么问题？"></a>使用全局锁会导致什么问题？</h5><p>如果在主库备份，在备份期间不能更新，业务停摆，所以更新业务会处于等待状态。</p><p>如果在从库备份，在备份期间不能执行主库同步的 binlog，导致主从延迟。</p><h5 id="如何处理逻辑备份时，整个数据库不能插入的情况？"><a href="#如何处理逻辑备份时，整个数据库不能插入的情况？" class="headerlink" title="如何处理逻辑备份时，整个数据库不能插入的情况？"></a>如何处理逻辑备份时，整个数据库不能插入的情况？</h5><p>如果使用全局锁进行逻辑备份就会让整个库成为只读状态，幸好官方推出了一个逻辑备份工具 MySQLdump 来解决了这个问题，只需要在使用 MySQLdump 时，使用参数 -single-transaction 就会在导入数据之前启动一个事务来保证数据的一致性，并且这个过程是支持数据更新操作的。</p><h5 id="如何设置数据库为全局只读锁？"><a href="#如何设置数据库为全局只读锁？" class="headerlink" title="如何设置数据库为全局只读锁？"></a>如何设置数据库为全局只读锁？</h5><p>使用命令 <code>flush tables with read lock</code>（简称 FTWRL）就可以实现设置数据库为全局只读锁。</p><h5 id="除了-FTWRL-可以设置数据库只读外，还有什么别的方法？"><a href="#除了-FTWRL-可以设置数据库只读外，还有什么别的方法？" class="headerlink" title="除了 FTWRL 可以设置数据库只读外，还有什么别的方法？"></a>除了 FTWRL 可以设置数据库只读外，还有什么别的方法？</h5><p>除了使用 FTWRL 外，还可以使用命令 <code>set global readonly=true</code> 设置数据库为只读。</p><h5 id="FTWRL-和-set-global-readonly-true-有什么区别？"><a href="#FTWRL-和-set-global-readonly-true-有什么区别？" class="headerlink" title="FTWRL 和 set global readonly=true 有什么区别？"></a>FTWRL 和 set global readonly=true 有什么区别？</h5><p>FTWRL 和 set global readonly=true 都是设置整个数据库为只读状态，但他们最大的区别就是，当执行 FTWRL 的客户端断开之后，整个数据库会取消只读，而 set global readonly=true 会一直让数据处于只读状态。</p><h5 id="如何实现表锁？"><a href="#如何实现表锁？" class="headerlink" title="如何实现表锁？"></a>如何实现表锁？</h5><p>MySQL 里标记锁有两种：表级锁、元数据锁（meta data lock）简称 MDL。表锁的语法是 lock tables t read/write。</p><p>可以用 unlock tables 主动释放锁，也可以在客户端断开的时候自动释放。lock tables 语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象。</p><p>对于 InnoDB 这种支持行锁的引擎，一般不使用 lock tables 命令来控制并发，毕竟锁住整个表的影响面还是太大。</p><p>MDL：不需要显式使用，在访问一个表的时候会被自动加上。</p><p>MDL 的作用：保证读写的正确性。</p><p>在对一个表做增删改查操作的时候，加 MDL 读锁；当要对表做结构变更操作的时候，加 MDL 写锁。</p><p>读锁之间不互斥，读写锁之间，写锁之间是互斥的，用来保证变更表结构操作的安全性。</p><p>MDL 会直到事务提交才会释放，在做表结构变更的时候，一定要小心不要导致锁住线上查询和更新。</p><h5 id="InnoDB-如何实现行锁？"><a href="#InnoDB-如何实现行锁？" class="headerlink" title="InnoDB 如何实现行锁？"></a>InnoDB 如何实现行锁？</h5><p>行级锁是 MySQL 中粒度最小的一种锁，他能大大减少数据库操作的冲突。</p><p>INNODB 的行级锁有共享锁（S LOCK）和排他锁（X LOCK）两种。共享锁允许事物读一行记录，不允许任何线程对该行记录进行修改。排他锁允许当前事物删除或更新一行记录，其他线程不能操作该记录。</p><p>共享锁：SELECT … LOCK IN SHARE MODE，MySQL 会对查询结果集中每行都添加共享锁，前提是当前线程没有对该结果集中的任何行使用排他锁，否则申请会阻塞。</p><p>排他锁：select * from t where id=1 for update，其中 id 字段必须有索引，MySQL 会对查询结果集中每行都添加排他锁，在事物操作中，任何对记录的更新与删除操作会自动加上排他锁。前提是当前没有线程对该结果集中的任何行使用排他锁或共享锁，否则申请会阻塞。</p><h5 id="悲观锁和乐观锁有什么区别？"><a href="#悲观锁和乐观锁有什么区别？" class="headerlink" title="悲观锁和乐观锁有什么区别？"></a>悲观锁和乐观锁有什么区别？</h5><p>顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会 block 直到它拿到锁。正因为如此，悲观锁需要耗费较多的时间，另外与乐观锁相对应的，悲观锁是由数据库自己实现了的，要用的时候，我们直接调用数据库的相关语句就可以了。</p><p>说到这里，由悲观锁涉及到的另外两个锁概念就出来了，它们就是共享锁与排它锁。共享锁和排它锁是悲观锁的不同的实现，它俩都属于悲观锁的范畴。</p><p>乐观锁是用数据版本（Version）记录机制实现，这是乐观锁最常用的一种实现方式。何谓数据版本？即为数据增加一个版本标识，一般是通过为数据库表增加一个数字类型的 version 字段来实现。当读取数据时，将 version 字段的值一同读出，数据每更新一次，对此 version 值加 1。当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的version值进行比对，如果数据库表当前版本号与第一次取出来的 version 值相等，则予以更新，否则认为是过期数据。</p><p>比如：</p><p>1、数据库表三个字段，分别是<code>id、value、version</code> <code>select id,value,version from t where id=#&#123;id&#125; </code></p><p>2、每次更新表中的value字段时，为了防止发生冲突，需要这样操作</p><p><code>update t set value=2,version=version+1 where id=#&#123;id&#125; and version=#&#123;version&#125;</code></p><h5 id="乐观锁有什么优点和缺点？"><a href="#乐观锁有什么优点和缺点？" class="headerlink" title="乐观锁有什么优点和缺点？"></a>乐观锁有什么优点和缺点？</h5><p>因为没有加锁所以乐观锁的优点就是执行性能高。它的缺点就是有可能产生 ABA 的问题，ABA 问题指的是有一个变量 V 初次读取的时候是 A 值，并且在准备赋值的时候检查到它仍然是 A 值，会误以为没有被修改会正常的执行修改操作，实际上这段时间它的值可能被改了其他值，之后又改回为 A 值，这个问题被称为 ABA 问题。</p><h5 id="优化锁方面你有什么建议？"><a href="#优化锁方面你有什么建议？" class="headerlink" title="优化锁方面你有什么建议？"></a>优化锁方面你有什么建议？</h5><ul><li><p>尽量使用较低的隔离级别。</p></li><li><p>精心设计索引， 并尽量使用索引访问数据， 使加锁更精确， 从而减少锁冲突的机会。</p></li><li><p>选择合理的事务大小，小事务发生锁冲突的几率也更小。</p></li><li><p>给记录集显示加锁时，最好一次性请求足够级别的锁。比如要修改数据的话，最好直接申请排他锁，而不是先申请共享锁，修改时再请求排他锁，这样容易产生死锁。</p></li><li><p>不同的程序访问一组表时，应尽量约定以相同的顺序访问各表，对一个表而言，尽可能以固定的顺序存取表中的行。这样可以大大减少死锁的机会。</p></li><li><p>尽量用相等条件访问数据，这样可以避免间隙锁对并发插入的影响。</p></li><li><p>不要申请超过实际需要的锁级别。</p></li><li><p>除非必须，查询时不要显示加锁。 MySQL 的 MVCC 可以实现事务中的查询不用加锁，优化事务性能；MVCC 只在 COMMITTED READ（读提交）和 REPEATABLE READ（可重复读）两种隔离级别下工作。</p></li><li><p>对于一些特定的事务，可以使用表锁来提高处理速度或减少死锁的可能。</p></li></ul><h5 id="什么是死锁？"><a href="#什么是死锁？" class="headerlink" title="什么是死锁？"></a>什么是死锁？</h5><p>是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象,若无外力作用,它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的过程称为死锁。</p><p>死锁是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象,若无外力作用,它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的过程称为死锁。</p><h5 id="常见的死锁案例有哪些？"><a href="#常见的死锁案例有哪些？" class="headerlink" title="常见的死锁案例有哪些？"></a>常见的死锁案例有哪些？</h5><ul><li><p>将投资的钱拆封几份借给借款人，这时处理业务逻辑就要把若干个借款人一起锁住<code> select * from xxx where id in (xx,xx,xx) for update</code>。</p></li><li><p>批量入库，存在则更新，不存在则插入。解决方法<code> insert into tab(xx,xx) on duplicate key update xx=&#39;xx&#39;</code>。</p></li></ul><h5 id="如何处理死锁？"><a href="#如何处理死锁？" class="headerlink" title="如何处理死锁？"></a>如何处理死锁？</h5><p>对待死锁常见的两种策略：</p><ul><li><p>通过<code> innodblockwait_timeout</code> 来设置超时时间，一直等待直到超时；</p></li><li><p>发起死锁检测，发现死锁之后，主动回滚死锁中的某一个事务，让其它事务继续执行。</p></li></ul><h5 id="如何查看死锁？"><a href="#如何查看死锁？" class="headerlink" title="如何查看死锁？"></a>如何查看死锁？</h5><ul><li><p>使用命令 show engine innodb status 查看最近的一次死锁。</p></li><li><p>InnoDB Lock Monitor 打开锁监控，每 15s 输出一次日志。使用完毕后建议关闭，否则会影响数据库性能。</p></li></ul><h5 id="如何避免死锁？"><a href="#如何避免死锁？" class="headerlink" title="如何避免死锁？"></a>如何避免死锁？</h5><ul><li><p>为了在单个 InnoDB 表上执行多个并发写入操作时避免死锁，可以在事务开始时通过为预期要修改的每个元祖（行）使用 SELECT … FOR UPDATE 语句来获取必要的锁，即使这些行的更改语句是在之后才执行的。</p></li><li><p>在事务中，如果要更新记录，应该直接申请足够级别的锁，即排他锁，而不应先申请共享锁、更新时再申请排他锁，因为这时候当用户再申请排他锁时，其他事务可能又已经获得了相同记录的共享锁，从而造成锁冲突，甚至死锁</p></li><li><p>如果事务需要修改或锁定多个表，则应在每个事务中以相同的顺序使用加锁语句。在应用中，如果不同的程序会并发存取多个表，应尽量约定以相同的顺序来访问表，这样可以大大降低产生死锁的机会</p></li><li><p>通过 <code>SELECT … LOCK IN SHARE MODE </code>获取行的读锁后，如果当前事务再需要对该记录进行更新操作，则很有可能造成死锁。</p></li><li><p>改变事务隔离级别。</p></li></ul><h5 id="InnoDB-默认是如何对待死锁的？"><a href="#InnoDB-默认是如何对待死锁的？" class="headerlink" title="InnoDB 默认是如何对待死锁的？"></a>InnoDB 默认是如何对待死锁的？</h5><p>InnoDB 默认是使用设置死锁时间来让死锁超时的策略，默认 innodblockwait_timeout 设置的时长是 50s。</p><h5 id="如何开启死锁检测？"><a href="#如何开启死锁检测？" class="headerlink" title="如何开启死锁检测？"></a>如何开启死锁检测？</h5><p>设置 <code>innodbdeadlockdetect </code>设置为 on 可以主动检测死锁，在 Innodb 中这个值默认就是 on 开启的状态。</p><h3 id="MySQL分库分表原理及实践"><a href="#MySQL分库分表原理及实践" class="headerlink" title="MySQL分库分表原理及实践"></a>MySQL分库分表原理及实践</h3><h4 id="MyCat"><a href="#MyCat" class="headerlink" title="MyCat"></a>MyCat</h4><p><img src="/images/mysql/mycat.png"></p><h5 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h5><ul><li>Schema：由它指定逻辑数据库（相当于MySQL的datebase数据库）</li><li>Table：逻辑表（相当于MySQL的table表）</li><li>DataNode：真正存储数据的物理节点</li><li>DateHost：存储节点所在的数据库主机（指定MySQL数据库的连接信息）</li><li>User：MyCat用户（类似于MySQL的用户，支持多用户）</li></ul><h5 id="主要解决问题"><a href="#主要解决问题" class="headerlink" title="主要解决问题"></a>主要解决问题</h5><ul><li>海量数据存储</li><li>查询优化</li></ul><h5 id="支持数据库"><a href="#支持数据库" class="headerlink" title="支持数据库"></a>支持数据库</h5><p><img src="/images/mysql/catdb.png"></p><h5 id="分片策略"><a href="#分片策略" class="headerlink" title="分片策略"></a>分片策略</h5><p>MyCAT支持水平分片语垂直分片：</p><ul><li>水平分片：一个表格的数据分割到多个节点上，按照行分割。</li><li>垂直分片：一个数据库中多个表A,B,C，A存储到节点1，B存储到节点2，C存储到节点3。</li></ul><p><img src="/images/mysql/catdate.png"></p><p><img src="/images/mysql/catdate2.png"></p><p>MyCAT通过定义表的分片规则来实现分片，没个表格可以捆绑一个分片规则，每个分片规则制定一个分片字段并绑定一个函数，来实现动态分片算法。</p><ul><li>Schema：逻辑库，与MySQL的datebase数据对应，一个逻辑库中定义了所有包括的Table。</li><li>Table：表，即物理数据库中存储的某张表，与传统数据库不同，这里的表格需要声明其所存储的逻辑数据节点DataNode。<strong>可以指定表的分片规则</strong></li><li>DataNode：MyCAT的逻辑数据节点，是存放Table的具体物理节点，也称之为分片节点，通过DateHost来关联到后段某个具体数据库上。</li><li>DateHost：定义某个物理库的访问地址，用于捆绑到DataNode上。</li></ul><h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><pre><code class="hljs zsh"><span class="hljs-comment"># 下载</span>wget http://dl.mycat.org.cn/1.6.7.4/Mycat-server-1.6.7.4-release/Mycat-server-1.6.7.4-release-20200105164103-linux.tar.gz<span class="hljs-comment"># 解压</span>tar -zxvf Mycat-server-1.6.7.4-release-20200105164103-linux.tar.gz /weitrue/install<span class="hljs-comment"># 进入mycat目录</span><span class="hljs-built_in">cd</span> /weitrue/install/mycat<span class="hljs-comment"># 启动/关闭  进入mycat/bin下</span>./mycat start     <span class="hljs-comment"># 启动</span>./mycat stop      <span class="hljs-comment"># 关闭</span>./mycat restart   <span class="hljs-comment"># 重启</span>./mycat status    <span class="hljs-comment"># 状态</span><span class="hljs-comment"># 使用mysql客户端直接连接mycat服务,默认端口【8066】</span>mysql -uroot -p123456 -h127.0.0.1 -P8066</code></pre><h5 id="分片设置"><a href="#分片设置" class="headerlink" title="分片设置"></a>分片设置</h5><h6 id="配置schema-xml文件"><a href="#配置schema-xml文件" class="headerlink" title="配置schema.xml文件"></a>配置schema.xml文件</h6><p><code>schema.xml</code>是Mycat中重要的配置文件之一，主要管理着MyCAT的逻辑库、表、分片规则、DataNode以及DateHost之间的映射关系。</p><ul><li><code>&lt;schema&gt;</code>定义Mycat实例中的逻辑库。<ul><li><code>&lt;table&gt;</code>定义Mycat中的逻辑表。</li></ul></li><li><code>&lt;dataNode&gt;</code>定义了Mycat的数据节点，即数据分片。</li><li><code>&lt;dataHost&gt;</code>定义了具体的数据库实例、读写分离配置和心跳语句。</li></ul><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot;?&gt;</span><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">mycat</span>:schema <span class="hljs-meta-keyword">SYSTEM</span> <span class="hljs-meta-string">&quot;schema.dtd&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">mycat:schema</span> <span class="hljs-attr">xmlns:mycat</span>=<span class="hljs-string">&quot;http://io.mycat/&quot;</span>&gt;</span><span class="hljs-comment">&lt;!-- </span><span class="hljs-comment">schema:逻辑库 name：逻辑库名 sqlMaxLimit 一次去多少条数据，如果超过limit</span><span class="hljs-comment">              table 逻辑表</span><span class="hljs-comment">                dataNode 数据节点 对应 dataNode标签名</span><span class="hljs-comment">                rule 分片规则 对应rule.xml</span><span class="hljs-comment">                subTables字表</span><span class="hljs-comment">                primaryKey 分片主键 可缓存</span><span class="hljs-comment"> --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">schema</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;TESTDB&quot;</span> <span class="hljs-attr">checkSQLschema</span>=<span class="hljs-string">&quot;false&quot;</span> <span class="hljs-attr">sqlMaxLimit</span>=<span class="hljs-string">&quot;100&quot;</span> <span class="hljs-attr">randomDataNode</span>=<span class="hljs-string">&quot;dn1&quot;</span>&gt;</span>                <span class="hljs-comment">&lt;!-- auto sharding by id (long) --&gt;</span>                <span class="hljs-comment">&lt;!--splitTableNames 启用&lt;table name 属性使用逗号分割配置多个表,即多个表使用这个配置--&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;item&quot;</span> <span class="hljs-attr">dataNode</span>=<span class="hljs-string">&quot;dn1,dn2,dn3&quot;</span> <span class="hljs-attr">rule</span>=<span class="hljs-string">&quot;mod-long&quot;</span> <span class="hljs-attr">primaryKey</span>=<span class="hljs-string">&quot;ID&quot;</span>/&gt;</span>                       <span class="hljs-tag">&lt;/<span class="hljs-name">schema</span>&gt;</span>          <span class="hljs-comment">&lt;!-- &lt;dataNode name=&quot;dn1$0-743&quot; dataHost=&quot;localhost1&quot; database=&quot;db$0-743&quot;/&gt; --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dataNode</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dn1&quot;</span> <span class="hljs-attr">dataHost</span>=<span class="hljs-string">&quot;localhost1&quot;</span> <span class="hljs-attr">database</span>=<span class="hljs-string">&quot;db1&quot;</span> /&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dataNode</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dn2&quot;</span> <span class="hljs-attr">dataHost</span>=<span class="hljs-string">&quot;localhost1&quot;</span> <span class="hljs-attr">database</span>=<span class="hljs-string">&quot;db2&quot;</span> /&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dataNode</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dn3&quot;</span> <span class="hljs-attr">dataHost</span>=<span class="hljs-string">&quot;localhost1&quot;</span> <span class="hljs-attr">database</span>=<span class="hljs-string">&quot;db3&quot;</span> /&gt;</span><span class="hljs-comment">&lt;!-- </span><span class="hljs-comment">dataHost:数据主机</span><span class="hljs-comment">            balance 1:读写分离 0:读写不分离</span><span class="hljs-comment">            writeType 0:第一个writrHost写 1:随机writrHost写</span><span class="hljs-comment">            dbDriver 数据驱动 native: MySQL JDBC:Oracle SQLServer</span><span class="hljs-comment">            switchType是否主动读 1:主从自动切换 -1:不切换 2:当从机延时超过slaveThreshold(毫秒级)值时切换为主读</span><span class="hljs-comment"> --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dataHost</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;localhost1&quot;</span> <span class="hljs-attr">maxCon</span>=<span class="hljs-string">&quot;1000&quot;</span> <span class="hljs-attr">minCon</span>=<span class="hljs-string">&quot;10&quot;</span> <span class="hljs-attr">balance</span>=<span class="hljs-string">&quot;0&quot;</span></span><span class="hljs-tag">                          <span class="hljs-attr">writeType</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">dbType</span>=<span class="hljs-string">&quot;mysql&quot;</span> <span class="hljs-attr">dbDriver</span>=<span class="hljs-string">&quot;native&quot;</span> <span class="hljs-attr">switchType</span>=<span class="hljs-string">&quot;1&quot;</span>  <span class="hljs-attr">slaveThreshold</span>=<span class="hljs-string">&quot;100&quot;</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">heartbeat</span>&gt;</span>select user()<span class="hljs-tag">&lt;/<span class="hljs-name">heartbeat</span>&gt;</span>                <span class="hljs-comment">&lt;!-- can have multi write hosts --&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">writeHost</span> <span class="hljs-attr">host</span>=<span class="hljs-string">&quot;hostM1&quot;</span> <span class="hljs-attr">url</span>=<span class="hljs-string">&quot;localhost:3306&quot;</span> <span class="hljs-attr">user</span>=<span class="hljs-string">&quot;root&quot;</span> <span class="hljs-attr">password</span>=<span class="hljs-string">&quot;123456&quot;</span>&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">writeHost</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dataHost</span>&gt;</span></code></pre><h6 id="rule-xml"><a href="#rule-xml" class="headerlink" title="rule.xml"></a><code>rule.xml</code></h6><p><code>rule.xml</code>定义我们对表拆分涉及到的规则定义。</p><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">mycat</span>:rule <span class="hljs-meta-keyword">SYSTEM</span> <span class="hljs-meta-string">&quot;rule.dtd&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">mycat:rule</span> <span class="hljs-attr">xmlns:mycat</span>=<span class="hljs-string">&quot;http://io.mycat/&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">tableRule</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;mod-long&quot;</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">rule</span>&gt;</span>                        <span class="hljs-tag">&lt;<span class="hljs-name">columns</span>&gt;</span>id<span class="hljs-tag">&lt;/<span class="hljs-name">columns</span>&gt;</span>                        <span class="hljs-tag">&lt;<span class="hljs-name">algorithm</span>&gt;</span>mod-long<span class="hljs-tag">&lt;/<span class="hljs-name">algorithm</span>&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">rule</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">tableRule</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">function</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;mod-long&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;io.mycat.route.function.PartitionByMod&quot;</span>&gt;</span>                <span class="hljs-comment">&lt;!-- how many data nodes --&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;count&quot;</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">function</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mycat:rule</span>&gt;</span></code></pre><h6 id="server-xml"><a href="#server-xml" class="headerlink" title="server.xml"></a><code>server.xml</code></h6><pre><code class="hljs xml"></code></pre><h6 id="十大分片规则"><a href="#十大分片规则" class="headerlink" title="十大分片规则"></a>十大分片规则</h6><p><strong>连续分片</strong></p><ul><li>日期分片<ul><li>按月</li><li>按日</li><li>按小时</li></ul></li><li>范围约定：配置简单，即预先制定可能的id范围对应某个分片<ul><li>优势：扩容无需迁移数据</li><li>缺点：热点数据，并发受限</li></ul></li></ul><p><strong>离散分片</strong></p><ul><li>枚举法</li><li>求模法</li><li>字符串拆分hash法</li><li>固定分片hash法</li><li>一致性哈希（解决扩容问题）</li><li>编程指定</li></ul><p><strong>综合分片</strong></p><ul><li>通配取模</li><li>ASCii码求模通配</li></ul><h5 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h5><p>建立在MySQL主从复制的基础上实现，必须搭建MySQL的主从复制。</p><p><img src="/images/mysql/mycatrw.png"></p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- &lt;dataNode name=&quot;dn1$0-743&quot; dataHost=&quot;localhost1&quot; database=&quot;db$0-743&quot;/&gt; --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dataNode</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dn1&quot;</span> <span class="hljs-attr">dataHost</span>=<span class="hljs-string">&quot;localhost1&quot;</span> <span class="hljs-attr">database</span>=<span class="hljs-string">&quot;db1&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dataNode</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dn2&quot;</span> <span class="hljs-attr">dataHost</span>=<span class="hljs-string">&quot;localhost1&quot;</span> <span class="hljs-attr">database</span>=<span class="hljs-string">&quot;db2&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dataNode</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dn3&quot;</span> <span class="hljs-attr">dataHost</span>=<span class="hljs-string">&quot;localhost1&quot;</span> <span class="hljs-attr">database</span>=<span class="hljs-string">&quot;db3&quot;</span> /&gt;</span><span class="hljs-comment">&lt;!-- </span><span class="hljs-comment">dataHost:数据主机</span><span class="hljs-comment">        balance 1:读写分离 0:读写不分离</span><span class="hljs-comment">        writeType 0:第一个writrHost写 1:随机writrHost写</span><span class="hljs-comment">        dbDriver 数据驱动 native: MySQL JDBC:Oracle SQLServer</span><span class="hljs-comment">        switchType是否主动读 1:主从自动切换 -1:不切换 2:当从机延时超过slaveThreshold(毫秒级)值时切换为主读</span><span class="hljs-comment">--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dataHost</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;localhost1&quot;</span> <span class="hljs-attr">maxCon</span>=<span class="hljs-string">&quot;1000&quot;</span> <span class="hljs-attr">minCon</span>=<span class="hljs-string">&quot;10&quot;</span> <span class="hljs-attr">balance</span>=<span class="hljs-string">&quot;1&quot;</span></span><span class="hljs-tag">                      <span class="hljs-attr">writeType</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">dbType</span>=<span class="hljs-string">&quot;mysql&quot;</span> <span class="hljs-attr">dbDriver</span>=<span class="hljs-string">&quot;native&quot;</span> <span class="hljs-attr">switchType</span>=<span class="hljs-string">&quot;2&quot;</span>  <span class="hljs-attr">slaveThreshold</span>=<span class="hljs-string">&quot;100&quot;</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">heartbeat</span>&gt;</span>show slave status<span class="hljs-tag">&lt;/<span class="hljs-name">heartbeat</span>&gt;</span>            <span class="hljs-comment">&lt;!-- can have multi write hosts --&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">writeHost</span> <span class="hljs-attr">host</span>=<span class="hljs-string">&quot;hostM1&quot;</span> <span class="hljs-attr">url</span>=<span class="hljs-string">&quot;localhost:3306&quot;</span> <span class="hljs-attr">user</span>=<span class="hljs-string">&quot;root&quot;</span> <span class="hljs-attr">password</span>=<span class="hljs-string">&quot;123456&quot;</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">writeHost</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dataHost</span>&gt;</span></code></pre><p><code>switchType=&quot;2&quot;</code>和<code>slaveThreshold=&quot;100&quot;</code>意味着开启MySQL主从复制状态绑定的读写分离语切换机制。Mycat心跳机制通过检测<code>show slave status</code>中<code>&quot;Seconds_Behind_Master&quot; &quot;Slave_IO_Running&quot; &quot;Slave_SQL_Running&quot;</code>三个字段来确定当前主从的状态以及<code>Seconds_Behind_Master</code>主从复制延时。</p><h4 id="MySQL分库分表"><a href="#MySQL分库分表" class="headerlink" title="MySQL分库分表"></a>MySQL分库分表</h4><h5 id="数据切分方案"><a href="#数据切分方案" class="headerlink" title="数据切分方案"></a>数据切分方案</h5><ul><li>垂直切分：根据业务模块进行切分，不同模块的表分到不同的库中。</li><li>水平切分：将一张大表按照一定切分规则，按照<strong>行</strong>切分到不同表或者不同库中。</li></ul><h6 id="水平切分原则"><a href="#水平切分原则" class="headerlink" title="水平切分原则"></a>水平切分原则</h6><p>常用的主要分为：</p><ul><li>按照ID取模：对ID取模，余数决定改行数据放到哪张表或者哪个库中。</li><li>按照日期：按照年月日，将数据切分到不同的表或者库中。</li><li>按照范围：可以对某一列按照范围进行切分不同的范围切分到不同的表或者库中。</li></ul><h6 id="切分原则"><a href="#切分原则" class="headerlink" title="切分原则"></a>切分原则</h6><ul><li>第一原则：能不切分尽量不要切分</li><li>第二原则：如果要切分一定要选择合适的规则，提前规划好</li><li>第三原则：数据切分尽量通过数据冗余或者表分组来<strong>降低跨库join</strong>的可能</li><li>第四原则：由于数据库中间件对数据join实现的优劣难以把握，而且实现高性能难度极大，业务读取尽量少使用多表join</li></ul><h5 id="分库分表需要解决问题"><a href="#分库分表需要解决问题" class="headerlink" title="分库分表需要解决问题"></a>分库分表需要解决问题</h5><h6 id="分布式事务问题"><a href="#分布式事务问题" class="headerlink" title="分布式事务问题"></a>分布式事务问题</h6><h6 id="分布式主键ID问题"><a href="#分布式主键ID问题" class="headerlink" title="分布式主键ID问题"></a>分布式主键ID问题</h6><h6 id="跨库join问题"><a href="#跨库join问题" class="headerlink" title="跨库join问题"></a>跨库join问题</h6><h6 id="跨库count、group、orderby问题"><a href="#跨库count、group、orderby问题" class="headerlink" title="跨库count、group、orderby问题"></a>跨库count、group、orderby问题</h6><h3 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h3><h4 id="基础模块"><a href="#基础模块" class="headerlink" title="基础模块"></a>基础模块</h4><h5 id="说一下-MySQL-执行一条查询语句的内部执行过程？"><a href="#说一下-MySQL-执行一条查询语句的内部执行过程？" class="headerlink" title="说一下 MySQL 执行一条查询语句的内部执行过程？"></a>说一下 MySQL 执行一条查询语句的内部执行过程？</h5><ul><li><p>客户端先通过连接器连接到 MySQL 服务器。</p></li><li><p>连接器权限验证通过之后，先查询是否有查询缓存，如果有缓存（之前执行过此语句）则直接返回缓存数据，如果没有缓存则进入分析器。</p></li><li><p>分析器会对查询语句进行语法分析和词法分析，判断 SQL 语法是否正确，如果查询语法错误会直接返回给客户端错误信息，如果语法正确则进入优化器。</p></li><li><p>优化器是对查询语句进行优化处理，例如一个表里面有多个索引，优化器会判别哪个索引性能更好。</p></li><li><p>优化器执行完就进入执行器，执行器就开始执行语句进行查询比对了，直到查询到满足条件的所有数据，然后进行返回。</p></li></ul><h5 id="MySQL-提示“不存在此列”是执行到哪个节点报出的？"><a href="#MySQL-提示“不存在此列”是执行到哪个节点报出的？" class="headerlink" title="MySQL 提示“不存在此列”是执行到哪个节点报出的？"></a>MySQL 提示“不存在此列”是执行到哪个节点报出的？</h5><p>此错误是执行到分析器阶段报出的，因为 MySQL 会在分析器阶段检查 SQL 语句的正确性。</p><h5 id="MySQL-查询缓存的功能有何优缺点？"><a href="#MySQL-查询缓存的功能有何优缺点？" class="headerlink" title="MySQL 查询缓存的功能有何优缺点？"></a>MySQL 查询缓存的功能有何优缺点？</h5><p>MySQL 查询缓存功能是在连接器之后发生的，它的优点是效率高，如果已经有缓存则会直接返回结果。 查询缓存的缺点是失效太频繁导致缓存命中率比较低，任何更新表操作都会清空查询缓存，因此导致查询缓存非常容易失效。</p><h5 id="如何关闭-MySQL-的查询缓存功能？"><a href="#如何关闭-MySQL-的查询缓存功能？" class="headerlink" title="如何关闭 MySQL 的查询缓存功能？"></a>如何关闭 MySQL 的查询缓存功能？</h5><p>MySQL 查询缓存默认是开启的，配置 querycachetype 参数为 DEMAND（按需使用）关闭查询缓存，MySQL 8.0 之后直接删除了查询缓存的功能。</p><h5 id="MySQL-的常用引擎都有哪些？"><a href="#MySQL-的常用引擎都有哪些？" class="headerlink" title="MySQL 的常用引擎都有哪些？"></a>MySQL 的常用引擎都有哪些？</h5><p>MySQL 的常用引擎有 InnoDB、MyISAM、Memory 等，从 MySQL 5.5.5 版本开始 InnoDB 就成为了默认的存储引擎。</p><h5 id="MySQL-可以针对表级别设置数据库引擎吗？怎么设置？"><a href="#MySQL-可以针对表级别设置数据库引擎吗？怎么设置？" class="headerlink" title="MySQL 可以针对表级别设置数据库引擎吗？怎么设置？"></a>MySQL 可以针对表级别设置数据库引擎吗？怎么设置？</h5><p>可以针对不同的表设置不同的引擎。在 create table 语句中使用 engine=引擎名（比如Memory）来设置此表的存储引擎。完整代码如下：</p><pre><code class="hljs mysql">create table student(    id int primary key auto_increment,    username varchar(120),    age int ) ENGINE&#x3D;Memory</code></pre><h5 id="常用的存储引擎-InnoDB-和-MyISAM-有什么区别？"><a href="#常用的存储引擎-InnoDB-和-MyISAM-有什么区别？" class="headerlink" title="常用的存储引擎 InnoDB 和 MyISAM 有什么区别？"></a>常用的存储引擎 InnoDB 和 MyISAM 有什么区别？</h5><p>InnoDB 和 MyISAM 最大的区别是 InnoDB 支持事务，而 MyISAM 不支持事务，它们主要区别如下：</p><ul><li><p>InnoDB 支持崩溃后安全恢复，MyISAM 不支持崩溃后安全恢复；</p></li><li><p>InnoDB 支持行级锁，MyISAM 不支持行级锁，只支持到表锁；</p></li><li><p>InnoDB 支持外键，MyISAM 不支持外键；</p></li><li><p>MyISAM 性能比 InnoDB 高；</p></li><li><p>MyISAM 支持 FULLTEXT 类型的全文索引，InnoDB 不支持 FULLTEXT 类型的全文索引，但是 InnoDB 可以使用 sphinx 插件支持全文索引，并且效果更好；</p></li><li><p>InnoDB 主键查询性能高于 MyISAM。</p></li></ul><h5 id="InnoDB-有哪些特性？"><a href="#InnoDB-有哪些特性？" class="headerlink" title="InnoDB 有哪些特性？"></a>InnoDB 有哪些特性？</h5><p>1）插入缓冲(insert buffer)：对于非聚集索引的插入和更新，不是每一次直接插入索引页中，而是首先判断插入的非聚集索引页是否在缓冲池中，如果在，则直接插入，否则，先放入一个插入缓冲区中。好似欺骗数据库这个非聚集的索引已经插入到叶子节点了，然后再以一定的频率执行插入缓冲和非聚集索引页子节点的合并操作，这时通常能将多个插入合并到一个操作中，这就大大提高了对非聚集索引执行插入和修改操作的性能。</p><p>2）两次写(double write)：两次写给 InnoDB 带来的是可靠性，主要用来解决部分写失败(partial page write)。doublewrite 有两部分组成，一部分是内存中的 doublewrite buffer ，大小为 2M，另外一部分就是物理磁盘上的共享表空间中连续的 128 个页，即两个区，大小同样为 2M。当缓冲池的作业刷新时，并不直接写硬盘，而是通过 memcpy 函数将脏页先拷贝到内存中的 doublewrite buffer，之后通过 doublewrite buffer 再分两次写，每次写入 1M 到共享表空间的物理磁盘上，然后马上调用 fsync 函数，同步磁盘。如下图所示</p><p> <img src="/images/mysql/innodb.png"></p><p>3）自适应哈希索引(adaptive hash index)：由于 InnoDB 不支持 hash 索引，但在某些情况下 hash 索引的效率很高，于是出现了 adaptive hash index 功能， InnoDB 存储引擎会监控对表上索引的查找，如果观察到建立 hash 索引可以提高性能的时候，则自动建立 hash 索引。</p><h5 id="一张自增表中有三条数据，删除了两条数据之后重启数据库，再新增一条数据，此时这条数据的-ID-是几？"><a href="#一张自增表中有三条数据，删除了两条数据之后重启数据库，再新增一条数据，此时这条数据的-ID-是几？" class="headerlink" title="一张自增表中有三条数据，删除了两条数据之后重启数据库，再新增一条数据，此时这条数据的 ID 是几？"></a>一张自增表中有三条数据，删除了两条数据之后重启数据库，再新增一条数据，此时这条数据的 ID 是几？</h5><p>如果这张表的引擎是 MyISAM，那么 ID=4，如果是 InnoDB 那么 ID=2（MySQL 8 之前的版本）。</p><h5 id="MySQL-中什么情况会导致自增主键不能连续？"><a href="#MySQL-中什么情况会导致自增主键不能连续？" class="headerlink" title="MySQL 中什么情况会导致自增主键不能连续？"></a>MySQL 中什么情况会导致自增主键不能连续？</h5><p>以下情况会导致 MySQL 自增主键不能连续：</p><ul><li><p>唯一主键冲突会导致自增主键不连续；</p></li><li><p>事务回滚也会导致自增主键不连续。</p></li></ul><h5 id="InnoDB-中自增主键能不能被持久化？"><a href="#InnoDB-中自增主键能不能被持久化？" class="headerlink" title="InnoDB 中自增主键能不能被持久化？"></a>InnoDB 中自增主键能不能被持久化？</h5><p>自增主键能不能被持久化，说的是 MySQL 重启之后 InnoDB 能不能恢复重启之前的自增列，InnoDB 在 8.0 之前是没有持久化能力的，但 MySQL 8.0 之后就把自增主键保存到 redo log（一种日志类型，下文会详细讲）中，当 MySQL 重启之后就会从 redo log 日志中恢复。</p><h5 id="什么是独立表空间和共享表空间？它们的区别是什么？"><a href="#什么是独立表空间和共享表空间？它们的区别是什么？" class="headerlink" title="什么是独立表空间和共享表空间？它们的区别是什么？"></a>什么是独立表空间和共享表空间？它们的区别是什么？</h5><p>共享表空间：指的是数据库的所有的表数据，索引文件全部放在一个文件中，默认这个共享表空间的文件路径在 data 目录下。 独立表空间：每一个表都将会生成以独立的文件方式来进行存储。 共享表空间和独立表空间最大的区别是如果把表放再共享表空间，即使表删除了空间也不会删除，所以表依然很大，而独立表空间如果删除表就会清除空间。</p><h5 id="如何设置独立表空间？"><a href="#如何设置独立表空间？" class="headerlink" title="如何设置独立表空间？"></a>如何设置独立表空间？</h5><p>独立表空间是由参数 innodbfileper_table 控制的，把它设置成 ON 就是独立表空间了，从 MySQL 5.6.6 版本之后，这个值就默认是 ON 了。</p><p>如何进行表空间收缩？</p><p>使用重建表的方式可以收缩表空间，重建表有以下三种方式：</p><ul><li><p><code>alter table t engine=InnoDB</code></p></li><li><p><code>optmize table t</code></p></li><li><p><code>truncate table t</code></p></li></ul><h5 id="说一下重建表的执行流程？"><a href="#说一下重建表的执行流程？" class="headerlink" title="说一下重建表的执行流程？"></a>说一下重建表的执行流程？</h5><ul><li><p>建立一个临时文件，扫描表 t 主键的所有数据页；</p></li><li><p>用数据页中表 t 的记录生成 B+ 树，存储到临时文件中；</p></li><li><p>生成临时文件的过程中，将所有对 t 的操作记录在一个日志文件（row log）中；</p></li><li><p>临时文件生成后，将日志文件中的操作应用到临时文件，得到一个逻辑数据上与表 t相同的数据文件；</p></li><li><p>用临时文件替换表 t 的数据文件。</p></li></ul><h5 id="表的结构信息存在哪里？"><a href="#表的结构信息存在哪里？" class="headerlink" title="表的结构信息存在哪里？"></a>表的结构信息存在哪里？</h5><p>表结构定义占有的存储空间比较小，在 MySQL 8 之前，表结构的定义信息存在以 .frm 为后缀的文件里，在 MySQL 8 之后，则允许把表结构的定义信息存在系统数据表之中。</p><h5 id="如果把一个-InnoDB-表的主键删掉，是不是就没有主键，就没办法进行回表查询了？"><a href="#如果把一个-InnoDB-表的主键删掉，是不是就没有主键，就没办法进行回表查询了？" class="headerlink" title="如果把一个 InnoDB 表的主键删掉，是不是就没有主键，就没办法进行回表查询了？"></a>如果把一个 InnoDB 表的主键删掉，是不是就没有主键，就没办法进行回表查询了？</h5><p>可以回表查询，如果把主键删掉了，那么 InnoDB 会自己生成一个长度为 6 字节的 rowid 作为主键。</p><h5 id="执行一个-update-语句以后，我再去执行-hexdump-命令直接查看-ibd-文件内容，为什么没有看到数据有改变呢？"><a href="#执行一个-update-语句以后，我再去执行-hexdump-命令直接查看-ibd-文件内容，为什么没有看到数据有改变呢？" class="headerlink" title="执行一个 update 语句以后，我再去执行 hexdump 命令直接查看 ibd 文件内容，为什么没有看到数据有改变呢？"></a>执行一个 update 语句以后，我再去执行 hexdump 命令直接查看 ibd 文件内容，为什么没有看到数据有改变呢？</h5><p>可能是因为 update 语句执行完成后，InnoDB 只保证写完了 redo log、内存，可能还没来得及将数据写到磁盘。</p><h5 id="内存表和临时表有什么区别？"><a href="#内存表和临时表有什么区别？" class="headerlink" title="内存表和临时表有什么区别？"></a>内存表和临时表有什么区别？</h5><ul><li><p>内存表，指的是使用 Memory 引擎的表，建表语法是 create table … engine=memory。这种表的数据都保存在内存里，系统重启的时候会被清空，但是表结构还在。除了这两个特性看上去比较“奇怪”外，从其他的特征上看，它就是一个正常的表。</p></li><li><p>而临时表，可以使用各种引擎类型 。如果是使用 InnoDB 引擎或者 MyISAM 引擎的临时表，写数据的时候是写到磁盘上的。</p></li></ul><h5 id="并发事务会带来哪些问题？"><a href="#并发事务会带来哪些问题？" class="headerlink" title="并发事务会带来哪些问题？"></a>并发事务会带来哪些问题？</h5><ul><li><p>脏读</p></li><li><p>修改丢失</p></li><li><p>不可重复读</p></li><li><p>幻读</p></li></ul><h5 id="什么是脏读和幻读？"><a href="#什么是脏读和幻读？" class="headerlink" title="什么是脏读和幻读？"></a>什么是脏读和幻读？</h5><p>脏读是一个事务在处理过程中读取了另外一个事务未提交的数据；幻读是指同一个事务内多次查询返回的结果集不一样（比如增加了或者减少了行记录）。</p><h5 id="为什么会出现幻读？幻读会带来什么问题？"><a href="#为什么会出现幻读？幻读会带来什么问题？" class="headerlink" title="为什么会出现幻读？幻读会带来什么问题？"></a>为什么会出现幻读？幻读会带来什么问题？</h5><p>因为行锁只能锁定存在的行，针对新插入的操作没有限定，所以就有可能产生幻读。 幻读带来的问题如下：</p><ul><li><p>对行锁语义的破坏；</p></li><li><p>破坏了数据一致性。</p></li></ul><h5 id="如何避免幻读？"><a href="#如何避免幻读？" class="headerlink" title="如何避免幻读？"></a>如何避免幻读？</h5><p>使用间隙锁的方式来避免出现幻读。间隙锁，是专门用于解决幻读这种问题的锁，它锁的了行与行之间的间隙，能够阻塞新插入的操作 间隙锁的引入也带来了一些新的问题，比如：降低并发度，可能导致死锁。</p><h5 id="如何查看-MySQL-的空闲连接？"><a href="#如何查看-MySQL-的空闲连接？" class="headerlink" title="如何查看 MySQL 的空闲连接？"></a>如何查看 MySQL 的空闲连接？</h5><p>在 MySQL 的命令行中使用 show processlist; 查看所有连接，其中 Command 列显示为 Sleep 的表示空闲连接，如下图所示：</p><p><img src="/images/mysql/processlist.png"></p><h5 id="MySQL-中的字符串类型都有哪些？"><a href="#MySQL-中的字符串类型都有哪些？" class="headerlink" title="MySQL 中的字符串类型都有哪些？"></a>MySQL 中的字符串类型都有哪些？</h5><p>MySQL 的字符串类型和取值如下：</p><table><thead><tr><th><strong>类型</strong></th><th><strong>取值范围</strong></th></tr></thead><tbody><tr><td>CHAR(N)</td><td>0~255</td></tr><tr><td>VARCHAR(N)</td><td>0~65536</td></tr><tr><td>TINYBLOB</td><td>0~255</td></tr><tr><td>BLOB</td><td>0~65535</td></tr><tr><td>MEDUIMBLOB</td><td>0~167772150</td></tr><tr><td>LONGBLOB</td><td>0~4294967295</td></tr><tr><td>TINYTEXT</td><td>0~255</td></tr><tr><td>TEXT</td><td>0~65535</td></tr><tr><td>MEDIUMTEXT</td><td>0~167772150</td></tr><tr><td>LONGTEXT</td><td>0~4294967295</td></tr><tr><td>VARBINARY(N)</td><td>0~N个字节的变长字节字符集</td></tr><tr><td>BINARY(N)</td><td>0~N个字节的定长字节字符集</td></tr></tbody></table><h5 id="VARCHAR-和-CHAR-的区别是什么？分别适用的场景有哪些？"><a href="#VARCHAR-和-CHAR-的区别是什么？分别适用的场景有哪些？" class="headerlink" title="VARCHAR 和 CHAR 的区别是什么？分别适用的场景有哪些？"></a>VARCHAR 和 CHAR 的区别是什么？分别适用的场景有哪些？</h5><p>VARCHAR 和 CHAR 最大区别就是，VARCHAR 的长度是可变的，而 CHAR 是固定长度，CHAR 的取值范围为1-255，因此 VARCHAR 可能会造成存储碎片。由于它们的特性决定了 CHAR 比较适合长度较短的字段和固定长度的字段，如身份证号、手机号等，反之则适合使用 VARCHAR。</p><h5 id="MySQL-存储金额应该使用哪种数据类型？为什么？"><a href="#MySQL-存储金额应该使用哪种数据类型？为什么？" class="headerlink" title="MySQL 存储金额应该使用哪种数据类型？为什么？"></a>MySQL 存储金额应该使用哪种数据类型？为什么？</h5><p>MySQL 存储金额应该使用 decimal ，因为如果存储其他数据类型，比如 float 有导致小数点后数据丢失的风险。</p><h5 id="limit-3-2-的含义是什么？"><a href="#limit-3-2-的含义是什么？" class="headerlink" title="limit 3,2 的含义是什么？"></a>limit 3,2 的含义是什么？</h5><p>去除前三条数据之后查询两条信息。</p><h5 id="now-和-current-date-有什么区别？"><a href="#now-和-current-date-有什么区别？" class="headerlink" title="now() 和 current_date() 有什么区别？"></a>now() 和 current_date() 有什么区别？</h5><p>now() 返回当前时间包含日期和时分秒，current_date() 只返回当前时间，如下图所示：</p><p> <img src="/images/mysql/cur.png"></p><h5 id="如何去重计算总条数？"><a href="#如何去重计算总条数？" class="headerlink" title="如何去重计算总条数？"></a>如何去重计算总条数？</h5><p>使用 distinct 去重，使用 count 统计总条数，具体实现脚本如下：</p><pre><code class="hljs mysql">select count(distinct f) from t;</code></pre><h5 id="lastinsertid-函数功能是什么？有什么特点？"><a href="#lastinsertid-函数功能是什么？有什么特点？" class="headerlink" title="lastinsertid() 函数功能是什么？有什么特点？"></a>lastinsertid() 函数功能是什么？有什么特点？</h5><p>lastinsertid() 用于查询最后一次自增表的编号，它的特点是查询时不需要不需要指定表名，使用 select last_insert_id() 即可查询，因为不需要指定表名所以它始终以最后一条自增编号为主，可以被其它表的自增编号覆盖。比如 A 表的最大编号是 10，lastinsertid() 查询出来的值为 10，这时 B 表插入了一条数据，它的最大编号为 3，这个时候使用 lastinsertid() 查询的值就是 3。</p><h5 id="删除表的数据有几种方式？它们有什么区别？"><a href="#删除表的数据有几种方式？它们有什么区别？" class="headerlink" title="删除表的数据有几种方式？它们有什么区别？"></a>删除表的数据有几种方式？它们有什么区别？</h5><p>删除数据有两种方式：delete 和 truncate，它们的区别如下：</p><ul><li><p>delete 可以添加 where 条件删除部分数据，truncate 不能添加 where 条件只能删除整张表；</p></li><li><p>delete 的删除信息会在 MySQL 的日志中记录，而 truncate 的删除信息不被记录在 MySQL 的日志中，因此 detele 的信息可以被找回而 truncate 的信息无法被找回；</p></li><li><p>truncate 因为不记录日志所以执行效率比 delete 快。</p></li></ul><p>delete 和 truncate 的使用脚本如下：</p><pre><code class="hljs mysql">delete from t where username&#x3D;&#39;redis&#39;; truncate table t;</code></pre><h5 id="MySQL-中支持几种模糊查询？它们有什么区别？"><a href="#MySQL-中支持几种模糊查询？它们有什么区别？" class="headerlink" title="MySQL 中支持几种模糊查询？它们有什么区别？"></a>MySQL 中支持几种模糊查询？它们有什么区别？</h5><p>MySQL 中支持两种模糊查询：regexp 和 like，like 是对任意多字符匹配或任意单字符进行模糊匹配，而 regexp 则支持正则表达式的匹配方式，提供比 like 更多的匹配方式。</p><p>regexp 和 like 的使用示例如下： </p><pre><code class="hljs mysql">select * from person where uname like &#39;%SQL%&#39;; select  from person where uname regexp &#39;.SQL*.&#39;;</code></pre><h5 id="MySQL-支持枚举吗？如何实现？它的用途是什么？"><a href="#MySQL-支持枚举吗？如何实现？它的用途是什么？" class="headerlink" title="MySQL 支持枚举吗？如何实现？它的用途是什么？"></a>MySQL 支持枚举吗？如何实现？它的用途是什么？</h5><p>MySQL 支持枚举，它的实现方式如下：</p><pre><code class="hljs mysql">create table t(     sex enum(&#39;boy&#39;,&#39;grid&#39;) default &#39;unknown&#39; );</code></pre><p>枚举的作用是预定义结果值，当插入数据不在枚举值范围内，则插入失败，提示错误 Data truncated for column ‘xxx’ at row n 。</p><h5 id="count-column-和-count-有什么区别？"><a href="#count-column-和-count-有什么区别？" class="headerlink" title="count(column) 和 count(*) 有什么区别？"></a>count(column) 和 count(*) 有什么区别？</h5><p>count(column) 和 count() 最大区别是统计结果可能不一致，count(column) 统计不会统计列值为 null 的数据，而 count() 则会统计所有信息，所以最终的统计结果可能会不同。</p><h5 id="以下关于-count-说法正确的是？"><a href="#以下关于-count-说法正确的是？" class="headerlink" title="以下关于 count 说法正确的是？"></a>以下关于 count 说法正确的是？</h5><p>A. count 的查询性能在各种存储引擎下的性能都是一样的。</p><p>B. count 在 MyISAM 比 InnoDB 的性能要低。 </p><p>C. count 在 InnoDB 中是一行一行读取，然后累计计数的。 </p><p>D. count 在 InnoDB 中存储了总条数，查询的时候直接取出。</p><p>答：C</p><h5 id="为什么-InnoDB-不把总条数记录下来，查询的时候直接返回呢？"><a href="#为什么-InnoDB-不把总条数记录下来，查询的时候直接返回呢？" class="headerlink" title="为什么 InnoDB 不把总条数记录下来，查询的时候直接返回呢？"></a>为什么 InnoDB 不把总条数记录下来，查询的时候直接返回呢？</h5><p>因为 InnoDB 使用了事务实现，而事务的设计使用了多版本并发控制，即使是在同一时间进行查询，得到的结果也可能不相同，所以 InnoDB 不能把结果直接保存下来，因为这样是不准确的。</p><h5 id="能否使用-show-table-status-中的表行数作为表的总行数直接使用？为什么？"><a href="#能否使用-show-table-status-中的表行数作为表的总行数直接使用？为什么？" class="headerlink" title="能否使用 show table status 中的表行数作为表的总行数直接使用？为什么？"></a>能否使用 show table status 中的表行数作为表的总行数直接使用？为什么？</h5><p>不能，因为 show table status 是通过采样统计估算出来的，官方文档说误差可能在 40% 左右，所以 show table status 中的表行数不能直接使用。</p><h5 id="以下哪个-SQL-的查询性能最高？"><a href="#以下哪个-SQL-的查询性能最高？" class="headerlink" title="以下哪个 SQL 的查询性能最高？"></a>以下哪个 SQL 的查询性能最高？</h5><p>A. select count(*) from t where time&gt;1000 and time&lt;4500 </p><p>B. show table status where name=’t’ </p><p>C. select count(id) from t where time&gt;1000 and time&lt;4500 </p><p>D. select count(name) from t where time&gt;1000 and time&lt;4500</p><p>答：B 题目解析：因为 show table status 的表行数是估算出来，而其他的查询因为添加了 where 条件，即使是 MyISAM 引擎也不能直接使用已经存储的总条数，所以 show table status 的查询性能最高。</p><h5 id="InnoDB-和-MyISAM-执行-select-count-from-t，哪个效率更高？为什么？"><a href="#InnoDB-和-MyISAM-执行-select-count-from-t，哪个效率更高？为什么？" class="headerlink" title="InnoDB 和 MyISAM 执行 select count(*) from t，哪个效率更高？为什么？"></a>InnoDB 和 MyISAM 执行 select count(*) from t，哪个效率更高？为什么？</h5><p>MyISAM 效率最高，因为 MyISAM 内部维护了一个计数器，直接返回总条数，而 InnoDB 要逐行统计。</p><h5 id="在-MySQL-中有对-count-做优化吗？做了哪些优化？"><a href="#在-MySQL-中有对-count-做优化吗？做了哪些优化？" class="headerlink" title="在 MySQL 中有对 count(*) 做优化吗？做了哪些优化？"></a>在 MySQL 中有对 count(*) 做优化吗？做了哪些优化？</h5><p>count(*) 在不同的 MySQL 引擎中的实现方式是不相同的，在没有 where 条件的情况下：</p><ul><li><p>MyISAM 引擎会把表的总行数存储在磁盘上，因此在执行 count(*) 的时候会直接返回这个这个行数，执行效率很高；</p></li><li><p>InnoDB 引擎中 count(*) 就比较麻烦了，需要把数据一行一行的从引擎中读出来，然后累计基数。</p></li></ul><p>但即使这样，在 InnoDB 中，MySQL 还是做了优化的，我们知道对于 count() 这样的操作，遍历任意索引树得到的结果，在逻辑上都是一样的，因此，MySQL 优化器会找到最小的那颗索引树来遍历，这样就能在保证逻辑正确的前提下，尽量少扫描数据量，从而优化了 count() 的执行效率。</p><h5 id="在-InnoDB-引擎中-count-、count-1-、count-主键-、count-字段-哪个性能最高？"><a href="#在-InnoDB-引擎中-count-、count-1-、count-主键-、count-字段-哪个性能最高？" class="headerlink" title="在 InnoDB 引擎中 count(*)、count(1)、count(主键)、count(字段) 哪个性能最高？"></a>在 InnoDB 引擎中 count(*)、count(1)、count(主键)、count(字段) 哪个性能最高？</h5><p>count(字段)&lt;count(主键 id)&lt;count(1)≈count(*) 题目解析：</p><ul><li><p>对于 count(主键 id) 来说，InnoDB 引擎会遍历整张表，把每一行的 id 值都取出来，返回给 server 层。server 层拿到 id 后，判断是不可能为空的，就按行累加。</p></li><li><p>对于 count(1) 来说，InnoDB 引擎遍历整张表，但不取值。server 层对于返回的每一行，放一个数字“1”进去，判断是不可能为空的，按行累加。</p></li><li><p>对于 count(字段) 来说，如果这个“字段”是定义为 not null 的话，一行行地从记录里面读出这个字段，判断不能为 null，按行累加；如果这个“字段”定义允许为 null，那么执行的时候，判断到有可能是 null，还要把值取出来再判断一下，不是 null 才累加。</p></li><li><p>对于 count(*) 来说，并不会把全部字段取出来，而是专门做了优化，不取值，直接按行累加。</p></li></ul><p>所以最后得出的结果是：count(字段)&lt;count(主键 id)&lt;count(1)≈count(*)。</p><h5 id="MySQL-中内连接、左连接、右连接有什么区别？"><a href="#MySQL-中内连接、左连接、右连接有什么区别？" class="headerlink" title="MySQL 中内连接、左连接、右连接有什么区别？"></a>MySQL 中内连接、左连接、右连接有什么区别？</h5><ul><li><p>内连（inner join）— 把匹配的关联数据显示出来；</p></li><li><p>左连接（left join）— 把左边的表全部显示出来，右边的表显示出符合条件的数据；</p></li><li><p>右连接（right join）— 把右边的表全部显示出来，左边的表显示出符合条件的数据；</p></li></ul><h5 id="什么是视图？如何创建视图？"><a href="#什么是视图？如何创建视图？" class="headerlink" title="什么是视图？如何创建视图？"></a>什么是视图？如何创建视图？</h5><p>视图是一种虚拟的表，具有和物理表相同的功能，可以对视图进行增、改、查操作。视图通常是一个表或者多个表的行或列的子集。 视图创建脚本如下：</p><pre><code class="hljs mysql">create view vname as select column_names from table_name where condition;</code></pre><h5 id="视图有哪些优点？"><a href="#视图有哪些优点？" class="headerlink" title="视图有哪些优点？"></a>视图有哪些优点？</h5><ul><li><p>获取数据更容易，相对于多表查询来说；</p></li><li><p>视图能够对机密数据提供安全保护；</p></li><li><p>视图的修改不会影响基本表，提供了独立的操作单元，比较轻量。</p></li></ul><h5 id="MySQL-中“视图”的概念有几个？分别代表什么含义？"><a href="#MySQL-中“视图”的概念有几个？分别代表什么含义？" class="headerlink" title="MySQL 中“视图”的概念有几个？分别代表什么含义？"></a>MySQL 中“视图”的概念有几个？分别代表什么含义？</h5><p>MySQL 中的“视图”概念有两个，它们分别是：</p><ul><li><p>MySQL 中的普通视图也是我们最常用的 view，创建语法是 create view …,它的查询和普通表一样；</p></li><li><p>InnoDB 实现 MVCC（Multi-Version Concurrency Control）多版本并发控制时用到的一致性读视图，它没有物理结构，作用是事务执行期间定于可以看到的数据。</p></li></ul><h5 id="使用-delete-误删数据怎么找回？"><a href="#使用-delete-误删数据怎么找回？" class="headerlink" title="使用 delete 误删数据怎么找回？"></a>使用 delete 误删数据怎么找回？</h5><p>可以用 Flashback 工具通过闪回把数据恢复回来。</p><h5 id="Flashback-恢复数据的原理是什么？"><a href="#Flashback-恢复数据的原理是什么？" class="headerlink" title="Flashback 恢复数据的原理是什么？"></a>Flashback 恢复数据的原理是什么？</h5><p>Flashback 恢复数据的原理是是修改 binlog 的内容，拿回原库重放，从而实现数据找回。</p><h4 id="MySQL-事务"><a href="#MySQL-事务" class="headerlink" title="MySQL 事务"></a>MySQL 事务</h4><h5 id="事务是什么？"><a href="#事务是什么？" class="headerlink" title="事务是什么？"></a>事务是什么？</h5><p>事务是一系列的数据库操作，是数据库应用的基本单位。MySQL 事务主要用于处理操作量大，复杂度高的数据。</p><h5 id="事务有哪些特性？"><a href="#事务有哪些特性？" class="headerlink" title="事务有哪些特性？"></a>事务有哪些特性？</h5><p>在 MySQL 中只有 InnDB 引擎支持事务，它的四个特性如下：</p><ul><li><p>原子性（Atomic）：要么全部执行，要么全部不执行；</p></li><li><p>一致性（Consistency）：事务的执行使得数据库从一种正确状态转化为另一种正确状态；</p></li><li><p>隔离性（Isolation）：在事务正确提交之前，不允许把该事务对数据的任何改变提供给其他事务；</p></li><li><p>持久性（Durability）：事务提交后，其结果永久保存在数据库中。</p></li></ul><h5 id="MySQL-中有几种事务隔离级别？分别是什么？"><a href="#MySQL-中有几种事务隔离级别？分别是什么？" class="headerlink" title="MySQL 中有几种事务隔离级别？分别是什么？"></a>MySQL 中有几种事务隔离级别？分别是什么？</h5><p>MySQL 中有四种事务隔离级别，它们分别是：</p><ul><li><p>read uncommited：未提交读，读到未提交数据；</p></li><li><p>read committed：读已提交，也叫不可重复读，两次读取到的数据不一致；</p></li><li><p>repetable read：可重复读；</p></li><li><p>serializable：串行化，读写数据都会锁住整张表，数据操作不会出错，但并发性能极低，开发中很少用到。</p></li></ul><p>MySQL 默认使用 REPEATABLE-READ 的事务隔离级别。</p><h5 id="幻读和不可重复读的区别？"><a href="#幻读和不可重复读的区别？" class="headerlink" title="幻读和不可重复读的区别？"></a>幻读和不可重复读的区别？</h5><ul><li><p>不可重复读的重点是修改：在同一事务中，同样的条件，第一次读的数据和第二次读的数据不一样。（因为中间有其他事务提交了修改）。</p></li><li><p>幻读的重点在于新增或者删除：在同一事务中，同样的条件,，第一次和第二次读出来的记录数不一样。（因为中间有其他事务提交了插入/删除）。</p></li></ul><h5 id="并发事务一般有哪些问题？"><a href="#并发事务一般有哪些问题？" class="headerlink" title="并发事务一般有哪些问题？"></a>并发事务一般有哪些问题？</h5><ul><li><p>更新丢失（Lost Update）：当两个或多个事务选择同一行，然后基于最初选定的值更新该行时，由于每个事务都不知道其他事务的存在，就会发生丢失更新问题，最后的更新覆盖了由其他事务所做的更新。例如，两个编辑人员制作了同一文档的电子副本，每个编辑人员独立地更改其副本，然后保存更改后的副本，这样就覆盖了原始文档。 最后保存其更改副本的编辑人员覆盖另一个编辑人员所做的更改，如果在前一个编辑人员完成并提交事务之前，另一个编辑人员不能访问同一文件，则可避免此问题。</p></li><li><p>脏读（Dirty Reads）：一个事务正在对一条记录做修改，在这个事务完成并提交前， 这条记录的数据就处于不一致状态； 这时， 另一个事务也来读取同一条记录，如果不加控制，第二个事务读取了这些脏数据，并据此做进一步的处理，就会产生未提交的数据依赖关系，这种现象被形象地叫做脏读。</p></li><li><p>不可重复读（Non-Repeatable Reads）：一个事务在读取某些数据后的某个时间，再次读取以前读过的数据，却发现其读出的数据已经发生了改变、或某些记录已经被删除了！这种现象就叫做“不可重复读” 。</p></li><li><p>幻读（Phantom Reads）： 一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象就称为“幻读” 。</p></li></ul><h5 id="并发事务会有什么问题？应该如何解决？"><a href="#并发事务会有什么问题？应该如何解决？" class="headerlink" title="并发事务会有什么问题？应该如何解决？"></a>并发事务会有什么问题？应该如何解决？</h5><p>并发事务可能造成：脏读、不可重复读和幻读等问题 ，这些问题其实都是数据库读一致性问题，必须由数据库提供一定的事务隔离机制来解决，解决方案如下：</p><ul><li><p>加锁：在读取数据前，对其加锁，阻止其他事务对数据进行修改。</p></li><li><p>提供数据多版本并发控制（MultiVersion Concurrency Control，简称 MVCC 或 MCC），也称为多版本数据库：不用加任何锁， 通过一定机制生成一个数据请求时间点的一致性数据快照（Snapshot)， 并用这个快照来提供一定级别 （语句级或事务级） 的一致性读取，从用户的角度来看，好象是数据库可以提供同一数据的多个版本。</p></li></ul><h5 id="什么是-MVCC？"><a href="#什么是-MVCC？" class="headerlink" title="什么是 MVCC？"></a>什么是 MVCC？</h5><p>MVCC 全称是多版本并发控制系统，InnoDB 和 Falcon 存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control）机制解决幻读问题。</p><h5 id="MVCC-是怎么工作的？"><a href="#MVCC-是怎么工作的？" class="headerlink" title="MVCC 是怎么工作的？"></a>MVCC 是怎么工作的？</h5><p>InnoDB 的 MVCC 是通过在每行记录后面保存两个隐藏的列来实现，这两个列一个保存了行的创建时间，一个保存行的过期时间（删除时间）。当然存储的并不是真实的时间而是系统版本号（system version number）。每开始一个新的事务，系统版本号都会自动新增，事务开始时刻的系统版本号会作为事务的版本号，用来查询到每行记录的版本号进行比较。</p><h5 id="REPEATABLE-READ（可重读）隔离级别下-MVCC-如何工作？"><a href="#REPEATABLE-READ（可重读）隔离级别下-MVCC-如何工作？" class="headerlink" title="REPEATABLE READ（可重读）隔离级别下 MVCC 如何工作？"></a>REPEATABLE READ（可重读）隔离级别下 MVCC 如何工作？</h5><ul><li><p>SELECT：InnoDB 会根据以下条件检查每一行记录：第一，InnoDB 只查找版本早于当前事务版本的数据行，这样可以确保事务读取的行要么是在开始事务之前已经存在要么是事务自身插入或者修改过的。第二，行的删除版本号要么未定义，要么大于当前事务版本号，这样可以确保事务读取到的行在事务开始之前未被删除。</p></li><li><p>INSERT：InnoDB 为新插入的每一行保存当前系统版本号作为行版本号。</p></li><li><p>DELETE：InnoDB 为删除的每一行保存当前系统版本号作为行删除标识。</p></li><li><p>UPDATE：InnoDB 为插入的一行新纪录保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为删除标识保存这两个版本号，使大多数操作都不用加锁。它不足之处是每行记录都需要额外的存储空间，需要做更多的行检查工作和一些额外的维护工作。</p></li></ul><h5 id="MySQL-事务实现原理是什么？"><a href="#MySQL-事务实现原理是什么？" class="headerlink" title="MySQL 事务实现原理是什么？"></a>MySQL 事务实现原理是什么？</h5><p>事务的实现是基于数据库的存储引擎，不同的存储引擎对事务的支持程度不一样。MySQL 中支持事务的存储引擎有InnoDB 和 NDB。 InnoDB 是高版本 MySQL 的默认的存储引擎，因此就以 InnoDB 的事务实现为例，InnoDB 是通过多版本并发控制（MVCC，Multiversion Concurrency Control ）解决不可重复读问题，加上间隙锁（也就是并发控制）解决幻读问题。因此 InnoDB 的 RR 隔离级别其实实现了串行化级别的效果，而且保留了比较好的并发性能。事务的隔离性是通过锁实现，而事务的原子性、一致性和持久性则是通过事务日志实现。 </p><h5 id="如何设置-MySQL-的事务隔离级别？"><a href="#如何设置-MySQL-的事务隔离级别？" class="headerlink" title="如何设置 MySQL 的事务隔离级别？"></a>如何设置 MySQL 的事务隔离级别？</h5><p>MySQL 事务隔离级别 MySQL.cnf 文件里设置的（默认目录 /etc/my.cnf），在文件的文末添加配置：</p><p><code>transaction-isolation = REPEATABLE-READ</code></p><p>可用的配置值：<code>READ-UNCOMMITTED、READ-COMMITTED、REPEATABLE-READ、SERIALIZABLE</code>。</p><h5 id="InnoDB-默认的事务隔离级别是什么？如何修改？"><a href="#InnoDB-默认的事务隔离级别是什么？如何修改？" class="headerlink" title="InnoDB 默认的事务隔离级别是什么？如何修改？"></a>InnoDB 默认的事务隔离级别是什么？如何修改？</h5><p><code>InnoDB </code>默认的事务隔离是 <code>repetable read</code>（可重复读）；可以通过<code> set</code> 作用域 <code>transaction isolation level </code>事务隔离级别 来修改事务的隔离级别</p><p>如：</p><pre><code class="hljs mysql">MySQL&gt; set global transaction isolation level read committed;  &#x2F;&#x2F; 设置全局事务隔离级别为 read committed   MySQL&gt; set session transaction isolation level read committed; &#x2F;&#x2F; 设置当前会话事务隔离级别为 read committed</code></pre><h5 id="InnoDB-如何开启手动提交事务？"><a href="#InnoDB-如何开启手动提交事务？" class="headerlink" title="InnoDB 如何开启手动提交事务？"></a>InnoDB 如何开启手动提交事务？</h5><p><code>InnoDB</code> 默认是自动提交事务的，每一次<code> SQL</code> 操作（非<code>select</code>操作）都会自动提交一个事务，如果要手动开启事务需要设置 <code>set autocommit=0 </code>禁止自动提交事务，相当于开启手动提交事务。</p><h5 id="在-InnoDB-中设置了-autocommit-0，添加一条信息之后没有手动执行提交操作，请问这条信息可以被查到吗？"><a href="#在-InnoDB-中设置了-autocommit-0，添加一条信息之后没有手动执行提交操作，请问这条信息可以被查到吗？" class="headerlink" title="在 InnoDB 中设置了 autocommit=0，添加一条信息之后没有手动执行提交操作，请问这条信息可以被查到吗？"></a>在 InnoDB 中设置了 autocommit=0，添加一条信息之后没有手动执行提交操作，请问这条信息可以被查到吗？</h5><p><code>autocommit=0</code> 表示禁止自动事务提交，在添加操作之后没有进行手动提交，默认情况下其他连接客户端是查询不到此条新增数据的。</p><h5 id="如何手动操作事务？"><a href="#如何手动操作事务？" class="headerlink" title="如何手动操作事务？"></a>如何手动操作事务？</h5><p>使用 begin 开启事务；rollback 回滚事务；commit 提交事务。具体使用示例如下：</p><pre><code class="hljs mysql">begin; insert person(name,age) values(&#39;laowang&#39;,18); rollback; commit;</code></pre><h4 id="MySQL-日志"><a href="#MySQL-日志" class="headerlink" title="MySQL 日志"></a>MySQL 日志</h4><h5 id="MySQL-有哪些重要的日志文件？"><a href="#MySQL-有哪些重要的日志文件？" class="headerlink" title="MySQL 有哪些重要的日志文件？"></a>MySQL 有哪些重要的日志文件？</h5><p><img src="/images/mysql/logfile.png"></p><p>MySQL 中的重要日志分为以下几个：</p><p> ① 错误日志：用来记录 MySQL 服务器运行过程中的错误信息，比如，无法加载 MySQL 数据库的数据文件，或权限不正确等都会被记录在此，还有复制环境下，从服务器进程的信息也会被记录进错误日志。默认情况下，错误日志是开启的，且无法被禁止。</p><p>​      错误日志是存储在数据库的数据文件目录中，名称为 hostname.err，其中 hostname 为服务器主机名。在 MySQL 5.5.7 之前，数据库管理员可以删除很长时间之前的错误日志，以节省服务器上的硬盘空间， MySQL 5.5.7 之后，服务器将关闭此项功能，只能使用重命名原来的错误日志文件，手动冲洗日志创建一个新的，命令为：</p><p><code>mv hostname.err  hostname.err.old mysqladmin flush-logs</code></p><p>② 查询日志：查询日志在 MySQL 中被称为 general log(通用日志)，查询日志里的内容不要被“查询日志”误导，认为里面只存储 select 语句，其实不然，查询日志里面记录了数据库执行的所有命令，不管语句是否正确，都会被记录，具体原因如下:</p><ul><li><p>insert 查询为了避免数据冲突，如果此前插入过数据，当前插入的数据如果跟主键或唯一键的数据重复那肯定会报错；</p></li><li><p>update 时也会查询因为更新的时候很可能会更新某一块数据；</p></li><li><p>delete 查询，只删除符合条件的数据；</p></li></ul><p>因此都会产生日志，在并发操作非常多的场景下，查询信息会非常多，那么如果都记录下来会导致 IO 非常大，影响 MySQL 性能，因此如果不是在调试环境下，是不建议开启查询日志功能的。</p><p>查询日志的开启有助于帮助我们分析哪些语句执行密集，执行密集的 select 语句对应的数据是否能够被缓存，同时也可以帮助我们分析问题，所以，我们可以根据自己的实际情况来决定是否开启查询日志。</p><p>查询日志模式是关闭的，可以通过以下命令开启查询日志：</p><p><code>set global generallog=1 set global logoutput=&#39;table&#39;;</code></p><p><code>general_log=1</code> 为开启查询日志，0 为关闭查询日志，这个设置命令即时生效，不用重启 MySQL 服务器。</p><p>③ 慢日志：慢查询会导致 CPU、IOPS、内存消耗过高，当数据库遇到性能瓶颈时，大部分时间都是由于慢查询导致的。开启慢查询日志，可以让 MySQL 记录下查询超过指定时间的语句，之后运维人员通过定位分析，能够很好的优化数据库性能。默认情况下，慢查询日志是不开启的，只有手动开启了，慢查询才会被记录到慢查询日志中。使用如下命令记录当前数据库的慢查询语句：</p><p><code>set global slowquerylog=&#39;ON&#39;;</code></p><p>使用 <code>set global slowquerylog=&#39;ON&#39;</code> 开启慢查询日志，只是对当前数据库有效，如果 MySQL 数据库重启后就会失效。所以如果要永久生效，就要修改配置文件<code> my.cnf</code>，设置<code> slowquerylog=1</code> 并重启 MySQL 服务器。</p><p>④ <code>redo log</code>（重做日志）：为了最大程度的避免数据写入时，因为 IO 瓶颈造成的性能问题，MySQL 采用了这样一种缓存机制，先将数据写入内存中，再批量把内存中的数据统一刷回磁盘。为了避免将数据刷回磁盘过程中，因为掉电或系统故障带来的数据丢失问题，InnoDB 采用 <code>redo log</code> 来解决此问题。</p><p>⑤ <code>undo log</code>（回滚日志）：用于存储日志被修改前的值，从而保证如果修改出现异常，可以使用 <code>undo log </code>日志来实现回滚操作。<code>undo log </code>和<code> redo log</code> 记录物理日志不一样，它是逻辑日志，可以认为当 <code>delete</code> 一条记录时，<code>undo log</code> 中会记录一条对应的<code> insert</code> 记录，反之亦然，当 <code>update</code> 一条记录时，它记录一条对应相反的 <code>update</code> 记录，当执行 rollback 时，就可以从 <code>undo log</code> 中的逻辑记录读取到相应的内容并进行回滚。<code>undo log </code>默认存放在共享表空间中，在 <code>mySQL 5.6</code> 中，<code>undo log</code> 的存放位置还可以通过变量<code>innodbundodirectory</code>来自定义存放目录，默认值为“.”表示 <code>datadir </code>目录。</p><p>⑥ <code>bin log</code>（二进制日志）：是一个二进制文件，主要记录所有数据库表结构变更，比如，<code>CREATE、ALTER TABLE</code> 等，以及表数据修改，比如，<code>INSERT、UPDATE、DELETE</code> 的所有操作，<code>bin log</code> 中记录了对 MySQL 数据库执行更改的所有操作，并且记录了语句发生时间、执行时长、操作数据等其它额外信息，但是它不记录<code>SELECT、SHOW</code>等那些不修改数据的 SQL 语句。</p><p>binlog 的作用如下：</p><ul><li><p>恢复（recovery）：某些数据的恢复需要二进制日志。比如，在一个数据库全备文件恢复后，用户可以通过二进制日志进行 point-in-time 的恢复；</p></li><li><p>复制（replication）：其原理与恢复类似，通过复制和执行二进制日志使一台远程的MySQL数据库（一般称为 slave 或者 standby）与一台 MySQL 数据库（一般称为 master 或者 primary）进行实时同步；</p></li><li><p>审计（audit）：用户可以通过二进制日志中的信息来进行审计，判断是否有对数据库进行注入攻击。</p></li></ul><p>除了上面介绍的几个作用外，binlog 对于事务存储引擎的崩溃恢复也有非常重要的作用，在开启 binlog 的情况下，为了保证 binlog 与 redo 的一致性，MySQL 将采用事务的两阶段提交协议。当 MySQL 系统发生崩溃时，事务在存储引擎内部的状态可能为 prepared（准备状态）和 commit（提交状态）两种，对于 prepared 状态的事务，是进行提交操作还是进行回滚操作，这时需要参考 binlog，如果事务在 binlog 中存在，那么将其提交；如果不在 binlog 中存在，那么将其回滚，这样就保证了数据在主库和从库之间的一致性。</p><p>binlog 默认是关闭状态，可以在 MySQL 配置文件（my.cnf）中通过配置参数 <code>log-bin = [base-name]</code> 开启记录 binlog 日志，如果不指定 <code>base-name</code>，则默认二进制日志文件名为主机名，并以自增的数字作为后缀，比如：<code>mysql-bin.000001</code>，所在目录为数据库所在目录（datadir）。</p><p>通过以下命令来查询 binlog 是否开启：</p><p><code>show variables like &#39;log_%&#39;;</code></p><p><img src="/images/mysql/binlog.png"> </p><p>binlog 格式分为: STATEMENT、ROW 和 MIXED 三种：</p><ul><li><p>STATEMENT 格式的 binlog 记录的是数据库上执行的原生 SQL 语句。这种格式的优点是简单，简单地记录和执行这些语句，能够让主备保持同步，在主服务器上执行的 SQL 语句，在从服务器上执行同样的语句。另一个好处是二进制日志里的时间更加紧凑，所以相对而言，基于语句的复制模式不会使用太多带宽，同时也节约磁盘空间。并且通过 mysqlbinlog 工具容易读懂其中的内容。缺点就是同一条 SQL 在主库和从库上执行的时间可能稍微或很大不相同，因此在传输的二进制日志中，除了查询语句，还包括了一些元数据信息，如当前的时间戳。即便如此，还存在着一些无法被正确复制的 SQL。比如，使用 <code>INSERT INTO TB1 VALUE(CUURENT_DATE()) </code>这一条使用函数的语句插入的数据复制到当前从服务器上来就会发生变化，存储过程和触发器在使用基于语句的复制模式时也可能存在问题；另外一个问题就是基于语句的复制必须是串行化的，比如：InnoDB 的 next-key 锁等，并不是所有的存储引擎都支持基于语句的复制；</p></li><li><p>ROW 格式是从 MySQL 5.1 开始支持基于行的复制，也就是基于数据的复制，基于行的更改。这种方式会将实际数据记录在二进制日志中，它有其自身的一些优点和缺点，最大的好处是可以正确地复制每一行数据，一些语句可以被更加有效地复制，另外就是几乎没有基于行的复制模式无法处理的场景，对于所有的 SQL 构造、触发器、存储过程等都能正确执行；它的缺点就是二进制日志可能会很大，而且不直观，所以，你不能使用 mysqlbinlog 来查看二进制日志，也无法通过看二进制日志判断当前执行到那一条 SQL 语句。现在对于 ROW 格式的二进制日志基本是标配了，主要是因为它的优势远远大于缺点，并且由于 ROW 格式记录行数据，所以可以基于这种模式做一些 DBA 工具，比如数据恢复，不同数据库之间数据同步等；</p></li><li><p>MIXED 也是 MySQL 默认使用的二进制日志记录方式，但 MIXED 格式默认采用基于语句的复制，一旦发现基于语句的无法精确的复制时，就会采用基于行的复制。比如用到 UUID()、USER()、CURRENTUSER()、ROWCOUNT() 等无法确定的函数。</p></li></ul><h5 id="redo-log-和-binlog-有什么区别？"><a href="#redo-log-和-binlog-有什么区别？" class="headerlink" title="redo log 和 binlog 有什么区别？"></a>redo log 和 binlog 有什么区别？</h5><p>redo log（重做日志）和 binlog（归档日志）都是 MySQL 的重要的日志，它们的区别如下：</p><ul><li><p>redo log 是物理日志，记录的是“在某个数据页上做了什么修改”。</p></li><li><p>binlog 是逻辑日志，记录的是这个语句的原始逻辑，比如“给 ID=2 这一行的 c 字段加 1 ”。</p></li><li><p>redo log 是 InnoDB 引擎特有的；binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用。</p></li><li><p>redo log 是循环写的，空间固定会用完；binlog 是可以追加写入的。“追加写”是指 binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。</p></li></ul><p>最开始 MySQL 里并没有 InnoDB 引擎，MySQL 自带的引擎是 MyISAM，但是 MyISAM 没有 crash-safe 的能力，binlog 日志只能用于归档。而 InnoDB 是另一个公司以插件形式引入 MySQL 的，既然只依靠 binlog 是没有 crash-safe 能力的，所以 InnoDB 使用另外一套日志系统，也就是 redo log 来实现 crash-safe 能力。</p><h5 id="什么是-crash-safe？"><a href="#什么是-crash-safe？" class="headerlink" title="什么是 crash-safe？"></a>什么是 crash-safe？</h5><p>crash-safe 是指发生宕机等意外情况下，服务器重启后数据依然不会丢失的情况。</p><h5 id="什么是脏页和干净页？"><a href="#什么是脏页和干净页？" class="headerlink" title="什么是脏页和干净页？"></a>什么是脏页和干净页？</h5><p>MySQL 为了操作的性能优化，会把数据更新先放入内存中，之后再统一更新到磁盘。当内存数据和磁盘数据内容不一致的时候，我们称这个内存页为脏页；内存数据写到磁盘后，内存的数据和磁盘上的内容就一致了，我们称为“干净页”。</p><h5 id="什么情况下会引发-MySQL-刷脏页（flush）的操作？"><a href="#什么情况下会引发-MySQL-刷脏页（flush）的操作？" class="headerlink" title="什么情况下会引发 MySQL 刷脏页（flush）的操作？"></a>什么情况下会引发 MySQL 刷脏页（flush）的操作？</h5><ul><li><p>内存写满了，这个时候就会引发 flush 操作，对应到 InnoDB 就是 redo log 写满了；</p></li><li><p>系统的内存不足了，当需要新的内存页的时候，就会淘汰一些内存页，如果淘汰的是脏页这个时候就会触发 flush 操作；</p></li><li><p>系统空闲的时候，MySQL 会同步内存中的数据到磁盘也会触发 flush 操作；</p></li><li><p>MySQL 服务关闭的时候也会刷脏页，触发 flush 操作。</p></li></ul><h5 id="MySQL-刷脏页的速度很慢可能是什么原因？"><a href="#MySQL-刷脏页的速度很慢可能是什么原因？" class="headerlink" title="MySQL 刷脏页的速度很慢可能是什么原因？"></a>MySQL 刷脏页的速度很慢可能是什么原因？</h5><p>在 MySQL 中单独刷一个脏页的速度是很快的，如果发现刷脏页的速度很慢，说明触发了 MySQL 刷脏页的“连坐”机制，MySQL 的“连坐”机制是指当 MySQL 刷脏页的时候如果发现相邻的数据页也是脏页也会一起刷掉，而这个动作可以一直蔓延下去，这就是导致 MySQL 刷脏页慢的原因了。</p><h5 id="如何控制-MySQL-只刷新当前脏页？"><a href="#如何控制-MySQL-只刷新当前脏页？" class="headerlink" title="如何控制 MySQL 只刷新当前脏页？"></a>如何控制 MySQL 只刷新当前脏页？</h5><p>在 InnoDB 中设置 innodbflushneighbors 这个参数的值为 0，来规定 MySQL 只刷当前脏页，MySQL 8 这个值默认是 0。</p><h5 id="MySQL-的-WAL-技术是解决什么问题的？"><a href="#MySQL-的-WAL-技术是解决什么问题的？" class="headerlink" title="MySQL 的 WAL 技术是解决什么问题的？"></a>MySQL 的 WAL 技术是解决什么问题的？</h5><p>A.防止误删除，找回数据用的</p><p>B.容灾恢复，为了还原异常数据用的</p><p>C.事务处理，为了数据库的稳定性</p><p>D.为了降低 IO 成本 </p><p>答：D 题目解析：WAL 技术的全称是 Write Ahead Logging（中文：预写式日志），是先写日志，再写磁盘的方式，因为每次更新都写磁盘的话 IO 成本很高，所以才有了 WAL 技术。</p><h5 id="为什么有时候会感觉-MySQL-偶尔卡一下？"><a href="#为什么有时候会感觉-MySQL-偶尔卡一下？" class="headerlink" title="为什么有时候会感觉 MySQL 偶尔卡一下？"></a>为什么有时候会感觉 MySQL 偶尔卡一下？</h5><p>如果偶尔感觉 MySQL 卡一下，可能是 MySQL 正在刷脏页，正在把内存中的更新操作刷到磁盘中。</p><h5 id="redo-log-和-binlog-是怎么关联的"><a href="#redo-log-和-binlog-是怎么关联的" class="headerlink" title="redo log 和 binlog 是怎么关联的?"></a>redo log 和 binlog 是怎么关联的?</h5><p>它们有一个共同的数据字段，叫 XID。崩溃恢复的时候，会按顺序扫描 redo log：</p><ul><li><p>如果碰到既有 prepare、又有 commit 的 redo log，就直接提交；</p></li><li><p>如果碰到只有 parepare、而没有 commit 的 redo log，就拿着 XID 去 binlog 找对应的事务。</p></li></ul><h5 id="MySQL-怎么知道-binlog-是完整的"><a href="#MySQL-怎么知道-binlog-是完整的" class="headerlink" title="MySQL 怎么知道 binlog 是完整的?"></a>MySQL 怎么知道 binlog 是完整的?</h5><ul><li><p>statement 格式的 binlog，完整的标识是最后有 COMMIT 关键字。</p></li><li><p>row 格式的 binlog，完整的标识是最后会有一个 XID event 关键字。</p></li></ul><h5 id="MySQL-中可不可以只要-binlog，不要-redo-log？"><a href="#MySQL-中可不可以只要-binlog，不要-redo-log？" class="headerlink" title="MySQL 中可不可以只要 binlog，不要 redo log？"></a>MySQL 中可不可以只要 binlog，不要 redo log？</h5><p>不可以，binlog 没有崩溃恢复的能力。</p><h5 id="MySQL-中可不可以只要-redo-log，不要-binlog？"><a href="#MySQL-中可不可以只要-redo-log，不要-binlog？" class="headerlink" title="MySQL 中可不可以只要 redo log，不要 binlog？"></a>MySQL 中可不可以只要 redo log，不要 binlog？</h5><p>不可以，原因有以下两个：</p><ul><li><p>redo log 是循环写不能保证所有的历史数据，这些历史数据只能在 binlog 中找到；</p></li><li><p>binlog 是高可用的基础，高可用的实现原理就是 binlog 复制。</p></li></ul><h5 id="为什么-binlog-cache-是每个线程自己维护的，而-redo-log-buffer-是全局共用的？"><a href="#为什么-binlog-cache-是每个线程自己维护的，而-redo-log-buffer-是全局共用的？" class="headerlink" title="为什么 binlog cache 是每个线程自己维护的，而 redo log buffer 是全局共用的？"></a>为什么 binlog cache 是每个线程自己维护的，而 redo log buffer 是全局共用的？</h5><p>因为 binlog 是不能“被打断的”，一个事务的 binlog 必须连续写，因此要整个事务完成后，再一起写到文件里。而 redo log 并没有这个要求，中间有生成的日志可以写到 redo log buffer 中，redo log buffer 中的内容还能“搭便车”，其他事务提交的时候可以被一起写到磁盘中。</p><h5 id="事务执行期间，还未提交，如果发生-crash，redo-log-丢失，会导致主备不一致呢？"><a href="#事务执行期间，还未提交，如果发生-crash，redo-log-丢失，会导致主备不一致呢？" class="headerlink" title="事务执行期间，还未提交，如果发生 crash，redo log 丢失，会导致主备不一致呢？"></a>事务执行期间，还未提交，如果发生 crash，redo log 丢失，会导致主备不一致呢？</h5><p>不会，因为这时候 binlog 也还在 binlog cache 里，没发给备库，crash 以后 redo log 和 binlog 都没有了，从业务角度看这个事务也没有提交，所以数据是一致的。</p><h5 id="在-MySQL-中用什么机制来优化随机读-写磁盘对-IO-的消耗？"><a href="#在-MySQL-中用什么机制来优化随机读-写磁盘对-IO-的消耗？" class="headerlink" title="在 MySQL 中用什么机制来优化随机读/写磁盘对 IO 的消耗？"></a>在 MySQL 中用什么机制来优化随机读/写磁盘对 IO 的消耗？</h5><p>redo log 是用来节省随机写磁盘的 IO 消耗，而 change buffer 主要是节省随机读磁盘的 IO 消耗。redo log 会把 MySQL 的更新操作先记录到内存中，之后再统一更新到磁盘，而 change buffer 也是把关键查询数据先加载到内存中，以便优化 MySQL 的查询。</p><h5 id="以下说法错误的是？"><a href="#以下说法错误的是？" class="headerlink" title="以下说法错误的是？"></a>以下说法错误的是？</h5><p>A.redo log 是 InnoDB 引擎特有的，它的固定大小的 </p><p>B.redo log 日志是不全的，只有最新的一些日志，这和它的内存大小有关</p><p>C.redo log 可以保证数据库异常重启之后，数据不丢失</p><p>D.binlog 是 MySQL 自带的日志，它能保证数据库异常重启之后，数据不丢失 </p><p>答：D 题目解析：binlog 是 MySQL 自带的日志，但它并不能保证数据库异常重启之后数据不丢失。</p><h5 id="以下说法正确的是？"><a href="#以下说法正确的是？" class="headerlink" title="以下说法正确的是？"></a>以下说法正确的是？</h5><p>A.redo log 日志是追加写的，后面的日志并不会覆盖前面的日志</p><p>B.binlog 日志是追加写的，后面的日志并不会覆盖前面的日志</p><p>C.redo log 和 binlog 日志都是追加写的，后面的日志并不会覆盖前面的日志 </p><p>D.以上说法都正确</p><p>答：B 题目解析：binlog 日志是追加写的，后面的日志并不会覆盖前面的日志，redo log 日志是固定大小的，后面的日志会覆盖前面的日志。</p><h5 id="有没有办法把-MySQL-的数据恢复到过去某个指定的时间节点？怎么恢复？"><a href="#有没有办法把-MySQL-的数据恢复到过去某个指定的时间节点？怎么恢复？" class="headerlink" title="有没有办法把 MySQL 的数据恢复到过去某个指定的时间节点？怎么恢复？"></a>有没有办法把 MySQL 的数据恢复到过去某个指定的时间节点？怎么恢复？</h5><p>可以恢复，只要你备份了这段时间的所有 binlog，同时做了全量数据库的定期备份，比如，一天一备，或者三天一备，这取决于你们的备份策略，这个时候你就可以把之前备份的数据库先还原到测试库，从备份的时间点开始，将备份的 binlog 依次取出来，重放到你要恢复数据的那个时刻，这个时候就完成了数据到指定节点的恢复。比如，今天早上 9 点的时候，你想把数据恢复成今天早上 6:00:00 的状态，这个时候你可以先取出今天凌晨（00:01:59）备份的数据库文件，还原到测试库，再从 binlog 文件中依次取出 00:01:59 之后的操作信息，重放到 6:00:00 这个时刻，这就完成了数据库的还原。</p><h4 id="MySQL-命令和内置函数"><a href="#MySQL-命令和内置函数" class="headerlink" title="MySQL 命令和内置函数"></a>MySQL 命令和内置函数</h4><h5 id="如何用命令行方式连接-MySQL-数据库？"><a href="#如何用命令行方式连接-MySQL-数据库？" class="headerlink" title="如何用命令行方式连接 MySQL 数据库？"></a>如何用命令行方式连接 MySQL 数据库？</h5><p>使用 mysql -u用户名 -p密码; 输入用户名和密码就可以正常进入数据库连接了，实例如下：</p><p><code>mysql -uroot -p123456;</code></p><p>其中，用户名为 root，密码为 123456。</p><h5 id="关于命令-mysql-h-127-0-0-1-uroot-P-3307-p3307-以下说法错误的是？"><a href="#关于命令-mysql-h-127-0-0-1-uroot-P-3307-p3307-以下说法错误的是？" class="headerlink" title="关于命令 mysql -h 127.0.0.1 -uroot -P 3307 -p3307 以下说法错误的是？"></a>关于命令 mysql -h 127.0.0.1 -uroot -P 3307 -p3307 以下说法错误的是？</h5><p>A.-h 和 -P 可以省略 </p><p>B.-u 和用户名之间不能有空格</p><p>C.-p 和密码之间不能用空格</p><p>D.小写 -p 对应的是用户密码，大写 -P 对应的是 MySQL 服务器的端口</p><p>答：B 题目解析：-p 和密码之间不能用空格，否则空格会被识别为密码的一部分，提示密码错误。-u 和用户名之间可以有空格。</p><h5 id="如何创建用户？并给用户授权？"><a href="#如何创建用户？并给用户授权？" class="headerlink" title="如何创建用户？并给用户授权？"></a>如何创建用户？并给用户授权？</h5><p>创建用户使用关键字：CREATE USER ，授权使用关键字： GRANT ，具体实现脚本如下：</p><pre><code class="hljs mysql">-- 创建用户laowang create user &#39;laowang&#39;@&#39;localhost&#39; identified by &#39;123456&#39;; -- 授权 test 数据库给 laowang grant all on test.* to &#39;laowang&#39;@&#39;localhost&#39;</code></pre><h5 id="如何修改-MySQL-密码？"><a href="#如何修改-MySQL-密码？" class="headerlink" title="如何修改 MySQL 密码？"></a>如何修改 MySQL 密码？</h5><p>使用如下命令，修改密码：</p><p><code>mysqladmin -u用户名 -p旧密码 password 新密码;</code></p><p>注意：刚开始 root 没有密码，所以 -p 旧密码一项就可以省略了。</p><h5 id="如何使用-SQL-创建数据库，并设置数据库的编码格式？"><a href="#如何使用-SQL-创建数据库，并设置数据库的编码格式？" class="headerlink" title="如何使用 SQL 创建数据库，并设置数据库的编码格式？"></a>如何使用 SQL 创建数据库，并设置数据库的编码格式？</h5><p>创建数据库可使用关键字： CREATE DATABASE ，设置编码格式使用关键字： CHARSET ，具体 SQL 如下：</p><pre><code class="hljs mysql">create database learndb default charset utf8 collate utf8_general_ci;</code></pre><h5 id="如何修改数据库、表的编码格式？"><a href="#如何修改数据库、表的编码格式？" class="headerlink" title="如何修改数据库、表的编码格式？"></a>如何修改数据库、表的编码格式？</h5><p>使用 alter 关键字设置库或表的编码格式即可，具体代码如下：</p><pre><code class="hljs mysql">mysql&gt; alter database dbname default character set utf8; mysql&gt; alter table t default character set utf8;</code></pre><h5 id="如何使用-SQL-创建表？"><a href="#如何使用-SQL-创建表？" class="headerlink" title="如何使用 SQL 创建表？"></a>如何使用 SQL 创建表？</h5><p>创建表的 SQL 如下：</p><pre><code class="hljs mysql">create table t(     tid int not null autoincrement,     tname char(50) not null,     tage int null default 18,     primary key(t_id) )engine&#x3D;innodb;</code></pre><p>其中：</p><ul><li><p>auto_increment：表示自增；</p></li><li><p>primary key：用于指定主键；</p></li><li><p>engine：用于指定表的引擎。</p></li></ul><h5 id="在-MySQL-命令行中如何查看表结构信息？"><a href="#在-MySQL-命令行中如何查看表结构信息？" class="headerlink" title="在 MySQL 命令行中如何查看表结构信息？"></a>在 MySQL 命令行中如何查看表结构信息？</h5><p>使用 desc 表名 查看表结构信息，示例信息如下：</p><p> <img src="/images/mysql/desc.png"></p><p>使用 desc person; 查看表 person 的结构信息。</p><h5 id="如何使用-SQL-查看已知表的建表脚本？"><a href="#如何使用-SQL-查看已知表的建表脚本？" class="headerlink" title="如何使用 SQL 查看已知表的建表脚本？"></a>如何使用 SQL 查看已知表的建表脚本？</h5><p>查看已知表的建表脚本，命令如下：</p><p>mysql&gt; show create table 表名; </p><p>效果如下图所示：</p><p><img src="/images/mysql/create.png"></p><h5 id="如何使用-SQL-语句更新表结构？"><a href="#如何使用-SQL-语句更新表结构？" class="headerlink" title="如何使用 SQL 语句更新表结构？"></a>如何使用 SQL 语句更新表结构？</h5><p>更新表结构信息可以使用 alter table 子句，如，为表增加一列的脚本如下：alter</p><p><code>alter table t add name char(20)；</code></p><p>如果要重命名表名，使用如下命令：</p><p><code>rename table new_t to t;</code></p><h5 id="MySQL-有哪些删除方式？有什么区别？"><a href="#MySQL-有哪些删除方式？有什么区别？" class="headerlink" title="MySQL 有哪些删除方式？有什么区别？"></a>MySQL 有哪些删除方式？有什么区别？</h5><p>MySQL 有三种删除方式： 1）删除表数据：</p><p><code>delete from t;</code></p><p>2）删除数据，保留表结构：</p><p><code>truncate table t;</code></p><p>3）删数据和表结构：</p><p><code>drop table t;</code></p><p>它们的区别如下：</p><ul><li><p>delete 可以有条件的删除，也可以回滚数据，删除数据时进行两个动作：删除与备份，所以速度很慢；</p></li><li><p>truncate 删除所有数据，无条件选择删除，不可回滚，保留表结构；</p></li><li><p>drop：删除数据和表结构 删除速度最快。</p></li></ul><p>执行速度，一般来说：drop&gt; truncate &gt; delete。</p><p>补充：delete 语句是数据库操作语言（dml），这个操作会放到 rollback segement 中，事务提交之后才生效；如果有相应的 trigger，执行的时候将被触发。truncate、drop 是数据库定义语言（ddl），操作立即生效，原数据不放到 rollback segment 中，不能回滚，操作不触发 trigger。</p><p>应用场景：</p><ul><li><p>当你不再需要该表时， 用 drop</p></li><li><p>当你仍要保留该表，但要删除所有记录时， 用 truncate</p></li><li><p>当你要删除部分记录时（always with a where clause），用 delete</p></li></ul><h5 id="如何开启和关闭-MySQL-服务？"><a href="#如何开启和关闭-MySQL-服务？" class="headerlink" title="如何开启和关闭 MySQL 服务？"></a>如何开启和关闭 MySQL 服务？</h5><p>使用 systemctl stop mysqld 停止 MySQL 服务，使用 systemctl start mysqld 启动 MySQL 服务。</p><h5 id="如何查询当前-MySQL-安装的版本号？"><a href="#如何查询当前-MySQL-安装的版本号？" class="headerlink" title="如何查询当前 MySQL 安装的版本号？"></a>如何查询当前 MySQL 安装的版本号？</h5><p>使用 SELECT VERSION(); </p><p>可以查询当前连接的 MySQL 的版本号。</p><h5 id="如何查看某张表的存储引擎？"><a href="#如何查看某张表的存储引擎？" class="headerlink" title="如何查看某张表的存储引擎？"></a>如何查看某张表的存储引擎？</h5><p>可使用 show table status from db where name=’t’; 查询数据库 db 中表 t 的所有信息，其中 Engine 列表示表 t 使用的存储引擎，如下图所示：</p><p> <img src="/images/mysql/engine.png"></p><h5 id="如何查看当前数据库增删改查的执行次数统计？"><a href="#如何查看当前数据库增删改查的执行次数统计？" class="headerlink" title="如何查看当前数据库增删改查的执行次数统计？"></a>如何查看当前数据库增删改查的执行次数统计？</h5><p>使用以下命令行查看：</p><pre><code class="hljs mysql">mysql&gt; show global status where variablename in(&#39;comselect&#39;,&#39;cominsert&#39;,&#39;comdelete&#39;,&#39;comupdate&#39;); +---------------+-------+ | Variablename | Value | +---------------+-------+ | Comdelete   | 0   | | Cominsert   | 1   | | Comselect   | 40   | | Comupdate   | 0   | +---------------+-------+</code></pre><h5 id="如何查询线程连接数？"><a href="#如何查询线程连接数？" class="headerlink" title="如何查询线程连接数？"></a>如何查询线程连接数？</h5><p>使用如下命令：</p><p><code>mysql&gt; show global status like &#39;threads_%&#39;;</code></p><p>执行效果如下图所示：</p><p> <img src="/images/mysql/thread.png"></p><p>其中：</p><ul><li><p>Threads_cached：代表当前此时此刻线程缓存中有多少空闲线程；</p></li><li><p>Threads_connected：代表当前已建立连接的数量，因为一个连接就需要一个线程，所以也可以看成当前被使用的线程数；</p></li><li><p>Threads_created：代表从最近一次服务启动，已创建线程的数量；</p></li><li><p>Threads_running：代表当前激活的（非睡眠状态）线程数。</p></li></ul><h5 id="如何查看-MySQL-的最大连接数？能不能修改？怎么修改？"><a href="#如何查看-MySQL-的最大连接数？能不能修改？怎么修改？" class="headerlink" title="如何查看 MySQL 的最大连接数？能不能修改？怎么修改？"></a>如何查看 MySQL 的最大连接数？能不能修改？怎么修改？</h5><p>查询 MySQL 最大连接数，使用如下命令：</p><p><code>mysql&gt; show variables like &#39;max_connections%&#39;;</code></p><p>此命令输出的结果如下：</p><p> <img src="/images/mysql/maxconn.png"></p><p>可以修改 MySQL 的最大连接数，可以在 MySQL 的配置文件 my.cnf 里修改最大连接数，通过修改 maxconnections 的值，然后重启 MySQL 就会生效，如果 my.ini 文件中没有找到 maxconnections，可自行添加 max_connections 的设置，内容如下：</p><p><code>max_connections=200</code></p><h5 id="CHAR-LENGTH-和-LENGTH-有什么区别？"><a href="#CHAR-LENGTH-和-LENGTH-有什么区别？" class="headerlink" title="CHAR_LENGTH 和 LENGTH 有什么区别？"></a>CHAR_LENGTH 和 LENGTH 有什么区别？</h5><p>CHARLENGTH 是字符数，而 LENGTH 是字节数。它们在不同编码下，值是不相同的，比如对于 UTF-8 编码来说，一个中文字的 LENGTH 为 1，而 CHARLENGTH 通常等于 3，如下图所示：</p><p> <img src="/images/mysql/charlength.png"></p><h5 id="UNION-和-UNION-ALL-的用途是什么？有什么区别？"><a href="#UNION-和-UNION-ALL-的用途是什么？有什么区别？" class="headerlink" title="UNION 和 UNION ALL 的用途是什么？有什么区别？"></a>UNION 和 UNION ALL 的用途是什么？有什么区别？</h5><p>UNION 和 UNION ALL 都是用于合并数据集的，它们的区别如下：</p><ul><li><p>去重：UNION 会对结果进行去重，UNION ALL 则不会进行去重操作；</p></li><li><p>排序：UNION 会对结果根据字段进行排序，而 UNION ALL 则不会进行排序；</p></li><li><p>性能：UNION ALL 的性能要高于 UNION。</p></li></ul><h5 id="以下关于-WHERE-和-HAVING-说法正确的是？"><a href="#以下关于-WHERE-和-HAVING-说法正确的是？" class="headerlink" title="以下关于 WHERE 和 HAVING 说法正确的是？"></a>以下关于 WHERE 和 HAVING 说法正确的是？</h5><p>A.任何情况 WHERE 和 HAVING 都可以相互替代 </p><p>B.GROUP BY 前后都可以使用 WHERE </p><p>C.使用 SELECT X FROM T HAVING Y&gt;20 查询报错 </p><p>D.使用 SELECT X FROM T WHERE Y&gt;20 查询报错 </p><p>答：C，HAVING 非报错用法是 SELECT X,Y FROM T HAVING Y&gt;20 。</p><h5 id="空值和-NULL-的区别是什么？"><a href="#空值和-NULL-的区别是什么？" class="headerlink" title="空值和 NULL 的区别是什么？"></a>空值和 NULL 的区别是什么？</h5><p>空值表示字段的值为空，而 NULL 则表示字段没有值，它们的区别如下：</p><ul><li><p>空值不占用空间，NULL 值是未知的占用空间；</p></li><li><p>空值判断使用 =’’ 或 &lt;&gt;’’ 来判断，NULL 值使用 IS NULL 或 IS NOT NULL 来判断；</p></li><li><p>使用 COUNT 统计某字段时，如果是 NULL 则会忽略不统计，而空值则会算入统计之内。</p></li></ul><p>比如，其中字段 name 有一个 NULL 值和两个空值，查询结果如图：</p><p> <img src="/images/mysql/count.png"></p><h5 id="MySQL-的常用函数有哪些？"><a href="#MySQL-的常用函数有哪些？" class="headerlink" title="MySQL 的常用函数有哪些？"></a>MySQL 的常用函数有哪些？</h5><ul><li><p>sum(field) – 求某个字段的和值；</p></li><li><p>count(*) – 查询总条数；</p></li><li><p>min(field) – 某列中最小的值；</p></li><li><p>max(field) – 某列中最大的值；</p></li><li><p>avg(field) – 求平均数；</p></li><li><p>current_date() – 获取当前日期；</p></li><li><p>now() – 获取当前日期和时间；</p></li><li><p>concat(a, b) – 连接两个字符串值以创建单个字符串输出；</p></li><li><p>datediff(a, b) – 确定两个日期之间的差异，通常用于计算年龄。</p></li></ul><h4 id="MySQL-性能优化-amp-分布式"><a href="#MySQL-性能优化-amp-分布式" class="headerlink" title="MySQL 性能优化 &amp; 分布式"></a>MySQL 性能优化 &amp; 分布式</h4><h5 id="MySQL-性能指标都有哪些？如何得到这些指标？"><a href="#MySQL-性能指标都有哪些？如何得到这些指标？" class="headerlink" title="MySQL 性能指标都有哪些？如何得到这些指标？"></a>MySQL 性能指标都有哪些？如何得到这些指标？</h5><p>MySQL 的性能指标如下：</p><p>① TPS（Transaction Per Second） 每秒事务数，即数据库每秒执行的事务数。</p><p>MySQL 本身没有直接提供 TPS 参数值，如果我们想要获得 TPS 的值，只有我们自己计算了，可以根据 MySQL 数据库提供的状态变量，来计算 TPS。</p><p>需要使用的参数：</p><ul><li><p>Com_commit ：表示提交次数，通过命令 show global status like ‘Com_commit’; 获取；</p></li><li><p>Com_rollback：表示回滚次数，通过命令 show global status like ‘Com_rollback’; 获取。</p></li></ul><p>我们定义第一次获取的 Comcommit 的值与 Comrollback 值的和为 c_r1，时间为 t1；</p><p>第二次获取的 Comcommit 的值与 Comrollback 值的和为 cr2，时间为 t2，t1 与 t2 单位为秒。 那么 TPS = ( cr2 - c_r1 ) / ( t2 - t1 ) 算出来的就是该 MySQL 实例在 t1 与 t2 生命周期之间的平均 TPS。</p><p>② QPS（Query Per Second） 每秒请求次数，也就是数据库每秒执行的 SQL 数量，包含 INSERT、SELECT、UPDATE、DELETE 等。 QPS = Queries / Seconds Queries 是系统状态值—总查询次数，可以通过 show status like ‘queries’; 查询得出，如下所示：</p><p> <img src="/imaegs/queries.png"></p><p>Seconds 是监控的时间区间，单位为秒。 比如，采样 10 秒内的查询次数，那么先查询一次 Queries 值（Q1），等待 10 秒，再查询一次 Queries 值（Q2），那么 QPS 就可以通过，如下公式获得：</p><p>QPS = (Q2 - Q1) / 10</p><p>③ IOPS（Input/Output Operations per Second） 每秒处理的 I/O 请求次数。</p><p>IOPS 是判断磁盘 I/O 能力的指标之一，一般来讲 IOPS 指标越高，那么单位时间内能够响应的请求自然也就越多。理论上讲，只要系统实际的请求数低于 IOPS 的能力，就相当于每一个请求都能得到即时响应，那么 I/O 就不会是瓶颈了。</p><p>注意：IOPS 与磁盘吞吐量不一样，吞吐量是指单位时间内可以成功传输的数据数量。</p><p>可以使用 iostat 命令，查看磁盘的 IOPS，命令如下：</p><pre><code class="hljs zsh">yum install sysstat iostat  -dx 1 10</code></pre><p>执行效果如下图所示：</p><p> <img src="/images/mysql/iostat.png"></p><p>IOPS = r/s + w/s 其中：</p><p>l r/s：代表每秒读了多少次；</p><p>l w/s：代表每秒写了多少次。</p><h5 id="什么是慢查询？"><a href="#什么是慢查询？" class="headerlink" title="什么是慢查询？"></a>什么是慢查询？</h5><p>慢查询是 MySQL 中提供的一种慢查询日志，它用来记录在 MySQL 中响应时间超过阀值的语句，具体指运行时间超过 longquerytime 值的 SQL，则会被记录到慢查询日志中。longquerytime 的默认值为 10，意思是运行 10S 以上的语句。默认情况下，MySQL 数据库并不启动慢查询日志，需要我们手动来设置这个参数，如果不是调优需要的话，一般不建议启动该参数，因为开启慢查询日志会给 MySQL 服务器带来一定的性能影响。慢查询日志支持将日志记录写入文件，也支持将日志记录写入数据库表。</p><p>使用 <code>mysql&gt; show variables like &#39;%slow_query_log%&#39;; </code>来查询慢查询日志是否开启，执行效果如下图所示：</p><p> <img src="/images/mysql/slow.png"></p><p>slowquerylog 的值为 OFF 时，表示未开启慢查询日志。</p><h5 id="如何开启慢查询日志？"><a href="#如何开启慢查询日志？" class="headerlink" title="如何开启慢查询日志？"></a>如何开启慢查询日志？</h5><p>开启慢查询日志，可以使用如下 MySQL 命令：</p><p><code>mysql&gt; set global slowquerylog=1</code></p><p>不过这种设置方式，只对当前数据库生效，如果 MySQL 重启也会失效，如果要永久生效，就必须修改 MySQL 的配置文件 my.cnf，配置如下：</p><p><code>slowquerylog =1 slowquerylogfile=/tmp/mysqlslow.log</code></p><h5 id="如何定位慢查询？"><a href="#如何定位慢查询？" class="headerlink" title="如何定位慢查询？"></a>如何定位慢查询？</h5><p>使用 MySQL 中的 explain 分析执行语句，比如：</p><p><code>explain select * from t where id=5;</code></p><p>如下图所示：</p><p><img src="/images/mysql/explain.png"></p><p>其中：</p><ul><li><p>id — 选择标识符。id越大优先级越高，越先被执行。</p></li><li><p>select_type — 表示查询的类型。</p></li><li><p>table — 输出结果集的表</p></li><li><p>partitions — 匹配的分区</p></li><li><p>type — 表示表的连接类型</p></li><li><p>possible_keys — 表示查询时，可能使用的索引</p></li><li><p>key — 表示实际使用的索引</p></li><li><p>key_len — 索引字段的长度</p></li><li><p>ref— 列与索引的比较</p></li><li><p>rows — 大概估算的行数</p></li><li><p>filtered — 按表条件过滤的行百分比</p></li><li><p>Extra — 执行情况的描述和说明</p></li></ul><p>其中最重要的就是 type 字段，type 值类型如下：</p><ul><li><p>all — 扫描全表数据</p></li><li><p>index — 遍历索引</p></li><li><p>range — 索引范围查找</p></li><li><p>index_subquery — 在子查询中使用 ref</p></li><li><p>uniquesubquery — 在子查询中使用 eqref</p></li><li><p>refornull — 对 null 进行索引的优化的 ref</p></li><li><p>fulltext — 使用全文索引</p></li><li><p>ref — 使用非唯一索引查找数据</p></li><li><p>eq_ref — 在 join 查询中使用主键或唯一索引关联</p></li><li><p>const — 将一个主键放置到 where 后面作为条件查询， MySQL 优化器就能把这次查询优化转化为一个常量，如何转化以及何时转化，这个取决于优化器，这个比 eq_ref 效率高一点</p></li></ul><h5 id="MySQL-的优化手段都有哪些？"><a href="#MySQL-的优化手段都有哪些？" class="headerlink" title="MySQL 的优化手段都有哪些？"></a>MySQL 的优化手段都有哪些？</h5><p>MySQL 的常见的优化手段有以下五种：</p><p>① 查询优化</p><ul><li><p>避免 SELECT *，只查询需要的字段。</p></li><li><p>小表驱动大表，即小的数据集驱动大的数据集，比如，当 B 表的数据集小于 A 表时，用 in 优化 exist，两表执行顺序是先查 B 表，再查 A 表，查询语句：select * from A where id in (select id from B) 。</p></li><li><p>一些情况下，可以使用连接代替子查询，因为使用 join 时，MySQL 不会在内存中创建临时表。</p></li></ul><p>② 优化索引的使用</p><ul><li><p>尽量使用主键查询，而非其他索引，因为主键查询不会触发回表查询。</p></li><li><p>不做列运算，把计算都放入各个业务系统实现</p></li><li><p>查询语句尽可能简单，大语句拆小语句，减少锁时间</p></li><li><p>不使用 select * 查询</p></li><li><p>or 查询改写成 in 查询</p></li><li><p>不用函数和触发器</p></li><li><p>避免 %xx 查询</p></li><li><p>少用 join 查询</p></li><li><p>使用同类型比较，比如 ‘123’ 和 ‘123’、123 和 123</p></li><li><p>尽量避免在 where 子句中使用 != 或者 &lt;&gt; 操作符，查询引用会放弃索引而进行全表扫描</p></li><li><p>列表数据使用分页查询，每页数据量不要太大</p></li><li><p>用 exists 替代 in 查询</p></li><li><p>避免在索引列上使用 is null 和 is not null</p></li><li><p>尽量使用主键查询</p></li><li><p>避免在 where 子句中对字段进行表达式操作</p></li><li><p>尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型</p></li></ul><p>③ 表结构设计优化</p><ul><li><p>使用可以存下数据最小的数据类型。</p></li><li><p>使用简单的数据类型，int 要比 varchar 类型在 MySQL 处理简单。</p></li><li><p>尽量使用 tinyint、smallint、mediumint 作为整数类型而非 int。</p></li><li><p>尽可能使用 not null 定义字段，因为 null 占用 4 字节空间。</p></li><li><p>尽量少用 text 类型，非用不可时最好考虑分表。</p></li><li><p>尽量使用 timestamp，而非 datetime。</p></li><li><p>单表不要有太多字段，建议在 20 个字段以内。</p></li></ul><p>④ 表拆分</p><p>当数据库中的数据非常大时，查询优化方案也不能解决查询速度慢的问题时，我们可以考虑拆分表，让每张表的数据量变小，从而提高查询效率。 </p><p>a）垂直拆分：是指数据表列的拆分，把一张列比较多的表拆分为多张表，比如，用户表中一些字段经常被访问，将这些字段放在一张表中，另外一些不常用的字段放在另一张表中，插入数据时，使用事务确保两张表的数据一致性。 垂直拆分的原则：</p><ul><li><p>把不常用的字段单独放在一张表；</p></li><li><p>把 text，blob 等大字段拆分出来放在附表中；</p></li><li><p>经常组合查询的列放在一张表中。</p></li></ul><p>b）水平拆分：指数据表行的拆分，表的行数超过200万行时，就会变慢，这时可以把一张的表的数据拆成多张表来存放。</p><p>通常情况下，我们使用取模的方式来进行表的拆分，比如，一张有 400W 的用户表 users，为提高其查询效率我们把其分成 4 张表 users1，users2，users3，users4，然后通过用户 ID 取模的方法，同时查询、更新、删除也是通过取模的方法来操作。</p><p>⑤ 读写分离</p><p>一般情况下对数据库而言都是“读多写少”，换言之，数据库的压力多数是因为大量的读取数据的操作造成的，我们可以采用数据库集群的方案，使用一个库作为主库，负责写入数据；其他库为从库，负责读取数据。这样可以缓解对数据库的访问压力。</p><h5 id="MySQL-常见读写分离方案有哪些？"><a href="#MySQL-常见读写分离方案有哪些？" class="headerlink" title="MySQL 常见读写分离方案有哪些？"></a>MySQL 常见读写分离方案有哪些？</h5><p>MySQL 常见的读写分离方案，如下列表：</p><p>1）应用层解决方案 可以通过应用层对数据源做路由来实现读写分离，比如，使用 SpringMVC + MyBatis，可以将 SQL 路由交给 Spring，通过 AOP 或者 Annotation 由代码显示的控制数据源。 优点：路由策略的扩展性和可控性较强。 缺点：需要在 Spring 中添加耦合控制代码。</p><p>2）中间件解决方案 通过 MySQL 的中间件做主从集群，比如：Mysql Proxy、Amoeba、Atlas 等中间件都能符合需求。 优点：与应用层解耦。 缺点：增加一个服务维护的风险点，性能及稳定性待测试，需要支持代码强制主从和事务。</p><h5 id="介绍一下-Sharding-JDBC-的功能和执行流程？"><a href="#介绍一下-Sharding-JDBC-的功能和执行流程？" class="headerlink" title="介绍一下 Sharding-JDBC 的功能和执行流程？"></a>介绍一下 Sharding-JDBC 的功能和执行流程？</h5><p>Sharding-JDBC 在客户端对数据库进行水平分区的常用解决方案，也就是保持表结构不变，根据策略存储数据分片，这样每一片数据被分散到不同的表或者库中，</p><p>Sharding-JDBC 提供以下功能：</p><ul><li><p>分库分表</p></li><li><p>读写分离</p></li><li><p>分布式主键生成</p></li></ul><p>Sharding-JDBC 的执行流程：当业务代码调用数据库执行的时候，先触发 Sharding-JDBC 的分配规则对 SQL 语句进行解析、改写之后，才会对改写的 SQL 进行执</p><p>行和结果归并，然后返回给调用层。</p><h5 id="什么是-MySQL-多实例？如何配置-MySQL-多实例？"><a href="#什么是-MySQL-多实例？如何配置-MySQL-多实例？" class="headerlink" title="什么是 MySQL 多实例？如何配置 MySQL 多实例？"></a>什么是 MySQL 多实例？如何配置 MySQL 多实例？</h5><p>MySQL 多实例就是在同一台服务器上启用多个 MySQL 服务，它们监听不同的端口，运行多个服务进程，它们相互独立，互不影响的对外提供服务，便于节约服务器</p><p>资源与后期架构扩展。 多实例的配置方法有两种：</p><ul><li><p>一个实例一个配置文件，不同端口；</p></li><li><p>同一配置文件(my.cnf)下配置不同实例，基于 MySQL 的 d_multi 工具。</p></li></ul><h5 id="怎样保证确保备库无延迟？"><a href="#怎样保证确保备库无延迟？" class="headerlink" title="怎样保证确保备库无延迟？"></a>怎样保证确保备库无延迟？</h5><p>通常保证主备无延迟有以下三种方法：</p><ul><li><p>每次从库执行查询请求前，先判断 secondsbehindmaster 是否已经等于 0。如果还不等于 0 ，那就必须等到这个参数变为 0 才能执行查询请求，secondsbehindmaster 参数是用来衡量主备延迟时间的长短；</p></li><li><p>对比位点确保主备无延迟。MasterLogFile 和 ReadMasterLogPos，表示的是读到的主库的最新位点，RelayMasterLogFile 和 ExecMasterLog_Pos，表示的是备库执行的最新位点；</p></li><li><p>对比 GTID 集合确保主备无延迟。AutoPosition=1 ，表示这对主备关系使用了 GTID 协议；RetrievedGtidSet，是备库收到的所有日志的 GTID 集合；ExecutedGtid_Set，是备库所有已经执行完成的 GTID 集合。</p></li></ul><h4 id="MySQL-常见的开放性问题"><a href="#MySQL-常见的开放性问题" class="headerlink" title="MySQL 常见的开放性问题"></a>MySQL 常见的开放性问题</h4><h5 id="有一个超级大表，如何优化分页查询？"><a href="#有一个超级大表，如何优化分页查询？" class="headerlink" title="有一个超级大表，如何优化分页查询？"></a>有一个超级大表，如何优化分页查询？</h5><p>超级大表的分页优化分有以下两种方式：</p><ul><li><p>数据库层面优化：利用子查询优化超多分页场景，比如：SELECT a.* FROM 表 1 a, (select id from 表 1 where 条件 LIMIT 100000,20 ) b where a.id=b.id ，先快速定位需要获取的 id 段，然后再关联查询。MySQL 并不是跳过 offset 行，而是取 offset+N 行，然后返回放弃前 offset 行，返回 N 行，那当 offset 特别大的时候，效率就非常的低下，要么控制返回的总页数，要么对超过特定阈值的页数进行 SQL 改写，利用子查询先快速定位需要获取的 id 段，然后再关联查询，就是对分页进行 SQL 改写的具体实现；</p></li><li><p>程序层面优化：可以利用缓存把查询的结果缓存起来，这样再下一次查询的时候性能就非常高了。</p></li></ul><h5 id="线上修改表结构有哪些风险？"><a href="#线上修改表结构有哪些风险？" class="headerlink" title="线上修改表结构有哪些风险？"></a>线上修改表结构有哪些风险？</h5><p>线上修改表结构有可能 MySQL 服务器阻塞，因为在执行 DML（select、update、delete、insert）操作时，会给表增加一个元数据锁，这个元数据锁是为了保证在查询期间表结构不会被修改，而执行修改表结构时，必须要等待元数据锁完成之后才能执行，这就可能造成数据库服务器的阻塞。</p><p>在 MySQL 5.6 开始提供了 online ddl 功能，允许一些 DDL（create table/view/index/syn/cluster）语句和 DML 语句并发，在 5.7 版本对 online ddl 又有了增强，这使得大部分 DDL 操作可以在线进行，详见：<a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-create-index-overview.html%EF%BC%8C%E8%BF%99%E4%BD%BF%E5%BE%97%E5%9C%A8%E7%BA%BF%E4%B8%8A%E4%BF%AE%E6%94%B9%E8%A1%A8%E7%BB%93%E6%9E%84%E7%9A%84%E9%A3%8E%E9%99%A9%E5%8F%98%E7%9A%84%E6%9B%B4%E5%A4%A7%EF%BC%8C%E5%A6%82%E6%9E%9C%E5%9C%A8%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%BF%85%E9%A1%BB%E5%9C%A8%E7%BA%BF%E4%BF%AE%E6%94%B9%E8%A1%A8%E7%BB%93%E6%9E%84%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%8F%82%E8%80%83%E4%BB%A5%E4%B8%8B%E6%96%B9%E6%A1%88%EF%BC%9A">https://dev.mysql.com/doc/refman/5.7/en/innodb-create-index-overview.html，这使得在线上修改表结构的风险变的更大，如果在业务开发过程中必须在线修改表结构，可以参考以下方案：</a></p><ul><li><p>尽量在业务量小的时间段进行；</p></li><li><p>查看官方文档，确认要做的表修改可以和 DML 并发，不会阻塞线上业务；</p></li><li><p>推荐使用 percona 公司的 pt-online-schema-change 工具，该工具被官方的 online ddl 更为强大，它的基本原理是：通过 insert…select… 语句进行一次全量拷贝，通过触发器记录表结构变更过程中产生的增量，从而达到表结构变更的目的。比如，要对 A 表进行变更，它的主要流程为：</p></li></ul><p>1）创建目的表结构的空表 A_new；</p><p>2）在A表上创建触发器，包括增、删、改触发器；</p><p>3）通过 insert…select…limit N 语句分片拷贝数据到目的表；</p><p>4）Copy完成后，将 A_new 表 rename 到 A 表。</p><h5 id="查询长时间不返回可能是什么原因？应该如何处理？"><a href="#查询长时间不返回可能是什么原因？应该如何处理？" class="headerlink" title="查询长时间不返回可能是什么原因？应该如何处理？"></a>查询长时间不返回可能是什么原因？应该如何处理？</h5><p>查询速度慢的原因很多，常见如下几种：</p><p> 1）查询字段没有索引或者没有触发索引查询，没有触发索引查询的情况如下： 不会使用索引的情况如下：</p><ul><li><p>以 % 开头的 like 查询不会使用 b-tree 索引；</p></li><li><p>数据类型出现隐式转换时不会使用索引，比如，某列是 varchar 类型，却使用了columnname=1 的查询语句，这是不会使用索引，正确触发索引的查询语句为：columnname=’1’ ；</p></li><li><p>不符合最左前缀原则；</p></li><li><p>如果查询条件有 or 分割，or 前面的使用索引，or 后面的未使用索引，则不会使用索引，因为即使 or 之前的使用了索引，但是 or 之后的也需要全表查询，索引就忽略索引，直接全表查询；</p></li><li><p>如果 MySQL 认为使用索引会比全表查询更慢，则不会使用索引。</p></li></ul><p>2）I/O 压力大，读取磁盘速度变慢。 </p><p>3）内存不足 </p><p>4）网络速度慢 </p><p>5）查询出的数据量过大，可以采用多次查询或其他的方法降低数据量 </p><p>6）死锁，一般碰到这种情况的话，大概率是表被锁住了，可以使用 show processlist; 命令，看看 SQL 语句的状态，再针对不同的状态做相应的处理。</p><p> <img src="/images/mysql/deadlock.png"></p><p>其中，当 State 列值为 Locked 时，表示被锁定。 其它关于查看死锁的命令：</p><p> a）查看当前的事务：</p><p><code>select * from informationschema.innodbtrx;</code></p><p>b）查看当前锁定的事务：</p><p><code>select * from informationschema.innodblocks;</code></p><p>c）查看当前等锁的事务</p><p><code>select * from informationschema.innodblock_waits;</code></p><p>以上问题的解决方案如下：</p><p>1）正确创建和使用索引。 </p><p>2）把数据、日志、索引放到不同的 IO 设备上，减少主数据库的 IO 操作。更换 MySQL 的磁盘为固态硬盘，以提高磁盘的 IO 性能。 </p><p>3）升级内存，更换更大的内存。</p><p>4）提升网速，升级带宽。 </p><p>5）用 Profiler 来跟踪查询，得到查询所需的时间，找出有问题的 SQL 语句，优化 SQL。 </p><p>6）查询时值返回需要的字段。 </p><p>7）设置死锁的超时时间，限制和避免死锁消耗过多服务器的资源。 </p><p>8）尽量少用视图，它的效率低，对视图操作比直接对表操作慢,可以用存储过程来代替视图。不要用视图嵌套，嵌套视图增加了寻找原始数据的难度。</p><h5 id="什么是-MySQL-主从？主从同步有什么好处？"><a href="#什么是-MySQL-主从？主从同步有什么好处？" class="headerlink" title="什么是 MySQL 主从？主从同步有什么好处？"></a>什么是 MySQL 主从？主从同步有什么好处？</h5><p>MySQL 主从同步：MySQL 有多个服务器去，一个服务器作为主服务器，其它服务器作为从服务器，通过配置我们可以将主服务器的所有数据或者部分数据复制到从服务器上。复制的过程是异步进行的。</p><p>主从同步的好处：（读写分离，数据备份，负载均衡）我们可以设置主服务器写入数据，读取数据使用从服务器。保证数据库负载均衡。数据随时都在进行同步备份，保证了数据的安全性。</p><h5 id="MySQL-主从延迟的原因有哪些？"><a href="#MySQL-主从延迟的原因有哪些？" class="headerlink" title="MySQL 主从延迟的原因有哪些？"></a>MySQL 主从延迟的原因有哪些？</h5><p>主从延迟可以根据 MySQL 提供的命令判断，比如，在从服务器使用命令： show slave status;，其中 SecondsBehindMaster 如果为 0 表示主从复制状态正常。 导致</p><p>主从延迟的原因有以下几个：</p><ul><li><p>主库有大事务处理；</p></li><li><p>主库做大量的增、删、改操作；</p></li><li><p>主库对大表进行字段新增、修改或添加索引等操作；</p></li><li><p>主库的从库太多，导致复制延迟。从库数量一般 3-5 个为宜，要复制的节点过多，导致复制延迟；</p></li><li><p>从库硬件配置比主库差，导致延迟。查看 Master 和 Slave 的配置，可能因为从库的配置过低，执行时间长，由此导致的复制延迟时间长；</p></li><li><p>主库读写压力大，导致复制延迟；</p></li><li><p>从库之间的网络延迟。主从库网卡、网线、连接的交换机等网络设备都可能成为复制的瓶颈，导致复制延迟，另外跨公网主从复制很容易导致主从复制延迟。</p></li></ul><h5 id="MySQL-主从与-MongoDB-副本集有什么区别？"><a href="#MySQL-主从与-MongoDB-副本集有什么区别？" class="headerlink" title="MySQL 主从与 MongoDB 副本集有什么区别？"></a>MySQL 主从与 MongoDB 副本集有什么区别？</h5><ul><li><p>MongoDB 是在同一个服务器（一台机器），同时复制备份多个数据库</p></li><li><p>MySQL 复制备份数据是在多个服务器（多台机器），复制备份多个数据库</p></li><li><p>MongoDB 复制备份是同步的，MySQL 复制备份可以是异步的，也可以主从同步</p></li><li><p>MongoDB 读写在指定的某一个数据库作为主数据库</p></li><li><p>MySQL 一般主服务器写，从服务器读，读写分离</p></li></ul><h5 id="如何保证数据不被误删？"><a href="#如何保证数据不被误删？" class="headerlink" title="如何保证数据不被误删？"></a>如何保证数据不被误删？</h5><p>保证数据不被误删的方法如下列表：</p><ul><li><p>权限控制与分配（数据库和服务器权限）</p></li><li><p>避免数据库账号信息泄露，在生产环境中，业务代码不要使用明文保存数据库连接信息；</p></li><li><p>重要的数据库操作，通过平台型工具自动实施，减少人工操作；</p></li><li><p>部署延迟复制从库，万一误删除时用于数据回档，且从库设置为 read-only；</p></li><li><p>确认备份制度及时有效；</p></li><li><p>启用 SQL 审计功能，养成良好 SQL 习惯；</p></li><li><p>启用 sqlsafeupdates 选项，不允许没 where 条件的更新/删除；</p></li><li><p>将系统层的 rm 改为 mv；</p></li><li><p>线上不进行物理删除，改为逻辑删除（将 row data 标记为不可用）；</p></li><li><p>启用堡垒机，屏蔽高危 SQL；</p></li><li><p>降低数据库中普通账号的权限级别；</p></li><li><p>开启 binlog，方便追溯数据。</p></li></ul><h5 id="MySQL-服务器-CPU-飙升应该如何处理？"><a href="#MySQL-服务器-CPU-飙升应该如何处理？" class="headerlink" title="MySQL 服务器 CPU 飙升应该如何处理？"></a>MySQL 服务器 CPU 飙升应该如何处理？</h5><p>使用 show full processlist; 查出慢查询，为了缓解数据库服务器压力，先使用 kill 命令杀掉慢查询的客户端，效果如下：</p><p> <img src="/images/mysql/fullprocesslist.png"></p><p>然后再去项目中找到执行慢的 SQL 语句进行修改和优化。</p><h5 id="MySQL-毫无规律的异常重启，可能产生的原因是什么？该如何解决？"><a href="#MySQL-毫无规律的异常重启，可能产生的原因是什么？该如何解决？" class="headerlink" title="MySQL 毫无规律的异常重启，可能产生的原因是什么？该如何解决？"></a>MySQL 毫无规律的异常重启，可能产生的原因是什么？该如何解决？</h5><p>可能是积累的长连接导致内存占用太多，被系统强行杀掉导致的异常重启，因为在 MySQL 中长连接在执行过程中使用的临时内存对象，只有在连接断开的时候才会</p><p>释放，这就会导致内存不断飙升，解决方案如下：</p><ul><li><p>定期断开空闲的长连接；</p></li><li><p>如果是用的是 MySQL 5.7 以上的版本，可以定期执行 <code>mysqlresetconnection</code> 重新初始化连接资源，这个过程会释放之前使用的内存资源，恢复到连接刚初始化的状态。</p></li></ul><h5 id="如何实现一个高并发的系统？"><a href="#如何实现一个高并发的系统？" class="headerlink" title="如何实现一个高并发的系统？"></a>如何实现一个高并发的系统？</h5><p>这道面试题涉及的知识点比较多，主要考察的是面试者的综合技术能力。高并发系统的设计手段有很多，主要体现在以下五个方面。</p><p>1）前端优化</p><p>① 静态资源缓存：将活动页面上的所有可以静态的元素全部静态化，尽量减少动态元素；通过 CDN、浏览器缓存，来减少客户端向服务器端的数据请求。</p><p>② 禁止重复提交：用户提交之后按钮置灰，禁止重复提交。</p><p>③ 用户限流：在某一时间段内只允许用户提交一次请求，比如，采取 IP 限流。</p><p>2）中间层负载分发</p><p>可利用负载均衡，比如 nginx 等工具，可以将并发请求分配到不同的服务器，从而提高了系统处理并发的能力。 nginx 负载分发的五种方式：</p><p>① 轮询（默认） 每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器不能正常响应，nginx 能自动剔除故障服务器。 </p><p>② 按权重（weight） 使用 weight 参数，指定轮询几率，weight 和访问比率成正比，用于后端服务器性能不均的情况，配置如下：</p><p><code>upstream backend &#123;   server 192.168.0.14 weight=10;   server 192.168.0.15 weight=10; &#125;</code></p><p>③ IP 哈希值（ip_hash） 每个请求按访问 IP 的哈希值分配，这样每个访客固定访问一个后端服务器，可以解决 session 共享的问题，配置如下：</p><p><code>upstream backend &#123;   ip_hash;   server 192.168.0.14:88;   server 192.168.0.15:80; &#125;</code></p><p>④ 响应时间（fair） 按后端服务器的响应时间来分配请求，响应时间短的优先分配，配置如下：</p><p><code>upstream backend &#123;   fair;   server server1.com;   server server2.com; &#125;</code></p><p>⑤ URL 哈希值（url_hash） 按访问 url 的 hash 结果来分配请求，和 IP 哈希值类似。</p><p><code>upstream backend &#123;   hash $request_uri;   server server1.com;   server server2.com;  &#125;</code></p><p>3）控制层（网关层）</p><p>限制同一个用户的访问频率，限制访问次数，防止多次恶意请求。</p><p>4）服务层</p><p>① 业务服务器分离：比如，将秒杀业务系统和其他业务分离，单独放在高配服务器上，可以集中资源对访问请求抗压。</p><p>② 采用 MQ（消息队列）缓存请求：MQ 具有削峰填谷的作用，可以把客户端的请求先导流到 MQ，程序在从 MQ 中进行消费（执行请求），这样可以避免短时间内大量请求，导致服务器程序无法响应的问题。 </p><p>③ 利用缓存应对读请求，比如，使用 Redis 等缓存，利用 Redis 可以分担数据库很大一部分压力。</p><p>5）数据库层</p><p>① 合理使用数据库引擎 </p><p>② 合理设置事务隔离级别，合理使用事务 </p><p>③ 正确使用 SQL 语句和查询索引 </p><p>④ 合理分库分表 </p><p>⑤ 使用数据库中间件实现数据库读写分离 </p><p>⑥ 设置数据库主从读写分离</p>]]></content>
    
    
    <categories>
      
      <category>Datebase</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Datebase</tag>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【LeetCode】图结构相关</title>
    <link href="/2021/03/12/lt-graph/"/>
    <url>/2021/03/12/lt-graph/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Go</tag>
      
      <tag>Java</tag>
      
      <tag>LeetCode</tag>
      
      <tag>scala</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【LeetCode】排序算法</title>
    <link href="/2021/03/10/lt-sort/"/>
    <url>/2021/03/10/lt-sort/</url>
    
    <content type="html"><![CDATA[<h3 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a><a id="more"></a>排序算法</h3><h4 id="快速排序（Quick-Sort）及优化"><a href="#快速排序（Quick-Sort）及优化" class="headerlink" title="快速排序（Quick-Sort）及优化"></a><strong>快速排序（Quick-Sort）及优化</strong></h4><h4 id="归并排序（Merge-Sort）：从二路到多路"><a href="#归并排序（Merge-Sort）：从二路到多路" class="headerlink" title="归并排序（Merge-Sort）：从二路到多路"></a>归并排序（Merge-Sort）：从二路到多路</h4><h4 id="算法系列（Algorith法杂谈m）：有趣的排序思想"><a href="#算法系列（Algorith法杂谈m）：有趣的排序思想" class="headerlink" title="算法系列（Algorith法杂谈m）：有趣的排序思想"></a>算法系列（Algorith法杂谈m）：有趣的排序思想</h4>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Go</tag>
      
      <tag>Java</tag>
      
      <tag>LeetCode</tag>
      
      <tag>scala</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【LeetCode】树结构相关</title>
    <link href="/2021/03/08/lt-tree/"/>
    <url>/2021/03/08/lt-tree/</url>
    
    <content type="html"><![CDATA[<h3 id="数结构相关与递归"><a href="#数结构相关与递归" class="headerlink" title=" 数结构相关与递归"></a><a id="more"></a> 数结构相关与递归</h3><h4 id="二叉树（Binary-Tree）与经典问题"><a href="#二叉树（Binary-Tree）与经典问题" class="headerlink" title="二叉树（Binary-Tree）与经典问题"></a><strong>二叉树（Binary-Tree）与经典问题</strong></h4><h5 id="二叉树的基本操作"><a href="#二叉树的基本操作" class="headerlink" title="二叉树的基本操作"></a>二叉树的基本操作</h5><h6 id="144-二叉树的前序遍历"><a href="#144-二叉树的前序遍历" class="headerlink" title="144. 二叉树的前序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/">144. 二叉树的前序遍历</a></h6><p>给你二叉树的根节点 <code>root</code> ，返回它节点值的 <strong>前序</strong> 遍历。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg"></p><pre><code class="hljs angelscript">输入：root = [<span class="hljs-number">1</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]输出：[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]</code></pre><p><strong>示例 2：</strong></p><pre><code class="hljs inform7">输入：root = <span class="hljs-comment">[]</span>输出：<span class="hljs-comment">[]</span></code></pre><p><strong>示例 3：</strong></p><pre><code class="hljs angelscript">输入：root = [<span class="hljs-number">1</span>]输出：[<span class="hljs-number">1</span>]</code></pre><p><strong>示例 4：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/09/15/inorder_5.jpg"></p><pre><code class="hljs angelscript">输入：root = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]输出：[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]</code></pre><p><strong>示例 5：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/09/15/inorder_4.jpg"></p><pre><code class="hljs angelscript">输入：root = [<span class="hljs-number">1</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">2</span>]输出：[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]</code></pre><p><strong>提示：</strong></p><ul><li>树中节点数目在范围 <code>[0, 100]</code> 内</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul><pre><code class="hljs Java"><span class="hljs-keyword">package</span> com.weitrue.leetcode.editor.cn;<span class="hljs-keyword">import</span> java.util.ArrayList;<span class="hljs-keyword">import</span> java.util.List;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BinaryTreePreorderTraversal</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;        Solution s = <span class="hljs-keyword">new</span> BinaryTreePreorderTraversal().<span class="hljs-function">new <span class="hljs-title">Solution</span><span class="hljs-params">()</span></span>;    &#125;        <span class="hljs-comment">// Given the root of a binary tree, return the preorder traversal of its nodes&#x27; values.</span>    <span class="hljs-comment">//</span>    <span class="hljs-comment">// Example 1:</span>    <span class="hljs-comment">// Input: root = [1,null,2,3]</span>    <span class="hljs-comment">// Output: [1,2,3]</span>    <span class="hljs-comment">//</span>    <span class="hljs-comment">// Example 2:</span>    <span class="hljs-comment">// Input: root = []</span>    <span class="hljs-comment">// Output: []</span>    <span class="hljs-comment">//</span>    <span class="hljs-comment">// Example 3:</span>    <span class="hljs-comment">// Input: root = [1]</span>    <span class="hljs-comment">// Output: [1]</span>    <span class="hljs-comment">//</span>    <span class="hljs-comment">// Example 4:</span>    <span class="hljs-comment">// Input: root = [1,2]</span>    <span class="hljs-comment">// Output: [1,2]</span>    <span class="hljs-comment">//</span>    <span class="hljs-comment">// Example 5:</span>    <span class="hljs-comment">// Input: root = [1,null,2]</span>    <span class="hljs-comment">// Output: [1,2]</span>    <span class="hljs-comment">//</span>    <span class="hljs-comment">// Constraints:</span>    <span class="hljs-comment">// The number of nodes in the tree is in the range [0, 100].</span>    <span class="hljs-comment">// -100 &lt;= Node.val &lt;= 100</span>    <span class="hljs-comment">//</span>    <span class="hljs-comment">// Follow up: Recursive solution is trivial, could you do it iteratively?</span>    <span class="hljs-comment">// Related Topics 栈 树</span>    <span class="hljs-comment">// 👍 549 👎 0</span>     <span class="hljs-comment">//leetcode submit region begin(Prohibit modification and deletion)</span>    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Definition for a binary tree node.</span><span class="hljs-comment">     */</span>      <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode</span> </span>&#123;          <span class="hljs-keyword">int</span> val;          TreeNode left;          TreeNode right;          TreeNode() &#123;&#125;          TreeNode(<span class="hljs-keyword">int</span> val) &#123; <span class="hljs-keyword">this</span>.val = val; &#125;          TreeNode(<span class="hljs-keyword">int</span> val, TreeNode left, TreeNode right) &#123;              <span class="hljs-keyword">this</span>.val = val;              <span class="hljs-keyword">this</span>.left = left;              <span class="hljs-keyword">this</span>.right = right;          &#125;     &#125;    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;          List&lt;Integer&gt; ret = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();          <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;              preOrder(root);              <span class="hljs-keyword">return</span> ret;          &#125;          <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">preOrder</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;              <span class="hljs-keyword">if</span> (root != <span class="hljs-keyword">null</span>) &#123;                  ret.add(root.val);                  preOrder(root.left);                  preOrder(root.right);              &#125;          &#125;    &#125;<span class="hljs-comment">//leetcode submit region end(Prohibit modification and deletion)</span>&#125;</code></pre><pre><code class="hljs Go"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * type TreeNode struct &#123;</span><span class="hljs-comment"> *     Val int</span><span class="hljs-comment"> *     Left *TreeNode</span><span class="hljs-comment"> *     Right *TreeNode</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span> <span class="hljs-keyword">var</span> ret []<span class="hljs-keyword">int</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(root *TreeNode)</span> []<span class="hljs-title">int</span></span> &#123;    ret = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">0</span>)    preOrder(root)    <span class="hljs-keyword">return</span> ret&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">preOrder</span><span class="hljs-params">(root *TreeNode)</span></span> &#123;    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;        <span class="hljs-keyword">return</span>    &#125;    ret = <span class="hljs-built_in">append</span>(ret, root.Val)    preOrder(root.Left)    preOrder(root.Right)&#125;</code></pre><pre><code class="hljs Python"><span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">Module Description: 144-二叉树的前序遍历</span><span class="hljs-string">Solution：</span><span class="hljs-string">Author: Wang P</span><span class="hljs-string">Problem:# 给你二叉树的根节点 root ，返回它节点值的 前序 遍历。 </span><span class="hljs-string">        #  示例 1：</span><span class="hljs-string">        # 输入：root = [1,null,2,3]</span><span class="hljs-string">        # 输出：[1,2,3]</span><span class="hljs-string">        #  示例 2：</span><span class="hljs-string">        # 输入：root = []</span><span class="hljs-string">        # 输出：[]</span><span class="hljs-string">        #  示例 3：</span><span class="hljs-string">        # 输入：root = [1]</span><span class="hljs-string">        # 输出：[1]</span><span class="hljs-string">        #  示例 4：</span><span class="hljs-string">        # 输入：root = [1,2]</span><span class="hljs-string">        # 输出：[1,2]</span><span class="hljs-string">        #  示例 5：</span><span class="hljs-string">        # 输入：root = [1,null,2]</span><span class="hljs-string">        # 输出：[1,2]</span><span class="hljs-string">        #</span><span class="hljs-string">        #  提示：</span><span class="hljs-string">        #  树中节点数目在范围 [0, 100] 内</span><span class="hljs-string">        #  -100 &lt;= Node.val &lt;= 100</span><span class="hljs-string">        #</span><span class="hljs-string">        #  进阶：递归算法很简单，你可以通过迭代算法完成吗？</span><span class="hljs-string">        #  Related Topics 栈 树</span><span class="hljs-string">        #  👍 549 👎 0</span><span class="hljs-string"></span><span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-comment"># leetcode submit region begin(Prohibit modification and deletion)</span><span class="hljs-comment"># Definition for a binary tree node.</span><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> List<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, val=<span class="hljs-number">0</span>, left=<span class="hljs-literal">None</span>, right=<span class="hljs-literal">None</span></span>):</span>        self.val = val        self.left = left        self.right = right<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span>        self.ret = []    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">preorderTraversal</span>(<span class="hljs-params">self, root: TreeNode</span>) -&gt; List[int]:</span>        self.pre_order(root)        <span class="hljs-keyword">return</span> self.ret    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pre_order</span>(<span class="hljs-params">self, root: TreeNode</span>):</span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:            <span class="hljs-keyword">return</span>        self.ret.append(root.val)        self.pre_order(root.left)        self.pre_order(root.right)</code></pre><h6 id="589-N-叉树的前序遍历"><a href="#589-N-叉树的前序遍历" class="headerlink" title="589. N 叉树的前序遍历"></a><a href="https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal/">589. N 叉树的前序遍历</a></h6><p>给定一个 N 叉树，返回其节点值的 <strong>前序遍历</strong> 。</p><p>N 叉树 在输入中按层序遍历进行序列化表示，每组子节点由空值 <code>null</code> 分隔（请参见示例）。</p><p><strong>进阶：</strong></p><p>递归法很简单，你可以使用迭代法完成此题吗?</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2018/10/12/narytreeexample.png"></p><pre><code class="hljs shell">输入：root = [1,null,3,2,4,null,5,6]输出：[1,3,5,6,2,4]</code></pre><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2019/11/08/sample_4_964.png"></p><pre><code class="hljs angelscript">输入：root = [<span class="hljs-number">1</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">8</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">11</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">12</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">13</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">14</span>]输出：[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">11</span>,<span class="hljs-number">14</span>,<span class="hljs-number">4</span>,<span class="hljs-number">8</span>,<span class="hljs-number">12</span>,<span class="hljs-number">5</span>,<span class="hljs-number">9</span>,<span class="hljs-number">13</span>,<span class="hljs-number">10</span>]</code></pre><p><strong>提示：</strong></p><ul><li>N 叉树的高度小于或等于 <code>1000</code></li><li>节点总数在范围 <code>[0, 10^4]</code> 内</li></ul><pre><code class="hljs Java"><span class="hljs-keyword">package</span> com.weitrue.leetcode.editor.cn;<span class="hljs-keyword">import</span> java.util.ArrayList;<span class="hljs-keyword">import</span> java.util.List;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NAryTreePreorderTraversal</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;        Solution s = <span class="hljs-keyword">new</span> NAryTreePreorderTraversal().<span class="hljs-function">new <span class="hljs-title">Solution</span><span class="hljs-params">()</span></span>;    &#125;        <span class="hljs-comment">// Given the root of an n-ary tree, return the preorder traversal of its nodes&#x27; values.</span>    <span class="hljs-comment">// Nary-Tree input serialization is represented in their level order traversal.</span>    <span class="hljs-comment">//Each group of children is separated by the null value (See examples)</span>    <span class="hljs-comment">// Example 1:</span>    <span class="hljs-comment">//Input: root = [1,null,3,2,4,null,5,6]</span>    <span class="hljs-comment">//Output: [1,3,5,6,2,4]</span>    <span class="hljs-comment">// Example 2:</span>    <span class="hljs-comment">//Input: root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null</span>    <span class="hljs-comment">//,12,null,13,null,null,14]</span>    <span class="hljs-comment">//Output: [1,2,3,6,7,11,14,4,8,12,5,9,13,10]</span>    <span class="hljs-comment">//</span>    <span class="hljs-comment">// Constraints:</span>    <span class="hljs-comment">// The number of nodes in the tree is in the range [0, 104].</span>    <span class="hljs-comment">// 0 &lt;= Node.val &lt;= 104</span>    <span class="hljs-comment">// The height of the n-ary tree is less than or equal to 1000.</span>    <span class="hljs-comment">//</span>    <span class="hljs-comment">// Follow up: Recursive solution is trivial, could you do it iteratively?</span>    <span class="hljs-comment">// Related Topics 树</span>    <span class="hljs-comment">// 👍 152 👎 0</span>     <span class="hljs-comment">//leetcode submit region begin(Prohibit modification and deletion)</span>    <span class="hljs-comment">// Definition for a Node.</span>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;        <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> val;        <span class="hljs-keyword">public</span> List&lt;Node&gt; children;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">()</span> </span>&#123;&#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(<span class="hljs-keyword">int</span> _val)</span> </span>&#123;            val = _val;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(<span class="hljs-keyword">int</span> _val, List&lt;Node&gt; _children)</span> </span>&#123;            val = _val;            children = _children;        &#125;    &#125;    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;        List&lt;Integer&gt; ret = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">preorder</span><span class="hljs-params">(Node root)</span> </span>&#123;            preOrder(root);            <span class="hljs-keyword">return</span> ret;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">preOrder</span><span class="hljs-params">(Node root)</span> </span>&#123;            <span class="hljs-keyword">if</span> (root != <span class="hljs-keyword">null</span>) &#123;                ret.add(root.val);                <span class="hljs-keyword">for</span> (Node n: root.children) &#123;                    preOrder(n);                &#125;            &#125;        &#125;    &#125;    <span class="hljs-comment">//leetcode submit region end(Prohibit modification and deletion)</span>&#125;</code></pre><pre><code class="hljs Go"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a Node.</span><span class="hljs-comment"> * type Node struct &#123;</span><span class="hljs-comment"> *     Val int</span><span class="hljs-comment"> *     Children []*Node</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> ret []<span class="hljs-keyword">int</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">preorder</span><span class="hljs-params">(root *Node)</span> []<span class="hljs-title">int</span></span> &#123;    ret = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">0</span>)    preOrder(root)    <span class="hljs-keyword">return</span> ret&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">preOrder</span><span class="hljs-params">(root *Node)</span></span> &#123;    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;        <span class="hljs-keyword">return</span>    &#125;    ret = <span class="hljs-built_in">append</span>(ret, root.Val)    <span class="hljs-keyword">for</span> _, c := <span class="hljs-keyword">range</span> root.Children &#123;        preOrder(c)    &#125;&#125;</code></pre><pre><code class="hljs Python"><span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">Module Description: 589-N 叉树的前序遍历</span><span class="hljs-string">Solution：</span><span class="hljs-string">Author: Wang P</span><span class="hljs-string">Problem:# 给定一个 N 叉树，返回其节点值的 前序遍历 。 </span><span class="hljs-string">        #  N 叉树 在输入中按层序遍历进行序列化表示，每组子节点由空值 null 分隔（请参见示例）。</span><span class="hljs-string">        #  进阶：</span><span class="hljs-string">        #  递归法很简单，你可以使用迭代法完成此题吗?</span><span class="hljs-string">        #  示例 1：</span><span class="hljs-string">        # 输入：root = [1,null,3,2,4,null,5,6]</span><span class="hljs-string">        # 输出：[1,3,5,6,2,4]</span><span class="hljs-string">        # 示例 2：</span><span class="hljs-string">        # 输入：root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,</span><span class="hljs-string">        # null,13,null,null,14]</span><span class="hljs-string">        # 输出：[1,2,3,6,7,11,14,4,8,12,5,9,13,10]</span><span class="hljs-string">        #  提示：</span><span class="hljs-string">        #  N 叉树的高度小于或等于 1000</span><span class="hljs-string">        #  节点总数在范围 [0, 10^4] 内</span><span class="hljs-string">        #  Related Topics 树</span><span class="hljs-string">        #  👍 152 👎 0</span><span class="hljs-string"></span><span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-comment"># leetcode submit region begin(Prohibit modification and deletion)</span><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> List<span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string"># Definition for a Node.</span><span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, val=<span class="hljs-literal">None</span>, children=<span class="hljs-literal">None</span></span>):</span>        self.val = val        self.children = children<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span>        self.ret = []    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">preorder</span>(<span class="hljs-params">self, root: <span class="hljs-string">&#x27;Node&#x27;</span></span>) -&gt; List[int]:</span>        self.pre_order(root)        <span class="hljs-keyword">return</span> self.ret    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pre_order</span>(<span class="hljs-params">self, root: <span class="hljs-string">&#x27;Node&#x27;</span></span>):</span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:            <span class="hljs-keyword">return</span>        self.ret.append(root.val)        <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> root.children:            self.pre_order(c)        <span class="hljs-comment"># leetcode submit region end(Prohibit modification and deletion)</span></code></pre><h6 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226. 翻转二叉树"></a><a href="https://leetcode-cn.com/problems/invert-binary-tree/">226. 翻转二叉树</a></h6><p>翻转一棵二叉树。</p><p><strong>示例：</strong></p><p>输入：</p><pre><code class="hljs angelscript">     <span class="hljs-number">4</span>   /   \  <span class="hljs-number">2</span>     <span class="hljs-number">7</span> / \   / \<span class="hljs-number">1</span>   <span class="hljs-number">3</span> <span class="hljs-number">6</span>   <span class="hljs-number">9</span></code></pre><p>输出：</p><pre><code class="hljs angelscript">     <span class="hljs-number">4</span>   /   \  <span class="hljs-number">7</span>     <span class="hljs-number">2</span> / \   / \<span class="hljs-number">9</span>   <span class="hljs-number">6</span> <span class="hljs-number">3</span>   <span class="hljs-number">1</span></code></pre><p><strong>备注:</strong><br>这个问题是受到 <a href="https://twitter.com/mxcl">Max Howell </a>的 <a href="https://twitter.com/mxcl/status/608682016205344768">原问题</a> 启发的 ：</p><blockquote><p>谷歌：我们90％的工程师使用您编写的软件(Homebrew)，但是您却无法在面试时在白板上写出翻转二叉树这道题，这太糟糕了。</p></blockquote><pre><code class="hljs Java"><span class="hljs-keyword">package</span> com.weitrue.leetcode.editor.cn;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InvertBinaryTree</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;        Solution s = <span class="hljs-keyword">new</span> InvertBinaryTree().<span class="hljs-function">new <span class="hljs-title">Solution</span><span class="hljs-params">()</span></span>;    &#125;        <span class="hljs-comment">// Given the root of a binary tree, invert the tree, and return its root.</span>    <span class="hljs-comment">// Example 1:</span>    <span class="hljs-comment">//Input: root = [4,2,7,1,3,6,9]</span>    <span class="hljs-comment">//Output: [4,7,2,9,6,3,1]</span>    <span class="hljs-comment">// Example 2:</span>    <span class="hljs-comment">//Input: root = [2,1,3]</span>    <span class="hljs-comment">//Output: [2,3,1]</span>    <span class="hljs-comment">// Example 3:</span>    <span class="hljs-comment">//Input: root = []</span>    <span class="hljs-comment">//Output: []</span>    <span class="hljs-comment">//</span>    <span class="hljs-comment">// Constraints:</span>    <span class="hljs-comment">// The number of nodes in the tree is in the range [0, 100].</span>    <span class="hljs-comment">// -100 &lt;= Node.val &lt;= 100</span>    <span class="hljs-comment">//</span>    <span class="hljs-comment">// Related Topics 树</span>    <span class="hljs-comment">// 👍 807 👎 0</span>     <span class="hljs-comment">//leetcode submit region begin(Prohibit modification and deletion)</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> */</span>    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode</span> </span>&#123;         <span class="hljs-keyword">int</span> val;         TreeNode left;         TreeNode right;         TreeNode() &#123;&#125;         TreeNode(<span class="hljs-keyword">int</span> val) &#123; <span class="hljs-keyword">this</span>.val = val; &#125;         TreeNode(<span class="hljs-keyword">int</span> val, TreeNode left, TreeNode right) &#123;             <span class="hljs-keyword">this</span>.val = val;             <span class="hljs-keyword">this</span>.left = left;             <span class="hljs-keyword">this</span>.right = right;         &#125;     &#125;    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;        <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">invertTree</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;            <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;            &#125;            invertTree(root.left);            invertTree(root.right);            TreeNode temp = root.left;            root.left = root.right;            root.right = temp;            <span class="hljs-keyword">return</span> root;        &#125;    &#125;<span class="hljs-comment">//leetcode submit region end(Prohibit modification and deletion)</span>&#125;</code></pre><pre><code class="hljs Go"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * type TreeNode struct &#123;</span><span class="hljs-comment"> *     Val int</span><span class="hljs-comment"> *     Left *TreeNode</span><span class="hljs-comment"> *     Right *TreeNode</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">invertTree</span><span class="hljs-params">(root *TreeNode)</span> *<span class="hljs-title">TreeNode</span></span> &#123;    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>    &#125;    invertTree(root.Left)    invertTree(root.Right)    root.Left, root.Right = root.Right, root.Left     <span class="hljs-keyword">return</span> root&#125;</code></pre><pre><code class="hljs Python"><span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">Module Description: 226-翻转二叉树</span><span class="hljs-string">Solution：</span><span class="hljs-string">Author: Wang P</span><span class="hljs-string">Problem:# 翻转一棵二叉树。 </span><span class="hljs-string">        #  示例：</span><span class="hljs-string">        #  输入：</span><span class="hljs-string">        #       4</span><span class="hljs-string">        #    /   \</span><span class="hljs-string">        #   2     7</span><span class="hljs-string">        #  / \   / \</span><span class="hljs-string">        # 1   3 6   9</span><span class="hljs-string">        #  输出：</span><span class="hljs-string">        #       4</span><span class="hljs-string">        #    /   \</span><span class="hljs-string">        #   7     2</span><span class="hljs-string">        #  / \   / \</span><span class="hljs-string">        # 9   6 3   1</span><span class="hljs-string">        #  备注:</span><span class="hljs-string">        # 这个问题是受到 Max Howell 的 原问题 启发的 ：</span><span class="hljs-string">        #</span><span class="hljs-string">        #  谷歌：我们90％的工程师使用您编写的软件(Homebrew)，但是您却无法在面试时在白板上写出翻转二叉树这道题，这太糟糕了。</span><span class="hljs-string">        #  Related Topics 树</span><span class="hljs-string">        #  👍 807 👎 0</span><span class="hljs-string"></span><span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-comment"># leetcode submit region begin(Prohibit modification and deletion)</span><span class="hljs-comment"># Definition for a binary tree node.</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, val=<span class="hljs-number">0</span>, left=<span class="hljs-literal">None</span>, right=<span class="hljs-literal">None</span></span>):</span>        self.val = val        self.left = left        self.right = right<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">invertTree</span>(<span class="hljs-params">self, root: TreeNode</span>) -&gt; TreeNode:</span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>        self.invertTree(root.left)        self.invertTree(root.right)        root.left, root.right = root.right, root.left        <span class="hljs-keyword">return</span> root<span class="hljs-comment"># leetcode submit region end(Prohibit modification and deletion)</span></code></pre><h6 id="剑指-Offer-32-II-从上到下打印二叉树-II"><a href="#剑指-Offer-32-II-从上到下打印二叉树-II" class="headerlink" title="剑指 Offer 32 - II. 从上到下打印二叉树 II"></a><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/">剑指 Offer 32 - II. 从上到下打印二叉树 II</a></h6><p>从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。</p><p>例如:<br>给定二叉树: <code>[3,9,20,null,null,15,7]</code>,</p><pre><code class="hljs angelscript">  <span class="hljs-number">3</span> / \<span class="hljs-number">9</span>  <span class="hljs-number">20</span>  /  \ <span class="hljs-number">15</span>   <span class="hljs-number">7</span></code></pre><p>返回其层次遍历结果：</p><pre><code class="hljs json">[  [<span class="hljs-number">3</span>],  [<span class="hljs-number">9</span>,<span class="hljs-number">20</span>],  [<span class="hljs-number">15</span>,<span class="hljs-number">7</span>]]</code></pre><p><strong>提示：</strong></p><ol><li><code>节点总数 &lt;= 1000</code></li></ol><pre><code class="hljs Java"><span class="hljs-keyword">package</span> com.weitrue.leetcode.editor.cn;<span class="hljs-keyword">import</span> java.util.ArrayList;<span class="hljs-keyword">import</span> java.util.List;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CongShangDaoXiaDaYinErChaShuIiLcof</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;        Solution s = <span class="hljs-keyword">new</span> CongShangDaoXiaDaYinErChaShuIiLcof().<span class="hljs-function">new <span class="hljs-title">Solution</span><span class="hljs-params">()</span></span>;    &#125;        <span class="hljs-comment">//English description is not available for the problem. Please switch to Chinese</span>    <span class="hljs-comment">//. Related Topics 树 广度优先搜索</span>    <span class="hljs-comment">// 👍 95 👎 0</span>     <span class="hljs-comment">//leetcode submit region begin(Prohibit modification and deletion)</span>    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Definition for a binary tree node.</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode</span> </span>&#123;         <span class="hljs-keyword">int</span> val;         TreeNode left;         TreeNode right;         TreeNode(<span class="hljs-keyword">int</span> x) &#123; val = x; &#125;    &#125;    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;        List&lt;List&lt;Integer&gt;&gt; liiRet = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;            signKLevel(root, <span class="hljs-number">0</span>);            <span class="hljs-keyword">return</span> liiRet;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">signKLevel</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> k)</span> </span>&#123;            <span class="hljs-keyword">if</span> (root != <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-keyword">if</span> (liiRet.size() == k) &#123;                    liiRet.add(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;());                &#125;                liiRet.get(k).add(root.val);                signKLevel(root.left, k+<span class="hljs-number">1</span>);                signKLevel(root.right, k+<span class="hljs-number">1</span>);            &#125;        &#125;    &#125;    <span class="hljs-comment">//leetcode submit region end(Prohibit modification and deletion)</span>&#125;</code></pre><pre><code class="hljs Go"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * type TreeNode struct &#123;</span><span class="hljs-comment"> *     Val int</span><span class="hljs-comment"> *     Left *TreeNode</span><span class="hljs-comment"> *     Right *TreeNode</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> ret [][]<span class="hljs-keyword">int</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">levelOrder</span><span class="hljs-params">(root *TreeNode)</span> [][]<span class="hljs-title">int</span></span> &#123;    <span class="hljs-comment">// write code here</span>    ret = <span class="hljs-built_in">make</span>([][]<span class="hljs-keyword">int</span>, <span class="hljs-number">0</span>)    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;        <span class="hljs-keyword">return</span> ret    &#125;    ret = <span class="hljs-built_in">append</span>(ret, []<span class="hljs-keyword">int</span>&#123;&#125;)    travelTree(root, <span class="hljs-number">0</span>)    <span class="hljs-keyword">return</span> ret&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">travelTree</span><span class="hljs-params">(root *TreeNode, k <span class="hljs-keyword">int</span>)</span></span> &#123;    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;        <span class="hljs-keyword">return</span>     &#125;    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(ret) == k &#123;        ret = <span class="hljs-built_in">append</span>(ret, []<span class="hljs-keyword">int</span>&#123;&#125;)    &#125;    ret[k] = <span class="hljs-built_in">append</span>(ret[k], root.Val)    travelTree(root.Left, k+<span class="hljs-number">1</span>)    travelTree(root.Right, k+<span class="hljs-number">1</span>)&#125;</code></pre><pre><code class="hljs Python"><span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">Module Description: 剑指 Offer 32 - II-从上到下打印二叉树 II</span><span class="hljs-string">Solution：</span><span class="hljs-string">Date: 2021-04-03 12:10:11</span><span class="hljs-string">Author: Wang P</span><span class="hljs-string">Problem:# 从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。 </span><span class="hljs-string">        #  例如:</span><span class="hljs-string">        # 给定二叉树: [3,9,20,null,null,15,7],</span><span class="hljs-string">        #      3</span><span class="hljs-string">        #    / \</span><span class="hljs-string">        #   9  20</span><span class="hljs-string">        #     /  \</span><span class="hljs-string">        #    15   7</span><span class="hljs-string">        #  返回其层次遍历结果：</span><span class="hljs-string">        #  [</span><span class="hljs-string">        #   [3],</span><span class="hljs-string">        #   [9,20],</span><span class="hljs-string">        #   [15,7]</span><span class="hljs-string">        # ]</span><span class="hljs-string">        #  提示：</span><span class="hljs-string">        #  节点总数 &lt;= 1000</span><span class="hljs-string">        #  注意：本题与主站 102 题相同：https://leetcode-cn.com/problems/binary-tree-level-order-traversal/</span><span class="hljs-string">        #  Related Topics 树 广度优先搜索</span><span class="hljs-string">        #  👍 95 👎 0</span><span class="hljs-string"></span><span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-comment"># leetcode submit region begin(Prohibit modification and deletion)</span><span class="hljs-comment"># Definition for a binary tree node.</span><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> List<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, x</span>):</span>        self.val = x        self.left = <span class="hljs-literal">None</span>        self.right = <span class="hljs-literal">None</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span>        self.lii_ret = []    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">levelOrder</span>(<span class="hljs-params">self, root: TreeNode</span>) -&gt; List[List[int]]:</span>        self.sign_k_level(root, <span class="hljs-number">0</span>)        <span class="hljs-keyword">return</span> self.lii_ret    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sign_k_level</span>(<span class="hljs-params">self, root: TreeNode, k: <span class="hljs-built_in">int</span></span>):</span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:            <span class="hljs-keyword">return</span>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(self.lii_ret) == k:            self.lii_ret.append([])        self.lii_ret[k].append(root.val)        self.sign_k_level(root.left, k+<span class="hljs-number">1</span>)        self.sign_k_level(root.right, k+<span class="hljs-number">1</span>)<span class="hljs-comment"># leetcode submit region end(Prohibit modification and deletion)</span></code></pre><h6 id="107-二叉树的层序遍历-II"><a href="#107-二叉树的层序遍历-II" class="headerlink" title="107. 二叉树的层序遍历 II"></a><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/">107. 二叉树的层序遍历 II</a></h6><p>给定一个二叉树，返回其节点值自底向上的层序遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）</p><p>例如：<br>给定二叉树 <code>[3,9,20,null,null,15,7]</code>,</p><pre><code class="hljs angelscript">  <span class="hljs-number">3</span> / \<span class="hljs-number">9</span>  <span class="hljs-number">20</span>  /  \ <span class="hljs-number">15</span>   <span class="hljs-number">7</span></code></pre><p>返回其自底向上的层序遍历为：</p><pre><code class="hljs json">[  [<span class="hljs-number">15</span>,<span class="hljs-number">7</span>],  [<span class="hljs-number">9</span>,<span class="hljs-number">20</span>],  [<span class="hljs-number">3</span>]]</code></pre><pre><code class="hljs Java"><span class="hljs-keyword">package</span> com.weitrue.leetcode.editor.cn;<span class="hljs-keyword">import</span> java.util.ArrayList;<span class="hljs-keyword">import</span> java.util.List;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BinaryTreeLevelOrderTraversalIi</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;        Solution s = <span class="hljs-keyword">new</span> BinaryTreeLevelOrderTraversalIi().<span class="hljs-function">new <span class="hljs-title">Solution</span><span class="hljs-params">()</span></span>;    &#125;        <span class="hljs-comment">//Given the root of a binary tree, return the bottom-up level order traversal of its nodes&#x27; values. (i.e., from left to right, level by level from leaf to root).</span>    <span class="hljs-comment">// Example 1:</span>    <span class="hljs-comment">//Input: root = [3,9,20,null,null,15,7]</span>    <span class="hljs-comment">//Output: [[15,7],[9,20],[3]]</span>    <span class="hljs-comment">// Example 2:</span>    <span class="hljs-comment">//Input: root = [1]</span>    <span class="hljs-comment">//Output: [[1]]</span>    <span class="hljs-comment">// Example 3:</span>    <span class="hljs-comment">//Input: root = []</span>    <span class="hljs-comment">//Output: []</span>    <span class="hljs-comment">//</span>    <span class="hljs-comment">// Constraints:</span>    <span class="hljs-comment">// The number of nodes in the tree is in the range [0, 2000].</span>    <span class="hljs-comment">// -1000 &lt;= Node.val &lt;= 1000</span>    <span class="hljs-comment">//</span>    <span class="hljs-comment">// Related Topics 树 广度优先搜索</span>    <span class="hljs-comment">// 👍 423 👎 0</span>     <span class="hljs-comment">//leetcode submit region begin(Prohibit modification and deletion)</span>    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Definition for a binary tree node.</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode</span> </span>&#123;        <span class="hljs-keyword">int</span> val;        TreeNode left;        TreeNode right;        TreeNode() &#123;&#125;        TreeNode(<span class="hljs-keyword">int</span> val) &#123; <span class="hljs-keyword">this</span>.val = val; &#125;        TreeNode(<span class="hljs-keyword">int</span> val, TreeNode left, TreeNode right) &#123;            <span class="hljs-keyword">this</span>.val = val;            <span class="hljs-keyword">this</span>.left = left;            <span class="hljs-keyword">this</span>.right = right;        &#125;    &#125;    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;        List&lt;List&lt;Integer&gt;&gt; liiRet = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) &#123;            signKLevel(root, <span class="hljs-number">0</span>);            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j=liiRet.size()-<span class="hljs-number">1</span>; i &lt; j; i++, j--) &#123;                List&lt;Integer&gt; tmp = liiRet.get(i);                liiRet.set(i, liiRet.get(j));                liiRet.set(j, tmp);            &#125;            <span class="hljs-keyword">return</span> liiRet;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">signKLevel</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> k)</span> </span>&#123;            <span class="hljs-keyword">if</span> (root != <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-keyword">if</span> (liiRet.size() == k) &#123;                    liiRet.add(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;());                &#125;                liiRet.get(k).add(root.val);                signKLevel(root.left, k+<span class="hljs-number">1</span>);                signKLevel(root.right, k+<span class="hljs-number">1</span>);            &#125;        &#125;    &#125;    <span class="hljs-comment">//leetcode submit region end(Prohibit modification and deletion)</span>&#125;</code></pre><pre><code class="hljs Go"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * type TreeNode struct &#123;</span><span class="hljs-comment"> *     Val int</span><span class="hljs-comment"> *     Left *TreeNode</span><span class="hljs-comment"> *     Right *TreeNode</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span> <span class="hljs-keyword">var</span> ret [][]<span class="hljs-keyword">int</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">levelOrderBottom</span><span class="hljs-params">(root *TreeNode)</span> [][]<span class="hljs-title">int</span></span> &#123;    ret = <span class="hljs-built_in">make</span>([][]<span class="hljs-keyword">int</span>, <span class="hljs-number">0</span>)    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;        <span class="hljs-keyword">return</span> ret    &#125;    travelTree(root, <span class="hljs-number">0</span>)    <span class="hljs-keyword">for</span> i, j := <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(ret) - <span class="hljs-number">1</span>; i &lt; j; i,j = i+<span class="hljs-number">1</span>, j<span class="hljs-number">-1</span> &#123;        ret[i], ret[j] = ret[j], ret[i]    &#125;    <span class="hljs-keyword">return</span> ret&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">travelTree</span><span class="hljs-params">(root *TreeNode, k <span class="hljs-keyword">int</span>)</span></span> &#123;    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;        <span class="hljs-keyword">return</span>     &#125;    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(ret) == k &#123;        ret = <span class="hljs-built_in">append</span>(ret, []<span class="hljs-keyword">int</span>&#123;&#125;)    &#125;    ret[k] = <span class="hljs-built_in">append</span>(ret[k], root.Val)    travelTree(root.Left, k+<span class="hljs-number">1</span>)    travelTree(root.Right, k+<span class="hljs-number">1</span>)&#125;</code></pre><pre><code class="hljs Python"><span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">Module Description: 107-二叉树的层序遍历 II</span><span class="hljs-string">Solution：</span><span class="hljs-string">Date: 2021-04-03 12:32:50</span><span class="hljs-string">Author: Wang P</span><span class="hljs-string">Problem:# 给定一个二叉树，返回其节点值自底向上的层序遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历） </span><span class="hljs-string">        #  例如：</span><span class="hljs-string">        # 给定二叉树 [3,9,20,null,null,15,7],</span><span class="hljs-string">        #     3</span><span class="hljs-string">        #    / \</span><span class="hljs-string">        #   9  20</span><span class="hljs-string">        #     /  \</span><span class="hljs-string">        #    15   7</span><span class="hljs-string">        #  返回其自底向上的层序遍历为：</span><span class="hljs-string">        # [</span><span class="hljs-string">        #   [15,7],</span><span class="hljs-string">        #   [9,20],</span><span class="hljs-string">        #   [3]</span><span class="hljs-string">        # ]</span><span class="hljs-string">        #</span><span class="hljs-string">        #  Related Topics 树 广度优先搜索</span><span class="hljs-string">        #  👍 423 👎 0</span><span class="hljs-string"></span><span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-comment"># leetcode submit region begin(Prohibit modification and deletion)</span><span class="hljs-comment"># Definition for a binary tree node.</span><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> List<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, val=<span class="hljs-number">0</span>, left=<span class="hljs-literal">None</span>, right=<span class="hljs-literal">None</span></span>):</span>        self.val = val        self.left = left        self.right = right<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span>        self.lii_ret = []    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sign_k_level</span>(<span class="hljs-params">self, root: TreeNode, k: <span class="hljs-built_in">int</span></span>):</span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:            <span class="hljs-keyword">return</span>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(self.lii_ret) == k:            self.lii_ret.append([])        self.lii_ret[k].append(root.val)        self.sign_k_level(root.left, k + <span class="hljs-number">1</span>)        self.sign_k_level(root.right, k + <span class="hljs-number">1</span>)    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">levelOrderBottom</span>(<span class="hljs-params">self, root: TreeNode</span>) -&gt; List[List[int]]:</span>        self.sign_k_level(root, <span class="hljs-number">0</span>)        self.lii_ret.reverse()        <span class="hljs-keyword">return</span> self.lii_ret<span class="hljs-comment"># leetcode submit region end(Prohibit modification and deletion)</span></code></pre><h6 id="103-二叉树的锯齿形层序遍历"><a href="#103-二叉树的锯齿形层序遍历" class="headerlink" title="103. 二叉树的锯齿形层序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/">103. 二叉树的锯齿形层序遍历</a></h6><p>给定一个二叉树，返回其节点值的锯齿形层序遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</p><p>例如：<br>给定二叉树 <code>[3,9,20,null,null,15,7]</code>,</p><pre><code class="hljs angelscript">  <span class="hljs-number">3</span> / \<span class="hljs-number">9</span>  <span class="hljs-number">20</span>  /  \ <span class="hljs-number">15</span>   <span class="hljs-number">7</span></code></pre><p>返回锯齿形层序遍历如下：</p><pre><code class="hljs json">[  [<span class="hljs-number">3</span>],  [<span class="hljs-number">20</span>,<span class="hljs-number">9</span>],  [<span class="hljs-number">15</span>,<span class="hljs-number">7</span>]]</code></pre><pre><code class="hljs Java"><span class="hljs-keyword">package</span> com.weitrue.leetcode.editor.cn;<span class="hljs-keyword">import</span> java.util.ArrayList;<span class="hljs-keyword">import</span> java.util.List;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BinaryTreeZigzagLevelOrderTraversal</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;        Solution s = <span class="hljs-keyword">new</span> BinaryTreeZigzagLevelOrderTraversal().<span class="hljs-function">new <span class="hljs-title">Solution</span><span class="hljs-params">()</span></span>;    &#125;        <span class="hljs-comment">//Given the root of a binary tree, return the zigzag level order traversal of its nodes&#x27; values. (i.e., from left to right, then right to left for the next level and alternate between).</span>    <span class="hljs-comment">// Example 1:</span>    <span class="hljs-comment">//Input: root = [3,9,20,null,null,15,7]</span>    <span class="hljs-comment">//Output: [[3],[20,9],[15,7]]</span>    <span class="hljs-comment">// Example 2:</span>    <span class="hljs-comment">//Input: root = [1]</span>    <span class="hljs-comment">//Output: [[1]]</span>    <span class="hljs-comment">// Example 3:</span>    <span class="hljs-comment">//Input: root = []</span>    <span class="hljs-comment">//Output: []</span>    <span class="hljs-comment">//</span>    <span class="hljs-comment">// Constraints:</span>    <span class="hljs-comment">// The number of nodes in the tree is in the range [0, 2000].</span>    <span class="hljs-comment">// -100 &lt;= Node.val &lt;= 100</span>    <span class="hljs-comment">//</span>    <span class="hljs-comment">// Related Topics 栈 树 广度优先搜索</span>    <span class="hljs-comment">// 👍 424 👎 0</span>     <span class="hljs-comment">//leetcode submit region begin(Prohibit modification and deletion)</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode</span> </span>&#123;     <span class="hljs-keyword">int</span> val;     TreeNode left;     TreeNode right;     TreeNode() &#123;&#125;     TreeNode(<span class="hljs-keyword">int</span> val) &#123; <span class="hljs-keyword">this</span>.val = val; &#125;     TreeNode(<span class="hljs-keyword">int</span> val, TreeNode left, TreeNode right) &#123;         <span class="hljs-keyword">this</span>.val = val;         <span class="hljs-keyword">this</span>.left = left;         <span class="hljs-keyword">this</span>.right = right;     &#125; &#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    List&lt;List&lt;Integer&gt;&gt; liiRet = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) &#123;        signKLevel(root, <span class="hljs-number">0</span>);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; liiRet.size(); k++) &#123;            <span class="hljs-keyword">if</span> (k%<span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j=liiRet.get(k).size()-<span class="hljs-number">1</span>; i &lt; j; i++, j--) &#123;                    <span class="hljs-keyword">int</span> tmp = liiRet.get(k).get(i);                    liiRet.get(k).set(i, liiRet.get(k).get(j));                    liiRet.get(k).set(j, tmp);                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> liiRet;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">signKLevel</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> k)</span> </span>&#123;        <span class="hljs-keyword">if</span> (root != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">if</span> (liiRet.size() == k) &#123;                liiRet.add(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;());            &#125;            liiRet.get(k).add(root.val);            signKLevel(root.left, k+<span class="hljs-number">1</span>);            signKLevel(root.right, k+<span class="hljs-number">1</span>);        &#125;    &#125;&#125;<span class="hljs-comment">//leetcode submit region end(Prohibit modification and deletion)</span>&#125;</code></pre><pre><code class="hljs Go"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * type TreeNode struct &#123;</span><span class="hljs-comment"> *     Val int</span><span class="hljs-comment"> *     Left *TreeNode</span><span class="hljs-comment"> *     Right *TreeNode</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> ret [][]<span class="hljs-keyword">int</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">zigzagLevelOrder</span><span class="hljs-params">(root *TreeNode)</span> [][]<span class="hljs-title">int</span></span> &#123;    <span class="hljs-comment">// write code here</span>    ret = <span class="hljs-built_in">make</span>([][]<span class="hljs-keyword">int</span>, <span class="hljs-number">0</span>)    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;        <span class="hljs-keyword">return</span> ret    &#125;    ret = <span class="hljs-built_in">append</span>(ret, []<span class="hljs-keyword">int</span>&#123;&#125;)    travelTree(root, <span class="hljs-number">0</span>)    <span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> ret &#123;        <span class="hljs-keyword">if</span> i% <span class="hljs-number">2</span> == <span class="hljs-number">1</span> &#123;            <span class="hljs-keyword">for</span> j, k := <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(v)<span class="hljs-number">-1</span>; j&lt;k; j, k = j+<span class="hljs-number">1</span>, k<span class="hljs-number">-1</span> &#123;                v[j], v[k] = v[k], v[j]            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> ret&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">travelTree</span><span class="hljs-params">(root *TreeNode, k <span class="hljs-keyword">int</span>)</span></span> &#123;    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;        <span class="hljs-keyword">return</span>     &#125;    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(ret) == k &#123;        ret = <span class="hljs-built_in">append</span>(ret, []<span class="hljs-keyword">int</span>&#123;&#125;)    &#125;    ret[k] = <span class="hljs-built_in">append</span>(ret[k], root.Val)    travelTree(root.Left, k+<span class="hljs-number">1</span>)    travelTree(root.Right, k+<span class="hljs-number">1</span>)&#125;</code></pre><pre><code class="hljs Python"><span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">Module Description: 103-二叉树的锯齿形层序遍历</span><span class="hljs-string">Solution：</span><span class="hljs-string">Author: Wang P</span><span class="hljs-string">Problem:# 给定一个二叉树，返回其节点值的锯齿形层序遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。 </span><span class="hljs-string">        #  例如：</span><span class="hljs-string">        # 给定二叉树 [3,9,20,null,null,15,7],</span><span class="hljs-string">        #     3</span><span class="hljs-string">        #    / \</span><span class="hljs-string">        #   9  20</span><span class="hljs-string">        #     /  \</span><span class="hljs-string">        #    15   7</span><span class="hljs-string">        #  返回锯齿形层序遍历如下：</span><span class="hljs-string">        # [</span><span class="hljs-string">        #   [3],</span><span class="hljs-string">        #   [20,9],</span><span class="hljs-string">        #   [15,7]</span><span class="hljs-string">        # ]</span><span class="hljs-string">        #</span><span class="hljs-string">        #  Related Topics 栈 树 广度优先搜索</span><span class="hljs-string">        #  👍 424 👎 0</span><span class="hljs-string"></span><span class="hljs-string">        &quot;&quot;&quot;</span><span class="hljs-comment"># leetcode submit region begin(Prohibit modification and deletion)</span><span class="hljs-comment"># Definition for a binary tree node.</span><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> List<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, val=<span class="hljs-number">0</span>, left=<span class="hljs-literal">None</span>, right=<span class="hljs-literal">None</span></span>):</span>        self.val = val        self.left = left        self.right = right<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span>        self.lii_ret = []    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sign_k_level</span>(<span class="hljs-params">self, root: TreeNode, k: <span class="hljs-built_in">int</span></span>):</span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:            <span class="hljs-keyword">return</span>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(self.lii_ret) == k:            self.lii_ret.append([])        self.lii_ret[k].append(root.val)        self.sign_k_level(root.left, k + <span class="hljs-number">1</span>)        self.sign_k_level(root.right, k + <span class="hljs-number">1</span>)    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">zigzagLevelOrder</span>(<span class="hljs-params">self, root: TreeNode</span>) -&gt; List[List[int]]:</span>        self.sign_k_level(root, <span class="hljs-number">0</span>)        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(self.lii_ret)):            <span class="hljs-keyword">if</span> i % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>:                self.lii_ret[i].reverse()        <span class="hljs-keyword">return</span> self.lii_ret<span class="hljs-comment"># leetcode submit region end(Prohibit modification and deletion)</span></code></pre><h5 id="二叉树的进阶操作"><a href="#二叉树的进阶操作" class="headerlink" title="二叉树的进阶操作"></a>二叉树的进阶操作</h5><h6 id="110-平衡二叉树"><a href="#110-平衡二叉树" class="headerlink" title="110. 平衡二叉树"></a><a href="https://leetcode-cn.com/problems/balanced-binary-tree/">110. 平衡二叉树</a></h6><p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p><p>本题中，一棵高度平衡二叉树定义为：</p><blockquote><p>一个二叉树<em>每个节点</em> 的左右两个子树的高度差的绝对值不超过 1 。</p></blockquote><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/06/balance_1.jpg"></p><pre><code class="hljs yaml"><span class="hljs-string">输入：root</span> <span class="hljs-string">=</span> [<span class="hljs-number">3</span>,<span class="hljs-number">9</span>,<span class="hljs-number">20</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">15</span>,<span class="hljs-number">7</span>]<span class="hljs-string">输出：true</span></code></pre><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/06/balance_2.jpg"></p><pre><code class="hljs yaml"><span class="hljs-string">输入：root</span> <span class="hljs-string">=</span> [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>]<span class="hljs-string">输出：false</span></code></pre><p><strong>示例 3：</strong></p><pre><code class="hljs nix">输入：<span class="hljs-attr">root</span> = []输出：<span class="hljs-literal">true</span></code></pre><p><strong>提示：</strong></p><ul><li>树中的节点数在范围 <code>[0, 5000]</code> 内</li><li><code>-104 &lt;= Node.val &lt;= 104</code></li></ul><pre><code class="hljs Java"><span class="hljs-keyword">package</span> com.weitrue.leetcode.editor.cn;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BalancedBinaryTree</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;        Solution s = <span class="hljs-keyword">new</span> BalancedBinaryTree().<span class="hljs-function">new <span class="hljs-title">Solution</span><span class="hljs-params">()</span></span>;    &#125;        <span class="hljs-comment">//Given a binary tree, determine if it is height-balanced.</span>    <span class="hljs-comment">// For this problem, a height-balanced binary tree is defined as:</span>    <span class="hljs-comment">// a binary tree in which the left and right subtrees of every node differ in height by no more than 1.</span>    <span class="hljs-comment">// Example 1:</span>    <span class="hljs-comment">//Input: root = [3,9,20,null,null,15,7]</span>    <span class="hljs-comment">//Output: true</span>    <span class="hljs-comment">// Example 2:</span>    <span class="hljs-comment">//Input: root = [1,2,2,3,3,null,null,4,4]</span>    <span class="hljs-comment">//Output: false</span>    <span class="hljs-comment">// Example 3:</span>    <span class="hljs-comment">//Input: root = []</span>    <span class="hljs-comment">//Output: true</span>    <span class="hljs-comment">// Constraints:</span>    <span class="hljs-comment">// The number of nodes in the tree is in the range [0, 5000].</span>    <span class="hljs-comment">// -104 &lt;= Node.val &lt;= 104</span>    <span class="hljs-comment">//</span>    <span class="hljs-comment">// Related Topics 树 深度优先搜索 递归</span>    <span class="hljs-comment">// 👍 652 👎 0</span>     <span class="hljs-comment">//leetcode submit region begin(Prohibit modification and deletion)</span>    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Definition for a binary tree node.</span><span class="hljs-comment">     *</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode</span> </span>&#123;        <span class="hljs-keyword">int</span> val;        TreeNode left;        TreeNode right;        TreeNode() &#123;&#125;        TreeNode(<span class="hljs-keyword">int</span> val) &#123; <span class="hljs-keyword">this</span>.val = val; &#125;        TreeNode(<span class="hljs-keyword">int</span> val, TreeNode left, TreeNode right) &#123;            <span class="hljs-keyword">this</span>.val = val;            <span class="hljs-keyword">this</span>.left = left;            <span class="hljs-keyword">this</span>.right = right;        &#125;    &#125;    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isBalanced</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;            <span class="hljs-keyword">return</span> getTreeHeight(root) &gt;= <span class="hljs-number">0</span>;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getTreeHeight</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;            <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;            &#125;            <span class="hljs-keyword">int</span> l = getTreeHeight(root.left);            <span class="hljs-keyword">int</span> r = getTreeHeight(root.right);            <span class="hljs-keyword">if</span> (l &lt; <span class="hljs-number">0</span> || r &lt; <span class="hljs-number">0</span> || Math.abs(l-r) &gt; <span class="hljs-number">1</span>) &#123;                <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;            &#125;            <span class="hljs-keyword">return</span> Math.max(l, r) + <span class="hljs-number">1</span>;        &#125;    &#125;    <span class="hljs-comment">//leetcode submit region end(Prohibit modification and deletion)</span>&#125;</code></pre><pre><code class="hljs Go"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * type TreeNode struct &#123;</span><span class="hljs-comment"> *     Val int</span><span class="hljs-comment"> *     Left *TreeNode</span><span class="hljs-comment"> *     Right *TreeNode</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isBalanced</span><span class="hljs-params">(root *TreeNode)</span> <span class="hljs-title">bool</span></span> &#123;<span class="hljs-keyword">return</span> treeHeight(root) &gt;= <span class="hljs-number">0</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">treeHeight</span><span class="hljs-params">(root *TreeNode)</span> <span class="hljs-title">int</span></span> &#123;<span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>&#125;l := treeHeight(root.Left)r := treeHeight(root.Right)<span class="hljs-keyword">if</span> l &lt; <span class="hljs-number">0</span> || r &lt; <span class="hljs-number">0</span> || math.Abs(<span class="hljs-keyword">float64</span>(l-r)) &gt; <span class="hljs-number">1</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-keyword">int</span>(math.Max(<span class="hljs-keyword">float64</span>(l), <span class="hljs-keyword">float64</span>(r))) + <span class="hljs-number">1</span>&#125;</code></pre><pre><code class="hljs Python"><span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">Module Description: 110-平衡二叉树</span><span class="hljs-string">Solution：</span><span class="hljs-string">Author: Wang P</span><span class="hljs-string">Problem:# 给定一个二叉树，判断它是否是高度平衡的二叉树。 </span><span class="hljs-string">        #  本题中，一棵高度平衡二叉树定义为：</span><span class="hljs-string">        #  一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 。</span><span class="hljs-string">        #  示例 1：</span><span class="hljs-string">        # 输入：root = [3,9,20,null,null,15,7]</span><span class="hljs-string">        # 输出：true</span><span class="hljs-string">        #  示例 2：</span><span class="hljs-string">        # 输入：root = [1,2,2,3,3,null,null,4,4]</span><span class="hljs-string">        # 输出：false</span><span class="hljs-string">        #  示例 3：</span><span class="hljs-string">        # 输入：root = []</span><span class="hljs-string">        # 输出：true</span><span class="hljs-string">        #</span><span class="hljs-string">        #  提示：</span><span class="hljs-string">        #  树中的节点数在范围 [0, 5000] 内</span><span class="hljs-string">        #  -104 &lt;= Node.val &lt;= 104</span><span class="hljs-string">        #</span><span class="hljs-string">        #  Related Topics 树 深度优先搜索 递归</span><span class="hljs-string">        #  👍 652 👎 0</span><span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-comment"># leetcode submit region begin(Prohibit modification and deletion)</span><span class="hljs-comment"># Definition for a binary tree node.</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, val=<span class="hljs-number">0</span>, left=<span class="hljs-literal">None</span>, right=<span class="hljs-literal">None</span></span>):</span>        self.val = val        self.left = left        self.right = right<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isBalanced</span>(<span class="hljs-params">self, root: TreeNode</span>) -&gt; bool:</span>        <span class="hljs-keyword">return</span> self.get_tree_height(root) &gt;= <span class="hljs-number">0</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_tree_height</span>(<span class="hljs-params">self, root: TreeNode</span>) -&gt; int:</span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>        l, r = self.get_tree_height(root.left), self.get_tree_height(root.right)        <span class="hljs-keyword">if</span> l &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> r &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> <span class="hljs-built_in">abs</span>(l-r) &gt; <span class="hljs-number">1</span>:            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(l, r) + <span class="hljs-number">1</span><span class="hljs-comment"># leetcode submit region end(Prohibit modification and deletion)</span></code></pre><h6 id="112-路径总和"><a href="#112-路径总和" class="headerlink" title="112. 路径总和"></a><a href="https://leetcode-cn.com/problems/path-sum/">112. 路径总和</a></h6><p>给你二叉树的根节点 root 和一个表示目标和的整数 targetSum ，判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。</p><p><strong>叶子节点</strong> 是指没有子节点的节点。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/18/pathsum1.jpg"></p><pre><code class="hljs yaml"><span class="hljs-string">输入：root</span> <span class="hljs-string">=</span> [<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">8</span>,<span class="hljs-number">11</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">13</span>,<span class="hljs-number">4</span>,<span class="hljs-number">7</span>,<span class="hljs-number">2</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">1</span>]<span class="hljs-string">,</span> <span class="hljs-string">targetSum</span> <span class="hljs-string">=</span> <span class="hljs-number">22</span><span class="hljs-string">输出：true</span></code></pre><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/18/pathsum2.jpg"></p><pre><code class="hljs angelscript">输入：root = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>], targetSum = <span class="hljs-number">5</span>输出：<span class="hljs-literal">false</span></code></pre><p><strong>示例 3</strong></p><pre><code class="hljs angelscript">输入：root = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>], targetSum = <span class="hljs-number">0</span>输出：<span class="hljs-literal">false</span></code></pre><p><strong>提示：</strong></p><ul><li>树中节点的数目在范围 [0, 5000] 内</li><li>-1000 &lt;= Node.val &lt;= 1000</li><li>-1000 &lt;= targetSum &lt;= 1000</li></ul><pre><code class="hljs Java"></code></pre><pre><code class="hljs Go"></code></pre><pre><code class="hljs Python"></code></pre><h6 id="105-从前序与中序遍历序列构造二叉树"><a href="#105-从前序与中序遍历序列构造二叉树" class="headerlink" title="105. 从前序与中序遍历序列构造二叉树"></a><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. 从前序与中序遍历序列构造二叉树</a></h6><p>根据一棵树的前序遍历与中序遍历构造二叉树。</p><p><strong>注意:</strong><br>你可以假设树中没有重复的元素。</p><p>例如，给出</p><pre><code class="hljs angelscript">前序遍历 preorder = [<span class="hljs-number">3</span>,<span class="hljs-number">9</span>,<span class="hljs-number">20</span>,<span class="hljs-number">15</span>,<span class="hljs-number">7</span>]中序遍历 inorder = [<span class="hljs-number">9</span>,<span class="hljs-number">3</span>,<span class="hljs-number">15</span>,<span class="hljs-number">20</span>,<span class="hljs-number">7</span>]</code></pre><p>返回如下的二叉树：</p><pre><code class="hljs angelscript">  <span class="hljs-number">3</span> / \<span class="hljs-number">9</span>  <span class="hljs-number">20</span>  /  \ <span class="hljs-number">15</span>   <span class="hljs-number">7</span></code></pre><pre><code class="hljs Java"></code></pre><pre><code class="hljs Go"></code></pre><pre><code class="hljs Python"></code></pre><h6 id="222-完全二叉树的节点个数"><a href="#222-完全二叉树的节点个数" class="headerlink" title="222. 完全二叉树的节点个数"></a><a href="https://leetcode-cn.com/problems/count-complete-tree-nodes/">222. 完全二叉树的节点个数</a></h6><p>给你一棵 完全二叉树 的根节点 root ，求出该树的节点个数。</p><p>完全二叉树 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2^h 个节点。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/14/complete.jpg"></p><pre><code class="hljs angelscript">输入：root = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]输出：<span class="hljs-number">6</span></code></pre><p><strong>示例 2：</strong></p><pre><code class="hljs angelscript">输入：root = []输出：<span class="hljs-number">0</span></code></pre><p><strong>示例 3：</strong></p><pre><code class="hljs angelscript">输入：root = [<span class="hljs-number">1</span>]输出：<span class="hljs-number">1</span></code></pre><p><strong>提示：</strong></p><ul><li>树中节点的数目范围是<code>[0, 5 * 104]</code></li><li><code>0 &lt;= Node.val &lt;= 5 * 104</code></li><li>题目数据保证输入的树是 <strong>完全二叉树</strong></li></ul><pre><code class="hljs Java"></code></pre><pre><code class="hljs Go"></code></pre><pre><code class="hljs Python"></code></pre><h6 id="剑指-Offer-54-二叉搜索树的第k大节点"><a href="#剑指-Offer-54-二叉搜索树的第k大节点" class="headerlink" title="剑指 Offer 54. 二叉搜索树的第k大节点"></a><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/">剑指 Offer 54. 二叉搜索树的第k大节点</a></h6><p>给定一棵二叉搜索树，请找出其中第k大的节点。</p><p><strong>示例 1:</strong></p><pre><code class="hljs yaml"><span class="hljs-string">输入:</span> <span class="hljs-string">root</span> <span class="hljs-string">=</span> [<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">2</span>]<span class="hljs-string">,</span> <span class="hljs-string">k</span> <span class="hljs-string">=</span> <span class="hljs-number">1</span>   <span class="hljs-number">3</span>  <span class="hljs-string">/</span> <span class="hljs-string">\</span> <span class="hljs-number">1</span>   <span class="hljs-number">4</span>  <span class="hljs-string">\</span>   <span class="hljs-number">2</span><span class="hljs-string">输出:</span> <span class="hljs-number">4</span></code></pre><p><strong>示例 2:</strong></p><pre><code class="hljs yaml"><span class="hljs-string">输入:</span> <span class="hljs-string">root</span> <span class="hljs-string">=</span> [<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">1</span>]<span class="hljs-string">,</span> <span class="hljs-string">k</span> <span class="hljs-string">=</span> <span class="hljs-number">3</span>       <span class="hljs-number">5</span>      <span class="hljs-string">/</span> <span class="hljs-string">\</span>     <span class="hljs-number">3</span>   <span class="hljs-number">6</span>    <span class="hljs-string">/</span> <span class="hljs-string">\</span>   <span class="hljs-number">2</span>   <span class="hljs-number">4</span>  <span class="hljs-string">/</span> <span class="hljs-number">1</span><span class="hljs-string">输出:</span> <span class="hljs-number">4</span></code></pre><p><strong>限制：</strong></p><p>1 ≤ k ≤ 二叉搜索树元素个数</p><pre><code class="hljs Java"></code></pre><pre><code class="hljs Go"></code></pre><pre><code class="hljs Python"></code></pre><h6 id="剑指-Offer-26-树的子结构"><a href="#剑指-Offer-26-树的子结构" class="headerlink" title="剑指 Offer 26. 树的子结构"></a><a href="https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/">剑指 Offer 26. 树的子结构</a></h6><p>输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)</p><p>B是A的子结构， 即 A中有出现和B相同的结构和节点值。</p><p>例如:<br>给定的树 A:</p><pre><code class="hljs angelscript">    <span class="hljs-number">3</span>   / \  <span class="hljs-number">4</span>   <span class="hljs-number">5</span> / \<span class="hljs-number">1</span>   <span class="hljs-number">2</span></code></pre><p>给定的树 B：</p><pre><code class="hljs angelscript">  <span class="hljs-number">4</span>  /<span class="hljs-number">1</span></code></pre><p>返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。</p><p><strong>示例 1：</strong></p><pre><code class="hljs angelscript">输入：A = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>], B = [<span class="hljs-number">3</span>,<span class="hljs-number">1</span>]输出：<span class="hljs-literal">false</span></code></pre><p><strong>示例 2：</strong></p><pre><code class="hljs angelscript">输入：A = [<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>], B = [<span class="hljs-number">4</span>,<span class="hljs-number">1</span>]输出：<span class="hljs-literal">true</span></code></pre><p><strong>限制：</strong></p><pre><code class="hljs basic"><span class="hljs-symbol">0 </span>&lt;= 节点个数 &lt;= <span class="hljs-number">10000</span></code></pre><pre><code class="hljs Java"></code></pre><pre><code class="hljs Go"></code></pre><pre><code class="hljs Python"></code></pre><h6 id="662-二叉树最大宽度"><a href="#662-二叉树最大宽度" class="headerlink" title="662. 二叉树最大宽度"></a><a href="https://leetcode-cn.com/problems/maximum-width-of-binary-tree/">662. 二叉树最大宽度</a></h6><p>给定一个二叉树，编写一个函数来获取这个树的最大宽度。树的宽度是所有层中的最大宽度。这个二叉树与满二叉树（full binary tree）结构相同，但一些节点为空。</p><p>每一层的宽度被定义为两个端点（该层最左和最右的非空节点，两端点间的null节点也计入长度）之间的长度。</p><p><strong>示例 1:</strong></p><pre><code class="hljs angelscript">输入:            <span class="hljs-number">1</span>         /   \        <span class="hljs-number">3</span>     <span class="hljs-number">2</span>       / \     \        <span class="hljs-number">5</span>   <span class="hljs-number">3</span>     <span class="hljs-number">9</span> 输出: <span class="hljs-number">4</span>解释: 最大值出现在树的第 <span class="hljs-number">3</span> 层，宽度为 <span class="hljs-number">4</span> (<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">9</span>)。</code></pre><p><strong>示例 2:</strong></p><pre><code class="hljs angelscript">输入:           <span class="hljs-number">1</span>         /          <span class="hljs-number">3</span>           / \             <span class="hljs-number">5</span>   <span class="hljs-number">3</span>     输出: <span class="hljs-number">2</span>解释: 最大值出现在树的第 <span class="hljs-number">3</span> 层，宽度为 <span class="hljs-number">2</span> (<span class="hljs-number">5</span>,<span class="hljs-number">3</span>)。</code></pre><p><strong>示例 3:</strong></p><pre><code class="hljs angelscript">输入:           <span class="hljs-number">1</span>         / \        <span class="hljs-number">3</span>   <span class="hljs-number">2</span>        /              <span class="hljs-number">5</span>      输出: <span class="hljs-number">2</span>解释: 最大值出现在树的第 <span class="hljs-number">2</span> 层，宽度为 <span class="hljs-number">2</span> (<span class="hljs-number">3</span>,<span class="hljs-number">2</span>)。</code></pre><p><strong>示例 4:</strong></p><pre><code class="hljs angelscript">输入:           <span class="hljs-number">1</span>         / \        <span class="hljs-number">3</span>   <span class="hljs-number">2</span>       /     \        <span class="hljs-number">5</span>       <span class="hljs-number">9</span>      /         \    <span class="hljs-number">6</span>           <span class="hljs-number">7</span>输出: <span class="hljs-number">8</span>解释: 最大值出现在树的第 <span class="hljs-number">4</span> 层，宽度为 <span class="hljs-number">8</span> (<span class="hljs-number">6</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">7</span>)。</code></pre><p><strong>注意:</strong> 答案在32位有符号整数的表示范围内。</p><pre><code class="hljs Java"></code></pre><pre><code class="hljs Go"></code></pre><pre><code class="hljs Python"></code></pre><h6 id="968-监控二叉树"><a href="#968-监控二叉树" class="headerlink" title="968. 监控二叉树"></a><a href="https://leetcode-cn.com/problems/binary-tree-cameras/">968. 监控二叉树</a></h6><p>给定一个二叉树，我们在树的节点上安装摄像头。</p><p>节点上的每个摄影头都可以监视<strong>其父对象、自身及其直接子对象。</strong></p><p>计算监控树的所有节点所需的最小摄像头数量。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/29/bst_cameras_01.png"></p><pre><code class="hljs angelscript">输入：[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]输出：<span class="hljs-number">1</span>解释：如图所示，一台摄像头足以监控所有节点。</code></pre><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/29/bst_cameras_02.png"></p><pre><code class="hljs angelscript">输入：[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">0</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">0</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">0</span>]输出：<span class="hljs-number">2</span>解释：需要至少两个摄像头来监视树的所有节点。 上图显示了摄像头放置的有效位置之一。</code></pre><p><strong>提示：</strong></p><ol><li>给定树的节点数的范围是 <code>[1, 1000]</code>。</li><li>每个节点的值都是 0。</li></ol><pre><code class="hljs Java"></code></pre><pre><code class="hljs Go"></code></pre><pre><code class="hljs Python"></code></pre><h4 id="堆（Heap）与优先队列"><a href="#堆（Heap）与优先队列" class="headerlink" title="堆（Heap）与优先队列"></a><strong>堆（Heap）与优先队列</strong></h4><blockquote><p>维护集合最值</p></blockquote><h5 id="基础应用"><a href="#基础应用" class="headerlink" title="基础应用"></a>基础应用</h5><h6 id="剑指-Offer-40-最小的k个数"><a href="#剑指-Offer-40-最小的k个数" class="headerlink" title="剑指 Offer 40. 最小的k个数"></a><a href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/">剑指 Offer 40. 最小的k个数</a></h6><p>输入整数数组 <code>arr</code> ，找出其中最小的 <code>k</code> 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。</p><p><strong>示例 1：</strong></p><pre><code class="hljs angelscript">输入：arr = [<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>], k = <span class="hljs-number">2</span>输出：[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>] 或者 [<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]</code></pre><p><strong>示例 2：</strong></p><pre><code class="hljs angelscript">输入：arr = [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>], k = <span class="hljs-number">1</span>输出：[<span class="hljs-number">0</span>]</code></pre><p><strong>限制：</strong></p><ul><li><code>0 &lt;= k &lt;= arr.length &lt;= 10000</code></li><li><code>0 &lt;= arr[i] &lt;= 10000</code></li></ul><pre><code class="hljs plain">大顶堆堆顶为k个数的最大的遍历数组，入堆 如果入堆后堆的大小大于k，出堆</code></pre><pre><code class="hljs Java"></code></pre><pre><code class="hljs Go"></code></pre><pre><code class="hljs Python"></code></pre><h6 id="1046-最后一块石头的重量"><a href="#1046-最后一块石头的重量" class="headerlink" title="1046. 最后一块石头的重量"></a><a href="https://leetcode-cn.com/problems/last-stone-weight/">1046. 最后一块石头的重量</a></h6><p>有一堆石头，每块石头的重量都是正整数。</p><p>每一回合，从中选出两块 <strong>最重的</strong> 石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x &lt;= y。那么粉碎的可能结果如下：</p><ul><li>如果 x == y，那么两块石头都会被完全粉碎；</li><li>如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。</li></ul><p>最后，最多只会剩下一块石头。返回此石头的重量。如果没有石头剩下，就返回 <code>0</code>。</p><p><strong>示例：</strong></p><pre><code class="hljs angelscript">输入：[<span class="hljs-number">2</span>,<span class="hljs-number">7</span>,<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">8</span>,<span class="hljs-number">1</span>]输出：<span class="hljs-number">1</span>解释：先选出 <span class="hljs-number">7</span> 和 <span class="hljs-number">8</span>，得到 <span class="hljs-number">1</span>，所以数组转换为 [<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]，再选出 <span class="hljs-number">2</span> 和 <span class="hljs-number">4</span>，得到 <span class="hljs-number">2</span>，所以数组转换为 [<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]，接着是 <span class="hljs-number">2</span> 和 <span class="hljs-number">1</span>，得到 <span class="hljs-number">1</span>，所以数组转换为 [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]，最后选出 <span class="hljs-number">1</span> 和 <span class="hljs-number">1</span>，得到 <span class="hljs-number">0</span>，最终数组转换为 [<span class="hljs-number">1</span>]，这就是最后剩下那块石头的重量。</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= stones.length &lt;= 30</code></li><li><code>1 &lt;= stones[i] &lt;= 1000</code></li></ul><pre><code class="hljs plain">大顶堆</code></pre><pre><code class="hljs Java"></code></pre><pre><code class="hljs Go"></code></pre><pre><code class="hljs Python"></code></pre><h6 id="703-数据流中的第-K-大元素"><a href="#703-数据流中的第-K-大元素" class="headerlink" title="703. 数据流中的第 K 大元素"></a><a href="https://leetcode-cn.com/problems/kth-largest-element-in-a-stream/">703. 数据流中的第 K 大元素</a></h6><p>设计一个找到数据流中第 <code>k</code> 大元素的类<code>（class）</code>。注意是排序后的第 <code>k</code> 大元素，不是第 <code>k</code> 个不同的元素。</p><p>请实现 <code>KthLargest</code> 类：</p><ul><li><code>KthLargest(int k, int[] nums)</code> 使用整数 k 和整数流 <code>nums </code>初始化对象。</li><li><code>int add(int val) </code>将 val 插入数据流 <code>nums </code>后，返回当前数据流中第 <code>k</code> 大的元素。</li></ul><p><strong>示例：</strong></p><pre><code class="hljs lsl">输入：[<span class="hljs-string">&quot;KthLargest&quot;</span>, <span class="hljs-string">&quot;add&quot;</span>, <span class="hljs-string">&quot;add&quot;</span>, <span class="hljs-string">&quot;add&quot;</span>, <span class="hljs-string">&quot;add&quot;</span>, <span class="hljs-string">&quot;add&quot;</span>][[<span class="hljs-number">3</span>, [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">2</span>]], [<span class="hljs-number">3</span>], [<span class="hljs-number">5</span>], [<span class="hljs-number">10</span>], [<span class="hljs-number">9</span>], [<span class="hljs-number">4</span>]]输出：[null, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">8</span>]解释：KthLargest kthLargest = new KthLargest(<span class="hljs-number">3</span>, [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">2</span>]);kthLargest.add(<span class="hljs-number">3</span>);   <span class="hljs-comment">// return 4</span>kthLargest.add(<span class="hljs-number">5</span>);   <span class="hljs-comment">// return 5</span>kthLargest.add(<span class="hljs-number">10</span>);  <span class="hljs-comment">// return 5</span>kthLargest.add(<span class="hljs-number">9</span>);   <span class="hljs-comment">// return 8</span>kthLargest.add(<span class="hljs-number">4</span>);   <span class="hljs-comment">// return 8</span></code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= k &lt;= 10^4</code></li><li><code>0 &lt;= nums.length &lt;= 10^4</code></li><li><code>-10^4 &lt;= nums[i] &lt;= 10^4</code></li><li><code>-10^4 &lt;= val &lt;= 10^4</code></li><li>最多调用 add 方法<code> 10^4</code> 次</li><li>题目数据保证，在查找第 k 大元素时，数组中至少有 k 个元素</li></ul><pre><code class="hljs plain">小顶堆堆顶为k个数的最大的</code></pre><pre><code class="hljs Java"></code></pre><pre><code class="hljs Go"></code></pre><pre><code class="hljs Python"></code></pre><h6 id="215-数组中的第K个最大元素"><a href="#215-数组中的第K个最大元素" class="headerlink" title="215. 数组中的第K个最大元素"></a><a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/">215. 数组中的第K个最大元素</a></h6><p>在未排序的数组中找到第 <strong>k</strong> 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</p><p><strong>示例 1:</strong></p><pre><code class="hljs angelscript">输入: [<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">4</span>] 和 k = <span class="hljs-number">2</span>输出: <span class="hljs-number">5</span></code></pre><p><strong>示例 2:</strong></p><pre><code class="hljs angelscript">输入: [<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>] 和 k = <span class="hljs-number">4</span>输出: <span class="hljs-number">4</span></code></pre><p><strong>说明:</strong></p><p>你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。</p><pre><code class="hljs Java"></code></pre><pre><code class="hljs Go"></code></pre><pre><code class="hljs Python"></code></pre><h5 id="373-查找和最小的K对数字"><a href="#373-查找和最小的K对数字" class="headerlink" title="373. 查找和最小的K对数字"></a><a href="https://leetcode-cn.com/problems/find-k-pairs-with-smallest-sums/">373. 查找和最小的K对数字</a></h5><p>给定两个以升序排列的整形数组 nums1 和 nums2, 以及一个整数 k。</p><p>定义一对值 (u,v)，其中第一个元素来自 nums1，第二个元素来自 nums2。</p><p>找到和最小的 k 对数字 (u1,v1), (u2,v2) … (uk,vk)。</p><p><strong>示例 1:</strong></p><pre><code class="hljs angelscript">输入: nums1 = [<span class="hljs-number">1</span>,<span class="hljs-number">7</span>,<span class="hljs-number">11</span>], nums2 = [<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>], k = <span class="hljs-number">3</span>输出: [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">6</span>]解释: 返回序列中的前 <span class="hljs-number">3</span> 对数：<span class="hljs-string">     [1,2]</span>,[<span class="hljs-number">1</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">6</span>],[<span class="hljs-number">7</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">7</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">11</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">7</span>,<span class="hljs-number">6</span>],[<span class="hljs-number">11</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">11</span>,<span class="hljs-number">6</span>]</code></pre><p><strong>示例 2:</strong></p><pre><code class="hljs angelscript">输入: nums1 = [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>], nums2 = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>], k = <span class="hljs-number">2</span>输出: [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]解释: 返回序列中的前 <span class="hljs-number">2</span> 对数：<span class="hljs-string">     [1,1]</span>,[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]</code></pre><p><strong>示例 3:</strong></p><pre><code class="hljs angelscript">输入: nums1 = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>], nums2 = [<span class="hljs-number">3</span>], k = <span class="hljs-number">3</span> 输出: [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]解释: 也可能序列中所有的数对都被返回:[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]</code></pre><pre><code class="hljs Java"></code></pre><pre><code class="hljs Go"></code></pre><pre><code class="hljs Python"></code></pre><h5 id="进阶应用"><a href="#进阶应用" class="headerlink" title="进阶应用"></a>进阶应用</h5><h6 id="692-前K个高频单词"><a href="#692-前K个高频单词" class="headerlink" title="692. 前K个高频单词"></a><a href="https://leetcode-cn.com/problems/top-k-frequent-words/">692. 前K个高频单词</a></h6><p>给一非空的单词列表，返回前 <em>k</em> 个出现次数最多的单词。</p><p>返回的答案应该按单词出现频率由高到低排序。如果不同的单词有相同出现频率，按字母顺序排序。</p><p><strong>示例 1：</strong></p><pre><code class="hljs prolog">输入: [<span class="hljs-string">&quot;i&quot;</span>, <span class="hljs-string">&quot;love&quot;</span>, <span class="hljs-string">&quot;leetcode&quot;</span>, <span class="hljs-string">&quot;i&quot;</span>, <span class="hljs-string">&quot;love&quot;</span>, <span class="hljs-string">&quot;coding&quot;</span>], k = <span class="hljs-number">2</span>输出: [<span class="hljs-string">&quot;i&quot;</span>, <span class="hljs-string">&quot;love&quot;</span>]解析: <span class="hljs-string">&quot;i&quot;</span> 和 <span class="hljs-string">&quot;love&quot;</span> 为出现次数最多的两个单词，均为<span class="hljs-number">2</span>次。    注意，按字母顺序 <span class="hljs-string">&quot;i&quot;</span> 在 <span class="hljs-string">&quot;love&quot;</span> 之前。</code></pre><p><strong>示例 2：</strong></p><pre><code class="hljs smalltalk">输入: [<span class="hljs-comment">&quot;the&quot;</span>, <span class="hljs-comment">&quot;day&quot;</span>, <span class="hljs-comment">&quot;is&quot;</span>, <span class="hljs-comment">&quot;sunny&quot;</span>, <span class="hljs-comment">&quot;the&quot;</span>, <span class="hljs-comment">&quot;the&quot;</span>, <span class="hljs-comment">&quot;the&quot;</span>, <span class="hljs-comment">&quot;sunny&quot;</span>, <span class="hljs-comment">&quot;is&quot;</span>, <span class="hljs-comment">&quot;is&quot;</span>], k = <span class="hljs-number">4</span>输出: [<span class="hljs-comment">&quot;the&quot;</span>, <span class="hljs-comment">&quot;is&quot;</span>, <span class="hljs-comment">&quot;sunny&quot;</span>, <span class="hljs-comment">&quot;day&quot;</span>]解析: <span class="hljs-comment">&quot;the&quot;</span>, <span class="hljs-comment">&quot;is&quot;</span>, <span class="hljs-comment">&quot;sunny&quot;</span> 和 <span class="hljs-comment">&quot;day&quot;</span> 是出现次数最多的四个单词，    出现次数依次为 <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span> 和 <span class="hljs-number">1</span> 次。</code></pre><p><strong>注意：</strong></p><ol><li>假定 <em>k</em> 总为有效值， 1 ≤ <em>k</em> ≤ 集合元素数。</li><li>输入的单词均由小写字母组成。</li></ol><pre><code class="hljs Java"></code></pre><pre><code class="hljs Go"></code></pre><pre><code class="hljs Python"></code></pre><h6 id="剑指-Offer-41-数据流中的中位数"><a href="#剑指-Offer-41-数据流中的中位数" class="headerlink" title="剑指 Offer 41. 数据流中的中位数"></a><a href="https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/">剑指 Offer 41. 数据流中的中位数</a></h6><p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。</p><p>例如，</p><p>[2,3,4] 的中位数是 3</p><p>[2,3] 的中位数是 (2 + 3) / 2 = 2.5</p><p>设计一个支持以下两种操作的数据结构：</p><ul><li>void addNum(int num) - 从数据流中添加一个整数到数据结构中。</li><li>double findMedian() - 返回目前所有元素的中位数。</li></ul><p><strong>示例 1：</strong></p><pre><code class="hljs prolog">输入：[<span class="hljs-string">&quot;MedianFinder&quot;</span>,<span class="hljs-string">&quot;addNum&quot;</span>,<span class="hljs-string">&quot;addNum&quot;</span>,<span class="hljs-string">&quot;findMedian&quot;</span>,<span class="hljs-string">&quot;addNum&quot;</span>,<span class="hljs-string">&quot;findMedian&quot;</span>][[],[<span class="hljs-number">1</span>],[<span class="hljs-number">2</span>],[],[<span class="hljs-number">3</span>],[]]输出：[null,null,null,<span class="hljs-number">1.50000</span>,null,<span class="hljs-number">2.00000</span>]</code></pre><p><strong>示例 2：</strong></p><pre><code class="hljs prolog">输入：[<span class="hljs-string">&quot;MedianFinder&quot;</span>,<span class="hljs-string">&quot;addNum&quot;</span>,<span class="hljs-string">&quot;findMedian&quot;</span>,<span class="hljs-string">&quot;addNum&quot;</span>,<span class="hljs-string">&quot;findMedian&quot;</span>][[],[<span class="hljs-number">2</span>],[],[<span class="hljs-number">3</span>],[]]输出：[null,null,<span class="hljs-number">2.00000</span>,null,<span class="hljs-number">2.50000</span>]</code></pre><h6 id="295-数据流的中位数"><a href="#295-数据流的中位数" class="headerlink" title="295. 数据流的中位数"></a><a href="https://leetcode-cn.com/problems/find-median-from-data-stream/">295. 数据流的中位数</a></h6><p>中位数是有序列表中间的数。如果列表长度是偶数，中位数则是中间两个数的平均值。</p><p>例如，</p><p>[2,3,4] 的中位数是 3</p><p>[2,3] 的中位数是 (2 + 3) / 2 = 2.5</p><p>设计一个支持以下两种操作的数据结构：</p><ul><li>void addNum(int num) - 从数据流中添加一个整数到数据结构中。</li><li>double findMedian() - 返回目前所有元素的中位数。</li></ul><p><strong>示例：</strong></p><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">addNum</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span><span class="hljs-function"><span class="hljs-title">addNum</span><span class="hljs-params">(<span class="hljs-number">2</span>)</span></span><span class="hljs-function"><span class="hljs-title">findMedian</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-number">1.5</span><span class="hljs-function"><span class="hljs-title">addNum</span><span class="hljs-params">(<span class="hljs-number">3</span>)</span></span> <span class="hljs-function"><span class="hljs-title">findMedian</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-number">2</span></code></pre><p>进阶:</p><ul><li>如果数据流中所有整数都在 0 到 100 范围内，你将如何优化你的算法？</li><li>如果数据流中 99% 的整数都在 0 到 100 范围内，你将如何优化你的算法？</li></ul><pre><code class="hljs plain">两个堆</code></pre><pre><code class="hljs Java"></code></pre><pre><code class="hljs Go"></code></pre><pre><code class="hljs Python"></code></pre><h6 id="355-设计推特"><a href="#355-设计推特" class="headerlink" title="355. 设计推特"></a><a href="https://leetcode-cn.com/problems/design-twitter/">355. 设计推特</a></h6><p>设计一个简化版的推特(Twitter)，可以让用户实现发送推文，关注/取消关注其他用户，能够看见关注人（包括自己）的最近十条推文。你的设计需要支持以下的几个功能</p><ul><li><code>postTweet(userId, tweetId)</code>: 创建一条新的推文</li><li><code>getNewsFeed(userId)</code>: 检索最近的十条推文。每个推文都必须是由此用户关注的人或者是用户自己发出的。推文必须按照时间顺序由最近的开始排序。</li><li><code>follow(followerId, followeeId)</code>: 关注一个用户</li><li><code>unfollow(followerId, followeeId)</code>: 取消关注一个用户</li></ul><p><strong>示例:</strong></p><pre><code class="hljs angelscript">Twitter twitter = new Twitter();<span class="hljs-comment">// 用户1发送了一条新推文 (用户id = 1, 推文id = 5).</span>twitter.postTweet(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>);<span class="hljs-comment">// 用户1的获取推文应当返回一个列表，其中包含一个id为5的推文.</span>twitter.getNewsFeed(<span class="hljs-number">1</span>);<span class="hljs-comment">// 用户1关注了用户2.</span>twitter.follow(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<span class="hljs-comment">// 用户2发送了一个新推文 (推文id = 6).</span>twitter.postTweet(<span class="hljs-number">2</span>, <span class="hljs-number">6</span>);<span class="hljs-comment">// 用户1的获取推文应当返回一个列表，其中包含两个推文，id分别为 -&gt; [6, 5].</span><span class="hljs-comment">// 推文id6应当在推文id5之前，因为它是在5之后发送的.</span>twitter.getNewsFeed(<span class="hljs-number">1</span>);<span class="hljs-comment">// 用户1取消关注了用户2.</span>twitter.unfollow(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<span class="hljs-comment">// 用户1的获取推文应当返回一个列表，其中包含一个id为5的推文.</span><span class="hljs-comment">// 因为用户1已经不再关注用户2.</span>twitter.getNewsFeed(<span class="hljs-number">1</span>);</code></pre><pre><code class="hljs Java"></code></pre><pre><code class="hljs Go"></code></pre><pre><code class="hljs Python"></code></pre><h6 id="面试题-17-20-连续中值"><a href="#面试题-17-20-连续中值" class="headerlink" title="面试题 17.20. 连续中值"></a><a href="https://leetcode-cn.com/problems/continuous-median-lcci/">面试题 17.20. 连续中值</a></h6><p>随机产生数字并传递给一个方法。你能否完成这个方法，在每次产生新值时，寻找当前所有值的中间值（中位数）并保存。</p><p>中位数是有序列表中间的数。如果列表长度是偶数，中位数则是中间两个数的平均值。</p><p>例如，</p><p>[2,3,4] 的中位数是 3</p><p>[2,3] 的中位数是 (2 + 3) / 2 = 2.5</p><p>设计一个支持以下两种操作的数据结构：</p><ul><li>void addNum(int num) - 从数据流中添加一个整数到数据结构中。</li><li>double findMedian() - 返回目前所有元素的中位数。</li></ul><p><strong>示例：</strong></p> <pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">addNum</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span><span class="hljs-function"><span class="hljs-title">addNum</span><span class="hljs-params">(<span class="hljs-number">2</span>)</span></span><span class="hljs-function"><span class="hljs-title">findMedian</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-number">1.5</span><span class="hljs-function"><span class="hljs-title">addNum</span><span class="hljs-params">(<span class="hljs-number">3</span>)</span></span> <span class="hljs-function"><span class="hljs-title">findMedian</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-number">2</span></code></pre><pre><code class="hljs Java"></code></pre><pre><code class="hljs Go"></code></pre><pre><code class="hljs Python"></code></pre><h6 id="1801-积压订单中的订单总数"><a href="#1801-积压订单中的订单总数" class="headerlink" title="1801. 积压订单中的订单总数"></a><a href="https://leetcode-cn.com/problems/number-of-orders-in-the-backlog/">1801. 积压订单中的订单总数</a></h6><p>给你一个二维整数数组 <code>orders</code> ，其中每个 <code>orders[i] = [pricei, amounti, orderTypei] </code>表示有 <code>amounti </code>笔类型为 <code>orderTypei </code>、价格为<code> pricei</code> 的订单。</p><p>订单类型 <code>orderTypei</code> 可以分为两种：</p><ul><li><code>0</code> 表示这是一批采购订单 <code>buy</code></li><li><code>1</code> 表示这是一批销售订单 <code>sell</code></li></ul><p>注意，orders[i] 表示一批共计 amounti 笔的独立订单，这些订单的价格和类型相同。对于所有有效的 i ，由 orders[i] 表示的所有订单提交时间均早于 orders[i+1] 表示的所有订单。</p><p>存在由未执行订单组成的 <strong>积压订单</strong> 。积压订单最初是空的。提交订单时，会发生以下情况：</p><ul><li>如果该订单是一笔采购订单 buy ，则可以查看积压订单中价格 最低 的销售订单 sell 。如果该销售订单 sell 的价格 低于或等于 当前采购订单 buy 的价格，则匹配并执行这两笔订单，并将销售订单 sell 从积压订单中删除。否则，采购订单 buy 将会添加到积压订单中。</li><li>反之亦然，如果该订单是一笔销售订单 sell ，则可以查看积压订单中价格 最高 的采购订单 buy 。如果该采购订单 buy 的价格 高于或等于 当前销售订单 sell 的价格，则匹配并执行这两笔订单，并将采购订单 buy 从积压订单中删除。否则，销售订单 sell 将会添加到积压订单中。</li></ul><p>输入所有订单后，返回积压订单中的 <strong>订单总数</strong> 。由于数字可能很大，所以需要返回对 <code>109 + 7</code> 取余的结果。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/03/21/ex1.png"></p><pre><code class="hljs angelscript">输入：orders = [[<span class="hljs-number">10</span>,<span class="hljs-number">5</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">15</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">25</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">30</span>,<span class="hljs-number">4</span>,<span class="hljs-number">0</span>]]输出：<span class="hljs-number">6</span>解释：输入订单后会发生下述情况：- 提交 <span class="hljs-number">5</span> 笔采购订单，价格为 <span class="hljs-number">10</span> 。没有销售订单，所以这 <span class="hljs-number">5</span> 笔订单添加到积压订单中。- 提交 <span class="hljs-number">2</span> 笔销售订单，价格为 <span class="hljs-number">15</span> 。没有采购订单的价格大于或等于 <span class="hljs-number">15</span> ，所以这 <span class="hljs-number">2</span> 笔订单添加到积压订单中。- 提交 <span class="hljs-number">1</span> 笔销售订单，价格为 <span class="hljs-number">25</span> 。没有采购订单的价格大于或等于 <span class="hljs-number">25</span> ，所以这 <span class="hljs-number">1</span> 笔订单添加到积压订单中。- 提交 <span class="hljs-number">4</span> 笔采购订单，价格为 <span class="hljs-number">30</span> 。前 <span class="hljs-number">2</span> 笔采购订单与价格最低（价格为 <span class="hljs-number">15</span>）的 <span class="hljs-number">2</span> 笔销售订单匹配，从积压订单中删除这 <span class="hljs-number">2</span> 笔销售订单。第 <span class="hljs-number">3</span> 笔采购订单与价格最低的 <span class="hljs-number">1</span> 笔销售订单匹配，销售订单价格为 <span class="hljs-number">25</span> ，从积压订单中删除这 <span class="hljs-number">1</span> 笔销售订单。积压订单中不存在更多销售订单，所以第 <span class="hljs-number">4</span> 笔采购订单需要添加到积压订单中。最终，积压订单中有 <span class="hljs-number">5</span> 笔价格为 <span class="hljs-number">10</span> 的采购订单，和 <span class="hljs-number">1</span> 笔价格为 <span class="hljs-number">30</span> 的采购订单。所以积压订单中的订单总数为 <span class="hljs-number">6</span> 。</code></pre><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/03/21/ex2.png"></p><pre><code class="hljs angelscript">输入：orders = [[<span class="hljs-number">7</span>,<span class="hljs-number">1000000000</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">15</span>,<span class="hljs-number">3</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">5</span>,<span class="hljs-number">999999995</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]]输出：<span class="hljs-number">999999984</span>解释：输入订单后会发生下述情况：- 提交 <span class="hljs-number">109</span> 笔销售订单，价格为 <span class="hljs-number">7</span> 。没有采购订单，所以这 <span class="hljs-number">109</span> 笔订单添加到积压订单中。- 提交 <span class="hljs-number">3</span> 笔采购订单，价格为 <span class="hljs-number">15</span> 。这些采购订单与价格最低（价格为 <span class="hljs-number">7</span> ）的 <span class="hljs-number">3</span> 笔销售订单匹配，从积压订单中删除这 <span class="hljs-number">3</span> 笔销售订单。- 提交 <span class="hljs-number">999999995</span> 笔采购订单，价格为 <span class="hljs-number">5</span> 。销售订单的最低价为 <span class="hljs-number">7</span> ，所以这 <span class="hljs-number">999999995</span> 笔订单添加到积压订单中。- 提交 <span class="hljs-number">1</span> 笔销售订单，价格为 <span class="hljs-number">5</span> 。这笔销售订单与价格最高（价格为 <span class="hljs-number">5</span> ）的 <span class="hljs-number">1</span> 笔采购订单匹配，从积压订单中删除这 <span class="hljs-number">1</span> 笔采购订单。最终，积压订单中有 (<span class="hljs-number">1000000000</span><span class="hljs-number">-3</span>) 笔价格为 <span class="hljs-number">7</span> 的销售订单，和 (<span class="hljs-number">999999995</span><span class="hljs-number">-1</span>) 笔价格为 <span class="hljs-number">5</span> 的采购订单。所以积压订单中的订单总数为 <span class="hljs-number">1999999991</span> ，等于 <span class="hljs-number">999999984</span> % (<span class="hljs-number">109</span> + <span class="hljs-number">7</span>) 。</code></pre><p>提示：</p><ul><li><code>1 &lt;= orders.length &lt;= 10^5</code></li><li><code>orders[i].length == 3</code></li><li><code>1 &lt;= pricei, amounti &lt;= 10^9</code></li><li><code>orderTypei 为 0 或 1</code></li></ul><pre><code class="hljs Java"></code></pre><pre><code class="hljs Go"></code></pre><pre><code class="hljs Python"></code></pre><h5 id="智力题"><a href="#智力题" class="headerlink" title="智力题"></a>智力题</h5><h6 id="264-丑数-II"><a href="#264-丑数-II" class="headerlink" title="264. 丑数 II"></a><a href="https://leetcode-cn.com/problems/ugly-number-ii/">264. 丑数 II</a></h6><p>编写一个程序，找出第 <code>n</code> 个丑数。</p><p>丑数就是质因数只包含 <code>2, 3, 5</code> 的<strong>正整数</strong>。</p><p><strong>示例:</strong></p><pre><code class="hljs angelscript">输入: n = <span class="hljs-number">10</span>输出: <span class="hljs-number">12</span>解释: <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">12</span> 是前 <span class="hljs-number">10</span> 个丑数。</code></pre><p><strong>说明:</strong> </p><ol><li><code>1</code> 是丑数。</li><li><code>n</code> <strong>不超过</strong>1690。</li></ol><pre><code class="hljs Java"></code></pre><pre><code class="hljs Go"></code></pre><pre><code class="hljs Python"></code></pre><h6 id="313-超级丑数"><a href="#313-超级丑数" class="headerlink" title="313. 超级丑数"></a><a href="https://leetcode-cn.com/problems/super-ugly-number/">313. 超级丑数</a></h6><p>编写一段程序来查找第 <code>*n*</code> 个超级丑数。</p><p>超级丑数是指其所有质因数都是长度为 <code>k</code> 的质数列表 <code>primes</code> 中的正整数。</p><p><strong>示例:</strong></p><pre><code class="hljs angelscript">输入: n = <span class="hljs-number">12</span>, primes = [<span class="hljs-number">2</span>,<span class="hljs-number">7</span>,<span class="hljs-number">13</span>,<span class="hljs-number">19</span>]输出: <span class="hljs-number">32</span> 解释: 给定长度为 <span class="hljs-number">4</span> 的质数列表 primes = [<span class="hljs-number">2</span>,<span class="hljs-number">7</span>,<span class="hljs-number">13</span>,<span class="hljs-number">19</span>]，前 <span class="hljs-number">12</span> 个超级丑数序列为：[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">13</span>,<span class="hljs-number">14</span>,<span class="hljs-number">16</span>,<span class="hljs-number">19</span>,<span class="hljs-number">26</span>,<span class="hljs-number">28</span>,<span class="hljs-number">32</span>] 。</code></pre><p>说明:</p><ul><li>1 是任何给定 primes 的超级丑数。</li><li> 给定 primes 中的数字以升序排列。</li><li>0 &lt; k ≤ 100, 0 &lt; n ≤ 10^6, 0 &lt; primes[i] &lt; 1000 。</li><li>第 n 个超级丑数确保在 32 位有符整数范围内。</li></ul><pre><code class="hljs Java"></code></pre><pre><code class="hljs Go"></code></pre><pre><code class="hljs Python"></code></pre><h6 id="1753-移除石子的最大得分"><a href="#1753-移除石子的最大得分" class="headerlink" title="1753. 移除石子的最大得分"></a><a href="https://leetcode-cn.com/problems/maximum-score-from-removing-stones/">1753. 移除石子的最大得分</a></h6><p>你正在玩一个单人游戏，面前放置着大小分别为 <code>a</code>、<code>b</code> 和 <code>c</code> 的 <strong>三堆</strong> 石子。</p><p>每回合你都要从两个 <strong>不同的非空堆</strong> 中取出一颗石子，并在得分上加 <code>1</code> 分。当存在 <strong>两个或更多</strong> 的空堆时，游戏停止。</p><p>给你三个整数 <code>a</code> 、<code>b</code> 和 <code>c</code> ，返回可以得到的 <strong>最大分数</strong> 。</p><p><strong>示例 1：</strong></p><pre><code class="hljs angelscript">输入：a = <span class="hljs-number">2</span>, b = <span class="hljs-number">4</span>, c = <span class="hljs-number">6</span>输出：<span class="hljs-number">6</span>解释：石子起始状态是 (<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>) ，最优的一组操作是：- 从第一和第三堆取，石子状态现在是 (<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>)- 从第一和第三堆取，石子状态现在是 (<span class="hljs-number">0</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>)- 从第二和第三堆取，石子状态现在是 (<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>)- 从第二和第三堆取，石子状态现在是 (<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>)- 从第二和第三堆取，石子状态现在是 (<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)- 从第二和第三堆取，石子状态现在是 (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)总分：<span class="hljs-number">6</span> 分 。</code></pre><p><strong>示例 2：</strong></p><pre><code class="hljs angelscript">输入：a = <span class="hljs-number">4</span>, b = <span class="hljs-number">4</span>, c = <span class="hljs-number">6</span>输出：<span class="hljs-number">7</span>解释：石子起始状态是 (<span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>) ，最优的一组操作是：- 从第一和第二堆取，石子状态现在是 (<span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>)- 从第一和第三堆取，石子状态现在是 (<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>)- 从第一和第三堆取，石子状态现在是 (<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>)- 从第一和第三堆取，石子状态现在是 (<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>)- 从第二和第三堆取，石子状态现在是 (<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>)- 从第二和第三堆取，石子状态现在是 (<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)- 从第二和第三堆取，石子状态现在是 (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)总分：<span class="hljs-number">7</span> 分 。</code></pre><p><strong>示例 3：</strong></p><pre><code class="hljs angelscript">输入：a = <span class="hljs-number">1</span>, b = <span class="hljs-number">8</span>, c = <span class="hljs-number">8</span>输出：<span class="hljs-number">8</span>解释：最优的一组操作是连续从第二和第三堆取 <span class="hljs-number">8</span> 回合，直到将它们取空。注意，由于第二和第三堆已经空了，游戏结束，不能继续从第一堆中取石子。</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= a, b, c &lt;= 10^5</code></li></ul><pre><code class="hljs Java"></code></pre><pre><code class="hljs Go"></code></pre><pre><code class="hljs Python"></code></pre><h4 id="并查集（Union-find）及经典问题"><a href="#并查集（Union-find）及经典问题" class="headerlink" title="并查集（Union-find）及经典问题"></a><strong>并查集（Union-find）及经典问题</strong></h4>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Go</tag>
      
      <tag>Java</tag>
      
      <tag>LeetCode</tag>
      
      <tag>scala</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【LeetCode】线性表相关问题</title>
    <link href="/2021/03/05/lt-linkedList/"/>
    <url>/2021/03/05/lt-linkedList/</url>
    
    <content type="html"><![CDATA[<blockquote><p>把所有数据用一根线儿串起来，再存储到物理空间中的数据结构<a id="more"></a></p></blockquote><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problemset/all/">https://leetcode-cn.com/problemset/all/</a></p><h4 id="链表相关"><a href="#链表相关" class="headerlink" title="链表相关"></a>链表相关</h4><h5 id="链表访问"><a href="#链表访问" class="headerlink" title="链表访问"></a>链表访问</h5><h6 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141. 环形链表"></a><a href="https://leetcode-cn.com/problems/linked-list-cycle/">141. 环形链表</a></h6><p>给定一个链表，判断链表中是否有环。</p><p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</p><p>如果链表中存在环，则返回 true 。 否则，返回 false 。</p><p>解题思路</p><pre><code class="hljs angelscript"><span class="hljs-number">1.</span>快慢指针，相遇问题<span class="hljs-number">2.</span>借助哈希（Set）</code></pre><p><code>Java</code></p><pre><code class="hljs Java"><span class="hljs-comment">/*</span><span class="hljs-comment"> * Author: Wang P</span><span class="hljs-comment"> * Version: 1.0.0</span><span class="hljs-comment"> * Date: 2021-03-04 17:27:34</span><span class="hljs-comment"> * Description:</span><span class="hljs-comment"> **/</span> <span class="hljs-keyword">package</span> com.weitrue.leetcode.editor.cn;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LinkedListCycle</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;        Solution s = <span class="hljs-keyword">new</span> LinkedListCycle().<span class="hljs-function">new <span class="hljs-title">Solution</span><span class="hljs-params">()</span></span>;    &#125;        <span class="hljs-comment">//Given head, the head of a linked list, determine if the linked list has a cycl</span>    <span class="hljs-comment">//e in it.</span>    <span class="hljs-comment">//</span>    <span class="hljs-comment">// There is a cycle in a linked list if there is some node in the list that can</span>    <span class="hljs-comment">//be reached again by continuously following the next pointer. Internally, pos is</span>    <span class="hljs-comment">//used to denote the index of the node that tail&#x27;s next pointer is connected to. N</span>    <span class="hljs-comment">//ote that pos is not passed as a parameter.</span>    <span class="hljs-comment">//</span>    <span class="hljs-comment">// Return true if there is a cycle in the linked list. Otherwise, return false.</span>    <span class="hljs-comment">//</span>    <span class="hljs-comment">// Example 1:</span>    <span class="hljs-comment">//Input: head = [3,2,0,-4], pos = 1</span>    <span class="hljs-comment">//Output: true</span>    <span class="hljs-comment">//Explanation: There is a cycle in the linked list, where the tail connects to t</span>    <span class="hljs-comment">//he 1st node (0-indexed).</span>    <span class="hljs-comment">//</span>    <span class="hljs-comment">// Example 2:</span>    <span class="hljs-comment">//Input: head = [1,2], pos = 0</span>    <span class="hljs-comment">//Output: true</span>    <span class="hljs-comment">//Explanation: There is a cycle in the linked list, where the tail connects to t</span>    <span class="hljs-comment">//he 0th node.</span>    <span class="hljs-comment">//</span>    <span class="hljs-comment">// Example 3:</span>    <span class="hljs-comment">//Input: head = [1], pos = -1</span>    <span class="hljs-comment">//Output: false</span>    <span class="hljs-comment">//Explanation: There is no cycle in the linked list.</span>    <span class="hljs-comment">//</span>    <span class="hljs-comment">// Constraints:</span>    <span class="hljs-comment">// The number of the nodes in the list is in the range [0, 104].</span>    <span class="hljs-comment">// -105 &lt;= Node.val &lt;= 105</span>    <span class="hljs-comment">// pos is -1 or a valid index in the linked-list.</span>    <span class="hljs-comment">//</span>    <span class="hljs-comment">// Follow up: Can you solve it using O(1) (i.e. constant) memory?</span>    <span class="hljs-comment">// Related Topics 链表 双指针</span>    <span class="hljs-comment">// 👍 970 👎 0</span>  <span class="hljs-comment">// leetcode submit region begin(Prohibit modification and deletion)</span>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListNode</span> </span>&#123;        <span class="hljs-keyword">int</span> val;        ListNode next;        ListNode(<span class="hljs-keyword">int</span> x) &#123;            val = x;            next = <span class="hljs-keyword">null</span>;        &#125;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasCycle</span><span class="hljs-params">(ListNode head)</span> </span>&#123;            <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span> ||  head.next == <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            &#125;            ListNode p = head, q = head;            <span class="hljs-keyword">do</span> &#123;                p = p.next;                q = q.next.next;            &#125;            <span class="hljs-keyword">while</span> (q != <span class="hljs-keyword">null</span> &amp;&amp; q.next != <span class="hljs-keyword">null</span> &amp;&amp; p != q);            <span class="hljs-keyword">return</span> p == q;        &#125;    &#125;    <span class="hljs-comment">//leetcode submit region end(Prohibit modification and deletion)</span>&#125;</code></pre><p><code>Golang</code></p><pre><code class="hljs golang"><span class="hljs-keyword">package</span> leetcode<span class="hljs-comment">/**</span><span class="hljs-comment"> * Author: Wang P</span><span class="hljs-comment"> * Version: 1.0.0</span><span class="hljs-comment"> * Date: 2021-03-05 11:03:59</span><span class="hljs-comment"> * Description:</span><span class="hljs-comment"> **/</span><span class="hljs-comment">//Given head, the head of a linked list, determine if the linked list has a cycl</span><span class="hljs-comment">//e in it. </span><span class="hljs-comment">//</span><span class="hljs-comment">// There is a cycle in a linked list if there is some node in the list that can </span><span class="hljs-comment">//be reached again by continuously following the next pointer. Internally, pos is </span><span class="hljs-comment">//used to denote the index of the node that tail&#x27;s next pointer is connected to. N</span><span class="hljs-comment">//ote that pos is not passed as a parameter. </span><span class="hljs-comment">//</span><span class="hljs-comment">// Return true if there is a cycle in the linked list. Otherwise, return false. </span><span class="hljs-comment">// </span><span class="hljs-comment">// Example 1: </span><span class="hljs-comment">//Input: head = [3,2,0,-4], pos = 1</span><span class="hljs-comment">//Output: true</span><span class="hljs-comment">//Explanation: There is a cycle in the linked list, where the tail connects to t</span><span class="hljs-comment">//he 1st node (0-indexed).</span><span class="hljs-comment">// </span><span class="hljs-comment">// Example 2: </span><span class="hljs-comment">//Input: head = [1,2], pos = 0</span><span class="hljs-comment">//Output: true</span><span class="hljs-comment">//Explanation: There is a cycle in the linked list, where the tail connects to t</span><span class="hljs-comment">//he 0th node.</span><span class="hljs-comment">// </span><span class="hljs-comment">// Example 3: </span><span class="hljs-comment">//Input: head = [1], pos = -1</span><span class="hljs-comment">//Output: false</span><span class="hljs-comment">//Explanation: There is no cycle in the linked list.</span><span class="hljs-comment">// </span><span class="hljs-comment">// Constraints: </span><span class="hljs-comment">// The number of the nodes in the list is in the range [0, 104]. </span><span class="hljs-comment">// -105 &lt;= Node.val &lt;= 105 </span><span class="hljs-comment">// pos is -1 or a valid index in the linked-list. </span><span class="hljs-comment">// Follow up: Can you solve it using O(1) (i.e. constant) memory? </span><span class="hljs-comment">// Related Topics 链表 双指针 </span><span class="hljs-comment">// 👍 971 👎 0</span><span class="hljs-comment">//leetcode submit region begin(Prohibit modification and deletion)</span><span class="hljs-comment">// Definition for singly-linked list.</span><span class="hljs-keyword">type</span> ListNode <span class="hljs-keyword">struct</span> &#123;   Val <span class="hljs-keyword">int</span>   Next *ListNode&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hasCycle</span><span class="hljs-params">(head *ListNode)</span> <span class="hljs-title">bool</span></span> &#123;<span class="hljs-keyword">if</span> head == <span class="hljs-literal">nil</span> || head.Next == <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>&#125;p := head.Nextq := head.Next.Next<span class="hljs-keyword">for</span> q != <span class="hljs-literal">nil</span> &amp;&amp; q.Next != <span class="hljs-literal">nil</span> &amp;&amp; p != q&#123;p = p.Nextq = q.Next.Next&#125;    <span class="hljs-keyword">return</span> p == q&#125;<span class="hljs-comment">//leetcode submit region end(Prohibit modification and deletion)</span></code></pre><p><code>Python</code></p><pre><code class="hljs Python"><span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">Module Description: 141-环形链表</span><span class="hljs-string">Solution：</span><span class="hljs-string">Date: 2021-03-05 10:38:59</span><span class="hljs-string">Author: Wang P</span><span class="hljs-string">Problem:# 给定一个链表，判断链表中是否有环。 </span><span class="hljs-string"># </span><span class="hljs-string">#  如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的</span><span class="hljs-string"># 位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。 </span><span class="hljs-string"># </span><span class="hljs-string">#  如果链表中存在环，则返回 true 。 否则，返回 false 。 </span><span class="hljs-string"># </span><span class="hljs-string">#  进阶： </span><span class="hljs-string">#  你能用 O(1)（即，常量）内存解决此问题吗？ </span><span class="hljs-string"># </span><span class="hljs-string">#  示例 1： </span><span class="hljs-string">#  输入：head = [3,2,0,-4], pos = 1</span><span class="hljs-string"># 输出：true</span><span class="hljs-string"># 解释：链表中有一个环，其尾部连接到第二个节点。</span><span class="hljs-string">#  </span><span class="hljs-string">#  示例 2： </span><span class="hljs-string">#  输入：head = [1,2], pos = 0</span><span class="hljs-string"># 输出：true</span><span class="hljs-string"># 解释：链表中有一个环，其尾部连接到第一个节点。</span><span class="hljs-string">#  </span><span class="hljs-string">#  示例 3： </span><span class="hljs-string">#  输入：head = [1], pos = -1</span><span class="hljs-string"># 输出：false</span><span class="hljs-string"># 解释：链表中没有环。</span><span class="hljs-string">#  </span><span class="hljs-string">#  提示：  </span><span class="hljs-string">#  链表中节点的数目范围是 [0, 104] </span><span class="hljs-string">#  -105 &lt;= Node.val &lt;= 105 </span><span class="hljs-string">#  pos 为 -1 或者链表中的一个 有效索引 。 </span><span class="hljs-string">#  </span><span class="hljs-string">#  Related Topics 链表 双指针 </span><span class="hljs-string">#  👍 971 👎 0</span><span class="hljs-string"></span><span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-comment"># leetcode submit region begin(Prohibit modification and deletion)</span><span class="hljs-comment"># Definition for singly-linked list.</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListNode</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, x</span>):</span>        self.val = x        self.<span class="hljs-built_in">next</span> = <span class="hljs-literal">None</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hasCycle</span>(<span class="hljs-params">self, head: ListNode</span>) -&gt; bool:</span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> head:            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>        p = ListNode(<span class="hljs-number">-1</span>)        p.<span class="hljs-built_in">next</span> = head        p, q = head, head.<span class="hljs-built_in">next</span>        <span class="hljs-keyword">while</span> q <span class="hljs-keyword">and</span> q.<span class="hljs-built_in">next</span>:            p = p.<span class="hljs-built_in">next</span>            q = q.<span class="hljs-built_in">next</span>.<span class="hljs-built_in">next</span>            <span class="hljs-keyword">if</span> p == q:                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>        <span class="hljs-comment"># leetcode submit region end(Prohibit modification and deletion)</span></code></pre><h6 id="142-环形链表-II"><a href="#142-环形链表-II" class="headerlink" title="142. 环形链表 II"></a><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">142. 环形链表 II</a></h6><p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p><p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意，pos 仅仅是用于标识环的情况，并不会作为参数传递到函数中。</p><p>说明：不允许修改给定的链表。</p><p>进阶：</p><p>你是否可以使用 O(1) 空间解决此题？</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png"></p><pre><div class="caption"><span>1：</span></div><code class="hljs 示例">输入：head &#x3D; [3,2,0,-4], pos &#x3D; 1输出：返回索引为 1 的链表节点解释：链表中有一个环，其尾部连接到第二个节点。</code></pre><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png"></p><pre><div class="caption"><span>2：</span></div><code class="hljs 示例">输入：head &#x3D; [1,2], pos &#x3D; 0输出：返回索引为 0 的链表节点解释：链表中有一个环，其尾部连接到第一个节点。</code></pre><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png"></p><pre><div class="caption"><span>3：</span></div><code class="hljs 示例">输入：head &#x3D; [1], pos &#x3D; -1输出：返回 null解释：链表中没有环。</code></pre><p><strong>提示：</strong></p><ul><li>链表中节点的数目范围在范围 <code>[0, 104]</code> 内</li><li><code>-105 &lt;= Node.val &lt;= 105</code></li><li><code>pos</code> 的值为 <code>-1</code> 或者链表中的一个有效索引</li></ul><p>解题思路</p><pre><code class="hljs coq"><span class="hljs-number">1.</span>快慢指针，相遇后，head-&gt;入环的第一个节点距离=相遇点-&gt;入环的第一个节点距离<span class="hljs-number">2.</span>借助哈希（<span class="hljs-keyword">Set</span>）</code></pre><p><code>Java</code></p><pre><code class="hljs Java"><span class="hljs-comment">/*</span><span class="hljs-comment"> * Author: Wang P</span><span class="hljs-comment"> * Version: 1.0.0</span><span class="hljs-comment"> * Date: 2021-03-04 19:03:31</span><span class="hljs-comment"> * Description: 142-Linked List Cycle II</span><span class="hljs-comment"> **/</span> <span class="hljs-keyword">package</span> com.weitrue.leetcode.editor.cn;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LinkedListCycleIi</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;        Solution s = <span class="hljs-keyword">new</span> LinkedListCycleIi().<span class="hljs-function">new <span class="hljs-title">Solution</span><span class="hljs-params">()</span></span>;    &#125;        <span class="hljs-comment">//Given a linked list, return the node where the cycle begins. If there is no cy</span>    <span class="hljs-comment">//cle, return null.</span>    <span class="hljs-comment">//</span>    <span class="hljs-comment">// There is a cycle in a linked list if there is some node in the list that can</span>    <span class="hljs-comment">//be reached again by continuously following the next pointer. Internally, pos is</span>    <span class="hljs-comment">//used to denote the index of the node that tail&#x27;s next pointer is connected to. N</span>    <span class="hljs-comment">//ote that pos is not passed as a parameter.</span>    <span class="hljs-comment">//</span>    <span class="hljs-comment">// Notice that you should not modify the linked list.</span>    <span class="hljs-comment">//</span>    <span class="hljs-comment">// Example 1:</span>    <span class="hljs-comment">//Input: head = [3,2,0,-4], pos = 1</span>    <span class="hljs-comment">//Output: tail connects to node index 1</span>    <span class="hljs-comment">//Explanation: There is a cycle in the linked list, where tail connects to the s</span>    <span class="hljs-comment">//econd node.</span>    <span class="hljs-comment">//</span>    <span class="hljs-comment">// Example 2:</span>    <span class="hljs-comment">//Input: head = [1,2], pos = 0</span>    <span class="hljs-comment">//Output: tail connects to node index 0</span>    <span class="hljs-comment">//Explanation: There is a cycle in the linked list, where tail connects to the f</span>    <span class="hljs-comment">//irst node.</span>    <span class="hljs-comment">//</span>    <span class="hljs-comment">// Example 3:</span>    <span class="hljs-comment">//Input: head = [1], pos = -1</span>    <span class="hljs-comment">//Output: no cycle</span>    <span class="hljs-comment">//Explanation: There is no cycle in the linked list.</span>    <span class="hljs-comment">//</span>    <span class="hljs-comment">// Constraints:</span>    <span class="hljs-comment">// The number of the nodes in the list is in the range [0, 104].</span>    <span class="hljs-comment">// -105 &lt;= Node.val &lt;= 105</span>    <span class="hljs-comment">// pos is -1 or a valid index in the linked-list.</span>    <span class="hljs-comment">//</span>    <span class="hljs-comment">// Follow up: Can you solve it using O(1) (i.e. constant) memory?</span>    <span class="hljs-comment">// Related Topics 链表 双指针</span>    <span class="hljs-comment">// 👍 897 👎 0</span>     <span class="hljs-comment">// leetcode submit region begin(Prohibit modification and deletion)</span>     <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListNode</span> </span>&#123;         <span class="hljs-keyword">int</span> val;         ListNode next;         ListNode(<span class="hljs-keyword">int</span> x) &#123;             val = x;             next = <span class="hljs-keyword">null</span>;         &#125;     &#125;    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;        <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">detectCycle</span><span class="hljs-params">(ListNode head)</span> </span>&#123;            <span class="hljs-keyword">if</span>(head == <span class="hljs-keyword">null</span> || head.next == <span class="hljs-keyword">null</span>)&#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;            &#125;            ListNode p = head, q = head;            <span class="hljs-keyword">do</span> &#123;                p = p.next;                q = q.next.next;            &#125; <span class="hljs-keyword">while</span> (q != <span class="hljs-keyword">null</span> &amp;&amp; q.next != <span class="hljs-keyword">null</span> &amp;&amp; p != q);            <span class="hljs-keyword">if</span> (p != q) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;            &#125;            q = head;            <span class="hljs-keyword">while</span> (p != q) &#123;                p = p.next;                q = q.next;            &#125;            <span class="hljs-keyword">return</span> q;        &#125;    &#125;    <span class="hljs-comment">//leetcode submit region end(Prohibit modification and deletion)</span>&#125;</code></pre><p><code>Golang</code></p><pre><code class="hljs golang"><span class="hljs-keyword">package</span> leetcode<span class="hljs-comment">/**</span><span class="hljs-comment"> * Author: Wang P</span><span class="hljs-comment"> * Version: 1.0.0</span><span class="hljs-comment"> * Date: 2021-03-05 11:14:26</span><span class="hljs-comment"> * Description:</span><span class="hljs-comment"> **/</span><span class="hljs-comment">//Given a linked list, return the node where the cycle begins. If there is no cy</span><span class="hljs-comment">//cle, return null. </span><span class="hljs-comment">//</span><span class="hljs-comment">// There is a cycle in a linked list if there is some node in the list that can </span><span class="hljs-comment">//be reached again by continuously following the next pointer. Internally, pos is </span><span class="hljs-comment">//used to denote the index of the node that tail&#x27;s next pointer is connected to. N</span><span class="hljs-comment">//ote that pos is not passed as a parameter. </span><span class="hljs-comment">//</span><span class="hljs-comment">// Notice that you should not modify the linked list. </span><span class="hljs-comment">//</span><span class="hljs-comment">// Example 1: </span><span class="hljs-comment">//Input: head = [3,2,0,-4], pos = 1</span><span class="hljs-comment">//Output: tail connects to node index 1</span><span class="hljs-comment">//Explanation: There is a cycle in the linked list, where tail connects to the s</span><span class="hljs-comment">//econd node.</span><span class="hljs-comment">// </span><span class="hljs-comment">// Example 2: </span><span class="hljs-comment">//Input: head = [1,2], pos = 0</span><span class="hljs-comment">//Output: tail connects to node index 0</span><span class="hljs-comment">//Explanation: There is a cycle in the linked list, where tail connects to the f</span><span class="hljs-comment">//irst node.</span><span class="hljs-comment">// </span><span class="hljs-comment">// Example 3: </span><span class="hljs-comment">//Input: head = [1], pos = -1</span><span class="hljs-comment">//Output: no cycle</span><span class="hljs-comment">//Explanation: There is no cycle in the linked list.</span><span class="hljs-comment">// </span><span class="hljs-comment">// Constraints: </span><span class="hljs-comment">// The number of the nodes in the list is in the range [0, 104]. </span><span class="hljs-comment">// -105 &lt;= Node.val &lt;= 105 </span><span class="hljs-comment">// pos is -1 or a valid index in the linked-list. </span><span class="hljs-comment">// Follow up: Can you solve it using O(1) (i.e. constant) memory? </span><span class="hljs-comment">// Related Topics 链表 双指针 </span><span class="hljs-comment">// 👍 898 👎 0</span><span class="hljs-comment">//leetcode submit region begin(Prohibit modification and deletion)</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for singly-linked list.</span><span class="hljs-comment"> * type ListNode struct &#123;</span><span class="hljs-comment"> *     Val int</span><span class="hljs-comment"> *     Next *ListNode</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">detectCycle</span><span class="hljs-params">(head *ListNode)</span> *<span class="hljs-title">ListNode</span></span> &#123;<span class="hljs-keyword">if</span> head == <span class="hljs-literal">nil</span> || head.Next == <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>&#125;p := head.Nextq := head.Next.Next<span class="hljs-keyword">for</span> q != <span class="hljs-literal">nil</span> &amp;&amp; q.Next != <span class="hljs-literal">nil</span> &amp;&amp; p != q&#123;q = q.Next.Nextp = p.Next&#125;<span class="hljs-keyword">if</span> p != q &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>&#125;q = head<span class="hljs-keyword">for</span> p != q &#123;p = p.Nextq = q.Next&#125;<span class="hljs-keyword">return</span> q&#125;<span class="hljs-comment">//leetcode submit region end(Prohibit modification and deletion)</span></code></pre><p><code>Python</code></p><pre><code class="hljs Python"><span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">Module Description: 142-环形链表 II</span><span class="hljs-string">Solution：</span><span class="hljs-string">Date: 2021-03-05 10:47:28</span><span class="hljs-string">Author: Wang P</span><span class="hljs-string">Problem: 给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</span><span class="hljs-string"># </span><span class="hljs-string">#  为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意，po</span><span class="hljs-string"># s 仅仅是用于标识环的情况，并不会作为参数传递到函数中。 </span><span class="hljs-string"># </span><span class="hljs-string">#  说明：不允许修改给定的链表。 </span><span class="hljs-string"># </span><span class="hljs-string">#  进阶：</span><span class="hljs-string">#  你是否可以使用 O(1) 空间解决此题？ </span><span class="hljs-string">#</span><span class="hljs-string">#  示例 1：</span><span class="hljs-string"># 输入：head = [3,2,0,-4], pos = 1</span><span class="hljs-string"># 输出：返回索引为 1 的链表节点</span><span class="hljs-string"># 解释：链表中有一个环，其尾部连接到第二个节点。</span><span class="hljs-string">#</span><span class="hljs-string">#  示例 2：</span><span class="hljs-string"># 输入：head = [1,2], pos = 0</span><span class="hljs-string"># 输出：返回索引为 0 的链表节点</span><span class="hljs-string"># 解释：链表中有一个环，其尾部连接到第一个节点。</span><span class="hljs-string">#</span><span class="hljs-string">#  示例 3：</span><span class="hljs-string"># 输入：head = [1], pos = -1</span><span class="hljs-string"># 输出：返回 null</span><span class="hljs-string"># 解释：链表中没有环。</span><span class="hljs-string">#</span><span class="hljs-string">#  提示：</span><span class="hljs-string">#  链表中节点的数目范围在范围 [0, 104] 内 </span><span class="hljs-string">#  -105 &lt;= Node.val &lt;= 105 </span><span class="hljs-string">#  pos 的值为 -1 或者链表中的一个有效索引 </span><span class="hljs-string">#  </span><span class="hljs-string">#  Related Topics 链表 双指针 </span><span class="hljs-string">#  👍 898 👎 0</span><span class="hljs-string"></span><span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-comment"># leetcode submit region begin(Prohibit modification and deletion)</span><span class="hljs-comment"># Definition for singly-linked list.</span><span class="hljs-comment">#</span><span class="hljs-comment">#</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListNode</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, x</span>):</span>        self.val = x        self.<span class="hljs-built_in">next</span> = <span class="hljs-literal">None</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">detectCycle</span>(<span class="hljs-params">self, head: ListNode</span>) -&gt; ListNode:</span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> head <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> head.<span class="hljs-built_in">next</span>:            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>        p, q = head.<span class="hljs-built_in">next</span>, head.<span class="hljs-built_in">next</span>.<span class="hljs-built_in">next</span>        <span class="hljs-keyword">while</span> q <span class="hljs-keyword">and</span> q.<span class="hljs-built_in">next</span> <span class="hljs-keyword">and</span> p != q:            p = p.<span class="hljs-built_in">next</span>            q = q.<span class="hljs-built_in">next</span>.<span class="hljs-built_in">next</span>        <span class="hljs-keyword">if</span> p != q:            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>        q = head        <span class="hljs-keyword">while</span> p != q:            p = p.<span class="hljs-built_in">next</span>            q = q.<span class="hljs-built_in">next</span>        <span class="hljs-keyword">return</span> q        <span class="hljs-comment"># leetcode submit region end(Prohibit modification and deletion)</span></code></pre><h6 id="202-快乐数"><a href="#202-快乐数" class="headerlink" title="202. 快乐数"></a><a href="https://leetcode-cn.com/problems/happy-number/">202. 快乐数</a></h6><p>编写一个算法来判断一个数 n 是不是快乐数。</p><p>「快乐数」定义为：</p><p>对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。<br>然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。<br>如果 可以变为  1，那么这个数就是快乐数。<br>如果 n 是快乐数就返回 true ；不是，则返回 false 。</p><p>解题思路</p><pre><code class="hljs angelscript"><span class="hljs-number">1.</span>链表是否有环问题</code></pre><p>示例 2：</p><pre><code class="hljs angelscript">输入：<span class="hljs-number">19</span>输出：<span class="hljs-literal">true</span>解释：<span class="hljs-number">12</span> + <span class="hljs-number">92</span> = <span class="hljs-number">82</span><span class="hljs-number">82</span> + <span class="hljs-number">22</span> = <span class="hljs-number">68</span><span class="hljs-number">62</span> + <span class="hljs-number">82</span> = <span class="hljs-number">100</span><span class="hljs-number">12</span> + <span class="hljs-number">02</span> + <span class="hljs-number">02</span> = <span class="hljs-number">1</span></code></pre><p>示例 2：</p><pre><code class="hljs angelscript">输入：n = <span class="hljs-number">2</span>输出：<span class="hljs-literal">false</span>提示：<span class="hljs-number">1</span> &lt;= n &lt;= <span class="hljs-number">231</span> - <span class="hljs-number">1</span></code></pre><p><code>Java</code></p><pre><code class="hljs java"><span class="hljs-comment">/*</span><span class="hljs-comment"> * Author: Wang P</span><span class="hljs-comment"> * Version: 1.0.0</span><span class="hljs-comment"> * Date: 2021-03-04 17:56:08</span><span class="hljs-comment"> * Description:</span><span class="hljs-comment"> **/</span><span class="hljs-keyword">package</span> com.weitrue.leetcode.editor.cn;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HappyNumber</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;        Solution s = <span class="hljs-keyword">new</span> HappyNumber().<span class="hljs-function">new <span class="hljs-title">Solution</span><span class="hljs-params">()</span></span>;        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;=<span class="hljs-number">100000</span>; i++) &#123;            <span class="hljs-keyword">if</span> (s.isHappy(i)) &#123;                sum++;            &#125;        &#125;        System.out.println(sum);    &#125;    <span class="hljs-comment">//Write an algorithm to determine if a number n is happy.</span>    <span class="hljs-comment">//</span>    <span class="hljs-comment">// A happy number is a number defined by the following process:</span>    <span class="hljs-comment">//</span>    <span class="hljs-comment">// Starting with any positive integer, replace the number by the sum of the squares of its digits.</span>    <span class="hljs-comment">// Repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1.</span>    <span class="hljs-comment">// Those numbers for which this process ends in 1 are happy.</span>    <span class="hljs-comment">//</span>    <span class="hljs-comment">// Return true if n is a happy number, and false if not.</span>    <span class="hljs-comment">//</span>    <span class="hljs-comment">// Example 1:</span>    <span class="hljs-comment">//Input: n = 19</span>    <span class="hljs-comment">//Output: true</span>    <span class="hljs-comment">//Explanation:</span>    <span class="hljs-comment">//12 + 92 = 82</span>    <span class="hljs-comment">//82 + 22 = 68</span>    <span class="hljs-comment">//62 + 82 = 100</span>    <span class="hljs-comment">//12 + 02 + 02 = 1</span>    <span class="hljs-comment">//</span>    <span class="hljs-comment">// Example 2:</span>    <span class="hljs-comment">//Input: n = 2</span>    <span class="hljs-comment">//Output: false</span>    <span class="hljs-comment">//</span>    <span class="hljs-comment">// Constraints:</span>    <span class="hljs-comment">//</span>    <span class="hljs-comment">// 1 &lt;= n &lt;= 231 - 1</span>    <span class="hljs-comment">//</span>    <span class="hljs-comment">// Related Topics 哈希表 数学</span>    <span class="hljs-comment">// 👍 542 👎 0</span>    <span class="hljs-comment">//leetcode submit region begin(Prohibit modification and deletion)</span>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getNext</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;                <span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>;                <span class="hljs-keyword">while</span>(n &gt; <span class="hljs-number">0</span>) &#123;                    x += (n % <span class="hljs-number">10</span>) * (n % <span class="hljs-number">10</span>);                    n = n / <span class="hljs-number">10</span>;                &#125;                <span class="hljs-keyword">return</span> x;            &#125;            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isHappy</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;                <span class="hljs-keyword">int</span> p = n, q = n;                <span class="hljs-keyword">do</span>&#123;                    p = getNext(p);                    q = getNext(getNext(q));                &#125; <span class="hljs-keyword">while</span> (p != q &amp;&amp; q!= <span class="hljs-number">1</span>);                <span class="hljs-keyword">return</span> q == <span class="hljs-number">1</span>;            &#125;    &#125;    <span class="hljs-comment">//leetcode submit region end(Prohibit modification and deletion)</span>&#125;</code></pre><p><code>Golang</code></p><pre><code class="hljs golang"><span class="hljs-keyword">package</span> leetcode<span class="hljs-comment">/**</span><span class="hljs-comment"> * Author: Wang P</span><span class="hljs-comment"> * Version: 1.0.0</span><span class="hljs-comment"> * Date: 2021-03-05 12:56:41</span><span class="hljs-comment"> * Description: //Write an algorithm to determine if a number n is happy.</span><span class="hljs-comment">//</span><span class="hljs-comment">// A happy number is a number defined by the following process:</span><span class="hljs-comment">//</span><span class="hljs-comment">// Starting with any positive integer, replace the number by the sum of the squa</span><span class="hljs-comment">//res of its digits.</span><span class="hljs-comment">// Repeat the process until the number equals 1 (where it will stay), or it loop</span><span class="hljs-comment">//s endlessly in a cycle which does not include 1.</span><span class="hljs-comment">// Those numbers for which this process ends in 1 are happy.</span><span class="hljs-comment">//</span><span class="hljs-comment">// Return true if n is a happy number, and false if not.</span><span class="hljs-comment">//</span><span class="hljs-comment">// Example 1:</span><span class="hljs-comment">//Input: n = 19</span><span class="hljs-comment">//Output: true</span><span class="hljs-comment">//Explanation:</span><span class="hljs-comment">//12 + 92 = 82</span><span class="hljs-comment">//82 + 22 = 68</span><span class="hljs-comment">//62 + 82 = 100</span><span class="hljs-comment">//12 + 02 + 02 = 1</span><span class="hljs-comment">//</span><span class="hljs-comment">// Example 2:</span><span class="hljs-comment">//Input: n = 2</span><span class="hljs-comment">//Output: false</span><span class="hljs-comment">//</span><span class="hljs-comment">// Constraints:</span><span class="hljs-comment">// 1 &lt;= n &lt;= 231 - 1</span><span class="hljs-comment">//</span><span class="hljs-comment">// Related Topics 哈希表 数学</span><span class="hljs-comment">// 👍 547 👎 0</span><span class="hljs-comment"> **/</span><span class="hljs-comment">//leetcode submit region begin(Prohibit modification and deletion)</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">IsHappy</span><span class="hljs-params">(n <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">bool</span></span> &#123;p, q := getNext(n), getNext(getNext(n))<span class="hljs-keyword">for</span> p != q &amp;&amp; q != <span class="hljs-number">1</span> &#123;p = getNext(p)q = getNext(getNext(q))&#125;<span class="hljs-keyword">return</span> q == <span class="hljs-number">1</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getNext</span><span class="hljs-params">(n <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;x := <span class="hljs-number">0</span><span class="hljs-keyword">for</span> n &gt; <span class="hljs-number">0</span> &#123;x += (n % <span class="hljs-number">10</span>) * (n % <span class="hljs-number">10</span>)n = n / <span class="hljs-number">10</span>&#125;<span class="hljs-keyword">return</span> x&#125;<span class="hljs-comment">//leetcode submit region end(Prohibit modification and deletion)</span></code></pre><p><code>Python</code></p><pre><code class="hljs Python"><span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">Module Description: 202-快乐数</span><span class="hljs-string">Solution：</span><span class="hljs-string">Date: 2021-03-05 12:02:33</span><span class="hljs-string">Author: Wang P</span><span class="hljs-string">Problem:# 编写一个算法来判断一个数 n 是不是快乐数。 </span><span class="hljs-string"># </span><span class="hljs-string">#  「快乐数」定义为： </span><span class="hljs-string">#  对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。 </span><span class="hljs-string">#  然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。 </span><span class="hljs-string">#  如果 可以变为 1，那么这个数就是快乐数。 </span><span class="hljs-string">#  如果 n 是快乐数就返回 true ；不是，则返回 false 。 </span><span class="hljs-string"># </span><span class="hljs-string">#  示例 1： </span><span class="hljs-string"># 输入：19</span><span class="hljs-string"># 输出：true</span><span class="hljs-string"># 解释：</span><span class="hljs-string"># 12 + 92 = 82</span><span class="hljs-string"># 82 + 22 = 68</span><span class="hljs-string"># 62 + 82 = 100</span><span class="hljs-string"># 12 + 02 + 02 = 1</span><span class="hljs-string">#  </span><span class="hljs-string">#  示例 2： </span><span class="hljs-string"># 输入：n = 2</span><span class="hljs-string"># 输出：false</span><span class="hljs-string">#  </span><span class="hljs-string">#  提示： </span><span class="hljs-string">#  1 &lt;= n &lt;= 231 - 1 </span><span class="hljs-string">#  </span><span class="hljs-string">#  Related Topics 哈希表 数学 </span><span class="hljs-string">#  👍 548 👎 0</span><span class="hljs-string"></span><span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-comment"># leetcode submit region begin(Prohibit modification and deletion)</span><span class="hljs-keyword">import</span> math<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isHappy</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; bool:</span>        p, q = n, self.get_next(n)        <span class="hljs-keyword">while</span> p != q <span class="hljs-keyword">and</span> q != <span class="hljs-number">1</span>:            p = self.get_next(p)            q = self.get_next(self.get_next(q))        <span class="hljs-keyword">return</span> q == <span class="hljs-number">1</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_next</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; int:</span>        x = <span class="hljs-number">0</span>        <span class="hljs-keyword">while</span> n:            n, tmp = <span class="hljs-built_in">divmod</span>(n, <span class="hljs-number">10</span>)            x += (tmp * tmp)        <span class="hljs-keyword">return</span> x<span class="hljs-comment"># leetcode submit region end(Prohibit modification and deletion)</span></code></pre><h5 id="链表反转"><a href="#链表反转" class="headerlink" title="链表反转"></a>链表反转</h5><h6 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206. 反转链表"></a><a href="https://leetcode-cn.com/problems/reverse-linked-list/">206. 反转链表</a></h6><p>反转一个单链表。</p><p>示例:</p><pre><code class="hljs angelscript">输入: <span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">5</span>-&gt;NULL输出: <span class="hljs-number">5</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">1</span>-&gt;NULL</code></pre><p>进阶:<br>你可以迭代或递归地反转链表。你能否用两种方法解决这道题？</p><p>解题思路</p><pre><code class="hljs angelscript"><span class="hljs-number">1.</span>通过前驱、后继对链表进行反转<span class="hljs-number">2.</span>递归方式<span class="hljs-number">3.</span>借助栈结构</code></pre><p><code>Java</code></p><pre><code class="hljs Java"><span class="hljs-comment">/*</span><span class="hljs-comment"> * Author: Wang P</span><span class="hljs-comment"> * Version: 1.0.0</span><span class="hljs-comment"> * Date: 2021-03-05 17:30:32</span><span class="hljs-comment"> * Description: 206-Reverse Linked List</span><span class="hljs-comment"> **/</span> <span class="hljs-keyword">package</span> com.weitrue.leetcode.editor.cn;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReverseLinkedList</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;        Solution s = <span class="hljs-keyword">new</span> ReverseLinkedList().<span class="hljs-function">new <span class="hljs-title">Solution</span><span class="hljs-params">()</span></span>;    &#125;        <span class="hljs-comment">//Given the head of a singly linked list, reverse the list, and return the reversed list.</span>    <span class="hljs-comment">//</span>    <span class="hljs-comment">// Example 1:</span>    <span class="hljs-comment">//Input: head = [1,2,3,4,5]</span>    <span class="hljs-comment">//Output: [5,4,3,2,1]</span>    <span class="hljs-comment">//</span>    <span class="hljs-comment">// Example 2:</span>    <span class="hljs-comment">//Input: head = [1,2]</span>    <span class="hljs-comment">//Output: [2,1]</span>    <span class="hljs-comment">//</span>    <span class="hljs-comment">// Example 3:</span>    <span class="hljs-comment">//Input: head = []</span>    <span class="hljs-comment">//Output: []</span>    <span class="hljs-comment">//</span>    <span class="hljs-comment">// Constraints:</span>    <span class="hljs-comment">// The number of nodes in the list is the range [0, 5000].</span>    <span class="hljs-comment">// -5000 &lt;= Node.val &lt;= 5000</span>    <span class="hljs-comment">//</span>    <span class="hljs-comment">// Follow up: A linked list can be reversed either iteratively or recursively. C</span>    <span class="hljs-comment">//ould you implement both?</span>    <span class="hljs-comment">// Related Topics 链表</span>    <span class="hljs-comment">// 👍 1568 👎 0</span>     <span class="hljs-comment">//leetcode submit region begin(Prohibit modification and deletion)</span>    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Definition for singly-linked list.</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListNode</span> </span>&#123;        <span class="hljs-keyword">int</span> val;        ListNode next;        ListNode() &#123;&#125;        ListNode(<span class="hljs-keyword">int</span> val) &#123; <span class="hljs-keyword">this</span>.val = val; &#125;        ListNode(<span class="hljs-keyword">int</span> val, ListNode next) &#123; <span class="hljs-keyword">this</span>.val = val; <span class="hljs-keyword">this</span>.next = next; &#125;    &#125;    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;        <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode head)</span> </span>&#123;            ListNode pre = <span class="hljs-keyword">null</span>, cur = head, next = <span class="hljs-keyword">null</span>;            <span class="hljs-keyword">while</span> (cur != <span class="hljs-keyword">null</span>) &#123;                next = cur.next;                cur.next = pre;                pre = cur;                cur = next;            &#125;            <span class="hljs-keyword">return</span> pre;        &#125;    &#125;<span class="hljs-comment">//leetcode submit region end(Prohibit modification and deletion)</span>&#125;</code></pre><p><code>Golang</code></p><pre><code class="hljs Golang"><span class="hljs-keyword">package</span> leetcode<span class="hljs-comment">/**</span><span class="hljs-comment"> * Author: Wang P</span><span class="hljs-comment"> * Version: 1.0.0</span><span class="hljs-comment"> * Date: 2021-03-05 17:46:07</span><span class="hljs-comment"> * Description: //Given the head of a singly linked list, reverse the list, and return the reversed list.</span><span class="hljs-comment">// Example 1:</span><span class="hljs-comment">//Input: head = [1,2,3,4,5]</span><span class="hljs-comment">//Output: [5,4,3,2,1]</span><span class="hljs-comment">//</span><span class="hljs-comment">// Example 2:</span><span class="hljs-comment">//Input: head = [1,2]</span><span class="hljs-comment">//Output: [2,1]</span><span class="hljs-comment">//</span><span class="hljs-comment">// Example 3:</span><span class="hljs-comment">//Input: head = []</span><span class="hljs-comment">//Output: []</span><span class="hljs-comment">//</span><span class="hljs-comment">// Constraints:</span><span class="hljs-comment">// The number of nodes in the list is the range [0, 5000].</span><span class="hljs-comment">// -5000 &lt;= Node.val &lt;= 5000</span><span class="hljs-comment">//</span><span class="hljs-comment">// Follow up: A linked list can be reversed either iteratively or recursively. C</span><span class="hljs-comment">//ould you implement both?</span><span class="hljs-comment">// Related Topics 链表</span><span class="hljs-comment">// 👍 1568 👎 0</span><span class="hljs-comment"> **/</span><span class="hljs-comment">//leetcode submit region begin(Prohibit modification and deletion)</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for singly-linked list.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">type</span> ListNode <span class="hljs-keyword">struct</span> &#123;Val <span class="hljs-keyword">int</span>Next *ListNode&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverseList</span><span class="hljs-params">(head *ListNode)</span> *<span class="hljs-title">ListNode</span></span> &#123;<span class="hljs-keyword">var</span> pre, cur, next *ListNode = <span class="hljs-literal">nil</span>, head, <span class="hljs-literal">nil</span><span class="hljs-keyword">for</span> cur != <span class="hljs-literal">nil</span> &#123;next = cur.Nextcur.Next = prepre = curcur = next&#125;<span class="hljs-keyword">return</span> pre&#125;<span class="hljs-comment">//leetcode submit region end(Prohibit modification and deletion)</span></code></pre><p><code>Python</code></p><pre><code class="hljs Python"><span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">Module Description: 206-反转链表</span><span class="hljs-string">Solution：</span><span class="hljs-string">Date: 2021-03-05 17:45:14</span><span class="hljs-string">Author: Wang P</span><span class="hljs-string">Problem:# 反转一个单链表。 </span><span class="hljs-string">        #</span><span class="hljs-string">        #  示例:</span><span class="hljs-string">        #</span><span class="hljs-string">        #  输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><span class="hljs-string">        # 输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</span><span class="hljs-string">        #</span><span class="hljs-string">        #  进阶:</span><span class="hljs-string">        # 你可以迭代或递归地反转链表。你能否用两种方法解决这道题？</span><span class="hljs-string">        #  Related Topics 链表</span><span class="hljs-string">        #  👍 1568 👎 0</span><span class="hljs-string"></span><span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-comment"># leetcode submit region begin(Prohibit modification and deletion)</span><span class="hljs-comment"># Definition for singly-linked list.</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListNode</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, val=<span class="hljs-number">0</span>, <span class="hljs-built_in">next</span>=<span class="hljs-literal">None</span></span>):</span>        self.val = val        self.<span class="hljs-built_in">next</span> = <span class="hljs-built_in">next</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reverseList</span>(<span class="hljs-params">self, head: ListNode</span>) -&gt; ListNode:</span>        pre, cur, nex = <span class="hljs-literal">None</span>, head, <span class="hljs-literal">None</span>        <span class="hljs-keyword">while</span> cur:            nex = cur.<span class="hljs-built_in">next</span>            cur.<span class="hljs-built_in">next</span> = pre            pre = cur            cur = nex        <span class="hljs-keyword">return</span> pre<span class="hljs-comment"># leetcode submit region end(Prohibit modification and deletion)</span></code></pre><h6 id="92-反转链表-II"><a href="#92-反转链表-II" class="headerlink" title="92. 反转链表 II"></a><a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/">92. 反转链表 II</a></h6><p>反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。</p><p>说明:<br>1 ≤ m ≤ n ≤ 链表长度。</p><p>示例:</p><pre><code class="hljs angelscript">输入: <span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">5</span>-&gt;NULL, m = <span class="hljs-number">2</span>, n = <span class="hljs-number">4</span>输出: <span class="hljs-number">1</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">5</span>-&gt;NULL</code></pre><p>解题思路</p><pre><code class="hljs angelscript"><span class="hljs-number">1.</span>先通过虚拟节点找到链表反转部分的头部<span class="hljs-number">2.</span>从反转部分的头部，反转n-m+<span class="hljs-number">1</span>个<span class="hljs-number">3.</span>将反转后的部分拼接上</code></pre><p><code>Java</code></p><pre><code class="hljs Java"><span class="hljs-comment">/*</span><span class="hljs-comment"> * Author: Wang P</span><span class="hljs-comment"> * Version: 1.0.0</span><span class="hljs-comment"> * Date: 2021-03-05 19:05:32</span><span class="hljs-comment"> * Description: 92-Reverse Linked List II</span><span class="hljs-comment"> **/</span> <span class="hljs-keyword">package</span> com.weitrue.leetcode.editor.cn;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReverseLinkedListIi</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;        Solution s = <span class="hljs-keyword">new</span> ReverseLinkedListIi().<span class="hljs-function">new <span class="hljs-title">Solution</span><span class="hljs-params">()</span></span>;        ListNode n5 = <span class="hljs-keyword">new</span> ReverseLinkedListIi().<span class="hljs-function">new <span class="hljs-title">ListNode</span><span class="hljs-params">(<span class="hljs-number">5</span>, <span class="hljs-keyword">null</span>)</span></span>;        ListNode n4 = <span class="hljs-keyword">new</span> ReverseLinkedListIi().<span class="hljs-function">new <span class="hljs-title">ListNode</span><span class="hljs-params">(<span class="hljs-number">4</span>, n5)</span></span>;        ListNode n3 = <span class="hljs-keyword">new</span> ReverseLinkedListIi().<span class="hljs-function">new <span class="hljs-title">ListNode</span><span class="hljs-params">(<span class="hljs-number">3</span>, n4)</span></span>;        ListNode n2 = <span class="hljs-keyword">new</span> ReverseLinkedListIi().<span class="hljs-function">new <span class="hljs-title">ListNode</span><span class="hljs-params">(<span class="hljs-number">2</span>, n3)</span></span>;        ListNode n1 = <span class="hljs-keyword">new</span> ReverseLinkedListIi().<span class="hljs-function">new <span class="hljs-title">ListNode</span><span class="hljs-params">(<span class="hljs-number">1</span>, n2)</span></span>;        ListNode n = s.reverseBetween(n1, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>);        <span class="hljs-keyword">while</span> (n != <span class="hljs-keyword">null</span> &amp;&amp; n.val &gt; <span class="hljs-number">0</span>) &#123;            System.out.print(n.val);            System.out.print(<span class="hljs-string">&quot;-&gt;&quot;</span>);            n = n.next;        &#125;    &#125;        <span class="hljs-comment">//Given the head of a singly linked list and two integers left and right where left &lt;= right,</span>    <span class="hljs-comment">// reverse the nodes of the list from position left to position right, and return the reversed list.</span>    <span class="hljs-comment">//</span>    <span class="hljs-comment">// Example 1:</span>    <span class="hljs-comment">//Input: head = [1,2,3,4,5], left = 2, right = 4</span>    <span class="hljs-comment">//Output: [1,4,3,2,5]</span>    <span class="hljs-comment">//</span>    <span class="hljs-comment">// Example 2:</span>    <span class="hljs-comment">//Input: head = [5], left = 1, right = 1</span>    <span class="hljs-comment">//Output: [5]</span>    <span class="hljs-comment">//</span>    <span class="hljs-comment">// Constraints:</span>    <span class="hljs-comment">// The number of nodes in the list is n.</span>    <span class="hljs-comment">// 1 &lt;= n &lt;= 500</span>    <span class="hljs-comment">// -500 &lt;= Node.val &lt;= 500</span>    <span class="hljs-comment">// 1 &lt;= left &lt;= right &lt;= n</span>    <span class="hljs-comment">//</span>    <span class="hljs-comment">//Follow up: Could you do it in one pass? Related Topics 链表</span>    <span class="hljs-comment">// 👍 709 👎 0</span>     <span class="hljs-comment">//leetcode submit region begin(Prohibit modification and deletion)</span>    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Definition for singly-linked list.</span><span class="hljs-comment">     */</span>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListNode</span> </span>&#123;        <span class="hljs-keyword">int</span> val;        ListNode next;        ListNode() &#123;&#125;        ListNode(<span class="hljs-keyword">int</span> val) &#123; <span class="hljs-keyword">this</span>.val = val; &#125;        ListNode(<span class="hljs-keyword">int</span> val, ListNode next) &#123; <span class="hljs-keyword">this</span>.val = val; <span class="hljs-keyword">this</span>.next = next; &#125;    &#125;    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;        <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">reverseBetween</span><span class="hljs-params">(ListNode head, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;            <span class="hljs-comment">// 需要虚拟节点</span>            ListNode hair = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>, head), cur = hair ;            <span class="hljs-keyword">int</span> n = right - left + <span class="hljs-number">1</span>;            <span class="hljs-keyword">while</span> (left &gt; <span class="hljs-number">1</span>) &#123;                cur = cur.next;                left--;            &#125;            cur.next = reverse(cur.next, n);            <span class="hljs-keyword">return</span> hair.next;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">reverse</span><span class="hljs-params">(ListNode head, <span class="hljs-keyword">int</span> x)</span> </span>&#123;            <span class="hljs-comment">// 从头节点开始，反转n个节点</span>            ListNode pre = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>), cur = head, next = <span class="hljs-keyword">null</span>;            <span class="hljs-keyword">while</span> (x &gt; <span class="hljs-number">0</span>) &#123;                next = cur.next;                cur.next = pre.next;                pre.next = cur;                cur = next;                x--;            &#125;            head.next = cur;            <span class="hljs-keyword">return</span> pre.next;        &#125;            <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">reverseN</span><span class="hljs-params">(ListNode head, <span class="hljs-keyword">int</span> n)</span> </span>&#123;            <span class="hljs-comment">// 递归方式</span>            <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;                <span class="hljs-keyword">return</span> head;            &#125;            ListNode tail = head.next, p = reverseN(head.next, n-<span class="hljs-number">1</span>);            head.next = tail.next;            tail.next = head;            <span class="hljs-keyword">return</span> p;        &#125;    &#125;    <span class="hljs-comment">//leetcode submit region end(Prohibit modification and deletion)</span>&#125;</code></pre><p><code>Golang</code></p><pre><code class="hljs Golang"><span class="hljs-keyword">package</span> leetcode<span class="hljs-comment">/**</span><span class="hljs-comment"> * Author: Wang P</span><span class="hljs-comment"> * Version: 1.0.0</span><span class="hljs-comment"> * Date: 2021-03-05 19:07:45</span><span class="hljs-comment"> * Description: //Given the head of a singly linked list and two integers left and right where left &lt;= right, reverse</span><span class="hljs-comment">                //the nodes of the list from position left to position right, and return the reversed list.</span><span class="hljs-comment">//</span><span class="hljs-comment">// Example 1:</span><span class="hljs-comment">//Input: head = [1,2,3,4,5], left = 2, right = 4</span><span class="hljs-comment">//Output: [1,4,3,2,5]</span><span class="hljs-comment">//</span><span class="hljs-comment">// Example 2:</span><span class="hljs-comment">//Input: head = [5], left = 1, right = 1</span><span class="hljs-comment">//Output: [5]</span><span class="hljs-comment">//</span><span class="hljs-comment">// Constraints:</span><span class="hljs-comment">// The number of nodes in the list is n.</span><span class="hljs-comment">// 1 &lt;= n &lt;= 500</span><span class="hljs-comment">// -500 &lt;= Node.val &lt;= 500</span><span class="hljs-comment">// 1 &lt;= left &lt;= right &lt;= n</span><span class="hljs-comment">//Follow up: Could you do it in one pass? Related Topics 链表</span><span class="hljs-comment">// 👍 709 👎 0</span><span class="hljs-comment"></span><span class="hljs-comment"> **/</span><span class="hljs-comment">//leetcode submit region begin(Prohibit modification and deletion)</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for singly-linked list.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">type</span> ListNode <span class="hljs-keyword">struct</span> &#123;Val <span class="hljs-keyword">int</span>Next *ListNode&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverseBetween</span><span class="hljs-params">(head *ListNode, left <span class="hljs-keyword">int</span>, right <span class="hljs-keyword">int</span>)</span> *<span class="hljs-title">ListNode</span></span> &#123;hair := &amp;ListNode&#123;Next:head&#125;cur := hairn := right - left + <span class="hljs-number">1</span><span class="hljs-keyword">for</span> left &gt; <span class="hljs-number">1</span> &#123;cur = cur.Nextleft--&#125;cur.Next = reverse(cur.Next, n)<span class="hljs-keyword">return</span> hair.Next&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverse</span><span class="hljs-params">(head *ListNode, n <span class="hljs-keyword">int</span>)</span> *<span class="hljs-title">ListNode</span></span> &#123;pre, next := &amp;ListNode&#123;&#125;, &amp;ListNode&#123;&#125;cur := head<span class="hljs-keyword">for</span> n &gt; <span class="hljs-number">0</span> &#123;next = cur.Nextcur.Next = pre.Nextpre.Next = curcur = nextn--&#125;head.Next = cur<span class="hljs-keyword">return</span> pre.Next&#125;<span class="hljs-comment">//leetcode submit region end(Prohibit modification and deletion)</span></code></pre><p><code>Python</code></p><pre><code class="hljs Python"><span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">Module Description: 92-反转链表 II</span><span class="hljs-string">Solution：</span><span class="hljs-string">Date: 2021-03-05 19:06:58</span><span class="hljs-string">Author: Wang P</span><span class="hljs-string">Problem:# 反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。 </span><span class="hljs-string">        #</span><span class="hljs-string">        #  说明:</span><span class="hljs-string">        # 1 ≤ m ≤ n ≤ 链表长度。</span><span class="hljs-string">        #</span><span class="hljs-string">        #  示例:</span><span class="hljs-string">        #</span><span class="hljs-string">        #  输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4</span><span class="hljs-string">        # 输出: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL</span><span class="hljs-string">        #  Related Topics 链表</span><span class="hljs-string">        #  👍 709 👎 0</span><span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-comment"># leetcode submit region begin(Prohibit modification and deletion)</span><span class="hljs-comment"># Definition for singly-linked list.</span><span class="hljs-comment"># class ListNode:</span><span class="hljs-comment">#     def __init__(self, val=0, next=None):</span><span class="hljs-comment">#         self.val = val</span><span class="hljs-comment">#         self.next = next</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reverseBetween</span>(<span class="hljs-params">self, head: ListNode, left: <span class="hljs-built_in">int</span>, right: <span class="hljs-built_in">int</span></span>) -&gt; ListNode:</span>        cur = hair = ListNode(<span class="hljs-built_in">next</span>=head)        n = right - left + <span class="hljs-number">1</span>        <span class="hljs-keyword">while</span> left &gt; <span class="hljs-number">1</span>:            cur = cur.<span class="hljs-built_in">next</span>            left -= <span class="hljs-number">1</span>        cur.<span class="hljs-built_in">next</span> = self.reverse(cur.<span class="hljs-built_in">next</span>, n)        <span class="hljs-keyword">return</span> hair.<span class="hljs-built_in">next</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reverse</span>(<span class="hljs-params">self, head: ListNode, n: <span class="hljs-built_in">int</span></span>) -&gt; ListNode:</span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> head:            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>        pre, cur, nex = ListNode(), head, <span class="hljs-literal">None</span>        <span class="hljs-keyword">while</span> n &gt; <span class="hljs-number">0</span>:            nex = cur.<span class="hljs-built_in">next</span>            cur.<span class="hljs-built_in">next</span> = pre.<span class="hljs-built_in">next</span>            pre.<span class="hljs-built_in">next</span> = cur            cur = nex            n -= <span class="hljs-number">1</span>        head.<span class="hljs-built_in">next</span> = cur        <span class="hljs-keyword">return</span> pre.<span class="hljs-built_in">next</span><span class="hljs-comment"># leetcode submit region end(Prohibit modification and deletion)</span></code></pre><h6 id="25-K-个一组翻转链表"><a href="#25-K-个一组翻转链表" class="headerlink" title="25. K 个一组翻转链表"></a><a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/">25. K 个一组翻转链表</a></h6><p>给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。</p><p>k 是一个正整数，它的值小于或等于链表的长度。</p><p>如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。</p><p>进阶：</p><p>你可以设计一个只使用常数额外空间的算法来解决此问题吗？<br>你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。</p><p><strong>示例 1</strong>：</p><p><img src="https://assets.leetcode.com/uploads/2020/10/03/reverse_ex1.jpg"></p><pre><code class="hljs angelscript">输入：head = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>], k = <span class="hljs-number">2</span>输出：[<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>]</code></pre><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/03/reverse_ex2.jpg"></p><pre><code class="hljs angelscript">输入：head = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>], k = <span class="hljs-number">3</span>输出：[<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]</code></pre><p><strong>示例 3：</strong></p><pre><code class="hljs angelscript">输入：head = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>], k = <span class="hljs-number">1</span>输出：[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]</code></pre><p><strong>示例 4：</strong></p><pre><code class="hljs angelscript">输入：head = [<span class="hljs-number">1</span>], k = <span class="hljs-number">1</span>输出：[<span class="hljs-number">1</span>]</code></pre><p><strong>提示：</strong></p><ul><li>列表中节点的数量在范围 <code>sz</code> 内</li><li><code>1 &lt;= sz &lt;= 5000</code></li><li><code>0 &lt;= Node.val &lt;= 1000</code></li><li><code>1 &lt;= k &lt;= sz</code></li></ul><p>解题思路</p><pre><code class="hljs cos">将链表分成sz<span class="hljs-built_in">%k</span>链表进行反转，然后拼接末尾部分</code></pre><p><code>Java</code></p><pre><code class="hljs Java"><span class="hljs-comment">/*</span><span class="hljs-comment"> * Author: Wang P</span><span class="hljs-comment"> * Version: 1.0.0</span><span class="hljs-comment"> * Date: 2021-03-06 17:42:34</span><span class="hljs-comment"> * Description: 25-Reverse Nodes in k-Group</span><span class="hljs-comment"> **/</span> <span class="hljs-keyword">package</span> com.weitrue.leetcode.editor.cn;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReverseNodesInKGroup</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;        Solution s = <span class="hljs-keyword">new</span> ReverseNodesInKGroup().<span class="hljs-function">new <span class="hljs-title">Solution</span><span class="hljs-params">()</span></span>;    &#125;        <span class="hljs-comment">//Given a linked list, reverse the nodes of a linked list k at a time and return its modified list. </span>    <span class="hljs-comment">//k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes, in the end, should remain as it is. </span>    <span class="hljs-comment">// Follow up: </span>    <span class="hljs-comment">// Could you solve the problem in O(1) extra memory space? </span>    <span class="hljs-comment">// You may not alter the values in the list&#x27;s nodes, only nodes itself may be changed. </span>     <span class="hljs-comment">// Example 1: </span>    <span class="hljs-comment">//Input: head = [1,2,3,4,5], k = 2</span>    <span class="hljs-comment">//Output: [2,1,4,3,5]</span>    <span class="hljs-comment">// Example 2: </span>    <span class="hljs-comment">//Input: head = [1,2,3,4,5], k = 3</span>    <span class="hljs-comment">//Output: [3,2,1,4,5]</span>    <span class="hljs-comment">// Example 3: </span>    <span class="hljs-comment">//Input: head = [1,2,3,4,5], k = 1</span>    <span class="hljs-comment">//Output: [1,2,3,4,5]</span>    <span class="hljs-comment">// Example 4: </span>    <span class="hljs-comment">//Input: head = [1], k = 1</span>    <span class="hljs-comment">//Output: [1]</span>    <span class="hljs-comment">// Constraints: </span>    <span class="hljs-comment">// The number of nodes in the list is in the range sz. </span>    <span class="hljs-comment">// 1 &lt;= sz &lt;= 5000 </span>    <span class="hljs-comment">// 0 &lt;= Node.val &lt;= 1000 </span>    <span class="hljs-comment">// 1 &lt;= k &lt;= sz </span>    <span class="hljs-comment">// </span>    <span class="hljs-comment">// Related Topics 链表 </span>    <span class="hljs-comment">// 👍 977 👎 0</span>     <span class="hljs-comment">//leetcode submit region begin(Prohibit modification and deletion)</span>    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Definition for singly-linked list.</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListNode</span> </span>&#123;        <span class="hljs-keyword">int</span> val;        ListNode next;        ListNode() &#123;&#125;        ListNode(<span class="hljs-keyword">int</span> val) &#123; <span class="hljs-keyword">this</span>.val = val; &#125;        ListNode(<span class="hljs-keyword">int</span> val, ListNode next) &#123; <span class="hljs-keyword">this</span>.val = val; <span class="hljs-keyword">this</span>.next = next; &#125;    &#125;    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;        <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">reverseKGroup</span><span class="hljs-params">(ListNode head, <span class="hljs-keyword">int</span> k)</span> </span>&#123;            ListNode hair = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>, head), pre = hair, tail = pre;            <span class="hljs-keyword">while</span> (head != <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-comment">//tail = pre;</span>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;k; i++) &#123;                    tail = tail.next;                    <span class="hljs-keyword">if</span> (tail == <span class="hljs-keyword">null</span>) &#123;                        <span class="hljs-keyword">return</span> hair.next;                    &#125;                &#125;                <span class="hljs-comment">// 反转长度为k的链表，并返回链表的新头尾节点</span>                ListNode[] ln = reverse(head, tail);                head = ln[<span class="hljs-number">0</span>];                tail = ln[<span class="hljs-number">1</span>];                pre.next = head;                pre = tail;                head = pre.next;            &#125;            <span class="hljs-keyword">return</span> hair.next;        &#125;        <span class="hljs-keyword">public</span> ListNode[] reverse(ListNode head, ListNode tail)&#123;            ListNode pre = tail.next, cur = head, next = <span class="hljs-keyword">null</span>;            <span class="hljs-keyword">while</span> (tail != pre) &#123;                next = cur.next;                cur.next = pre;                pre = cur;                cur = next;            &#125;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ListNode[]&#123;tail, head&#125;;        &#125;    &#125;<span class="hljs-comment">//leetcode submit region end(Prohibit modification and deletion)</span>&#125;</code></pre><p><code>Golang</code></p><pre><code class="hljs Golang"><span class="hljs-keyword">package</span> leetcode<span class="hljs-comment">/**</span><span class="hljs-comment"> * Author: Wang P</span><span class="hljs-comment"> * Version: 1.0.0</span><span class="hljs-comment"> * Date: 2021-03-18 18:38:00</span><span class="hljs-comment"> * Description: //Given a linked list, reverse the nodes of a linked list k at a time and return its modified list.</span><span class="hljs-comment">// k is a positive integer and is less than or equal to the length of the linked</span><span class="hljs-comment">// list. If the number of nodes is not a multiple of k then left-out nodes, in the</span><span class="hljs-comment">// end, should remain as it is.</span><span class="hljs-comment">// Follow up:</span><span class="hljs-comment">// Could you solve the problem in O(1) extra memory space?</span><span class="hljs-comment">// You may not alter the values in the list&#x27;s nodes, only nodes itself may be changed.</span><span class="hljs-comment">//</span><span class="hljs-comment">// Example 1:</span><span class="hljs-comment">//Input: head = [1,2,3,4,5], k = 2</span><span class="hljs-comment">//Output: [2,1,4,3,5]</span><span class="hljs-comment">//</span><span class="hljs-comment">// Example 2:</span><span class="hljs-comment">//Input: head = [1,2,3,4,5], k = 3</span><span class="hljs-comment">//Output: [3,2,1,4,5]</span><span class="hljs-comment">//</span><span class="hljs-comment">// Example 3:</span><span class="hljs-comment">//Input: head = [1,2,3,4,5], k = 1</span><span class="hljs-comment">//Output: [1,2,3,4,5]</span><span class="hljs-comment">//</span><span class="hljs-comment">// Example 4:</span><span class="hljs-comment">//Input: head = [1], k = 1</span><span class="hljs-comment">//Output: [1]</span><span class="hljs-comment">//</span><span class="hljs-comment">// Constraints:</span><span class="hljs-comment">// The number of nodes in the list is in the range sz.</span><span class="hljs-comment">// 1 &lt;= sz &lt;= 5000</span><span class="hljs-comment">// 0 &lt;= Node.val &lt;= 1000</span><span class="hljs-comment">// 1 &lt;= k &lt;= sz</span><span class="hljs-comment">// Related Topics 链表</span><span class="hljs-comment">// 👍 977 👎 0</span><span class="hljs-comment"></span><span class="hljs-comment"> **/</span><span class="hljs-comment">//leetcode submit region begin(Prohibit modification and deletion)</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for singly-linked list.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">type</span> ListNode <span class="hljs-keyword">struct</span> &#123;    Val <span class="hljs-keyword">int</span>    Next *ListNode&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverseKGroup</span><span class="hljs-params">(head *ListNode, k <span class="hljs-keyword">int</span>)</span> *<span class="hljs-title">ListNode</span></span> &#123;hair := &amp;ListNode&#123;Next:head&#125;pre, tail := hair, hair<span class="hljs-keyword">for</span> head != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; k; i++ &#123;tail = tail.Next<span class="hljs-keyword">if</span> tail == <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> hair.Next&#125;&#125;head, tail = reverseK(head, tail)pre.Next = headpre = tailhead = pre.Next&#125;<span class="hljs-keyword">return</span> hair.Next&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverseK</span><span class="hljs-params">(head, tail *ListNode)</span> <span class="hljs-params">(*ListNode, *ListNode)</span></span> &#123;pre, cur, next := tail.Next, head, &amp;ListNode&#123;&#125;<span class="hljs-keyword">for</span> pre != tail &#123;next = cur.Nextcur.Next = prepre = curcur = next&#125;<span class="hljs-keyword">return</span> tail, head&#125;<span class="hljs-comment">//leetcode submit region end(Prohibit modification and deletion)</span></code></pre><p><code>Python</code></p><pre><code class="hljs Python"><span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">Module Description: 25-K 个一组翻转链表</span><span class="hljs-string">Solution：</span><span class="hljs-string">Date: 2021-03-06 18:15:19</span><span class="hljs-string">Author: Wang P</span><span class="hljs-string">Problem:# 给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。 </span><span class="hljs-string">        #  k 是一个正整数，它的值小于或等于链表的长度。</span><span class="hljs-string">        #  如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。</span><span class="hljs-string">        #  进阶：</span><span class="hljs-string">        #  你可以设计一个只使用常数额外空间的算法来解决此问题吗？</span><span class="hljs-string">        #  你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。</span><span class="hljs-string">        #</span><span class="hljs-string">        #  示例 1：</span><span class="hljs-string">        # 输入：head = [1,2,3,4,5], k = 2</span><span class="hljs-string">        # 输出：[2,1,4,3,5]</span><span class="hljs-string">        #</span><span class="hljs-string">        #  示例 2：</span><span class="hljs-string">        # 输入：head = [1,2,3,4,5], k = 3</span><span class="hljs-string">        # 输出：[3,2,1,4,5]</span><span class="hljs-string">        #</span><span class="hljs-string">        #  示例 3：</span><span class="hljs-string">        # 输入：head = [1,2,3,4,5], k = 1</span><span class="hljs-string">        # 输出：[1,2,3,4,5]</span><span class="hljs-string">        #</span><span class="hljs-string">        #  示例 4：</span><span class="hljs-string">        # 输入：head = [1], k = 1</span><span class="hljs-string">        # 输出：[1]</span><span class="hljs-string">        #</span><span class="hljs-string">        #  提示：</span><span class="hljs-string">        #  列表中节点的数量在范围 sz 内</span><span class="hljs-string">        #  1 &lt;= sz &lt;= 5000</span><span class="hljs-string">        #  0 &lt;= Node.val &lt;= 1000</span><span class="hljs-string">        #  1 &lt;= k &lt;= sz</span><span class="hljs-string">        #</span><span class="hljs-string">        #  Related Topics 链表</span><span class="hljs-string">        #  👍 977 👎 0</span><span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-comment"># leetcode submit region begin(Prohibit modification and deletion)</span><span class="hljs-comment"># Definition for singly-linked list.</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListNode</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, val=<span class="hljs-number">0</span>, <span class="hljs-built_in">next</span>=<span class="hljs-literal">None</span></span>):</span>        self.val = val        self.<span class="hljs-built_in">next</span> = <span class="hljs-built_in">next</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reverseKGroup</span>(<span class="hljs-params">self, head: ListNode, k: <span class="hljs-built_in">int</span></span>) -&gt; ListNode:</span>        tail = pre = hair = ListNode(<span class="hljs-built_in">next</span>=head)        <span class="hljs-keyword">while</span> head:            <span class="hljs-comment"># tail = pre</span>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, k):                tail = tail.<span class="hljs-built_in">next</span>                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> tail:                    <span class="hljs-keyword">return</span> hair.<span class="hljs-built_in">next</span>            head, tail = self.reverse(head, tail)            pre.<span class="hljs-built_in">next</span> = head            pre = tail            head = pre.<span class="hljs-built_in">next</span>        <span class="hljs-keyword">return</span> hair.<span class="hljs-built_in">next</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reverse</span>(<span class="hljs-params">self, head, tail: ListNode</span>) -&gt; (ListNode, ListNode):</span>        pre, cur, nex = tail.<span class="hljs-built_in">next</span>, head, <span class="hljs-literal">None</span>        <span class="hljs-keyword">while</span> pre != tail:            nex = cur.<span class="hljs-built_in">next</span>            cur.<span class="hljs-built_in">next</span> = pre            pre = cur            cur = nex        <span class="hljs-keyword">return</span> tail, head<span class="hljs-comment"># leetcode submit region end(Prohibit modification and deletion)</span></code></pre><h6 id="61-旋转链表"><a href="#61-旋转链表" class="headerlink" title="61. 旋转链表"></a><a href="https://leetcode-cn.com/problems/rotate-list/">61. 旋转链表</a></h6><p>给定一个链表，旋转链表，将链表每个节点向右移动 <em>k</em> 个位置，其中 <em>k</em> 是非负数。</p><p><strong>示例 1:</strong></p><pre><code class="hljs angelscript">输入: <span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">5</span>-&gt;NULL, k = <span class="hljs-number">2</span>输出: <span class="hljs-number">4</span>-&gt;<span class="hljs-number">5</span>-&gt;<span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>-&gt;NULL解释:向右旋转 <span class="hljs-number">1</span> 步: <span class="hljs-number">5</span>-&gt;<span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>-&gt;NULL向右旋转 <span class="hljs-number">2</span> 步: <span class="hljs-number">4</span>-&gt;<span class="hljs-number">5</span>-&gt;<span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>-&gt;NULL</code></pre><p><strong>示例 2:</strong></p><pre><code class="hljs angelscript">输入: <span class="hljs-number">0</span>-&gt;<span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;NULL, k = <span class="hljs-number">4</span>输出: <span class="hljs-number">2</span>-&gt;<span class="hljs-number">0</span>-&gt;<span class="hljs-number">1</span>-&gt;NULL解释:向右旋转 <span class="hljs-number">1</span> 步: <span class="hljs-number">2</span>-&gt;<span class="hljs-number">0</span>-&gt;<span class="hljs-number">1</span>-&gt;NULL向右旋转 <span class="hljs-number">2</span> 步: <span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">0</span>-&gt;NULL向右旋转 <span class="hljs-number">3</span> 步: <span class="hljs-number">0</span>-&gt;<span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;NULL向右旋转 <span class="hljs-number">4</span> 步: <span class="hljs-number">2</span>-&gt;<span class="hljs-number">0</span>-&gt;<span class="hljs-number">1</span>-&gt;NULL</code></pre><p>解题思路</p><pre><code class="hljs angelscript"><span class="hljs-number">1.</span>先将链表首尾相连并获取链表的长度<span class="hljs-number">2.</span>找到新链表要断开的前一个节点，后继指向<span class="hljs-literal">null</span></code></pre><p><code>Java</code></p><pre><code class="hljs Java"><span class="hljs-comment">/*</span><span class="hljs-comment"> * Author: Wang P</span><span class="hljs-comment"> * Version: 1.0.0</span><span class="hljs-comment"> * Date: 2021-03-06 20:20:15</span><span class="hljs-comment"> * Description: 61-Rotate List</span><span class="hljs-comment"> **/</span> <span class="hljs-keyword">package</span> com.weitrue.leetcode.editor.cn;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RotateList</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;        Solution s = <span class="hljs-keyword">new</span> RotateList().<span class="hljs-function">new <span class="hljs-title">Solution</span><span class="hljs-params">()</span></span>;        ListNode n5 = <span class="hljs-keyword">new</span> RotateList().<span class="hljs-function">new <span class="hljs-title">ListNode</span><span class="hljs-params">(<span class="hljs-number">5</span>, <span class="hljs-keyword">null</span>)</span></span>;        ListNode n4 = <span class="hljs-keyword">new</span> RotateList().<span class="hljs-function">new <span class="hljs-title">ListNode</span><span class="hljs-params">(<span class="hljs-number">4</span>, n5)</span></span>;        ListNode n3 = <span class="hljs-keyword">new</span> RotateList().<span class="hljs-function">new <span class="hljs-title">ListNode</span><span class="hljs-params">(<span class="hljs-number">3</span>, n4)</span></span>;        ListNode n2 = <span class="hljs-keyword">new</span> RotateList().<span class="hljs-function">new <span class="hljs-title">ListNode</span><span class="hljs-params">(<span class="hljs-number">2</span>, n3)</span></span>;        ListNode n1 = <span class="hljs-keyword">new</span> RotateList().<span class="hljs-function">new <span class="hljs-title">ListNode</span><span class="hljs-params">(<span class="hljs-number">1</span>, n2)</span></span>;        ListNode n = s.rotateRight(n1, <span class="hljs-number">2</span>);        <span class="hljs-keyword">while</span> (n != <span class="hljs-keyword">null</span>) &#123;            System.out.print(n.val);            System.out.print(<span class="hljs-string">&quot;-&gt;&quot;</span>);            n = n.next;        &#125;    &#125;        <span class="hljs-comment">//Given the head of a linked list, rotate the list to the right by k places. </span>    <span class="hljs-comment">//</span>    <span class="hljs-comment">// Example 1:</span>    <span class="hljs-comment">//Input: head = [1,2,3,4,5], k = 2</span>    <span class="hljs-comment">//Output: [4,5,1,2,3]</span>    <span class="hljs-comment">//</span>    <span class="hljs-comment">// Example 2:</span>    <span class="hljs-comment">//Input: head = [0,1,2], k = 4</span>    <span class="hljs-comment">//Output: [2,0,1]</span>    <span class="hljs-comment">//</span>    <span class="hljs-comment">// Constraints:</span>    <span class="hljs-comment">// The number of nodes in the list is in the range [0, 500].</span>    <span class="hljs-comment">// -100 &lt;= Node.val &lt;= 100</span>    <span class="hljs-comment">// 0 &lt;= k &lt;= 2 * 109</span>    <span class="hljs-comment">//</span>    <span class="hljs-comment">// Related Topics 链表 双指针</span>    <span class="hljs-comment">// 👍 444 👎 0</span>    <span class="hljs-comment">//leetcode submit region begin(Prohibit modification and deletion)</span>    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Definition for singly-linked list.</span><span class="hljs-comment">     */</span>     <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListNode</span> </span>&#123;         <span class="hljs-keyword">int</span> val;         ListNode next;         ListNode() &#123;&#125;         ListNode(<span class="hljs-keyword">int</span> val) &#123; <span class="hljs-keyword">this</span>.val = val; &#125;         ListNode(<span class="hljs-keyword">int</span> val, ListNode next) &#123; <span class="hljs-keyword">this</span>.val = val; <span class="hljs-keyword">this</span>.next = next; &#125;     &#125;    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;        <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">rotateRight</span><span class="hljs-params">(ListNode head, <span class="hljs-keyword">int</span> k)</span> </span>&#123;            <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span> || head.next == <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-keyword">return</span> head;            &#125;            <span class="hljs-keyword">int</span> length = <span class="hljs-number">1</span>;            ListNode oldTail = head;            <span class="hljs-keyword">while</span> (oldTail.next != <span class="hljs-keyword">null</span>) &#123;                oldTail = oldTail.next;                length++;            &#125;            oldTail.next = head;            ListNode newTail = head;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; length - (k % length) - <span class="hljs-number">1</span>; i++)&#123;                newTail = newTail.next;            &#125;            ListNode newHead = newTail.next;            newTail.next = <span class="hljs-keyword">null</span>;            <span class="hljs-keyword">return</span> newHead;        &#125;    &#125;    <span class="hljs-comment">//leetcode submit region end(Prohibit modification and deletion)</span>&#125;</code></pre><p><code>Golang</code></p><pre><code class="hljs Golang"><span class="hljs-keyword">package</span> leetcode<span class="hljs-comment">/**</span><span class="hljs-comment"> * Author: Wang P</span><span class="hljs-comment"> * Version: 1.0.0</span><span class="hljs-comment"> * Date: 2021-03-06 20:26:17</span><span class="hljs-comment"> * Description:  Given the head of a linked list, rotate the list to the right by k places.</span><span class="hljs-comment"></span><span class="hljs-comment"> Example 1:</span><span class="hljs-comment">Input: head = [1,2,3,4,5], k = 2</span><span class="hljs-comment">Output: [4,5,1,2,3]</span><span class="hljs-comment"></span><span class="hljs-comment"> Example 2:</span><span class="hljs-comment">Input: head = [0,1,2], k = 4</span><span class="hljs-comment">Output: [2,0,1]</span><span class="hljs-comment"></span><span class="hljs-comment"> Constraints:</span><span class="hljs-comment"> The number of nodes in the list is in the range [0, 500].</span><span class="hljs-comment"> -100 &lt;= Node.val &lt;= 100</span><span class="hljs-comment"> 0 &lt;= k &lt;= 2 * 109</span><span class="hljs-comment"></span><span class="hljs-comment"> Related Topics 链表 双指针</span><span class="hljs-comment"> 👍 444 👎 0</span><span class="hljs-comment"> **/</span><span class="hljs-comment">//leetcode submit region begin(Prohibit modification and deletion)</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for singly-linked list.</span><span class="hljs-comment"> * type ListNode struct &#123;</span><span class="hljs-comment"> *     Val int</span><span class="hljs-comment"> *     Next *ListNode</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">rotateRight</span><span class="hljs-params">(head *ListNode, k <span class="hljs-keyword">int</span>)</span> *<span class="hljs-title">ListNode</span></span> &#123;<span class="hljs-keyword">if</span> head == <span class="hljs-literal">nil</span> || head.Next == <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> head&#125;oldTail := headlength := <span class="hljs-number">1</span><span class="hljs-keyword">for</span> oldTail.Next != <span class="hljs-literal">nil</span> &#123;oldTail = oldTail.Nextlength++&#125;oldTail.Next = headnewTail := head<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; length - k%length <span class="hljs-number">-1</span>; i++ &#123;newTail = newTail.Next&#125;head = newTail.NextnewTail.Next = <span class="hljs-literal">nil</span><span class="hljs-keyword">return</span> head&#125;<span class="hljs-comment">//leetcode submit region end(Prohibit modification and deletion)</span></code></pre><p><code>Python</code></p><pre><code class="hljs Python"><span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">Module Description: 61-旋转链表</span><span class="hljs-string">Solution：</span><span class="hljs-string">Date: 2021-03-06 20:23:59</span><span class="hljs-string">Author: Wang P</span><span class="hljs-string">Problem:  给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。</span><span class="hljs-string"></span><span class="hljs-string">          示例 1:</span><span class="hljs-string">          输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k = 2</span><span class="hljs-string">         输出: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL</span><span class="hljs-string">         解释:</span><span class="hljs-string">         向右旋转 1 步: 5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULL</span><span class="hljs-string">         向右旋转 2 步: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL</span><span class="hljs-string"></span><span class="hljs-string">          示例 2:</span><span class="hljs-string">          输入: 0-&gt;1-&gt;2-&gt;NULL, k = 4</span><span class="hljs-string">         输出: 2-&gt;0-&gt;1-&gt;NULL</span><span class="hljs-string">         解释:</span><span class="hljs-string">         向右旋转 1 步: 2-&gt;0-&gt;1-&gt;NULL</span><span class="hljs-string">         向右旋转 2 步: 1-&gt;2-&gt;0-&gt;NULL</span><span class="hljs-string">         向右旋转 3 步: 0-&gt;1-&gt;2-&gt;NULL</span><span class="hljs-string">         向右旋转 4 步: 2-&gt;0-&gt;1-&gt;NULL</span><span class="hljs-string">          Related Topics 链表 双指针</span><span class="hljs-string">          👍 444 👎 0</span><span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-comment"># leetcode submit region begin(Prohibit modification and deletion)</span><span class="hljs-comment"># Definition for singly-linked list.</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListNode</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, val=<span class="hljs-number">0</span>, <span class="hljs-built_in">next</span>=<span class="hljs-literal">None</span></span>):</span>        self.val = val        self.<span class="hljs-built_in">next</span> = <span class="hljs-built_in">next</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">rotateRight</span>(<span class="hljs-params">self, head: ListNode, k: <span class="hljs-built_in">int</span></span>) -&gt; ListNode:</span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> head <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> head.<span class="hljs-built_in">next</span>:            <span class="hljs-keyword">return</span> head        old_tail = head        length = <span class="hljs-number">1</span>        <span class="hljs-keyword">while</span> old_tail.<span class="hljs-built_in">next</span>:            old_tail = old_tail.<span class="hljs-built_in">next</span>            length += <span class="hljs-number">1</span>        old_tail.<span class="hljs-built_in">next</span> = head        new_tail = head        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, length - (k % length) - <span class="hljs-number">1</span>):            new_tail = new_tail.<span class="hljs-built_in">next</span>        head = new_tail.<span class="hljs-built_in">next</span>        new_tail.<span class="hljs-built_in">next</span> = <span class="hljs-literal">None</span>        <span class="hljs-keyword">return</span> head<span class="hljs-comment"># leetcode submit region end(Prohibit modification and deletion)</span></code></pre><h6 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24. 两两交换链表中的节点"></a><a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/">24. 两两交换链表中的节点</a></h6><p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</p><p><strong>你不能只是单纯的改变节点内部的值</strong>，而是需要实际的进行节点交换。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/03/swap_ex1.jpg"></p><pre><code class="hljs angelscript">输入：head = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]输出：[<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>]</code></pre><p><strong>示例 2：</strong></p><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[]</span>输出：<span class="hljs-comment">[]</span></code></pre><p><strong>示例 3：</strong></p><pre><code class="hljs angelscript">输入：head = [<span class="hljs-number">1</span>]输出：[<span class="hljs-number">1</span>]</code></pre><p><strong>提示：</strong></p><ul><li>链表中节点的数目在范围 <code>[0, 100]</code> 内</li><li><code>0 &lt;= Node.val &lt;= 100</code></li></ul><p><strong>进阶：</strong>你能在不修改链表节点值的情况下解决这个问题吗?（也就是说，仅修改节点本身。）</p><p>解题思路</p><pre><code class="hljs mathematica"><span class="hljs-keyword">K</span>个一组反转中 <span class="hljs-keyword">K</span>等于<span class="hljs-number">2</span></code></pre><p><code>Java</code></p><pre><code class="hljs Java"><span class="hljs-comment">/*</span><span class="hljs-comment"> * Author: Wang P</span><span class="hljs-comment"> * Version: 1.0.0</span><span class="hljs-comment"> * Date: 2021-03-06 20:22:33</span><span class="hljs-comment"> * Description: 24-Swap Nodes in Pairs</span><span class="hljs-comment"> **/</span> <span class="hljs-keyword">package</span> com.weitrue.leetcode.editor.cn;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SwapNodesInPairs</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;        Solution s = <span class="hljs-keyword">new</span> SwapNodesInPairs().<span class="hljs-function">new <span class="hljs-title">Solution</span><span class="hljs-params">()</span></span>;    &#125;        <span class="hljs-comment">//Given a linked list, swap every two adjacent nodes and return its head. </span>    <span class="hljs-comment">//</span>    <span class="hljs-comment">// Example 1:</span>    <span class="hljs-comment">//Input: head = [1,2,3,4]</span>    <span class="hljs-comment">//Output: [2,1,4,3]</span>    <span class="hljs-comment">//</span>    <span class="hljs-comment">// Example 2:</span>    <span class="hljs-comment">//Input: head = []</span>    <span class="hljs-comment">//Output: []</span>    <span class="hljs-comment">//</span>    <span class="hljs-comment">// Example 3:</span>    <span class="hljs-comment">//Input: head = [1]</span>    <span class="hljs-comment">//Output: [1]</span>    <span class="hljs-comment">//</span>    <span class="hljs-comment">// Constraints:</span>    <span class="hljs-comment">// The number of nodes in the list is in the range [0, 100].</span>    <span class="hljs-comment">// 0 &lt;= Node.val &lt;= 100</span>    <span class="hljs-comment">//Follow up: Can you solve the problem without modifying the values in the list&#x27;</span>    <span class="hljs-comment">//s nodes? (i.e., Only nodes themselves may be changed.) Related Topics 递归 链表</span>    <span class="hljs-comment">// 👍 859 👎 0</span>        <span class="hljs-comment">//leetcode submit region begin(Prohibit modification and deletion)</span>    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Definition for singly-linked list.</span><span class="hljs-comment">     */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListNode</span> </span>&#123;        <span class="hljs-keyword">int</span> val;        ListNode next;        ListNode() &#123;&#125;        ListNode(<span class="hljs-keyword">int</span> val) &#123; <span class="hljs-keyword">this</span>.val = val; &#125;        ListNode(<span class="hljs-keyword">int</span> val, ListNode next) &#123; <span class="hljs-keyword">this</span>.val = val; <span class="hljs-keyword">this</span>.next = next; &#125;     &#125;    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;        <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">swapPairs</span><span class="hljs-params">(ListNode head)</span> </span>&#123;            ListNode hair = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>, head), pre = hair, tail = pre;            <span class="hljs-keyword">while</span> (head != <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">2</span>; i++) &#123;                    tail = tail.next;                    <span class="hljs-keyword">if</span> (tail == <span class="hljs-keyword">null</span>) &#123;                        <span class="hljs-keyword">return</span> hair.next;                    &#125;                &#125;                <span class="hljs-comment">// 反转长度为k的链表，并返回链表的新头尾节点</span>                ListNode[] ln = reverse(head, tail);                head = ln[<span class="hljs-number">0</span>];                tail = ln[<span class="hljs-number">1</span>];                pre.next = head;                pre = tail;                head = pre.next;            &#125;            <span class="hljs-keyword">return</span> hair.next;        &#125;        <span class="hljs-keyword">public</span> ListNode[] reverse(ListNode head, ListNode tail)&#123;            ListNode pre = tail.next, cur = head, next = <span class="hljs-keyword">null</span>;            <span class="hljs-keyword">while</span> (tail != pre) &#123;                next = cur.next;                cur.next = pre;                pre = cur;                cur = next;            &#125;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ListNode[]&#123;tail, head&#125;;        &#125;    &#125;    <span class="hljs-comment">//leetcode submit region end(Prohibit modification and deletion)</span>&#125;</code></pre><p><code>Golang</code></p><pre><code class="hljs Golang"><span class="hljs-keyword">package</span> leetcode<span class="hljs-comment">/**</span><span class="hljs-comment"> * Author: Wang P</span><span class="hljs-comment"> * Version: 1.0.0</span><span class="hljs-comment"> * Date: 2021-03-06 20:26:56</span><span class="hljs-comment"> * Description:  Given a linked list, swap every two adjacent nodes and return its head.</span><span class="hljs-comment"></span><span class="hljs-comment"> Example 1:</span><span class="hljs-comment">Input: head = [1,2,3,4]</span><span class="hljs-comment">Output: [2,1,4,3]</span><span class="hljs-comment"></span><span class="hljs-comment"> Example 2:</span><span class="hljs-comment">Input: head = []</span><span class="hljs-comment">Output: []</span><span class="hljs-comment"></span><span class="hljs-comment"> Example 3:</span><span class="hljs-comment">Input: head = [1]</span><span class="hljs-comment">Output: [1]</span><span class="hljs-comment"></span><span class="hljs-comment"> Constraints:</span><span class="hljs-comment"> The number of nodes in the list is in the range [0, 100].</span><span class="hljs-comment"> 0 &lt;= Node.val &lt;= 100</span><span class="hljs-comment"></span><span class="hljs-comment">Follow up: Can you solve the problem without modifying the values in the list&#x27;</span><span class="hljs-comment">s nodes? (i.e., Only nodes themselves may be changed.) Related Topics 递归 链表</span><span class="hljs-comment"> 👍 859 👎 0</span><span class="hljs-comment"> **/</span><span class="hljs-comment">//leetcode submit region begin(Prohibit modification and deletion)</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for singly-linked list.</span><span class="hljs-comment"> * type ListNode struct &#123;</span><span class="hljs-comment"> *     Val int</span><span class="hljs-comment"> *     Next *ListNode</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">swapPairs</span><span class="hljs-params">(head *ListNode)</span> *<span class="hljs-title">ListNode</span></span> &#123;hair := &amp;ListNode&#123;Next:head&#125;pre, tail := hair, hair<span class="hljs-keyword">for</span> head != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++ &#123;tail = tail.Next<span class="hljs-keyword">if</span> tail == <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> hair.Next&#125;&#125;head, tail = reverseN(head, tail)pre.Next = headpre = tailhead = pre.Next&#125;<span class="hljs-keyword">return</span> hair.Next&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverseN</span><span class="hljs-params">(head, tail *ListNode)</span> <span class="hljs-params">(*ListNode, *ListNode)</span></span> &#123;pre, cur, next := tail.Next, head, &amp;ListNode&#123;&#125;<span class="hljs-keyword">for</span> pre != tail &#123;next = cur.Nextcur.Next = prepre = curcur = next&#125;<span class="hljs-keyword">return</span> tail, head&#125;<span class="hljs-comment">//leetcode submit region end(Prohibit modification and deletion)</span></code></pre><p><code>Python</code></p><pre><code class="hljs Python"><span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">Module Description: 24-两两交换链表中的节点</span><span class="hljs-string">Solution：</span><span class="hljs-string">Date: 2021-03-06 20:25:15</span><span class="hljs-string">Author: Wang P</span><span class="hljs-string">Problem:  给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</span><span class="hljs-string">          你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</span><span class="hljs-string"></span><span class="hljs-string">          示例 1：</span><span class="hljs-string">         输入：head = [1,2,3,4]</span><span class="hljs-string">         输出：[2,1,4,3]</span><span class="hljs-string"></span><span class="hljs-string">          示例 2：</span><span class="hljs-string">         输入：head = []</span><span class="hljs-string">         输出：[]</span><span class="hljs-string"></span><span class="hljs-string">          示例 3：</span><span class="hljs-string">         输入：head = [1]</span><span class="hljs-string">         输出：[1]</span><span class="hljs-string"></span><span class="hljs-string">          提示：</span><span class="hljs-string">          链表中节点的数目在范围 [0, 100] 内</span><span class="hljs-string">          0 &lt;= Node.val &lt;= 100</span><span class="hljs-string">          进阶：你能在不修改链表节点值的情况下解决这个问题吗?（也就是说，仅修改节点本身。）</span><span class="hljs-string">          Related Topics 递归 链表</span><span class="hljs-string">          👍 859 👎 0</span><span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-comment"># leetcode submit region begin(Prohibit modification and deletion)</span><span class="hljs-comment"># Definition for singly-linked list.</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListNode</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, val=<span class="hljs-number">0</span>, <span class="hljs-built_in">next</span>=<span class="hljs-literal">None</span></span>):</span>        self.val = val        self.<span class="hljs-built_in">next</span> = <span class="hljs-built_in">next</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">swapPairs</span>(<span class="hljs-params">self, head: ListNode</span>) -&gt; ListNode:</span>        tail = pre = hair = ListNode(<span class="hljs-built_in">next</span>=head)        <span class="hljs-keyword">while</span> head:            <span class="hljs-comment"># tail = pre</span>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>):                tail = tail.<span class="hljs-built_in">next</span>                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> tail:                    <span class="hljs-keyword">return</span> hair.<span class="hljs-built_in">next</span>            head, tail = self.reverse(head, tail)            pre.<span class="hljs-built_in">next</span> = head            pre = tail            head = pre.<span class="hljs-built_in">next</span>        <span class="hljs-keyword">return</span> hair.<span class="hljs-built_in">next</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reverse</span>(<span class="hljs-params">self, head, tail: ListNode</span>) -&gt; (ListNode, ListNode):</span>        pre, cur, nex = tail.<span class="hljs-built_in">next</span>, head, <span class="hljs-literal">None</span>        <span class="hljs-keyword">while</span> pre != tail:            nex = cur.<span class="hljs-built_in">next</span>            cur.<span class="hljs-built_in">next</span> = pre            pre = cur            cur = nex        <span class="hljs-keyword">return</span> tail, head<span class="hljs-comment"># leetcode submit region end(Prohibit modification and deletion)</span></code></pre><h5 id="链表节点删除"><a href="#链表节点删除" class="headerlink" title="链表节点删除"></a>链表节点删除</h5><h6 id="19-删除链表的倒数第-N-个结点"><a href="#19-删除链表的倒数第-N-个结点" class="headerlink" title="19. 删除链表的倒数第 N 个结点"></a><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第 N 个结点</a></h6><p>给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。</p><p>进阶：你能尝试使用一趟扫描实现吗？</p><p>示例 1：</p><pre><code class="hljs angelscript">输入：head = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>], n = <span class="hljs-number">2</span>输出：[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>]</code></pre><p>示例 2：</p><pre><code class="hljs angelscript">输入：head = [<span class="hljs-number">1</span>], n = <span class="hljs-number">1</span>输出：[]</code></pre><p>示例 3：</p><pre><code class="hljs angelscript">输入：head = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>], n = <span class="hljs-number">1</span>输出：[<span class="hljs-number">1</span>]</code></pre><p>提示：</p><pre><code class="hljs angelscript">链表中结点的数目为 sz<span class="hljs-number">1</span> &lt;= sz &lt;= <span class="hljs-number">30</span><span class="hljs-number">0</span> &lt;= Node.val &lt;= <span class="hljs-number">100</span><span class="hljs-number">1</span> &lt;= n &lt;= sz</code></pre><p>解题思路</p><pre><code class="hljs angelscript">快慢指针<span class="hljs-number">1.</span>快指针先行N步；<span class="hljs-number">2.</span>慢指针与快指针开始同时走，快指针走到头，慢指针走到第N个节点的前驱</code></pre><p><code>Java</code></p><pre><code class="hljs Java"><span class="hljs-comment">/*</span><span class="hljs-comment"> * Author: Wang P</span><span class="hljs-comment"> * Version: 1.0.0</span><span class="hljs-comment"> * Date: 2021-03-05 12:54:46</span><span class="hljs-comment"> * Description: 19-Remove Nth Node From End of List</span><span class="hljs-comment"> **/</span> <span class="hljs-keyword">package</span> com.weitrue.leetcode.editor.cn;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RemoveNthNodeFromEndOfList</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;        Solution s = <span class="hljs-keyword">new</span> RemoveNthNodeFromEndOfList().<span class="hljs-function">new <span class="hljs-title">Solution</span><span class="hljs-params">()</span></span>;    &#125;        <span class="hljs-comment">//Given the head of a linked list, remove the nth node from the end of the list </span>    <span class="hljs-comment">//and return its head.</span>    <span class="hljs-comment">//</span>    <span class="hljs-comment">// Follow up: Could you do this in one pass?</span>    <span class="hljs-comment">//</span>    <span class="hljs-comment">// Example 1:</span>    <span class="hljs-comment">//Input: head = [1,2,3,4,5], n = 2</span>    <span class="hljs-comment">//Output: [1,2,3,5]</span>    <span class="hljs-comment">//</span>    <span class="hljs-comment">// Example 2:</span>    <span class="hljs-comment">//Input: head = [1], n = 1</span>    <span class="hljs-comment">//Output: []</span>    <span class="hljs-comment">//</span>    <span class="hljs-comment">// Example 3:</span>    <span class="hljs-comment">//Input: head = [1,2], n = 1</span>    <span class="hljs-comment">//Output: [1]</span>    <span class="hljs-comment">// Constraints:</span>    <span class="hljs-comment">// The number of nodes in the list is sz.</span>    <span class="hljs-comment">// 1 &lt;= sz &lt;= 30</span>    <span class="hljs-comment">// 0 &lt;= Node.val &lt;= 100</span>    <span class="hljs-comment">// 1 &lt;= n &lt;= sz</span>    <span class="hljs-comment">//</span>    <span class="hljs-comment">// Related Topics 链表 双指针</span>    <span class="hljs-comment">// 👍 1264 👎 0</span>     <span class="hljs-comment">//leetcode submit region begin(Prohibit modification and deletion)</span>    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Definition for singly-linked list.</span><span class="hljs-comment">     */</span>     <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListNode</span> </span>&#123;         <span class="hljs-keyword">int</span> val;         ListNode next;         ListNode() &#123;&#125;         ListNode(<span class="hljs-keyword">int</span> val) &#123; <span class="hljs-keyword">this</span>.val = val; &#125;         ListNode(<span class="hljs-keyword">int</span> val, ListNode next) &#123; <span class="hljs-keyword">this</span>.val = val; <span class="hljs-keyword">this</span>.next = next; &#125;     &#125;    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;        <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(ListNode head, <span class="hljs-keyword">int</span> n)</span> </span>&#123;            ListNode hair = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>, head), fast = head, slow = hair;            <span class="hljs-keyword">while</span> (n &gt; <span class="hljs-number">0</span>)&#123;                fast = fast.next;                n--;            &#125;            <span class="hljs-keyword">while</span> (fast != <span class="hljs-keyword">null</span>) &#123;                fast = fast.next;                slow = slow.next;            &#125;            slow.next = slow.next.next;            <span class="hljs-keyword">return</span> hair.next;        &#125;&#125;<span class="hljs-comment">//leetcode submit region end(Prohibit modification and deletion)</span>&#125;</code></pre><p><code>Golang</code></p><pre><code class="hljs Golang"><span class="hljs-keyword">package</span> leetcode<span class="hljs-comment">/**</span><span class="hljs-comment"> * Author: Wang P</span><span class="hljs-comment"> * Version: 1.0.0</span><span class="hljs-comment"> * Date: 2021-03-05 13:43:33</span><span class="hljs-comment"> * Description:</span><span class="hljs-comment"> **/</span><span class="hljs-comment">//Given the head of a linked list, remove the nth node from the end of the list </span><span class="hljs-comment">//and return its head. </span><span class="hljs-comment">//</span><span class="hljs-comment">// Follow up: Could you do this in one pass? </span><span class="hljs-comment">//</span><span class="hljs-comment">// Example 1:</span><span class="hljs-comment">//Input: head = [1,2,3,4,5], n = 2</span><span class="hljs-comment">//Output: [1,2,3,5]</span><span class="hljs-comment">//</span><span class="hljs-comment">// Example 2:</span><span class="hljs-comment">//Input: head = [1], n = 1</span><span class="hljs-comment">//Output: []</span><span class="hljs-comment">//</span><span class="hljs-comment">// Example 3:</span><span class="hljs-comment">//Input: head = [1,2], n = 1</span><span class="hljs-comment">//Output: [1]</span><span class="hljs-comment">// Constraints:</span><span class="hljs-comment">// The number of nodes in the list is sz. </span><span class="hljs-comment">// 1 &lt;= sz &lt;= 30 </span><span class="hljs-comment">// 0 &lt;= Node.val &lt;= 100 </span><span class="hljs-comment">// 1 &lt;= n &lt;= sz </span><span class="hljs-comment">// </span><span class="hljs-comment">// Related Topics 链表 双指针 </span><span class="hljs-comment">// 👍 1264 👎 0</span><span class="hljs-comment">//leetcode submit region begin(Prohibit modification and deletion)</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for singly-linked list.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">type</span> ListNode <span class="hljs-keyword">struct</span> &#123;Val <span class="hljs-keyword">int</span>Next *ListNode&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(head *ListNode, n <span class="hljs-keyword">int</span>)</span> *<span class="hljs-title">ListNode</span></span> &#123;hair := &amp;ListNode&#123;Next:head&#125;fast, slow := head, hair<span class="hljs-keyword">for</span> n &gt; <span class="hljs-number">0</span> &#123;fast = fast.Nextn--&#125;<span class="hljs-keyword">for</span> fast != <span class="hljs-literal">nil</span> &#123;fast = fast.Nextslow = slow.Next&#125;slow.Next = slow.Next.Next<span class="hljs-keyword">return</span> hair.Next&#125;<span class="hljs-comment">//leetcode submit region end(Prohibit modification and deletion)</span></code></pre><p><code>Python</code></p><pre><code class="hljs Python"><span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">Module Description: 19-删除链表的倒数第 N 个结点</span><span class="hljs-string">Solution：</span><span class="hljs-string">Date: 2021-03-05 13:39:13</span><span class="hljs-string">Author: Wang P</span><span class="hljs-string">Problem:# 给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。 </span><span class="hljs-string">        #</span><span class="hljs-string">        #  进阶：你能尝试使用一趟扫描实现吗？</span><span class="hljs-string"></span><span class="hljs-string">        #  示例 1：</span><span class="hljs-string">        # 输入：head = [1,2,3,4,5], n = 2</span><span class="hljs-string">        # 输出：[1,2,3,5]</span><span class="hljs-string">        #</span><span class="hljs-string">        #  示例 2：</span><span class="hljs-string">        # 输入：head = [1], n = 1</span><span class="hljs-string">        # 输出：[]</span><span class="hljs-string">        #</span><span class="hljs-string">        #  示例 3：</span><span class="hljs-string">        # 输入：head = [1,2], n = 1</span><span class="hljs-string">        # 输出：[1]</span><span class="hljs-string">        #</span><span class="hljs-string">        #  提示：</span><span class="hljs-string">        #  链表中结点的数目为 sz</span><span class="hljs-string">        #  1 &lt;= sz &lt;= 30</span><span class="hljs-string">        #  0 &lt;= Node.val &lt;= 100</span><span class="hljs-string">        #  1 &lt;= n &lt;= sz</span><span class="hljs-string">        #</span><span class="hljs-string">        #  Related Topics 链表 双指针</span><span class="hljs-string">        #  👍 1264 👎 0</span><span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-comment"># leetcode submit region begin(Prohibit modification and deletion)</span><span class="hljs-comment"># Definition for singly-linked list.</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListNode</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, val=<span class="hljs-number">0</span>, <span class="hljs-built_in">next</span>=<span class="hljs-literal">None</span></span>):</span>        self.val = val        self.<span class="hljs-built_in">next</span> = <span class="hljs-built_in">next</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">removeNthFromEnd</span>(<span class="hljs-params">self, head: ListNode, n: <span class="hljs-built_in">int</span></span>) -&gt; ListNode:</span>        hair = ListNode(<span class="hljs-built_in">next</span>=head)        slow, fast = hair, head;        <span class="hljs-keyword">while</span> n &gt; <span class="hljs-number">0</span>:            fast = fast.<span class="hljs-built_in">next</span>            n -= <span class="hljs-number">1</span>        <span class="hljs-keyword">while</span> fast:            fast = fast.<span class="hljs-built_in">next</span>            slow = slow.<span class="hljs-built_in">next</span>        slow.<span class="hljs-built_in">next</span> = slow.<span class="hljs-built_in">next</span>.<span class="hljs-built_in">next</span>        <span class="hljs-keyword">return</span> hair.<span class="hljs-built_in">next</span><span class="hljs-comment"># leetcode submit region end(Prohibit modification and deletion)</span></code></pre><h6 id="83-删除排序链表中的重复元素"><a href="#83-删除排序链表中的重复元素" class="headerlink" title="83. 删除排序链表中的重复元素"></a><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/">83. 删除排序链表中的重复元素</a></h6><p>给定一个<strong>排序</strong>链表，删除所有重复的元素，使得每个元素只出现一次。</p><p>示例 1:</p><pre><code class="hljs angelscript">输入: <span class="hljs-number">1</span>-&gt;<span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>输出: <span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span></code></pre><p>示例 2:</p><pre><code class="hljs angelscript">输入: <span class="hljs-number">1</span>-&gt;<span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">3</span>输出: <span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span></code></pre><p>解题思路</p><pre><code class="hljs plain">排序链表某节点与下一个节点值相等则删除</code></pre><p><code>Java</code></p><pre><code class="hljs Java"><span class="hljs-comment">/*</span><span class="hljs-comment"> * Author: Wang P</span><span class="hljs-comment"> * Version: 1.0.0</span><span class="hljs-comment"> * Date: 2021-03-05 13:48:45</span><span class="hljs-comment"> * Description: 83-Remove Duplicates from Sorted List</span><span class="hljs-comment"> **/</span> <span class="hljs-keyword">package</span> com.weitrue.leetcode.editor.cn;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RemoveDuplicatesFromSortedList</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;        Solution s = <span class="hljs-keyword">new</span> RemoveDuplicatesFromSortedList().<span class="hljs-function">new <span class="hljs-title">Solution</span><span class="hljs-params">()</span></span>;    &#125;        <span class="hljs-comment">//Given the head of a sorted linked list, delete all duplicates such that each e</span>    <span class="hljs-comment">//lement appears only once. Return the linked list sorted as well. </span>    <span class="hljs-comment">// Example 1: </span>    <span class="hljs-comment">//Input: head = [1,1,2]</span>    <span class="hljs-comment">//Output: [1,2]</span>    <span class="hljs-comment">// Example 2: </span>    <span class="hljs-comment">//Input: head = [1,1,2,3,3]</span>    <span class="hljs-comment">//Output: [1,2,3]</span>    <span class="hljs-comment">// Constraints: </span>    <span class="hljs-comment">// The number of nodes in the list is in the range [0, 300]. </span>    <span class="hljs-comment">// -100 &lt;= Node.val &lt;= 100 </span>    <span class="hljs-comment">// The list is guaranteed to be sorted in ascending order. </span>    <span class="hljs-comment">// </span>    <span class="hljs-comment">// Related Topics 链表 </span>    <span class="hljs-comment">// 👍 488 👎 0</span>     <span class="hljs-comment">//leetcode submit region begin(Prohibit modification and deletion)</span>    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Definition for singly-linked list.</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListNode</span> </span>&#123;        <span class="hljs-keyword">int</span> val;        ListNode next;        ListNode() &#123;&#125;        ListNode(<span class="hljs-keyword">int</span> val) &#123; <span class="hljs-keyword">this</span>.val = val; &#125;        ListNode(<span class="hljs-keyword">int</span> val, ListNode next) &#123; <span class="hljs-keyword">this</span>.val = val; <span class="hljs-keyword">this</span>.next = next; &#125;    &#125;    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;        <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">deleteDuplicates</span><span class="hljs-params">(ListNode head)</span> </span>&#123;            <span class="hljs-keyword">if</span>(head == <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;            &#125;            ListNode fast = head.next, slow = head;            <span class="hljs-keyword">while</span> (fast != <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-keyword">if</span> (fast.val == slow.val) &#123;                    slow.next = fast.next;                    fast = slow.next;                &#125;<span class="hljs-keyword">else</span> &#123;                    fast = fast.next;                    slow = slow.next;                &#125;            &#125;            <span class="hljs-keyword">return</span> head;        &#125;&#125;<span class="hljs-comment">//leetcode submit region end(Prohibit modification and deletion)</span>&#125;</code></pre><p><code>Golang</code></p><pre><code class="hljs Golang"><span class="hljs-keyword">package</span> leetcode<span class="hljs-comment">/**</span><span class="hljs-comment"> * Author: Wang P</span><span class="hljs-comment"> * Version: 1.0.0</span><span class="hljs-comment"> * Date: 2021-03-05 13:50:35</span><span class="hljs-comment"> * Description: //Given the head of a sorted linked list, delete all duplicates such that each e</span><span class="hljs-comment">//lement appears only once. Return the linked list sorted as well.</span><span class="hljs-comment">//</span><span class="hljs-comment">// Example 1:</span><span class="hljs-comment">//Input: head = [1,1,2]</span><span class="hljs-comment">//Output: [1,2]</span><span class="hljs-comment">//</span><span class="hljs-comment">// Example 2:</span><span class="hljs-comment">//Input: head = [1,1,2,3,3]</span><span class="hljs-comment">//Output: [1,2,3]</span><span class="hljs-comment">//</span><span class="hljs-comment">// Constraints:</span><span class="hljs-comment">// The number of nodes in the list is in the range [0, 300].</span><span class="hljs-comment">// -100 &lt;= Node.val &lt;= 100</span><span class="hljs-comment">// The list is guaranteed to be sorted in ascending order.</span><span class="hljs-comment">//</span><span class="hljs-comment">// Related Topics 链表</span><span class="hljs-comment">// 👍 488 👎 0</span><span class="hljs-comment"> **/</span><span class="hljs-comment">//leetcode submit region begin(Prohibit modification and deletion)</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for singly-linked list.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">type</span> ListNode <span class="hljs-keyword">struct</span> &#123;Val <span class="hljs-keyword">int</span>Next *ListNode&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">deleteDuplicates</span><span class="hljs-params">(head *ListNode)</span> *<span class="hljs-title">ListNode</span></span> &#123;cur := head<span class="hljs-keyword">for</span> cur != <span class="hljs-literal">nil</span> &amp;&amp; cur.Next != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">if</span> cur.Val == cur.Next.Val &#123;cur.Next = cur.Next.Next&#125;<span class="hljs-keyword">else</span> &#123;cur = cur.Next&#125;&#125;<span class="hljs-keyword">return</span> head&#125;<span class="hljs-comment">//leetcode submit region end(Prohibit modification and deletion)</span></code></pre><p><code>Python</code></p><pre><code class="hljs Python"><span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">Module Description: 83-删除排序链表中的重复元素</span><span class="hljs-string">Solution：</span><span class="hljs-string">Date: 2021-03-05 13:50:26</span><span class="hljs-string">Author: Wang P</span><span class="hljs-string">Problem:# 给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。 </span><span class="hljs-string">        #</span><span class="hljs-string">        #  示例 1:</span><span class="hljs-string">        #</span><span class="hljs-string">        #  输入: 1-&gt;1-&gt;2</span><span class="hljs-string">        # 输出: 1-&gt;2</span><span class="hljs-string">        #</span><span class="hljs-string">        #</span><span class="hljs-string">        #  示例 2:</span><span class="hljs-string">        #</span><span class="hljs-string">        #  输入: 1-&gt;1-&gt;2-&gt;3-&gt;3</span><span class="hljs-string">        # 输出: 1-&gt;2-&gt;3</span><span class="hljs-string">        #  Related Topics 链表</span><span class="hljs-string">        #  👍 488 👎 0</span><span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-comment"># leetcode submit region begin(Prohibit modification and deletion)</span><span class="hljs-comment"># Definition for singly-linked list.</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListNode</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, val=<span class="hljs-number">0</span>, <span class="hljs-built_in">next</span>=<span class="hljs-literal">None</span></span>):</span>        self.val = val        self.<span class="hljs-built_in">next</span> = <span class="hljs-built_in">next</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">deleteDuplicates</span>(<span class="hljs-params">self, head: ListNode</span>) -&gt; ListNode:</span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> head:            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>        fast, slow = head.<span class="hljs-built_in">next</span>, head        <span class="hljs-keyword">while</span> fast:            <span class="hljs-keyword">if</span> fast.val == slow.val:                slow.<span class="hljs-built_in">next</span> = fast.<span class="hljs-built_in">next</span>                fast = slow.<span class="hljs-built_in">next</span>            <span class="hljs-keyword">else</span>:                fast = fast.<span class="hljs-built_in">next</span>                slow = slow.<span class="hljs-built_in">next</span>        <span class="hljs-keyword">return</span> head<span class="hljs-comment"># leetcode submit region end(Prohibit modification and deletion)</span></code></pre><h6 id="82-删除排序链表中的重复元素-II"><a href="#82-删除排序链表中的重复元素-II" class="headerlink" title="82. 删除排序链表中的重复元素 II"></a><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/">82. 删除排序链表中的重复元素 II</a></h6><p>给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中 <em>没有重复出现</em> 的数字。</p><p><strong>示例 1:</strong></p><pre><code class="hljs angelscript">输入: <span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">5</span>输出: <span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">5</span></code></pre><p><strong>示例 2:</strong></p><pre><code class="hljs angelscript">输入: <span class="hljs-number">1</span>-&gt;<span class="hljs-number">1</span>-&gt;<span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>输出: <span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span></code></pre><p>解题思路</p><pre><code class="hljs plain"></code></pre><p><code>Java</code></p><pre><code class="hljs Java"><span class="hljs-comment">/*</span><span class="hljs-comment"> * Author: Wang P</span><span class="hljs-comment"> * Version: 1.0.0</span><span class="hljs-comment"> * Date: 2021-03-05 13:50:14</span><span class="hljs-comment"> * Description: 82-Remove Duplicates from Sorted List II</span><span class="hljs-comment"> **/</span> <span class="hljs-keyword">package</span> com.weitrue.leetcode.editor.cn;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RemoveDuplicatesFromSortedListIi</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;        Solution s = <span class="hljs-keyword">new</span> RemoveDuplicatesFromSortedListIi().<span class="hljs-function">new <span class="hljs-title">Solution</span><span class="hljs-params">()</span></span>;    &#125;        <span class="hljs-comment">//Given the head of a sorted linked list, delete all nodes that have duplicate numbers, </span>    <span class="hljs-comment">//leaving only distinct numbers from the original list. Return the linked</span>    <span class="hljs-comment">//list sorted as well.</span>    <span class="hljs-comment">//</span>    <span class="hljs-comment">// Example 1:</span>    <span class="hljs-comment">//Input: head = [1,2,3,3,4,4,5]</span>    <span class="hljs-comment">//Output: [1,2,5]</span>    <span class="hljs-comment">//</span>    <span class="hljs-comment">// Example 2:</span>    <span class="hljs-comment">//Input: head = [1,1,1,2,3]</span>    <span class="hljs-comment">//Output: [2,3]</span>    <span class="hljs-comment">//</span>    <span class="hljs-comment">// Constraints:</span>    <span class="hljs-comment">// The number of nodes in the list is in the range [0, 300].</span>    <span class="hljs-comment">// -100 &lt;= Node.val &lt;= 100</span>    <span class="hljs-comment">// The list is guaranteed to be sorted in ascending order.</span>    <span class="hljs-comment">//</span>    <span class="hljs-comment">// Related Topics 链表</span>    <span class="hljs-comment">// 👍 469 👎 0</span>     <span class="hljs-comment">//leetcode submit region begin(Prohibit modification and deletion)</span>    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Definition for singly-linked list.</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListNode</span> </span>&#123;        <span class="hljs-keyword">int</span> val;        ListNode next;        ListNode() &#123;&#125;        ListNode(<span class="hljs-keyword">int</span> val) &#123; <span class="hljs-keyword">this</span>.val = val; &#125;        ListNode(<span class="hljs-keyword">int</span> val, ListNode next) &#123; <span class="hljs-keyword">this</span>.val = val; <span class="hljs-keyword">this</span>.next = next; &#125;    &#125;    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;        <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">deleteDuplicates</span><span class="hljs-params">(ListNode head)</span> </span>&#123;            ListNode hair = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>, head), fast = head, slow = hair;            <span class="hljs-keyword">while</span> (fast != <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-keyword">while</span> (fast.next != <span class="hljs-keyword">null</span> &amp;&amp; fast.val == fast.next.val) &#123;                    fast = fast.next;                &#125;                <span class="hljs-keyword">if</span> (slow.next == fast) &#123;                    slow = slow.next;                &#125;<span class="hljs-keyword">else</span> &#123;                    slow.next = fast.next;                &#125;                fast = fast.next;            &#125;            <span class="hljs-keyword">return</span> hair.next;        &#125;    &#125;<span class="hljs-comment">//leetcode submit region end(Prohibit modification and deletion)</span>&#125;</code></pre><p><code>Golang</code></p><pre><code class="hljs Golang"><span class="hljs-keyword">package</span> leetcode<span class="hljs-comment">/**</span><span class="hljs-comment"> * Author: Wang P</span><span class="hljs-comment"> * Version: 1.0.0</span><span class="hljs-comment"> * Date: 2021-03-05 13:50:38</span><span class="hljs-comment"> * Description: //Given the head of a sorted linked list, delete all nodes that have duplicate n</span><span class="hljs-comment">//umbers, leaving only distinct numbers from the original list. Return the linked</span><span class="hljs-comment">//list sorted as well.</span><span class="hljs-comment">// Example 1:</span><span class="hljs-comment">//Input: head = [1,2,3,3,4,4,5]</span><span class="hljs-comment">//Output: [1,2,5]</span><span class="hljs-comment">//</span><span class="hljs-comment">// Example 2:</span><span class="hljs-comment">//Input: head = [1,1,1,2,3]</span><span class="hljs-comment">//Output: [2,3]</span><span class="hljs-comment">//</span><span class="hljs-comment">// Constraints:</span><span class="hljs-comment">// The number of nodes in the list is in the range [0, 300].</span><span class="hljs-comment">// -100 &lt;= Node.val &lt;= 100</span><span class="hljs-comment">// The list is guaranteed to be sorted in ascending order.</span><span class="hljs-comment">//</span><span class="hljs-comment">// Related Topics 链表</span><span class="hljs-comment">// 👍 469 👎 0</span><span class="hljs-comment"> **/</span><span class="hljs-comment">//leetcode submit region begin(Prohibit modification and deletion)</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for singly-linked list.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">type</span> ListNode <span class="hljs-keyword">struct</span> &#123;Val <span class="hljs-keyword">int</span>Next *ListNode&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">deleteDuplicates</span><span class="hljs-params">(head *ListNode)</span> *<span class="hljs-title">ListNode</span></span> &#123;hair := &amp;ListNode&#123;Next: head&#125;fast, slow := head, hair<span class="hljs-keyword">for</span> fast != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">for</span> fast.Next != <span class="hljs-literal">nil</span> &amp;&amp; fast.Val == fast.Next.Val &#123;fast = fast.Next&#125;<span class="hljs-keyword">if</span> slow.Next == fast&#123;slow = slow.Next&#125; <span class="hljs-keyword">else</span> &#123;slow.Next = fast.Next&#125;fast = fast.Next&#125;<span class="hljs-keyword">return</span> hair.Next&#125;<span class="hljs-comment">//leetcode submit region end(Prohibit modification and deletion)</span></code></pre><p><code>Python</code></p><pre><code class="hljs Python"><span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">Module Description: 82-删除排序链表中的重复元素 II</span><span class="hljs-string">Solution：</span><span class="hljs-string">Date: 2021-03-05 13:50:50</span><span class="hljs-string">Author: Wang P</span><span class="hljs-string">Problem:# 给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中 没有重复出现 的数字。</span><span class="hljs-string">        #  示例 1:</span><span class="hljs-string">        #  输入: 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5</span><span class="hljs-string">        # 输出: 1-&gt;2-&gt;5</span><span class="hljs-string">        #  示例 2:</span><span class="hljs-string">        #  输入: 1-&gt;1-&gt;1-&gt;2-&gt;3</span><span class="hljs-string">        # 输出: 2-&gt;3</span><span class="hljs-string">        #  Related Topics 链表</span><span class="hljs-string">        #  👍 469 👎 0</span><span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-comment"># leetcode submit region begin(Prohibit modification and deletion)</span><span class="hljs-comment"># Definition for singly-linked list.</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListNode</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, val=<span class="hljs-number">0</span>, <span class="hljs-built_in">next</span>=<span class="hljs-literal">None</span></span>):</span>        self.val = val        self.<span class="hljs-built_in">next</span> = <span class="hljs-built_in">next</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">deleteDuplicates</span>(<span class="hljs-params">self, head: ListNode</span>) -&gt; ListNode:</span>        hair, fast = ListNode(<span class="hljs-built_in">next</span>=head), head        slow = hair        <span class="hljs-keyword">while</span> fast:            <span class="hljs-keyword">while</span> fast.<span class="hljs-built_in">next</span> <span class="hljs-keyword">and</span> fast.val == fast.<span class="hljs-built_in">next</span>.val:                fast = fast.<span class="hljs-built_in">next</span>            <span class="hljs-keyword">if</span> slow.<span class="hljs-built_in">next</span> == fast:                slow = slow.<span class="hljs-built_in">next</span>            <span class="hljs-keyword">else</span>:                slow.<span class="hljs-built_in">next</span> = fast.<span class="hljs-built_in">next</span>            fast = fast.<span class="hljs-built_in">next</span>        <span class="hljs-keyword">return</span> hair.<span class="hljs-built_in">next</span><span class="hljs-comment"># leetcode submit region end(Prohibit modification and deletion)</span></code></pre><h5 id="经典面试题"><a href="#经典面试题" class="headerlink" title="经典面试题"></a>经典面试题</h5><h6 id="86-分隔链表"><a href="#86-分隔链表" class="headerlink" title="86. 分隔链表"></a><a href="https://leetcode-cn.com/problems/partition-list/">86. 分隔链表</a></h6><p>给你一个链表的头节点 head 和一个特定值 x ，请你对链表进行分隔，使得所有 小于 x 的节点都出现在 大于或等于 x 的节点之前。</p><p>你应当 保留 两个分区中每个节点的初始相对位置。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/04/partition.jpg"></p><pre><code class="hljs angelscript">输入：head = [<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">2</span>], x = <span class="hljs-number">3</span>输出：[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>]</code></pre><p><strong>示例 2：</strong></p><pre><code class="hljs angelscript">输入：head = [<span class="hljs-number">2</span>,<span class="hljs-number">1</span>], x = <span class="hljs-number">2</span>输出：[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]</code></pre><p><strong>提示：</strong></p><ul><li>链表中节点的数目在范围 <code>[0, 200]</code> 内</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li><li><code>-200 &lt;= x &lt;= 200</code></li></ul><p>解题思路</p><pre><code class="hljs gml">准备两个虚拟头指针 一个用于连接小于 <span class="hljs-symbol">x</span> 的节点，一个用于连接大于或等于<span class="hljs-symbol">x</span>的节点，然后将两个链表连接即可</code></pre><p><code>Java</code></p><pre><code class="hljs Java"><span class="hljs-comment">/*</span><span class="hljs-comment"> * Author: Wang P</span><span class="hljs-comment"> * Version: 1.0.0</span><span class="hljs-comment"> * Date: 2021-03-06 20:29:46</span><span class="hljs-comment"> * Description: 86-Partition List</span><span class="hljs-comment"> **/</span> <span class="hljs-keyword">package</span> com.weitrue.leetcode.editor.cn;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PartitionList</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;        Solution s = <span class="hljs-keyword">new</span> PartitionList().<span class="hljs-function">new <span class="hljs-title">Solution</span><span class="hljs-params">()</span></span>;    &#125;        <span class="hljs-comment">// Given the head of a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x.</span>    <span class="hljs-comment">// You should preserve the original relative order of the nodes in each of the two partitions.</span>    <span class="hljs-comment">//</span>    <span class="hljs-comment">// Example 1:</span>    <span class="hljs-comment">//Input: head = [1,4,3,2,5,2], x = 3</span>    <span class="hljs-comment">//Output: [1,2,2,4,3,5]</span>    <span class="hljs-comment">//</span>    <span class="hljs-comment">// Example 2:</span>    <span class="hljs-comment">//Input: head = [2,1], x = 2</span>    <span class="hljs-comment">//Output: [1,2]</span>    <span class="hljs-comment">//</span>    <span class="hljs-comment">// Constraints:</span>    <span class="hljs-comment">// The number of nodes in the list is in the range [0, 200].</span>    <span class="hljs-comment">// -100 &lt;= Node.val &lt;= 100</span>    <span class="hljs-comment">// -200 &lt;= x &lt;= 200</span>    <span class="hljs-comment">//</span>    <span class="hljs-comment">// Related Topics 链表 双指针</span>    <span class="hljs-comment">// 👍 378 👎 0</span>    <span class="hljs-comment">//leetcode submit region begin(Prohibit modification and deletion)</span>    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Definition for singly-linked list.</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListNode</span> </span>&#123;        <span class="hljs-keyword">int</span> val;        ListNode next;        ListNode() &#123;&#125;        ListNode(<span class="hljs-keyword">int</span> val) &#123; <span class="hljs-keyword">this</span>.val = val; &#125;        ListNode(<span class="hljs-keyword">int</span> val, ListNode next) &#123; <span class="hljs-keyword">this</span>.val = val; <span class="hljs-keyword">this</span>.next = next; &#125;     &#125;    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;        <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">partition</span><span class="hljs-params">(ListNode head, <span class="hljs-keyword">int</span> x)</span> </span>&#123;            ListNode less = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>, head), greater = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>, head);            ListNode curLess = less, curGreater = greater;            <span class="hljs-keyword">while</span> (head != <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-keyword">if</span> (head.val &lt; x) &#123;                    curLess.next = head;                    curLess = curLess.next;                &#125; <span class="hljs-keyword">else</span> &#123;                    curGreater.next = head;                    curGreater = curGreater.next;                &#125;                head = head.next;            &#125;            curGreater.next = <span class="hljs-keyword">null</span>;            curLess.next = greater.next;            <span class="hljs-keyword">return</span> less.next;        &#125;    &#125;    <span class="hljs-comment">//leetcode submit region end(Prohibit modification and deletion)</span>&#125;</code></pre><p><code>Golang</code></p><pre><code class="hljs Golang"><span class="hljs-keyword">package</span> leetcode<span class="hljs-comment">/**</span><span class="hljs-comment"> * Author: Wang P</span><span class="hljs-comment"> * Version: 1.0.0</span><span class="hljs-comment"> * Date: 2021-03-06 20:37:43</span><span class="hljs-comment"> * Description: Given the head of a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x.</span><span class="hljs-comment">You should preserve the original relative order of the nodes in each of the two partitions.</span><span class="hljs-comment">Example 1:</span><span class="hljs-comment">Input: head = [1,4,3,2,5,2], x = 3</span><span class="hljs-comment">Output: [1,2,2,4,3,5]</span><span class="hljs-comment"></span><span class="hljs-comment">Example 2:</span><span class="hljs-comment">Input: head = [2,1], x = 2</span><span class="hljs-comment">Output: [1,2]</span><span class="hljs-comment"></span><span class="hljs-comment">Constraints:</span><span class="hljs-comment"> The number of nodes in the list is in the range [0, 200].</span><span class="hljs-comment"> -100 &lt;= Node.val &lt;= 100</span><span class="hljs-comment"> -200 &lt;= x &lt;= 200</span><span class="hljs-comment"></span><span class="hljs-comment"> Related Topics 链表 双指针</span><span class="hljs-comment"> 👍 378 👎 0</span><span class="hljs-comment"> **/</span><span class="hljs-comment">//leetcode submit region begin(Prohibit modification and deletion)</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for singly-linked list.</span><span class="hljs-comment"> * type ListNode struct &#123;</span><span class="hljs-comment"> *     Val int</span><span class="hljs-comment"> *     Next *ListNode</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">partition</span><span class="hljs-params">(head *ListNode, x <span class="hljs-keyword">int</span>)</span> *<span class="hljs-title">ListNode</span></span> &#123;lesser, greater := &amp;ListNode&#123;Next:head&#125;, &amp;ListNode&#123;Next:head&#125;less, great := lesser, greater<span class="hljs-keyword">for</span> head != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">if</span> head.Val &lt; x &#123;less.Next = headless = less.Next&#125; <span class="hljs-keyword">else</span> &#123;great.Next = headgreat = great.Next&#125;head = head.Next&#125;great.Next = <span class="hljs-literal">nil</span>less.Next = greater.Next<span class="hljs-keyword">return</span> lesser.Next&#125;<span class="hljs-comment">//leetcode submit region end(Prohibit modification and deletion)</span></code></pre><p><code>Python</code></p><pre><code class="hljs Python"><span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">Module Description: 86-分隔链表</span><span class="hljs-string">Solution：</span><span class="hljs-string">Date: 2021-03-06 20:33:40</span><span class="hljs-string">Author: Wang P</span><span class="hljs-string">Problem:  给你一个链表的头节点 head 和一个特定值 x ，请你对链表进行分隔，使得所有 小于 x 的节点都出现在 大于或等于 x 的节点之前。</span><span class="hljs-string">          你应当 保留 两个分区中每个节点的初始相对位置。</span><span class="hljs-string"></span><span class="hljs-string">          示例 1：</span><span class="hljs-string">         输入：head = [1,4,3,2,5,2], x = 3</span><span class="hljs-string">         输出：[1,2,2,4,3,5]</span><span class="hljs-string"></span><span class="hljs-string">          示例 2：</span><span class="hljs-string">         输入：head = [2,1], x = 2</span><span class="hljs-string">         输出：[1,2]</span><span class="hljs-string"></span><span class="hljs-string">          提示：</span><span class="hljs-string">          链表中节点的数目在范围 [0, 200] 内</span><span class="hljs-string">          -100 &lt;= Node.val &lt;= 100</span><span class="hljs-string">          -200 &lt;= x &lt;= 200</span><span class="hljs-string"></span><span class="hljs-string">          Related Topics 链表 双指针</span><span class="hljs-string">          👍 378 👎 0</span><span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-comment"># leetcode submit region begin(Prohibit modification and deletion)</span><span class="hljs-comment"># Definition for singly-linked list.</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListNode</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, val=<span class="hljs-number">0</span>, <span class="hljs-built_in">next</span>=<span class="hljs-literal">None</span></span>):</span>        self.val = val        self.<span class="hljs-built_in">next</span> = <span class="hljs-built_in">next</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">partition</span>(<span class="hljs-params">self, head: ListNode, x: <span class="hljs-built_in">int</span></span>) -&gt; ListNode:</span>        lesser, greater = ListNode(<span class="hljs-built_in">next</span>=head), ListNode(<span class="hljs-built_in">next</span>=head)        less, great = lesser, greater        <span class="hljs-keyword">while</span> head:            <span class="hljs-keyword">if</span> head.val &lt; x:                less.<span class="hljs-built_in">next</span> = head                less = less.<span class="hljs-built_in">next</span>            <span class="hljs-keyword">else</span>:                great.<span class="hljs-built_in">next</span> = head                great = great.<span class="hljs-built_in">next</span>            head = head.<span class="hljs-built_in">next</span>        great.<span class="hljs-built_in">next</span> = <span class="hljs-literal">None</span>        less.<span class="hljs-built_in">next</span> = greater.<span class="hljs-built_in">next</span>        <span class="hljs-keyword">return</span> lesser.<span class="hljs-built_in">next</span><span class="hljs-comment"># leetcode submit region end(Prohibit modification and deletion)</span></code></pre><h6 id="138-复制带随机指针的链表"><a href="#138-复制带随机指针的链表" class="headerlink" title="138. 复制带随机指针的链表"></a><a href="https://leetcode-cn.com/problems/copy-list-with-random-pointer/">138. 复制带随机指针的链表</a></h6><p>给你一个长度为 n 的链表，每个节点包含一个额外增加的随机指针 random ，该指针可以指向链表中的任何节点或空节点。</p><p>构造这个链表的 深拷贝。 深拷贝应该正好由 n 个 全新 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 next 指针和 random 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。<strong>复制链表中的指针都不应指向原链表中的节点 。</strong></p><p>例如，如果原链表中有 X 和 Y 两个节点，其中 X.random –&gt; Y 。那么在复制链表中对应的两个节点 x 和 y ，同样有 x.random –&gt; y 。</p><p>返回复制链表的头节点。</p><p>用一个由 n 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 [val, random_index] 表示：</p><p>val：一个表示 Node.val 的整数。<br>random_index：随机指针指向的节点索引（范围从 0 到 n-1）；如果不指向任何节点，则为  null 。<br>你的代码 只 接受原链表的头节点 head 作为传入参数。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e1.png"></p><pre><code class="hljs angelscript">输入：head = [[<span class="hljs-number">7</span>,<span class="hljs-literal">null</span>],[<span class="hljs-number">13</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">11</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">10</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">0</span>]]输出：[[<span class="hljs-number">7</span>,<span class="hljs-literal">null</span>],[<span class="hljs-number">13</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">11</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">10</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">0</span>]]</code></pre><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e2.png"></p><pre><code class="hljs lua">输入：head = <span class="hljs-string">[[1,1],[2,1]]</span>输出：<span class="hljs-string">[[1,1],[2,1]]</span></code></pre><p><strong>示例 3：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e3.png"></p><p><strong>示例 4：</strong></p><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[]</span>输出：<span class="hljs-comment">[]</span>解释：给定的链表为空（空指针），因此返回 null。</code></pre><p><strong>提示：</strong></p><ul><li><code>0 &lt;= n &lt;= 1000</code></li><li><code>-10000 &lt;= Node.val &lt;= 10000</code></li><li><code>Node.random</code> 为空（null）或指向链表中的节点。</li></ul><p>解题思路</p><pre><code class="hljs lsl">三轮：<span class="hljs-number">1.</span>原始链表每个节点后插入该节点的复制节点（<span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span> =&gt; <span class="hljs-number">1</span>-&gt;<span class="hljs-number">1</span>&#x27;-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">2</span>&#x27;-&gt;<span class="hljs-number">3</span><span class="hljs-number">-3</span>&#x27;）<span class="hljs-number">2.</span>修正新节点的random值<span class="hljs-number">3.</span>将<span class="hljs-number">1</span>-&gt;<span class="hljs-number">1</span>&#x27;-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">2</span>&#x27;-&gt;<span class="hljs-number">3</span><span class="hljs-number">-3</span>&#x27;拆分成<span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>  <span class="hljs-number">1</span>&#x27;-&gt;<span class="hljs-number">2</span>&#x27;-&gt;<span class="hljs-number">3</span>&#x27;</code></pre><p><code>Java</code></p><pre><code class="hljs Java"><span class="hljs-comment">/*</span><span class="hljs-comment"> * Author: Wang P</span><span class="hljs-comment"> * Version: 1.0.0</span><span class="hljs-comment"> * Date: 2021-03-06 20:31:24</span><span class="hljs-comment"> * Description: 138-Copy List with Random Pointer</span><span class="hljs-comment"> **/</span> <span class="hljs-keyword">package</span> com.weitrue.leetcode.editor.cn;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CopyListWithRandomPointer</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;        Solution s = <span class="hljs-keyword">new</span> CopyListWithRandomPointer().<span class="hljs-function">new <span class="hljs-title">Solution</span><span class="hljs-params">()</span></span>;    &#125;        <span class="hljs-comment">//A linked list of length n is given such that each node contains an additional random pointer, which could point to any node in the list, or null.</span>    <span class="hljs-comment">//</span>    <span class="hljs-comment">// Construct a deep copy of the list. The deep copy should consist of exactly n brand new nodes, where each new node has its value set to the value of its corre</span>    <span class="hljs-comment">//sponding original node. Both the next and random pointer of the new nodes should point to new nodes in the copied list such that the pointers in the original li</span>    <span class="hljs-comment">//st and copied list represent the same list state. None of the pointers in the new list should point to nodes in the original list.</span>    <span class="hljs-comment">//</span>    <span class="hljs-comment">// For example, if there are two nodes X and Y in the original list, where X.random --&gt; Y, then for the corresponding two nodes x and y in the copied list, x.random --&gt; y.</span>    <span class="hljs-comment">//</span>    <span class="hljs-comment">// Return the head of the copied linked list.</span>    <span class="hljs-comment">//</span>    <span class="hljs-comment">// The linked list is represented in the input/output as a list of n nodes. Each node is represented as a pair of [val, random_index] where:</span>    <span class="hljs-comment">//</span>    <span class="hljs-comment">// val: an integer representing Node.val</span>    <span class="hljs-comment">// random_index: the index of the node (range from 0 to n-1) that the random pointer points to, or null if it does not point to any node.</span>    <span class="hljs-comment">//</span>    <span class="hljs-comment">// Your code will only be given the head of the original linked list.</span>    <span class="hljs-comment">//</span>    <span class="hljs-comment">// Example 1:</span>    <span class="hljs-comment">//Input: head = [[7,null],[13,0],[11,4],[10,2],[1,0]]</span>    <span class="hljs-comment">//Output: [[7,null],[13,0],[11,4],[10,2],[1,0]]</span>    <span class="hljs-comment">//</span>    <span class="hljs-comment">// Example 2:</span>    <span class="hljs-comment">//Input: head = [[1,1],[2,1]]</span>    <span class="hljs-comment">//Output: [[1,1],[2,1]]</span>    <span class="hljs-comment">//</span>    <span class="hljs-comment">// Example 3:</span>    <span class="hljs-comment">//Input: head = [[3,null],[3,0],[3,null]]</span>    <span class="hljs-comment">//Output: [[3,null],[3,0],[3,null]]</span>    <span class="hljs-comment">//</span>    <span class="hljs-comment">// Example 4:</span>    <span class="hljs-comment">//Input: head = []</span>    <span class="hljs-comment">//Output: []</span>    <span class="hljs-comment">//Explanation: The given linked list is empty (null pointer), so return null.</span>    <span class="hljs-comment">//</span>    <span class="hljs-comment">// Constraints:</span>    <span class="hljs-comment">// 0 &lt;= n &lt;= 1000</span>    <span class="hljs-comment">// -10000 &lt;= Node.val &lt;= 10000</span>    <span class="hljs-comment">// Node.random is null or is pointing to some node in the linked list.</span>    <span class="hljs-comment">//</span>    <span class="hljs-comment">// Related Topics 哈希表 链表</span>    <span class="hljs-comment">// 👍 519 👎 0</span>    <span class="hljs-comment">//leetcode submit region begin(Prohibit modification and deletion)</span>    <span class="hljs-comment">/*</span><span class="hljs-comment">    // Definition for a Node.</span><span class="hljs-comment"></span><span class="hljs-comment">    */</span>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;        <span class="hljs-keyword">int</span> val;        Node next;        Node random;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span> </span>&#123;            <span class="hljs-keyword">this</span>.val = val;            <span class="hljs-keyword">this</span>.next = <span class="hljs-keyword">null</span>;            <span class="hljs-keyword">this</span>.random = <span class="hljs-keyword">null</span>;        &#125;    &#125;    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;        <span class="hljs-function"><span class="hljs-keyword">public</span> Node <span class="hljs-title">copyRandomList</span><span class="hljs-params">(Node head)</span> </span>&#123;            <span class="hljs-keyword">if</span> (head ==  <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;            &#125;            Node cur = head;            <span class="hljs-keyword">while</span> (cur != <span class="hljs-keyword">null</span>) &#123;                Node n = <span class="hljs-keyword">new</span> Node(cur.val);                n.next = cur.next;                cur.next = n;                cur = n.next;            &#125;            cur = head;            <span class="hljs-keyword">while</span> (cur != <span class="hljs-keyword">null</span>) &#123;                cur.next.random = (cur.random != <span class="hljs-keyword">null</span>) ? cur.random.next : <span class="hljs-keyword">null</span>;                cur = cur.next.next;            &#125;            cur = head;            Node newNode = head.next, next = newNode;            <span class="hljs-keyword">while</span> (cur != <span class="hljs-keyword">null</span>) &#123;                cur.next = cur.next.next;                next.next = next.next != <span class="hljs-keyword">null</span> ? next.next.next: <span class="hljs-keyword">null</span>;                cur = cur.next;                next = next.next;            &#125;            <span class="hljs-keyword">return</span> newNode;        &#125;    &#125;    <span class="hljs-comment">//leetcode submit region end(Prohibit modification and deletion)</span>&#125;</code></pre><p><code>Golang</code></p><pre><code class="hljs Golang"><span class="hljs-keyword">package</span> leetcode<span class="hljs-comment">/**</span><span class="hljs-comment"> * Author: Wang P</span><span class="hljs-comment"> * Version: 1.0.0</span><span class="hljs-comment"> * Date: 2021-03-18 20:37:49</span><span class="hljs-comment"> * Description: A linked list of length n is given such that each node contains an additional random pointer, which could point to any node in the list, or null.</span><span class="hljs-comment"></span><span class="hljs-comment">Construct a deep copy of the list. The deep copy should consist of exactly n brand new nodes, where each new node has its value set to the value of its corre</span><span class="hljs-comment">sponding original node. Both the next and random pointer of the new nodes should point to new nodes in the copied list such that the pointers in the original li</span><span class="hljs-comment">st and copied list represent the same list state. None of the pointers in the new list should point to nodes in the original list.</span><span class="hljs-comment"></span><span class="hljs-comment">For example, if there are two nodes X and Y in the original list, where X.random --&gt; Y, then for the corresponding two nodes x and y in the copied list, x.random --&gt; y.</span><span class="hljs-comment"></span><span class="hljs-comment">Return the head of the copied linked list.</span><span class="hljs-comment"></span><span class="hljs-comment">The linked list is represented in the input/output as a list of n nodes. Each node is represented as a pair of [val, random_index] where:</span><span class="hljs-comment"></span><span class="hljs-comment">val: an integer representing Node.val</span><span class="hljs-comment">random_index: the index of the node (range from 0 to n-1) that the random pointer points to, or null if it does not point to any node.</span><span class="hljs-comment"></span><span class="hljs-comment">Your code will only be given the head of the original linked list.</span><span class="hljs-comment"></span><span class="hljs-comment">Example 1:</span><span class="hljs-comment">Input: head = [[7,null],[13,0],[11,4],[10,2],[1,0]]</span><span class="hljs-comment">Output: [[7,null],[13,0],[11,4],[10,2],[1,0]]</span><span class="hljs-comment"></span><span class="hljs-comment">Example 2:</span><span class="hljs-comment">Input: head = [[1,1],[2,1]]</span><span class="hljs-comment">Output: [[1,1],[2,1]]</span><span class="hljs-comment"></span><span class="hljs-comment">Example 3:</span><span class="hljs-comment">Input: head = [[3,null],[3,0],[3,null]]</span><span class="hljs-comment">Output: [[3,null],[3,0],[3,null]]</span><span class="hljs-comment"></span><span class="hljs-comment">Example 4:</span><span class="hljs-comment">Input: head = []</span><span class="hljs-comment">Output: []</span><span class="hljs-comment">Explanation: The given linked list is empty (null pointer), so return null.</span><span class="hljs-comment"></span><span class="hljs-comment">Constraints:</span><span class="hljs-comment">0 &lt;= n &lt;= 1000</span><span class="hljs-comment">-10000 &lt;= Node.val &lt;= 10000</span><span class="hljs-comment">Node.random is null or is pointing to some node in the linked list.</span><span class="hljs-comment"></span><span class="hljs-comment">Related Topics 哈希表 链表</span><span class="hljs-comment">👍 519 👎 0</span><span class="hljs-comment"> **/</span><span class="hljs-comment">//leetcode submit region begin(Prohibit modification and deletion)</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a Node.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">type</span> Node <span class="hljs-keyword">struct</span> &#123;Val <span class="hljs-keyword">int</span>   Next *Node   Random *Node&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">copyRandomList</span><span class="hljs-params">(head *Node)</span> *<span class="hljs-title">Node</span></span> &#123;<span class="hljs-keyword">if</span> head == <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>&#125;cur := head<span class="hljs-keyword">for</span> cur != <span class="hljs-literal">nil</span> &#123;n := &amp;Node&#123;Val:cur.Val, Next:cur.Next&#125;cur.Next = ncur = n.Next&#125;  cur = head<span class="hljs-keyword">for</span> cur != <span class="hljs-literal">nil</span> &amp;&amp; cur.Next != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">if</span> cur.Random != <span class="hljs-literal">nil</span> &#123;cur.Next.Random = cur.Random.Next&#125;<span class="hljs-keyword">else</span> &#123;cur.Next.Random = <span class="hljs-literal">nil</span>&#125;cur = cur.Next.Next&#125;  cur = headnewNode, next := head.Next, head.Next<span class="hljs-keyword">for</span> cur != <span class="hljs-literal">nil</span> &amp;&amp; cur.Next != <span class="hljs-literal">nil</span> &#123;cur.Next = cur.Next.Next<span class="hljs-keyword">if</span> next.Next != <span class="hljs-literal">nil</span> &#123;next.Next = next.Next.Next&#125;<span class="hljs-keyword">else</span> &#123;next.Next = <span class="hljs-literal">nil</span>&#125;cur = cur.Nextnext = next.Next&#125;<span class="hljs-keyword">return</span> newNode&#125;<span class="hljs-comment">//leetcode submit region end(Prohibit modification and deletion)</span></code></pre><p><code>Python</code></p><pre><code class="hljs Python"><span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">Module Description: 138-复制带随机指针的链表</span><span class="hljs-string">Solution：</span><span class="hljs-string">Date: 2021-03-06 20:33:56</span><span class="hljs-string">Author: Wang P</span><span class="hljs-string">Problem:  给你一个长度为 n 的链表，每个节点包含一个额外增加的随机指针 random ，该指针可以指向链表中的任何节点或空节点。</span><span class="hljs-string">          构造这个链表的 深拷贝。 深拷贝应该正好由 n 个 全新 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 next 指针和 random</span><span class="hljs-string">         指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。复制链表中的指针都不应指向原链表中的节点 。</span><span class="hljs-string">          例如，如果原链表中有 X 和 Y 两个节点，其中 X.random --&gt; Y 。那么在复制链表中对应的两个节点 x 和 y ，同样有 x.random--&gt; y 。</span><span class="hljs-string">          返回复制链表的头节点。</span><span class="hljs-string">          用一个由 n 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 [val, random_index] 表示：</span><span class="hljs-string">          val：一个表示 Node.val 的整数。</span><span class="hljs-string">          random_index：随机指针指向的节点索引（范围从 0 到 n-1）；如果不指向任何节点，则为 null 。</span><span class="hljs-string">          你的代码 只 接受原链表的头节点 head 作为传入参数。</span><span class="hljs-string"></span><span class="hljs-string">          示例 1：</span><span class="hljs-string">         输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]</span><span class="hljs-string">         输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]</span><span class="hljs-string"></span><span class="hljs-string">          示例 2：</span><span class="hljs-string">         输入：head = [[1,1],[2,1]]</span><span class="hljs-string">         输出：[[1,1],[2,1]]</span><span class="hljs-string"></span><span class="hljs-string">          示例 3：</span><span class="hljs-string">         输入：head = [[3,null],[3,0],[3,null]]</span><span class="hljs-string">         输出：[[3,null],[3,0],[3,null]]</span><span class="hljs-string"></span><span class="hljs-string">          示例 4：</span><span class="hljs-string"></span><span class="hljs-string">         输入：head = []</span><span class="hljs-string">         输出：[]</span><span class="hljs-string">         解释：给定的链表为空（空指针），因此返回 null。</span><span class="hljs-string"></span><span class="hljs-string">          提示：</span><span class="hljs-string">          0 &lt;= n &lt;= 1000</span><span class="hljs-string">          -10000 &lt;= Node.val &lt;= 10000</span><span class="hljs-string">          Node.random 为空（null）或指向链表中的节点。</span><span class="hljs-string"></span><span class="hljs-string">          Related Topics 哈希表 链表</span><span class="hljs-string">          👍 519 👎 0</span><span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-comment"># leetcode submit region begin(Prohibit modification and deletion)</span><span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string"># Definition for a Node.</span><span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-comment"># class Node:</span><span class="hljs-comment">#     def __init__(self, x: int, next: &#x27;Node&#x27; = None, random: &#x27;Node&#x27; = None):</span><span class="hljs-comment">#         self.val = int(x)</span><span class="hljs-comment">#         self.next = next</span><span class="hljs-comment">#         self.random = random</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">copyRandomList</span>(<span class="hljs-params">self, head: <span class="hljs-string">&#x27;Node&#x27;</span></span>) -&gt; &#x27;Node&#x27;:</span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> head:            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>        cur = head        <span class="hljs-keyword">while</span> cur:            n = Node(x=cur.val, <span class="hljs-built_in">next</span>=cur.<span class="hljs-built_in">next</span>)            cur.<span class="hljs-built_in">next</span> = n            cur = n.<span class="hljs-built_in">next</span>        cur = head        <span class="hljs-keyword">while</span> cur <span class="hljs-keyword">and</span> cur.<span class="hljs-built_in">next</span>:            cur.<span class="hljs-built_in">next</span>.random = cur.random.<span class="hljs-built_in">next</span> <span class="hljs-keyword">if</span> cur.random <span class="hljs-keyword">else</span> <span class="hljs-literal">None</span>            cur = cur.<span class="hljs-built_in">next</span>.<span class="hljs-built_in">next</span>        cur = head        new_node = nex = head.<span class="hljs-built_in">next</span>        <span class="hljs-keyword">while</span> cur <span class="hljs-keyword">and</span> nex:            cur.<span class="hljs-built_in">next</span> = cur.<span class="hljs-built_in">next</span>.<span class="hljs-built_in">next</span>            nex.<span class="hljs-built_in">next</span> = nex.<span class="hljs-built_in">next</span>.<span class="hljs-built_in">next</span> <span class="hljs-keyword">if</span> nex.<span class="hljs-built_in">next</span> <span class="hljs-keyword">else</span> <span class="hljs-literal">None</span>            cur = cur.<span class="hljs-built_in">next</span>            nex = nex.<span class="hljs-built_in">next</span>        <span class="hljs-keyword">return</span> new_node        <span class="hljs-comment"># leetcode submit region end(Prohibit modification and deletion)</span></code></pre><h4 id="线程池与任务队列"><a href="#线程池与任务队列" class="headerlink" title="线程池与任务队列"></a>线程池与任务队列</h4><h5 id="简单队列设计"><a href="#简单队列设计" class="headerlink" title="简单队列设计"></a>简单队列设计</h5><pre><code class="hljs Java"></code></pre><pre><code class="hljs go"><span class="hljs-keyword">package</span> array<span class="hljs-keyword">type</span> Queue []<span class="hljs-keyword">interface</span> &#123;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(q *Queue)</span><span class="hljs-title">push</span><span class="hljs-params">(v <span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">error</span></span> &#123;  <span class="hljs-comment">// 入队</span>*q = <span class="hljs-built_in">append</span>(*q, v)<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(q *Queue)</span><span class="hljs-title">pop</span><span class="hljs-params">()</span> <span class="hljs-params">(<span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-keyword">bool</span>)</span></span> &#123;  <span class="hljs-comment">// 出队</span><span class="hljs-keyword">if</span> q.isEmpty() &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">false</span>&#125;head := (*q)[<span class="hljs-number">0</span>]*q = (*q)[<span class="hljs-number">1</span>:]<span class="hljs-keyword">return</span> head, <span class="hljs-literal">true</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(q *Queue)</span><span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> <span class="hljs-title">bool</span></span> &#123;  <span class="hljs-comment">// 队列判空</span><span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(*q) == <span class="hljs-number">0</span>&#125;</code></pre><pre><code class="hljs Python"></code></pre><h6 id="622-设计循环队列"><a href="#622-设计循环队列" class="headerlink" title="622. 设计循环队列"></a><a href="https://leetcode-cn.com/problems/design-circular-queue/">622. 设计循环队列</a></h6><p>设计你的循环队列实现。 循环队列是一种线性数据结构，其操作表现基于 FIFO（先进先出）原则并且队尾被连接在队首之后以形成一个循环。它也被称为“环形缓冲器”。</p><p>循环队列的一个好处是我们可以利用这个队列之前用过的空间。在一个普通队列里，一旦一个队列满了，我们就不能插入下一个元素，即使在队列前面仍有空间。但是使用循环队列，我们能使用这些空间去存储新的值。</p><p><code>(tail-front)</code></p><p>你的实现应该支持如下操作：</p><ul><li>MyCircularQueue(k): 构造器，设置队列长度为 k 。</li><li>Front: 从队首获取元素。如果队列为空，返回 -1 。</li><li>Rear: 获取队尾元素。如果队列为空，返回 -1 。</li><li>enQueue(value): 向循环队列插入一个元素。如果成功插入则返回真。<br>deQueue(): 从循环队列中删除一个元素。如果成功删除则返回真。<br>isEmpty(): 检查循环队列是否为空。<br>isFull(): 检查循环队列是否已满。</li></ul><p>解题思路</p><pre><code class="hljs plain">基于数组实现基于链表实现</code></pre><p><code>Java</code></p><pre><code class="hljs Java"><span class="hljs-keyword">package</span> com.weitrue.leetcode.editor.cn;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DesignCircularQueue</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;        Solution s = <span class="hljs-keyword">new</span> DesignCircularQueue().<span class="hljs-function">new <span class="hljs-title">Solution</span><span class="hljs-params">()</span></span>;    &#125;     <span class="hljs-comment">//leetcode submit region begin(Prohibit modification and deletion)</span>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyCircularQueue</span> </span>&#123;            <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] queue;            <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> capacity, front, rear, count;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyCircularQueue</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k)</span> </span>&#123;            queue = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[k];            capacity = k;            count = <span class="hljs-number">0</span>;            front = <span class="hljs-number">0</span>;            rear = <span class="hljs-number">0</span>;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">enQueue</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;            <span class="hljs-keyword">if</span> (isFull()) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            queue[rear++] = value;            rear %= capacity;            count++;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">deQueue</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">if</span> (isEmpty()) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            front = (front + <span class="hljs-number">1</span>) % capacity;            count--;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">Front</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">if</span> (isEmpty()) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;            <span class="hljs-keyword">return</span> queue[front];        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">Rear</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">if</span> (isEmpty()) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;            <span class="hljs-keyword">return</span> queue[(rear-<span class="hljs-number">1</span>+capacity)%capacity];        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> count == <span class="hljs-number">0</span>;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isFull</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> count == capacity;        &#125;    &#125;    <span class="hljs-comment">//leetcode submit region end(Prohibit modification and deletion)</span>&#125;</code></pre><p><code>Golang</code></p><pre><code class="hljs Golang"><span class="hljs-keyword">type</span> MyCircularQueue <span class="hljs-keyword">struct</span> &#123;queue []<span class="hljs-keyword">int</span>capacity <span class="hljs-keyword">int</span>count <span class="hljs-keyword">int</span>front <span class="hljs-keyword">int</span>rear <span class="hljs-keyword">int</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">(k <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">MyCircularQueue</span></span> &#123;<span class="hljs-keyword">return</span> MyCircularQueue&#123;queue:<span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, k),capacity:k,&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MyCircularQueue)</span> <span class="hljs-title">EnQueue</span><span class="hljs-params">(value <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">bool</span></span> &#123;<span class="hljs-keyword">if</span> this.IsFull() &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>&#125;this.queue[this.rear] = valuethis.rear = (this.rear + <span class="hljs-number">1</span>) % this.capacitythis.count++<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MyCircularQueue)</span> <span class="hljs-title">DeQueue</span><span class="hljs-params">()</span> <span class="hljs-title">bool</span></span> &#123;<span class="hljs-keyword">if</span> this.IsEmpty()&#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>&#125;this.front = (this.front + <span class="hljs-number">1</span>) % this.capacitythis.count--<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MyCircularQueue)</span> <span class="hljs-title">Front</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span> &#123;<span class="hljs-keyword">if</span> this.IsEmpty() &#123; <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>&#125;<span class="hljs-keyword">return</span> this.queue[this.front]&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MyCircularQueue)</span> <span class="hljs-title">Rear</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span> &#123;<span class="hljs-keyword">if</span> this.IsEmpty() &#123; <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>&#125;<span class="hljs-keyword">return</span> this.queue[(this.rear - <span class="hljs-number">1</span> + this.capacity)%this.capacity]&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MyCircularQueue)</span> <span class="hljs-title">IsEmpty</span><span class="hljs-params">()</span> <span class="hljs-title">bool</span></span> &#123;<span class="hljs-keyword">return</span> this.count == <span class="hljs-number">0</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MyCircularQueue)</span> <span class="hljs-title">IsFull</span><span class="hljs-params">()</span> <span class="hljs-title">bool</span></span> &#123;<span class="hljs-keyword">return</span> this.count == this.capacity&#125;</code></pre><p><code>Python</code></p><pre><code class="hljs Python"><span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">Module Description: 622-设计循环队列</span><span class="hljs-string">Solution：</span><span class="hljs-string">Author: Wang P</span><span class="hljs-string">Problem:# 设计你的循环队列实现。 循环队列是一种线性数据结构，其操作表现基于 FIFO（先进先出）原则并且队尾被连接在队首之后以形成一个循环。它也被称为“环形缓冲器”。</span><span class="hljs-string">        #  循环队列的一个好处是我们可以利用这个队列之前用过的空间。在一个普通队列里，一旦一个队列满了，我们就不能插入下一个元素，即使在队列前面仍有空间。但是使用循环队列，我们能使用这些空间去存储新的值。</span><span class="hljs-string">        #</span><span class="hljs-string">        #  你的实现应该支持如下操作：</span><span class="hljs-string">        #</span><span class="hljs-string">        #  MyCircularQueue(k): 构造器，设置队列长度为 k 。</span><span class="hljs-string">        #  Front: 从队首获取元素。如果队列为空，返回 -1 。</span><span class="hljs-string">        #  Rear: 获取队尾元素。如果队列为空，返回 -1 。</span><span class="hljs-string">        #  enQueue(value): 向循环队列插入一个元素。如果成功插入则返回真。</span><span class="hljs-string">        #  deQueue(): 从循环队列中删除一个元素。如果成功删除则返回真。</span><span class="hljs-string">        #  isEmpty(): 检查循环队列是否为空。</span><span class="hljs-string">        #  isFull(): 检查循环队列是否已满。</span><span class="hljs-string">        #</span><span class="hljs-string">        #  示例：</span><span class="hljs-string">        #  MyCircularQueue circularQueue = new MyCircularQueue(3); // 设置长度为 3</span><span class="hljs-string">        # circularQueue.enQueue(1);  // 返回 true</span><span class="hljs-string">        # circularQueue.enQueue(2);  // 返回 true</span><span class="hljs-string">        # circularQueue.enQueue(3);  // 返回 true</span><span class="hljs-string">        # circularQueue.enQueue(4);  // 返回 false，队列已满</span><span class="hljs-string">        # circularQueue.Rear();  // 返回 3</span><span class="hljs-string">        # circularQueue.isFull();  // 返回 true</span><span class="hljs-string">        # circularQueue.deQueue();  // 返回 true</span><span class="hljs-string">        # circularQueue.enQueue(4);  // 返回 true</span><span class="hljs-string">        # circularQueue.Rear();  // 返回 4</span><span class="hljs-string">        #</span><span class="hljs-string">        #  提示：</span><span class="hljs-string">        #  所有的值都在 0 至 1000 的范围内；</span><span class="hljs-string">        #  操作数将在 1 至 1000 的范围内；</span><span class="hljs-string">        #  请不要使用内置的队列库。</span><span class="hljs-string">        #</span><span class="hljs-string">        #  Related Topics 设计 队列</span><span class="hljs-string">        #  👍 180 👎 0</span><span class="hljs-string"></span><span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-comment"># leetcode submit region begin(Prohibit modification and deletion)</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyCircularQueue</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, k: <span class="hljs-built_in">int</span></span>):</span>        self.queue = []        self.capacity = k        self.count = <span class="hljs-number">0</span>        self.front = <span class="hljs-number">0</span>        self.rear = <span class="hljs-number">0</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, k):            self.queue.append(<span class="hljs-number">-1</span>)    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">enQueue</span>(<span class="hljs-params">self, value: <span class="hljs-built_in">int</span></span>) -&gt; bool:</span>        <span class="hljs-keyword">if</span> self.isFull():            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>        self.queue[self.rear] = value        self.rear = (self.rear + <span class="hljs-number">1</span>) % self.capacity        self.count += <span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">deQueue</span>(<span class="hljs-params">self</span>) -&gt; bool:</span>        <span class="hljs-keyword">if</span> self.isEmpty():            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>        self.front = (self.front + <span class="hljs-number">1</span>) % self.capacity        self.count -= <span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Front</span>(<span class="hljs-params">self</span>) -&gt; int:</span>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span> <span class="hljs-keyword">if</span> self.isEmpty() <span class="hljs-keyword">else</span> self.queue[self.front]    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Rear</span>(<span class="hljs-params">self</span>) -&gt; int:</span>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span> <span class="hljs-keyword">if</span> self.isEmpty() <span class="hljs-keyword">else</span> self.queue[(self.rear - <span class="hljs-number">1</span> + self.capacity) % self.capacity]    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isEmpty</span>(<span class="hljs-params">self</span>) -&gt; bool:</span>        <span class="hljs-keyword">return</span> self.count == <span class="hljs-number">0</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isFull</span>(<span class="hljs-params">self</span>) -&gt; bool:</span>        <span class="hljs-keyword">return</span> self.count == self.capacity<span class="hljs-comment"># leetcode submit region end(Prohibit modification and deletion)</span></code></pre><p><strong>链表方式</strong></p><pre><code class="hljs Java"><span class="hljs-comment">// 链表方式实现</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;     <span class="hljs-keyword">int</span> val;     Node next;     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span> </span>&#123;         <span class="hljs-keyword">this</span>.val = val;     &#125; &#125; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CircularQueue</span> </span>&#123;     <span class="hljs-keyword">private</span> Node head, tail;     <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> count, capacity;     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CircularQueue</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k)</span> </span>&#123;         capacity = k;     &#125;     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">enQueue</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;         <span class="hljs-keyword">if</span> (isFull()) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;         Node node = <span class="hljs-keyword">new</span> Node(value);         <span class="hljs-keyword">if</span> (count == <span class="hljs-number">0</span>) &#123;             head = node;             tail = node;         &#125;<span class="hljs-keyword">else</span>&#123;             tail.next = node;             tail = tail.next;         &#125;         count++;         <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;     &#125;     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">deQueue</span><span class="hljs-params">()</span> </span>&#123;         <span class="hljs-keyword">if</span> (isEmpty()) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;         head = head.next;         <span class="hljs-keyword">if</span> (count == <span class="hljs-number">1</span>) tail = head;         count--;         <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;     &#125;     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">Front</span><span class="hljs-params">()</span> </span>&#123;         <span class="hljs-keyword">return</span> head.val;     &#125;     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">Rear</span><span class="hljs-params">()</span> </span>&#123;         <span class="hljs-keyword">return</span> tail.val;     &#125;     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> </span>&#123;         <span class="hljs-keyword">return</span> count == <span class="hljs-number">0</span>;     &#125;     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isFull</span><span class="hljs-params">()</span> </span>&#123;         <span class="hljs-keyword">return</span> count == capacity;     &#125; &#125;</code></pre><pre><code class="hljs Go"><span class="hljs-keyword">type</span> ListNode <span class="hljs-keyword">struct</span> &#123;Val  <span class="hljs-keyword">int</span>Next *ListNode&#125;<span class="hljs-keyword">type</span> CircularQueue <span class="hljs-keyword">struct</span> &#123;capacity <span class="hljs-keyword">int</span>count    <span class="hljs-keyword">int</span>head     *ListNodetail     *ListNode&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewCircularQueue</span><span class="hljs-params">(k <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">CircularQueue</span></span> &#123;<span class="hljs-keyword">return</span> CircularQueue&#123;capacity:k,&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *CircularQueue)</span> <span class="hljs-title">EnQueue</span><span class="hljs-params">(value <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">bool</span></span> &#123;<span class="hljs-keyword">if</span> this.IsFull() &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>&#125;node := ListNode&#123;Val: value&#125;<span class="hljs-keyword">if</span> this.count == <span class="hljs-number">0</span> &#123;this.head = &amp;nodethis.tail = &amp;node&#125; <span class="hljs-keyword">else</span> &#123;this.tail.Next = &amp;nodethis.tail = this.tail.Next&#125;this.count++<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *CircularQueue)</span> <span class="hljs-title">DeQueue</span><span class="hljs-params">()</span> <span class="hljs-title">bool</span></span> &#123;<span class="hljs-keyword">if</span> this.IsEmpty()&#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>&#125;this.head = this.head.Next<span class="hljs-keyword">if</span> this.count == <span class="hljs-number">1</span> &#123;this.tail = this.head&#125;this.count--<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *CircularQueue)</span> <span class="hljs-title">Front</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span> &#123;<span class="hljs-keyword">if</span> this.IsEmpty() &#123; <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>&#125;<span class="hljs-keyword">return</span> this.head.Val&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *CircularQueue)</span> <span class="hljs-title">Rear</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span> &#123;<span class="hljs-keyword">if</span> this.IsEmpty() &#123;<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>&#125;<span class="hljs-keyword">return</span> this.tail.Val&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *CircularQueue)</span> <span class="hljs-title">IsEmpty</span><span class="hljs-params">()</span> <span class="hljs-title">bool</span></span> &#123;<span class="hljs-keyword">return</span> this.count == <span class="hljs-number">0</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *CircularQueue)</span> <span class="hljs-title">IsFull</span><span class="hljs-params">()</span> <span class="hljs-title">bool</span></span> &#123;<span class="hljs-keyword">return</span> this.count == this.capacity&#125;</code></pre><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, value: <span class="hljs-built_in">int</span></span>):</span>        self.val = value        self.next_node = <span class="hljs-literal">None</span>        <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CircularQueue</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, k: <span class="hljs-built_in">int</span></span>):</span>        self.capacity = k        self.count = <span class="hljs-number">0</span>        self.head = <span class="hljs-literal">None</span>        self.tail = <span class="hljs-literal">None</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">enQueue</span>(<span class="hljs-params">self, value: <span class="hljs-built_in">int</span></span>) -&gt; bool:</span>        <span class="hljs-keyword">if</span> self.isFull():            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>        node = Node(value)        <span class="hljs-keyword">if</span> self.count == <span class="hljs-number">0</span>:            self.head = self.tail = node        <span class="hljs-keyword">else</span>:            self.tail.next_node = node            self.tail = self.tail.next_node        self.count += <span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">deQueue</span>(<span class="hljs-params">self</span>) -&gt; bool:</span>        <span class="hljs-keyword">if</span> self.isEmpty():            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>        self.head = self.head.next_node        <span class="hljs-keyword">if</span> self.count == <span class="hljs-number">1</span>:            self.tail = self.head        self.count -= <span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Front</span>(<span class="hljs-params">self</span>) -&gt; int:</span>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span> <span class="hljs-keyword">if</span> self.isEmpty() <span class="hljs-keyword">else</span> self.head.val    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Rear</span>(<span class="hljs-params">self</span>) -&gt; int:</span>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span> <span class="hljs-keyword">if</span> self.isEmpty() <span class="hljs-keyword">else</span> self.tail.val    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isEmpty</span>(<span class="hljs-params">self</span>) -&gt; bool:</span>        <span class="hljs-keyword">return</span> self.count == <span class="hljs-number">0</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isFull</span>(<span class="hljs-params">self</span>) -&gt; bool:</span>        <span class="hljs-keyword">return</span> self.count == self.capacity</code></pre><h6 id="641-设计循环双端队列"><a href="#641-设计循环双端队列" class="headerlink" title="641. 设计循环双端队列"></a><a href="https://leetcode-cn.com/problems/design-circular-deque/">641. 设计循环双端队列</a></h6><p>设计实现双端队列。<br>你的实现需要支持以下操作：</p><ul><li><code>MyCircularDeque(k)</code>：构造函数,双端队列的大小为k。</li><li><code>insertFront()</code>：将一个元素添加到双端队列头部。 如果操作成功返回 true。</li><li><code>insertLast()</code>：将一个元素添加到双端队列尾部。如果操作成功返回 true。</li><li><code>deleteFront()</code>：从双端队列头部删除一个元素。 如果操作成功返回 true。</li><li><code>deleteLast()</code>：从双端队列尾部删除一个元素。如果操作成功返回 true。</li><li><code>getFront()</code>：从双端队列头部获得一个元素。如果双端队列为空，返回 -1。</li><li><code>getRear()</code>：获得双端队列的最后一个元素。 如果双端队列为空，返回 -1。</li><li><code>isEmpty()</code>：检查双端队列是否为空。</li><li><code>isFull()</code>：检查双端队列是否满了。</li></ul><p><strong>示例：</strong></p><pre><code class="hljs Java">MyCircularDeque circularDeque = <span class="hljs-keyword">new</span> MycircularDeque(<span class="hljs-number">3</span>); <span class="hljs-comment">// 设置容量大小为3</span>circularDeque.insertLast(<span class="hljs-number">1</span>);        <span class="hljs-comment">// 返回 true</span>circularDeque.insertLast(<span class="hljs-number">2</span>);        <span class="hljs-comment">// 返回 true</span>circularDeque.insertFront(<span class="hljs-number">3</span>);        <span class="hljs-comment">// 返回 true</span>circularDeque.insertFront(<span class="hljs-number">4</span>);        <span class="hljs-comment">// 已经满了，返回 false</span>circularDeque.getRear();  <span class="hljs-comment">// 返回 2</span>circularDeque.isFull();        <span class="hljs-comment">// 返回 true</span>circularDeque.deleteLast();        <span class="hljs-comment">// 返回 true</span>circularDeque.insertFront(<span class="hljs-number">4</span>);        <span class="hljs-comment">// 返回 true</span>circularDeque.getFront();<span class="hljs-comment">// 返回 4</span></code></pre><p><strong>提示：</strong></p><ul><li>所有值的范围为 [1, 1000]</li><li>操作次数的范围为 [1, 1000]</li><li>请不要使用内置的双端队列库。</li></ul><p>解题思路</p><pre><code class="hljs plain"></code></pre><p><code>Java</code></p><pre><code class="hljs Java"><span class="hljs-keyword">package</span> com.weitrue.leetcode.editor.cn;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DesignCircularDeque</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;        MyCircularDeque s = <span class="hljs-keyword">new</span> DesignCircularDeque().<span class="hljs-function">new <span class="hljs-title">MyCircularDeque</span><span class="hljs-params">(<span class="hljs-number">3</span>)</span></span>;        s.insertLast(<span class="hljs-number">1</span>); <span class="hljs-comment">// return True</span>        s.insertLast(<span class="hljs-number">2</span>); <span class="hljs-comment">// return True</span>        s.insertLast(<span class="hljs-number">3</span>); <span class="hljs-comment">// return True</span>        s.insertLast(<span class="hljs-number">4</span>); <span class="hljs-comment">// return False</span>        s.getRear();     <span class="hljs-comment">// return 3</span>        s.isFull();   <span class="hljs-comment">// return True</span>        s.deleteLast();  <span class="hljs-comment">// return True</span>        s.insertFront(<span class="hljs-number">4</span>); <span class="hljs-comment">// return True</span>        s.getFront();     <span class="hljs-comment">// return 4</span>    &#125;        <span class="hljs-comment">//Design your implementation of the circular double-ended queue (deque). </span>    <span class="hljs-comment">// Your implementation should support following operations:</span>    <span class="hljs-comment">//</span>    <span class="hljs-comment">// MyCircularDeque(k): Constructor, set the size of the deque to be k.</span>    <span class="hljs-comment">// insertFront(): Adds an item at the front of Deque. Return true if the operation is successful.</span>    <span class="hljs-comment">// insertLast(): Adds an item at the rear of Deque. Return true if the operationis successful.</span>    <span class="hljs-comment">// deleteFront(): Deletes an item from the front of Deque. Return true if the operation is successful.</span>    <span class="hljs-comment">// deleteLast(): Deletes an item from the rear of Deque. Return true if the operation is successful.</span>    <span class="hljs-comment">// getFront(): Gets the front item from the Deque. If the deque is empty, return-1.</span>    <span class="hljs-comment">// getRear(): Gets the last item from Deque. If the deque is empty, return -1.</span>    <span class="hljs-comment">// isEmpty(): Checks whether Deque is empty or not.</span>    <span class="hljs-comment">// isFull(): Checks whether Deque is full or not.</span>    <span class="hljs-comment">//</span>    <span class="hljs-comment">// Example:</span>    <span class="hljs-comment">//MyCircularDeque circularDeque = new MycircularDeque(3); // set the size to be</span>    <span class="hljs-comment">//3</span>    <span class="hljs-comment">//circularDeque.insertLast(1);// return true</span>    <span class="hljs-comment">//circularDeque.insertLast(2);// return true</span>    <span class="hljs-comment">//circularDeque.insertFront(3);// return true</span>    <span class="hljs-comment">//circularDeque.insertFront(4);// return false, the queue is full</span>    <span class="hljs-comment">//circularDeque.getRear();  // return 2</span>    <span class="hljs-comment">//circularDeque.isFull();// return true</span>    <span class="hljs-comment">//circularDeque.deleteLast();// return true</span>    <span class="hljs-comment">//circularDeque.insertFront(4);// return true</span>    <span class="hljs-comment">//circularDeque.getFront();// return 4</span>    <span class="hljs-comment">//</span>    <span class="hljs-comment">// Note:</span>    <span class="hljs-comment">// All values will be in the range of [0, 1000].</span>    <span class="hljs-comment">// The number of operations will be in the range of [1, 1000].</span>    <span class="hljs-comment">// Please do not use the built-in Deque library.</span>    <span class="hljs-comment">//</span>    <span class="hljs-comment">// Related Topics 设计 队列</span>    <span class="hljs-comment">// 👍 77 👎 0</span>     <span class="hljs-comment">//leetcode submit region begin(Prohibit modification and deletion)</span>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyCircularDeque</span> </span>&#123;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] queue;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> capacity, front, rear, count;        <span class="hljs-comment">/** Initialize your data structure here. Set the size of the deque to be k. */</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyCircularDeque</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k)</span> </span>&#123;            queue = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[k];            capacity = k;            count = <span class="hljs-number">0</span>;            front = <span class="hljs-number">0</span>;            rear = <span class="hljs-number">0</span>;        &#125;        <span class="hljs-comment">/** Adds an item at the front of Deque. Return true if the operation is successful. */</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">insertFront</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;            <span class="hljs-keyword">if</span> (isFull()) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            front = (front -<span class="hljs-number">1</span> + capacity) % capacity;            queue[front] = value;            count++;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125;        <span class="hljs-comment">/** Adds an item at the rear of Deque. Return true if the operation is successful. */</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">insertLast</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;            <span class="hljs-keyword">if</span> (isFull()) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            queue[rear++] = value;            rear %= capacity;            count++;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125;        <span class="hljs-comment">/** Deletes an item from the front of Deque. Return true if the operation is successful. */</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">deleteFront</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">if</span> (isEmpty()) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            front = (front + <span class="hljs-number">1</span>) % capacity;            count--;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125;        <span class="hljs-comment">/** Deletes an item from the rear of Deque. Return true if the operation is successful. */</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">deleteLast</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">if</span> (isEmpty()) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            rear = (rear -<span class="hljs-number">1</span> + capacity) % capacity;            count--;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125;        <span class="hljs-comment">/** Get the front item from the deque. */</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getFront</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">if</span> (isEmpty()) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;            <span class="hljs-keyword">return</span> queue[front];        &#125;        <span class="hljs-comment">/** Get the last item from the deque. */</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getRear</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">if</span> (isEmpty()) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;            <span class="hljs-keyword">return</span> queue[(rear-<span class="hljs-number">1</span>+capacity)%capacity];        &#125;        <span class="hljs-comment">/** Checks whether the circular deque is empty or not. */</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> count == <span class="hljs-number">0</span>;        &#125;        <span class="hljs-comment">/** Checks whether the circular deque is full or not. */</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isFull</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> count == capacity;        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Your MyCircularDeque object will be instantiated and called as such:</span><span class="hljs-comment">     * MyCircularDeque obj = new MyCircularDeque(k);</span><span class="hljs-comment">     * boolean param_1 = obj.insertFront(value);</span><span class="hljs-comment">     * boolean param_2 = obj.insertLast(value);</span><span class="hljs-comment">     * boolean param_3 = obj.deleteFront();</span><span class="hljs-comment">     * boolean param_4 = obj.deleteLast();</span><span class="hljs-comment">     * int param_5 = obj.getFront();</span><span class="hljs-comment">     * int param_6 = obj.getRear();</span><span class="hljs-comment">     * boolean param_7 = obj.isEmpty();</span><span class="hljs-comment">     * boolean param_8 = obj.isFull();</span><span class="hljs-comment">     */</span>    <span class="hljs-comment">//leetcode submit region end(Prohibit modification and deletion)</span>&#125;</code></pre><p><code>Golang</code></p><pre><code class="hljs Golang"><span class="hljs-keyword">type</span> MyCircularDeque <span class="hljs-keyword">struct</span> &#123;queue []<span class="hljs-keyword">int</span>front <span class="hljs-keyword">int</span>rear <span class="hljs-keyword">int</span>capacity <span class="hljs-keyword">int</span>count <span class="hljs-keyword">int</span>&#125;<span class="hljs-comment">/** Initialize your data structure here. Set the size of the deque to be k. */</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">(k <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">MyCircularDeque</span></span> &#123;<span class="hljs-keyword">return</span> MyCircularDeque&#123;queue:    <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, k),capacity: k,&#125;&#125;<span class="hljs-comment">/** Adds an item at the front of Deque. Return true if the operation is successful. */</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MyCircularDeque)</span> <span class="hljs-title">InsertFront</span><span class="hljs-params">(value <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">bool</span></span> &#123;<span class="hljs-keyword">if</span> this.IsFull() &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>&#125;this.front = (this.front - <span class="hljs-number">1</span> + this.capacity) % this.capacitythis.queue[this.front] = valuethis.count += <span class="hljs-number">1</span><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>&#125;<span class="hljs-comment">/** Adds an item at the rear of Deque. Return true if the operation is successful. */</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MyCircularDeque)</span> <span class="hljs-title">InsertLast</span><span class="hljs-params">(value <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">bool</span></span> &#123;<span class="hljs-keyword">if</span> this.IsFull() &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>&#125;this.queue[this.rear] = valuethis.rear = (this.rear +<span class="hljs-number">1</span>) % this.capacitythis.count += <span class="hljs-number">1</span><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>&#125;<span class="hljs-comment">/** Deletes an item from the front of Deque. Return true if the operation is successful. */</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MyCircularDeque)</span> <span class="hljs-title">DeleteFront</span><span class="hljs-params">()</span> <span class="hljs-title">bool</span></span> &#123;<span class="hljs-keyword">if</span> this.IsEmpty() &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>&#125;this.front = (this.front +<span class="hljs-number">1</span>) % this.capacitythis.count -= <span class="hljs-number">1</span><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>&#125;<span class="hljs-comment">/** Deletes an item from the rear of Deque. Return true if the operation is successful. */</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MyCircularDeque)</span> <span class="hljs-title">DeleteLast</span><span class="hljs-params">()</span> <span class="hljs-title">bool</span></span> &#123;<span class="hljs-keyword">if</span> this.IsEmpty() &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>&#125;this.rear = (this.rear - <span class="hljs-number">1</span> + this.capacity) % this.capacitythis.count -= <span class="hljs-number">1</span><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>&#125;<span class="hljs-comment">/** Get the front item from the deque. */</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MyCircularDeque)</span> <span class="hljs-title">GetFront</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span> &#123;<span class="hljs-keyword">if</span> this.IsEmpty() &#123;<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>&#125;<span class="hljs-keyword">return</span> this.queue[this.front]&#125;<span class="hljs-comment">/** Get the last item from the deque. */</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MyCircularDeque)</span> <span class="hljs-title">GetRear</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span> &#123;<span class="hljs-keyword">if</span> this.IsEmpty() &#123;<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>&#125;<span class="hljs-keyword">return</span> this.queue[(this.rear<span class="hljs-number">-1</span>+this.capacity)%this.capacity]&#125;<span class="hljs-comment">/** Checks whether the circular deque is empty or not. */</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MyCircularDeque)</span> <span class="hljs-title">IsEmpty</span><span class="hljs-params">()</span> <span class="hljs-title">bool</span></span> &#123;<span class="hljs-keyword">return</span> this.count == <span class="hljs-number">0</span>&#125;<span class="hljs-comment">/** Checks whether the circular deque is full or not. */</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MyCircularDeque)</span> <span class="hljs-title">IsFull</span><span class="hljs-params">()</span> <span class="hljs-title">bool</span></span> &#123;<span class="hljs-keyword">return</span> this.count == this.capacity&#125;</code></pre><p><code>Python</code></p><pre><code class="hljs Python"><span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">Module Description: 641-设计循环双端队列</span><span class="hljs-string">Solution：</span><span class="hljs-string">Author: Wang P</span><span class="hljs-string">Problem:# 设计实现双端队列。 </span><span class="hljs-string">        # 你的实现需要支持以下操作：</span><span class="hljs-string">        #  MyCircularDeque(k)：构造函数,双端队列的大小为k。</span><span class="hljs-string">        #  insertFront()：将一个元素添加到双端队列头部。 如果操作成功返回 true。</span><span class="hljs-string">        #  insertLast()：将一个元素添加到双端队列尾部。如果操作成功返回 true。</span><span class="hljs-string">        #  deleteFront()：从双端队列头部删除一个元素。 如果操作成功返回 true。</span><span class="hljs-string">        #  deleteLast()：从双端队列尾部删除一个元素。如果操作成功返回 true。</span><span class="hljs-string">        #  getFront()：从双端队列头部获得一个元素。如果双端队列为空，返回 -1。</span><span class="hljs-string">        #  getRear()：获得双端队列的最后一个元素。 如果双端队列为空，返回 -1。</span><span class="hljs-string">        #  isEmpty()：检查双端队列是否为空。</span><span class="hljs-string">        #  isFull()：检查双端队列是否满了。</span><span class="hljs-string">        #  示例：</span><span class="hljs-string">        #  MyCircularDeque circularDeque = new MycircularDeque(3); // 设置容量大小为3</span><span class="hljs-string">        # circularDeque.insertLast(1);        // 返回 true</span><span class="hljs-string">        # circularDeque.insertLast(2);        // 返回 true</span><span class="hljs-string">        # circularDeque.insertFront(3);        // 返回 true</span><span class="hljs-string">        # circularDeque.insertFront(4);        // 已经满了，返回 false</span><span class="hljs-string">        # circularDeque.getRear();          // 返回 2</span><span class="hljs-string">        # circularDeque.isFull();            // 返回 true</span><span class="hljs-string">        # circularDeque.deleteLast();          // 返回 true</span><span class="hljs-string">        # circularDeque.insertFront(4);        // 返回 true</span><span class="hljs-string">        # circularDeque.getFront();          // 返回 4</span><span class="hljs-string">        #  </span><span class="hljs-string">        #  提示：</span><span class="hljs-string">        #  所有值的范围为 [1, 1000]</span><span class="hljs-string">        #  操作次数的范围为 [1, 1000]</span><span class="hljs-string">        #  请不要使用内置的双端队列库。</span><span class="hljs-string">        #</span><span class="hljs-string">        #  Related Topics 设计 队列</span><span class="hljs-string">        #  👍 77 👎 0</span><span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-comment"># leetcode submit region begin(Prohibit modification and deletion)</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyCircularDeque</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, k: <span class="hljs-built_in">int</span></span>):</span>        <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">        Initialize your data structure here. Set the size of the deque to be k.</span><span class="hljs-string">        &quot;&quot;&quot;</span>        self.queue = []        self.capacity = k        self.count = <span class="hljs-number">0</span>        self.front = <span class="hljs-number">0</span>        self.rear = <span class="hljs-number">0</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, k):            self.queue.append(<span class="hljs-number">-1</span>)    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">insertFront</span>(<span class="hljs-params">self, value: <span class="hljs-built_in">int</span></span>) -&gt; bool:</span>        <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">        Adds an item at the front of Deque. Return true if the operation is successful.</span><span class="hljs-string">        &quot;&quot;&quot;</span>        <span class="hljs-keyword">if</span> self.isFull():            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>        self.front = (self.front - <span class="hljs-number">1</span> + self.capacity) % self.capacity        self.queue[self.front] = value        self.count += <span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">insertLast</span>(<span class="hljs-params">self, value: <span class="hljs-built_in">int</span></span>) -&gt; bool:</span>        <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">        Adds an item at the rear of Deque. Return true if the operation is successful.</span><span class="hljs-string">        &quot;&quot;&quot;</span>        <span class="hljs-keyword">if</span> self.isFull():            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>        self.queue[self.rear] = value        self.rear = (self.rear + <span class="hljs-number">1</span>) % self.capacity        self.count += <span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">deleteFront</span>(<span class="hljs-params">self</span>) -&gt; bool:</span>        <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">        Deletes an item from the front of Deque. Return true if the operation is successful.</span><span class="hljs-string">        &quot;&quot;&quot;</span>        <span class="hljs-keyword">if</span> self.isEmpty():            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>        self.front = (self.front + <span class="hljs-number">1</span>) % self.capacity        self.count -= <span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">deleteLast</span>(<span class="hljs-params">self</span>) -&gt; bool:</span>        <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">        Deletes an item from the rear of Deque. Return true if the operation is successful.</span><span class="hljs-string">        &quot;&quot;&quot;</span>        <span class="hljs-keyword">if</span> self.isEmpty():            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>        self.rear = (self.rear - <span class="hljs-number">1</span> + self.capacity) % self.capacity        self.count -= <span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getFront</span>(<span class="hljs-params">self</span>) -&gt; int:</span>        <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">        Get the front item from the deque.</span><span class="hljs-string">        &quot;&quot;&quot;</span>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span> <span class="hljs-keyword">if</span> self.isEmpty() <span class="hljs-keyword">else</span> self.queue[self.front]    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getRear</span>(<span class="hljs-params">self</span>) -&gt; int:</span>        <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">        Get the last item from the deque.</span><span class="hljs-string">        &quot;&quot;&quot;</span>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span> <span class="hljs-keyword">if</span> self.isEmpty() <span class="hljs-keyword">else</span> self.queue[(self.rear - <span class="hljs-number">1</span> + self.capacity) % self.capacity]    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isEmpty</span>(<span class="hljs-params">self</span>) -&gt; bool:</span>        <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">        Checks whether the circular deque is empty or not.</span><span class="hljs-string">        &quot;&quot;&quot;</span>        <span class="hljs-keyword">return</span> self.count == <span class="hljs-number">0</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isFull</span>(<span class="hljs-params">self</span>) -&gt; bool:</span>        <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">        Checks whether the circular deque is full or not.</span><span class="hljs-string">        &quot;&quot;&quot;</span>        <span class="hljs-keyword">return</span> self.count == self.capacity    <span class="hljs-comment"># Your MyCircularDeque object will be instantiated and called as such:</span>    <span class="hljs-comment"># obj = MyCircularDeque(k)</span>    <span class="hljs-comment"># param_1 = obj.insertFront(value)</span>    <span class="hljs-comment"># param_2 = obj.insertLast(value)</span>    <span class="hljs-comment"># param_3 = obj.deleteFront()</span>    <span class="hljs-comment"># param_4 = obj.deleteLast()</span>    <span class="hljs-comment"># param_5 = obj.getFront()</span>    <span class="hljs-comment"># param_6 = obj.getRear()</span>    <span class="hljs-comment"># param_7 = obj.isEmpty()</span>    <span class="hljs-comment"># param_8 = obj.isFull()</span>    <span class="hljs-comment"># leetcode submit region end(Prohibit modification and deletion)</span></code></pre><h6 id="1670-设计前中后队列"><a href="#1670-设计前中后队列" class="headerlink" title="1670. 设计前中后队列"></a><a href="https://leetcode-cn.com/problems/design-front-middle-back-queue/">1670. 设计前中后队列</a></h6><p>请你设计一个队列，支持在前，中，后三个位置的 <code>push</code> 和 <code>pop</code> 操作。</p><p>请你完成 <code>FrontMiddleBack</code> 类：</p><ul><li><code>FrontMiddleBack()</code> 初始化队列。</li><li><code>void pushFront(int val) </code>将<code>val</code>添加到队列的<strong>最前面</strong>。</li><li><code>void pushMiddle(int val) </code>将<code>val</code>添加到队列的<strong>正中间</strong>。</li><li><code>void pushBack(int val) </code>将<code>val</code>添加到队里的<strong>最后面</strong>。</li><li><code>int popFront() </code>将<strong>最前面</strong>的元素从队列中删除并返回值，如果删除之前队列为空，那么返回 -1 。</li><li><code>int popMiddle() </code>将<strong>正中间</strong>的元素从队列中删除并返回值，如果删除之前队列为空，那么返回 -1 。</li><li><code>int popBack() </code>将<strong>最后面</strong>的元素从队列中删除并返回值，如果删除之前队列为空，那么返回 -1 。</li></ul><p>请注意当有<strong>两个</strong>中间位置的时候，选择靠前面的位置进行操作。比方说：</p><p>将 6 添加到 <code>[1, 2, 3, 4, 5] </code>的中间位置，结果数组为<code>[1, 2, 6, 3, 4, 5]</code>。<br>从 <code>[1, 2, 3, 4, 5, 6] </code>的中间位置弹出元素，返回<code>3</code>，数组变为<code>[1, 2, 4, 5, 6]</code>。</p><p><strong>示例 1：</strong></p><pre><code class="hljs Java">输入：[<span class="hljs-string">&quot;FrontMiddleBackQueue&quot;</span>, <span class="hljs-string">&quot;pushFront&quot;</span>, <span class="hljs-string">&quot;pushBack&quot;</span>, <span class="hljs-string">&quot;pushMiddle&quot;</span>, <span class="hljs-string">&quot;pushMiddle&quot;</span>, <span class="hljs-string">&quot;popFront&quot;</span>, <span class="hljs-string">&quot;popMiddle&quot;</span>, <span class="hljs-string">&quot;popMiddle&quot;</span>, <span class="hljs-string">&quot;popBack&quot;</span>, <span class="hljs-string">&quot;popFront&quot;</span>][[], [<span class="hljs-number">1</span>], [<span class="hljs-number">2</span>], [<span class="hljs-number">3</span>], [<span class="hljs-number">4</span>], [], [], [], [], []]输出：[<span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>, -<span class="hljs-number">1</span>]解释：FrontMiddleBackQueue q = <span class="hljs-keyword">new</span> FrontMiddleBackQueue();q.pushFront(<span class="hljs-number">1</span>);   <span class="hljs-comment">// [1]</span>q.pushBack(<span class="hljs-number">2</span>);    <span class="hljs-comment">// [1, 2]</span>q.pushMiddle(<span class="hljs-number">3</span>);  <span class="hljs-comment">// [1, 3, 2]</span>q.pushMiddle(<span class="hljs-number">4</span>);  <span class="hljs-comment">// [1, 4, 3, 2]</span>q.popFront();     <span class="hljs-comment">// 返回 1 -&gt; [4, 3, 2]</span>q.popMiddle();    <span class="hljs-comment">// 返回 3 -&gt; [4, 2]</span>q.popMiddle();    <span class="hljs-comment">// 返回 4 -&gt; [2]</span>q.popBack();      <span class="hljs-comment">// 返回 2 -&gt; []</span>q.popFront();     <span class="hljs-comment">// 返回 -1 -&gt; [] （队列为空）</span></code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= val &lt;= 109</code></li><li>最多调用 1000 次 <code>pushFront</code>， <code>pushMiddle</code>， <code>pushBack</code>， <code>popFront</code>， <code>popMiddle</code> 和 <code>popBack </code>。</li></ul><p>解题思路</p><pre><code class="hljs plain">两个双端队列</code></pre><p><code>Java</code></p><pre><code class="hljs Java"><span class="hljs-keyword">package</span> com.weitrue.leetcode.editor.cn;<span class="hljs-keyword">import</span> java.util.Deque;<span class="hljs-keyword">import</span> java.util.LinkedList;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DesignFrontMiddleBackQueue</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;        FrontMiddleBackQueue s = <span class="hljs-keyword">new</span> DesignFrontMiddleBackQueue().<span class="hljs-function">new <span class="hljs-title">FrontMiddleBackQueue</span><span class="hljs-params">()</span></span>;    &#125;        <span class="hljs-comment">//Design a queue that supports push and pop operations in the front, middle, and back.</span>    <span class="hljs-comment">// Implement the FrontMiddleBack class:</span>    <span class="hljs-comment">//</span>    <span class="hljs-comment">// FrontMiddleBack() Initializes the queue.</span>    <span class="hljs-comment">// void pushFront(int val) Adds val to the front of the queue.</span>    <span class="hljs-comment">// void pushMiddle(int val) Adds val to the middle of the queue.</span>    <span class="hljs-comment">// void pushBack(int val) Adds val to the back of the queue.</span>    <span class="hljs-comment">// int popFront() Removes the front element of the queue and returns it. If the queue is empty, return -1.</span>    <span class="hljs-comment">// int popMiddle() Removes the middle element of the queue and returns it. If the queue is empty, return -1.</span>    <span class="hljs-comment">// int popBack() Removes the back element of the queue and returns it. If the queue is empty, return -1.</span>    <span class="hljs-comment">//</span>    <span class="hljs-comment">// Notice that when there are two middle position choices, the operation is performed on the frontmost middle position choice. For example:</span>    <span class="hljs-comment">//</span>    <span class="hljs-comment">// Pushing 6 into the middle of [1, 2, 3, 4, 5] results in [1, 2, 6, 3, 4, 5].</span>    <span class="hljs-comment">// Popping the middle from [1, 2, 3, 4, 5, 6] returns 3 and results in [1, 2, 4, 5, 6].</span>    <span class="hljs-comment">//</span>    <span class="hljs-comment">// Example 1:</span>    <span class="hljs-comment">//</span>    <span class="hljs-comment">//Input:</span>    <span class="hljs-comment">//[&quot;FrontMiddleBackQueue&quot;, &quot;pushFront&quot;, &quot;pushBack&quot;, &quot;pushMiddle&quot;, &quot;pushMiddle&quot;,</span>    <span class="hljs-comment">//&quot;popFront&quot;, &quot;popMiddle&quot;, &quot;popMiddle&quot;, &quot;popBack&quot;, &quot;popFront&quot;]</span>    <span class="hljs-comment">//[[], [1], [2], [3], [4], [], [], [], [], []]</span>    <span class="hljs-comment">//Output:</span>    <span class="hljs-comment">//[null, null, null, null, null, 1, 3, 4, 2, -1]</span>    <span class="hljs-comment">//</span>    <span class="hljs-comment">//Explanation:</span>    <span class="hljs-comment">//FrontMiddleBackQueue q = new FrontMiddleBackQueue();</span>    <span class="hljs-comment">//q.pushFront(1);   // [1]</span>    <span class="hljs-comment">//q.pushBack(2);    // [1, 2]</span>    <span class="hljs-comment">//q.pushMiddle(3);  // [1, 3, 2]</span>    <span class="hljs-comment">//q.pushMiddle(4);  // [1, 4, 3, 2]</span>    <span class="hljs-comment">//q.popFront();     // return 1 -&gt; [4, 3, 2]</span>    <span class="hljs-comment">//q.popMiddle();    // return 3 -&gt; [4, 2]</span>    <span class="hljs-comment">//q.popMiddle();    // return 4 -&gt; [2]</span>    <span class="hljs-comment">//q.popBack();      // return 2 -&gt; []</span>    <span class="hljs-comment">//q.popFront();     // return -1 -&gt; [] (The queue is empty)</span>    <span class="hljs-comment">//</span>    <span class="hljs-comment">// Constraints:</span>    <span class="hljs-comment">// 1 &lt;= val &lt;= 109</span>    <span class="hljs-comment">// At most 1000 calls will be made to pushFront, pushMiddle, pushBack, popFront,</span>    <span class="hljs-comment">// popMiddle, and popBack.</span>    <span class="hljs-comment">//</span>    <span class="hljs-comment">// Related Topics 设计 链表</span>    <span class="hljs-comment">// 👍 6 👎 0</span>     <span class="hljs-comment">//leetcode submit region begin(Prohibit modification and deletion)</span>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FrontMiddleBackQueue</span> </span>&#123;        <span class="hljs-keyword">private</span> Deque&lt;Integer&gt; left;        <span class="hljs-keyword">private</span> Deque&lt;Integer&gt; right;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FrontMiddleBackQueue</span><span class="hljs-params">()</span> </span>&#123;            left = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();            right = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pushFront</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span> </span>&#123;            left.addFirst(val);            balanceQueue();        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pushMiddle</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span> </span>&#123;            <span class="hljs-keyword">if</span> (left.size() &gt; right.size()) &#123;                right.addFirst(left.pollLast());            &#125;            left.addLast(val);        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pushBack</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span> </span>&#123;            right.addLast(val);            balanceQueue();        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">popFront</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">if</span> (left.size() + right.size() == <span class="hljs-number">0</span>) &#123;                <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;            &#125;            Integer v;            <span class="hljs-keyword">if</span> (left.size() == <span class="hljs-number">0</span>) &#123;                v = right.pollFirst();            &#125;<span class="hljs-keyword">else</span> &#123;                v= left.pollFirst();            &#125;            balanceQueue();            <span class="hljs-keyword">return</span> v == <span class="hljs-keyword">null</span> ? -<span class="hljs-number">1</span>: v;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">popMiddle</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">if</span> (left.size() + right.size() == <span class="hljs-number">0</span>) &#123;                <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;            &#125;            Integer v = left.pollLast();            balanceQueue();            <span class="hljs-keyword">return</span> v == <span class="hljs-keyword">null</span> ? -<span class="hljs-number">1</span>: v;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">popBack</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">if</span> (left.size() + right.size() == <span class="hljs-number">0</span>) &#123;                <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;            &#125;            Integer v;            <span class="hljs-keyword">if</span> (right.size() == <span class="hljs-number">0</span>) &#123;                v = left.pollLast();            &#125; <span class="hljs-keyword">else</span> &#123;                v = right.pollLast();            &#125;            balanceQueue();            <span class="hljs-keyword">return</span> v == <span class="hljs-keyword">null</span> ? -<span class="hljs-number">1</span>: v;        &#125;        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">balanceQueue</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">if</span> (left.size() - right.size() &gt;=<span class="hljs-number">2</span>) &#123;                right.addFirst(left.pollLast());            &#125;            <span class="hljs-keyword">if</span> (left.size() &lt; right.size()) &#123;                left.addLast(right.pollFirst());            &#125;        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Your FrontMiddleBackQueue object will be instantiated and called as such:</span><span class="hljs-comment">     * FrontMiddleBackQueue obj = new FrontMiddleBackQueue();</span><span class="hljs-comment">     * obj.pushFront(val);</span><span class="hljs-comment">     * obj.pushMiddle(val);</span><span class="hljs-comment">     * obj.pushBack(val);</span><span class="hljs-comment">     * int param_4 = obj.popFront();</span><span class="hljs-comment">     * int param_5 = obj.popMiddle();</span><span class="hljs-comment">     * int param_6 = obj.popBack();</span><span class="hljs-comment">     */</span>    <span class="hljs-comment">//leetcode submit region end(Prohibit modification and deletion)</span>&#125;</code></pre><p><code>Golang</code></p><pre><code class="hljs Golang"><span class="hljs-keyword">package</span> leetcode<span class="hljs-comment">//leetcode submit region begin(Prohibit modification and deletion)</span><span class="hljs-comment">// 双向链表分装</span><span class="hljs-keyword">type</span> DNode <span class="hljs-keyword">struct</span> &#123;val <span class="hljs-keyword">int</span>pre *DNodenext *DNode&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d *DNode)</span> <span class="hljs-title">insertPre</span><span class="hljs-params">(value <span class="hljs-keyword">int</span>)</span></span> &#123;node := &amp;DNode&#123;val: value,pre:d.pre,next: d,&#125;<span class="hljs-keyword">if</span> d.pre != <span class="hljs-literal">nil</span> &#123;d.pre.next = node&#125;d.pre = node&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d *DNode)</span> <span class="hljs-title">insertNext</span><span class="hljs-params">(value <span class="hljs-keyword">int</span>)</span></span> &#123;node := &amp;DNode&#123;val:  value,pre:  d,next: d.next,&#125;<span class="hljs-keyword">if</span> d.next != <span class="hljs-literal">nil</span> &#123;d.next.pre = node&#125;d.next = node&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d *DNode)</span> <span class="hljs-title">deletePre</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">if</span> d.pre == <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span>&#125;d.pre = d.pre.pre<span class="hljs-keyword">if</span> d.pre != <span class="hljs-literal">nil</span> &#123;d.pre.next = d&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d *DNode)</span> <span class="hljs-title">deleteNext</span><span class="hljs-params">()</span></span>  &#123;<span class="hljs-keyword">if</span> d.next == <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span>&#125;d.next = d.next.next<span class="hljs-keyword">if</span> d.next != <span class="hljs-literal">nil</span> &#123;d.next.pre = d&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d *DNode)</span> <span class="hljs-title">printNode</span><span class="hljs-params">()</span></span>  &#123;h := d<span class="hljs-keyword">for</span> h != <span class="hljs-literal">nil</span> &#123;fmt.Print(h.val, <span class="hljs-string">&quot;-&gt;&quot;</span>)h = h.next&#125;&#125;<span class="hljs-keyword">type</span> CircularDeque <span class="hljs-keyword">struct</span> &#123;front *DNoderear *DNodecount <span class="hljs-keyword">int</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewCircularDeque</span><span class="hljs-params">()</span> <span class="hljs-title">CircularDeque</span></span> &#123;<span class="hljs-keyword">return</span> CircularDeque&#123;front:<span class="hljs-literal">nil</span>,rear:<span class="hljs-literal">nil</span>,&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *CircularDeque)</span><span class="hljs-title">pushPre</span><span class="hljs-params">(value <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">bool</span></span> &#123;<span class="hljs-keyword">if</span> c.count == <span class="hljs-number">0</span> &#123;node := &amp;DNode&#123;val:  value,&#125;c.front = nodec.rear = node&#125; <span class="hljs-keyword">else</span> &#123;c.front.insertPre(value)c.front = c.front.pre&#125;c.count += <span class="hljs-number">1</span><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *CircularDeque)</span><span class="hljs-title">pushTail</span><span class="hljs-params">(value <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">bool</span></span> &#123;<span class="hljs-keyword">if</span> c.count == <span class="hljs-number">0</span> &#123;node := &amp;DNode&#123;val:  value,&#125;c.front = nodec.rear = node&#125; <span class="hljs-keyword">else</span> &#123;c.rear.insertNext(value)c.rear = c.rear.next&#125;c.count += <span class="hljs-number">1</span><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *CircularDeque)</span><span class="hljs-title">popFront</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span> &#123;<span class="hljs-keyword">if</span> c.isEmpty() &#123;<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>&#125;v := c.front.val<span class="hljs-keyword">if</span> c.count == <span class="hljs-number">1</span> &#123;c.front = <span class="hljs-literal">nil</span>c.rear = <span class="hljs-literal">nil</span>&#125;<span class="hljs-keyword">else</span>&#123;c.front = c.front.nextc.front.deletePre()&#125;c.count -= <span class="hljs-number">1</span><span class="hljs-keyword">return</span> v&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *CircularDeque)</span><span class="hljs-title">popTail</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span> &#123;<span class="hljs-keyword">if</span> c.isEmpty() &#123;<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>&#125;v := c.rear.val<span class="hljs-keyword">if</span> c.count == <span class="hljs-number">1</span> &#123;c.front = <span class="hljs-literal">nil</span>c.rear = <span class="hljs-literal">nil</span>&#125;<span class="hljs-keyword">else</span>&#123;c.rear = c.rear.prec.rear.deleteNext()&#125;c.count -= <span class="hljs-number">1</span><span class="hljs-keyword">return</span> v&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *CircularDeque)</span><span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> <span class="hljs-title">bool</span></span> &#123;<span class="hljs-keyword">return</span> c.count == <span class="hljs-number">0</span>&#125;<span class="hljs-keyword">type</span> FrontMiddleBackQueue <span class="hljs-keyword">struct</span> &#123;lQueue CircularDequerQueue CircularDeque&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">()</span> <span class="hljs-title">FrontMiddleBackQueue</span></span> &#123;<span class="hljs-keyword">return</span> FrontMiddleBackQueue&#123;lQueue: NewCircularDeque(),rQueue: NewCircularDeque(),&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *FrontMiddleBackQueue)</span> <span class="hljs-title">PushFront</span><span class="hljs-params">(val <span class="hljs-keyword">int</span>)</span></span>  &#123;this.lQueue.pushPre(val)this.formatQueue()&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *FrontMiddleBackQueue)</span> <span class="hljs-title">PushMiddle</span><span class="hljs-params">(val <span class="hljs-keyword">int</span>)</span></span>  &#123;<span class="hljs-comment">// 插入中间需要先平衡</span>  <span class="hljs-keyword">if</span> this.lQueue.count &gt; this.rQueue.count &#123;this.rQueue.pushPre(this.lQueue.popTail())&#125;this.lQueue.pushTail(val)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *FrontMiddleBackQueue)</span> <span class="hljs-title">PushBack</span><span class="hljs-params">(val <span class="hljs-keyword">int</span>)</span></span>  &#123;this.rQueue.pushTail(val)this.formatQueue()&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *FrontMiddleBackQueue)</span> <span class="hljs-title">PopFront</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span> &#123;v := <span class="hljs-number">-1</span><span class="hljs-keyword">if</span> this.isEmpty() &#123;<span class="hljs-keyword">return</span> v&#125;<span class="hljs-keyword">if</span> this.lQueue.count == <span class="hljs-number">0</span> &#123;v = this.rQueue.popFront()&#125; <span class="hljs-keyword">else</span> &#123;v = this.lQueue.popFront()&#125;this.formatQueue()<span class="hljs-keyword">return</span> v&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *FrontMiddleBackQueue)</span> <span class="hljs-title">PopMiddle</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span> &#123;v := <span class="hljs-number">-1</span><span class="hljs-keyword">if</span> this.isEmpty() &#123;<span class="hljs-keyword">return</span> v&#125;v = this.lQueue.popTail()this.formatQueue()<span class="hljs-keyword">return</span> v&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *FrontMiddleBackQueue)</span> <span class="hljs-title">PopBack</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span> &#123;v := <span class="hljs-number">-1</span><span class="hljs-keyword">if</span> this.isEmpty() &#123;<span class="hljs-keyword">return</span> v&#125;<span class="hljs-keyword">if</span> this.rQueue.count == <span class="hljs-number">0</span> &#123;v = this.lQueue.popTail()&#125; <span class="hljs-keyword">else</span> &#123;v = this.rQueue.popTail()&#125;this.formatQueue()<span class="hljs-keyword">return</span> v&#125;<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(this *FrontMiddleBackQueue)</span> <span class="hljs-title">isEmpty</span> <span class="hljs-params">()</span> <span class="hljs-title">bool</span></span> &#123;<span class="hljs-keyword">return</span> this.lQueue.count + this.rQueue.count == <span class="hljs-number">0</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *FrontMiddleBackQueue)</span> <span class="hljs-title">formatQueue</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">if</span> this.lQueue.count &lt; this.rQueue.count &#123;this.lQueue.pushTail(this.rQueue.popFront())&#125;<span class="hljs-keyword">if</span> this.lQueue.count - this.rQueue.count &gt;= <span class="hljs-number">2</span> &#123;this.rQueue.pushPre(this.lQueue.popTail())&#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Your FrontMiddleBackQueue object will be instantiated and called as such:</span><span class="hljs-comment"> * obj := Constructor();</span><span class="hljs-comment"> * obj.PushFront(val);</span><span class="hljs-comment"> * obj.PushMiddle(val);</span><span class="hljs-comment"> * obj.PushBack(val);</span><span class="hljs-comment"> * param_4 := obj.PopFront();</span><span class="hljs-comment"> * param_5 := obj.PopMiddle();</span><span class="hljs-comment"> * param_6 := obj.PopBack();</span><span class="hljs-comment"> */</span><span class="hljs-comment">//leetcode submit region end(Prohibit modification and deletion)</span></code></pre><p><code>Python</code></p><pre><code class="hljs Python"><span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">Module Description: 1670-设计前中后队列</span><span class="hljs-string">Solution：</span><span class="hljs-string">Author: Wang P</span><span class="hljs-string">Problem:# 请你设计一个队列，支持在前，中，后三个位置的 push 和 pop 操作。 </span><span class="hljs-string">        #  请你完成 FrontMiddleBack 类：</span><span class="hljs-string">        #  FrontMiddleBack() 初始化队列。</span><span class="hljs-string">        #  void pushFront(int val) 将 val 添加到队列的 最前面 。</span><span class="hljs-string">        #  void pushMiddle(int val) 将 val 添加到队列的 正中间 。</span><span class="hljs-string">        #  void pushBack(int val) 将 val 添加到队里的 最后面 。</span><span class="hljs-string">        #  int popFront() 将 最前面 的元素从队列中删除并返回值，如果删除之前队列为空，那么返回 -1 。</span><span class="hljs-string">        #  int popMiddle() 将 正中间 的元素从队列中删除并返回值，如果删除之前队列为空，那么返回 -1 。</span><span class="hljs-string">        #  int popBack() 将 最后面 的元素从队列中删除并返回值，如果删除之前队列为空，那么返回 -1 。</span><span class="hljs-string">        #  请注意当有 两个 中间位置的时候，选择靠前面的位置进行操作。比方说：</span><span class="hljs-string">        #</span><span class="hljs-string">        #  将 6 添加到 [1, 2, 3, 4, 5] 的中间位置，结果数组为 [1, 2, 6, 3, 4, 5] 。</span><span class="hljs-string">        #  从 [1, 2, 3, 4, 5, 6] 的中间位置弹出元素，返回 3 ，数组变为 [1, 2, 4, 5, 6] 。</span><span class="hljs-string">        #</span><span class="hljs-string">        #  示例 1：</span><span class="hljs-string">        # 输入：</span><span class="hljs-string">        # [&quot;FrontMiddleBackQueue&quot;, &quot;pushFront&quot;, &quot;pushBack&quot;, &quot;pushMiddle&quot;, &quot;pushMiddle&quot;,</span><span class="hljs-string">        # &quot;popFront&quot;, &quot;popMiddle&quot;, &quot;popMiddle&quot;, &quot;popBack&quot;, &quot;popFront&quot;]</span><span class="hljs-string">        # [[], [1], [2], [3], [4], [], [], [], [], []]</span><span class="hljs-string">        # 输出：</span><span class="hljs-string">        # [null, null, null, null, null, 1, 3, 4, 2, -1]</span><span class="hljs-string">        #</span><span class="hljs-string">        # 解释：</span><span class="hljs-string">        # FrontMiddleBackQueue q = new FrontMiddleBackQueue();</span><span class="hljs-string">        # q.pushFront(1);   // [1]</span><span class="hljs-string">        # q.pushBack(2);    // [1, 2]</span><span class="hljs-string">        # q.pushMiddle(3);  // [1, 3, 2]</span><span class="hljs-string">        # q.pushMiddle(4);  // [1, 4, 3, 2]</span><span class="hljs-string">        # q.popFront();     // 返回 1 -&gt; [4, 3, 2]</span><span class="hljs-string">        # q.popMiddle();    // 返回 3 -&gt; [4, 2]</span><span class="hljs-string">        # q.popMiddle();    // 返回 4 -&gt; [2]</span><span class="hljs-string">        # q.popBack();      // 返回 2 -&gt; []</span><span class="hljs-string">        # q.popFront();     // 返回 -1 -&gt; [] （队列为空）</span><span class="hljs-string">        #</span><span class="hljs-string">        #  提示：</span><span class="hljs-string">        #  1 &lt;= val &lt;= 109</span><span class="hljs-string">        #  最多调用 1000 次 pushFront， pushMiddle， pushBack， popFront， popMiddle 和 popBack 。</span><span class="hljs-string">        #</span><span class="hljs-string">        #  Related Topics 设计 链表</span><span class="hljs-string">        #  👍 6 👎 0</span><span class="hljs-string"></span><span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-comment"># leetcode submit region begin(Prohibit modification and deletion)</span><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> deque<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FrontMiddleBackQueue</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span>        self.left = deque()        self.right = deque()    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pushFront</span>(<span class="hljs-params">self, val: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-keyword">None</span>:</span>        self.left.appendleft(val)        self.balance_queue()    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pushMiddle</span>(<span class="hljs-params">self, val: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-keyword">None</span>:</span>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(self.left) &gt; <span class="hljs-built_in">len</span>(self.right):            self.right.appendleft(self.left.pop())        self.left.append(val)    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pushBack</span>(<span class="hljs-params">self, val: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-keyword">None</span>:</span>        self.right.append(val)        self.balance_queue()    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">popFront</span>(<span class="hljs-params">self</span>) -&gt; int:</span>        v = <span class="hljs-number">-1</span>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(self.left) + <span class="hljs-built_in">len</span>(self.right) == <span class="hljs-number">0</span>:            <span class="hljs-keyword">return</span> v        v = self.left.popleft()        self.balance_queue()        <span class="hljs-keyword">return</span> v    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">popMiddle</span>(<span class="hljs-params">self</span>) -&gt; int:</span>        v = <span class="hljs-number">-1</span>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(self.left) + <span class="hljs-built_in">len</span>(self.right) == <span class="hljs-number">0</span>:            <span class="hljs-keyword">return</span> v        v = self.left.pop()        self.balance_queue()        <span class="hljs-keyword">return</span> v    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">popBack</span>(<span class="hljs-params">self</span>) -&gt; int:</span>        v = <span class="hljs-number">-1</span>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(self.left) + <span class="hljs-built_in">len</span>(self.right) == <span class="hljs-number">0</span>:            <span class="hljs-keyword">return</span> v        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(self.right) == <span class="hljs-number">0</span>:            v = self.left.pop()        <span class="hljs-keyword">else</span>:            v = self.right.pop()        self.balance_queue()        <span class="hljs-keyword">return</span> v    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">balance_queue</span>(<span class="hljs-params">self</span>):</span>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(self.left) - <span class="hljs-built_in">len</span>(self.right) &gt;= <span class="hljs-number">2</span>:            self.right.appendleft(self.left.pop())        <span class="hljs-keyword">else</span>:            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(self.left) &lt; <span class="hljs-built_in">len</span>(self.right):                self.left.append(self.right.popleft())    <span class="hljs-comment"># Your FrontMiddleBackQueue object will be instantiated and called as such:</span>    <span class="hljs-comment"># obj = FrontMiddleBackQueue()</span>    <span class="hljs-comment"># obj.pushFront(val)</span>    <span class="hljs-comment"># obj.pushMiddle(val)</span>    <span class="hljs-comment"># obj.pushBack(val)</span>    <span class="hljs-comment"># param_4 = obj.popFront()</span>    <span class="hljs-comment"># param_5 = obj.popMiddle()</span>    <span class="hljs-comment"># param_6 = obj.popBack()</span>    <span class="hljs-comment"># leetcode submit region end(Prohibit modification and deletion)</span><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:    obj = FrontMiddleBackQueue()    obj.pushFront(<span class="hljs-number">1</span>)    obj.pushMiddle(<span class="hljs-number">2</span>)    obj.pushBack(<span class="hljs-number">3</span>)    print(obj.popFront())    print(obj.popMiddle())    print(obj.popBack())</code></pre><h6 id="933-最近的请求次数"><a href="#933-最近的请求次数" class="headerlink" title="933. 最近的请求次数"></a><a href="https://leetcode-cn.com/problems/number-of-recent-calls/">933. 最近的请求次数</a></h6><p>写一个 <code>RecentCounter </code>类来计算特定时间范围内最近的请求。</p><p>请你实现<code>RecentCounter</code>类：</p><ul><li><code>RecentCounter() </code>初始化计数器，请求数为 0 。</li><li><code>int ping(int t) </code>在时间<code>t</code>添加一个新请求，其中 <code>t</code> 表示以毫秒为单位的某个时间，并返回过去 <code>3000</code> 毫秒内发生的所有请求数（包括新请求）。确切地说，返回在<code>[t-3000, t]</code>内发生的请求数。<br>保证 每次对<code>ping</code>的调用都使用比之前更大的<code>t</code>值。</li></ul><p><strong>示例：</strong></p><pre><code class="hljs Java">输入：[<span class="hljs-string">&quot;RecentCounter&quot;</span>, <span class="hljs-string">&quot;ping&quot;</span>, <span class="hljs-string">&quot;ping&quot;</span>, <span class="hljs-string">&quot;ping&quot;</span>, <span class="hljs-string">&quot;ping&quot;</span>][[], [<span class="hljs-number">1</span>], [<span class="hljs-number">100</span>], [<span class="hljs-number">3001</span>], [<span class="hljs-number">3002</span>]]输出：[<span class="hljs-keyword">null</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>]解释：RecentCounter recentCounter = <span class="hljs-keyword">new</span> RecentCounter();recentCounter.ping(<span class="hljs-number">1</span>);     <span class="hljs-comment">// requests = [1]，范围是 [-2999,1]，返回 1</span>recentCounter.ping(<span class="hljs-number">100</span>);   <span class="hljs-comment">// requests = [1, 100]，范围是 [-2900,100]，返回 2</span>recentCounter.ping(<span class="hljs-number">3001</span>);  <span class="hljs-comment">// requests = [1, 100, 3001]，范围是 [1,3001]，返回 3</span>recentCounter.ping(<span class="hljs-number">3002</span>);  <span class="hljs-comment">// requests = [1, 100, 3001, 3002]，范围是 [2,3002]，返回 3</span></code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= t &lt;= 10^9</code></li><li>保证每次对 <code>ping</code> 调用所使用的 <code>t</code> 值都 <strong>严格递增</strong></li><li>至多调用 <code>ping</code> 方法 <code>10^4</code> 次</li></ul><p>解题思路</p><pre><code class="hljs angelscript">队列实现  入队时，对手请求时间&lt;当前<span class="hljs-number">-3000</span>，出队  队列中的元素数量即是`[t<span class="hljs-number">-3000</span>, t]`内发生的请求数</code></pre><p><code>Java</code></p><pre><code class="hljs Java"><span class="hljs-keyword">package</span> com.weitrue.leetcode.editor.cn;<span class="hljs-keyword">import</span> java.util.Deque;<span class="hljs-keyword">import</span> java.util.LinkedList;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NumberOfRecentCalls</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;        Solution s = <span class="hljs-keyword">new</span> NumberOfRecentCalls().<span class="hljs-function">new <span class="hljs-title">Solution</span><span class="hljs-params">()</span></span>;    &#125;        <span class="hljs-comment">//You have a RecentCounter class which counts the number of recent requests with in a certain time frame.</span>    <span class="hljs-comment">// Implement the RecentCounter class:</span>    <span class="hljs-comment">// RecentCounter() Initializes the counter with zero recent requests.</span>    <span class="hljs-comment">// int ping(int t) Adds a new request at time t, where t represents some time in milliseconds, and returns the number</span>    <span class="hljs-comment">// of requests that has happened in the past 3000 milliseconds (including the new request). Specifically, return the</span>    <span class="hljs-comment">// number of requests that have happened in the inclusive range [t - 3000, t].</span>    <span class="hljs-comment">//</span>    <span class="hljs-comment">// It is guaranteed that every call to ping uses a strictly larger value of t than the previous call.</span>    <span class="hljs-comment">//</span>    <span class="hljs-comment">// Example 1:</span>    <span class="hljs-comment">//Input</span>    <span class="hljs-comment">//[&quot;RecentCounter&quot;, &quot;ping&quot;, &quot;ping&quot;, &quot;ping&quot;, &quot;ping&quot;]</span>    <span class="hljs-comment">//[[], [1], [100], [3001], [3002]]</span>    <span class="hljs-comment">//Output</span>    <span class="hljs-comment">//[null, 1, 2, 3, 3]</span>    <span class="hljs-comment">//</span>    <span class="hljs-comment">//Explanation</span>    <span class="hljs-comment">//RecentCounter recentCounter = new RecentCounter();</span>    <span class="hljs-comment">//recentCounter.ping(1);     // requests = [1], range is [-2999,1], return 1</span>    <span class="hljs-comment">//recentCounter.ping(100);   // requests = [1, 100], range is [-2900,100], return 2</span>    <span class="hljs-comment">//recentCounter.ping(3001);  // requests = [1, 100, 3001], range is [1,3001], return 3</span>    <span class="hljs-comment">//recentCounter.ping(3002);  // requests = [1, 100, 3001, 3002], range is [2,3002], return 3</span>    <span class="hljs-comment">// Constraints:</span>    <span class="hljs-comment">// 1 &lt;= t &lt;= 109</span>    <span class="hljs-comment">// Each test case will call ping with strictly increasing values of t.</span>    <span class="hljs-comment">// At most 104 calls will be made to ping.</span>    <span class="hljs-comment">//</span>    <span class="hljs-comment">// Related Topics 队列</span>    <span class="hljs-comment">// 👍 82 👎 0</span>     <span class="hljs-comment">//leetcode submit region begin(Prohibit modification and deletion)</span>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RecentCounter</span> </span>&#123;        <span class="hljs-keyword">private</span> Deque&lt;Integer&gt; deque = <span class="hljs-keyword">new</span> LinkedList();        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">RecentCounter</span><span class="hljs-params">()</span> </span>&#123;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">ping</span><span class="hljs-params">(<span class="hljs-keyword">int</span> t)</span> </span>&#123;            deque.add(t);            <span class="hljs-keyword">while</span> (deque.peek() &lt; t-<span class="hljs-number">3000</span>) &#123;                deque.poll();            &#125;            <span class="hljs-keyword">return</span> deque.size();        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Your RecentCounter object will be instantiated and called as such:</span><span class="hljs-comment">     * RecentCounter obj = new RecentCounter();</span><span class="hljs-comment">     * int param_1 = obj.ping(t);</span><span class="hljs-comment">     */</span>    <span class="hljs-comment">//leetcode submit region end(Prohibit modification and deletion)</span>&#125;</code></pre><p><code>Golang</code></p><pre><code class="hljs Golang"><span class="hljs-keyword">type</span> RecentCounter <span class="hljs-keyword">struct</span> &#123;queue Queue&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">()</span> <span class="hljs-title">RecentCounter</span></span> &#123;<span class="hljs-keyword">return</span> RecentCounter&#123;queue: <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">0</span>),&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *RecentCounter)</span> <span class="hljs-title">Ping</span><span class="hljs-params">(t <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;this.queue.push(t)<span class="hljs-keyword">for</span> this.queue.peek() &lt; t<span class="hljs-number">-3000</span> &#123;this.queue.pop()&#125;<span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(this.queue)&#125;<span class="hljs-keyword">type</span> Queue []<span class="hljs-keyword">int</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(q *Queue)</span><span class="hljs-title">push</span><span class="hljs-params">(v <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">error</span></span> &#123;*q = <span class="hljs-built_in">append</span>(*q, v)<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(q *Queue)</span><span class="hljs-title">pop</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span> &#123;<span class="hljs-keyword">if</span> q.isEmpty() &#123;<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>&#125;head := (*q)[<span class="hljs-number">0</span>]*q = (*q)[<span class="hljs-number">1</span>:]<span class="hljs-keyword">return</span> head&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(q *Queue)</span><span class="hljs-title">peek</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span> &#123;<span class="hljs-keyword">if</span> q.isEmpty() &#123;<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>&#125;<span class="hljs-keyword">return</span> (*q)[<span class="hljs-number">0</span>]&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(q *Queue)</span><span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> <span class="hljs-title">bool</span></span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(*q) == <span class="hljs-number">0</span>&#125;</code></pre><p><code>Python</code></p><pre><code class="hljs Python"><span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">Module Description: 933-最近的请求次数</span><span class="hljs-string">Solution：</span><span class="hljs-string">Author: Wang P</span><span class="hljs-string">Problem:# 写一个 RecentCounter 类来计算特定时间范围内最近的请求。 </span><span class="hljs-string">        #  请你实现 RecentCounter 类：</span><span class="hljs-string">        #</span><span class="hljs-string">        #  RecentCounter() 初始化计数器，请求数为 0 。</span><span class="hljs-string">        #  int ping(int t) 在时间 t 添加一个新请求，其中 t 表示以毫秒为单位的某个时间，并返回过去 3000 毫秒内发生的所有请求数（包括新请求）。确切地说，返回在 [t-3000, t] 内发生的请求数。</span><span class="hljs-string">        #  保证 每次对 ping 的调用都使用比之前更大的 t 值。</span><span class="hljs-string">        #  示例：</span><span class="hljs-string">        # 输入：</span><span class="hljs-string">        # [&quot;RecentCounter&quot;, &quot;ping&quot;, &quot;ping&quot;, &quot;ping&quot;, &quot;ping&quot;]</span><span class="hljs-string">        # [[], [1], [100], [3001], [3002]]</span><span class="hljs-string">        # 输出：</span><span class="hljs-string">        # [null, 1, 2, 3, 3]</span><span class="hljs-string">        #</span><span class="hljs-string">        # 解释：</span><span class="hljs-string">        # RecentCounter recentCounter = new RecentCounter();</span><span class="hljs-string">        # recentCounter.ping(1);     // requests = [1]，范围是 [-2999,1]，返回 1</span><span class="hljs-string">        # recentCounter.ping(100);   // requests = [1, 100]，范围是 [-2900,100]，返回 2</span><span class="hljs-string">        # recentCounter.ping(3001);  // requests = [1, 100, 3001]，范围是 [1,3001]，返回 3</span><span class="hljs-string">        # recentCounter.ping(3002);  // requests = [1, 100, 3001, 3002]，范围是 [2,3002]，返回 3</span><span class="hljs-string">        #  提示：</span><span class="hljs-string">        #  1 &lt;= t &lt;= 109</span><span class="hljs-string">        #  保证每次对 ping 调用所使用的 t 值都 严格递增</span><span class="hljs-string">        #  至多调用 ping 方法 104 次</span><span class="hljs-string">        #</span><span class="hljs-string">        #  Related Topics 队列</span><span class="hljs-string">        #  👍 82 👎 0</span><span class="hljs-string">        &quot;&quot;&quot;</span><span class="hljs-comment"># leetcode submit region begin(Prohibit modification and deletion)</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RecentCounter</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span>        self.queue = []    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">ping</span>(<span class="hljs-params">self, t: <span class="hljs-built_in">int</span></span>) -&gt; int:</span>        self.push(t)        <span class="hljs-keyword">while</span> self.peek() &lt; t - <span class="hljs-number">3000</span>:            self.pop()        <span class="hljs-keyword">return</span> self.size()    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">push</span>(<span class="hljs-params">self, t: <span class="hljs-built_in">int</span></span>):</span>        self.queue.append(t)    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pop</span>(<span class="hljs-params">self</span>):</span>        <span class="hljs-keyword">if</span> self.is_empty():            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>        t = self.queue[<span class="hljs-number">0</span>]        self.queue = self.queue[<span class="hljs-number">1</span>:]        <span class="hljs-keyword">return</span> t    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">peek</span>(<span class="hljs-params">self</span>):</span>        <span class="hljs-keyword">if</span> self.is_empty():            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>        <span class="hljs-keyword">return</span> self.queue[<span class="hljs-number">0</span>]    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">is_empty</span>(<span class="hljs-params">self</span>):</span>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(self.queue) == <span class="hljs-number">0</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">size</span>(<span class="hljs-params">self</span>):</span>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(self.queue)</code></pre><h6 id="621-任务调度器"><a href="#621-任务调度器" class="headerlink" title="621. 任务调度器"></a><a href="https://leetcode-cn.com/problems/task-scheduler/">621. 任务调度器</a></h6><p>给你一个用字符数组 tasks 表示的 CPU 需要执行的任务列表。其中每个字母表示一种不同种类的任务。任务可以以任意顺序执行，并且每个任务都可以在 1 个单位时间内执行完。在任何一个单位时间，CPU 可以完成一个任务，或者处于待命状态。</p><p>然而，两个 相同种类 的任务之间必须有长度为整数 n 的冷却时间，因此至少有连续 n 个单位时间内 CPU 在执行不同的任务，或者在待命状态。</p><p>你需要计算完成所有任务所需要的 最短时间 。</p><p><strong>示例 1：</strong></p><pre><code class="hljs livescript">输入：tasks = [<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;B&quot;</span>,<span class="hljs-string">&quot;B&quot;</span>,<span class="hljs-string">&quot;B&quot;</span>], n = <span class="hljs-number">2</span>输出：<span class="hljs-number">8</span>解释：A<span class="hljs-function"> -&gt;</span> B<span class="hljs-function"> -&gt;</span> <span class="hljs-function"><span class="hljs-params">(待命)</span> -&gt;</span> A<span class="hljs-function"> -&gt;</span> B<span class="hljs-function"> -&gt;</span> <span class="hljs-function"><span class="hljs-params">(待命)</span> -&gt;</span> A<span class="hljs-function"> -&gt;</span> B     在本示例中，两个相同类型任务之间必须间隔长度为 n = <span class="hljs-number">2</span> 的冷却时间，而执行一个任务只需要一个单位时间，所以中间出现了（待命）状态。</code></pre><p><strong>示例 2：</strong></p><pre><code class="hljs prolog">输入：tasks = [<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;B&quot;</span>,<span class="hljs-string">&quot;B&quot;</span>,<span class="hljs-string">&quot;B&quot;</span>], n = <span class="hljs-number">0</span>输出：<span class="hljs-number">6</span>解释：在这种情况下，任何大小为 <span class="hljs-number">6</span> 的排列都可以满足要求，因为 n = <span class="hljs-number">0</span>[<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;B&quot;</span>,<span class="hljs-string">&quot;B&quot;</span>,<span class="hljs-string">&quot;B&quot;</span>][<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;B&quot;</span>,<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;B&quot;</span>,<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;B&quot;</span>][<span class="hljs-string">&quot;B&quot;</span>,<span class="hljs-string">&quot;B&quot;</span>,<span class="hljs-string">&quot;B&quot;</span>,<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;A&quot;</span>]...诸如此类</code></pre><p><strong>示例 3：</strong></p><pre><code class="hljs livescript">输入：tasks = [<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;B&quot;</span>,<span class="hljs-string">&quot;C&quot;</span>,<span class="hljs-string">&quot;D&quot;</span>,<span class="hljs-string">&quot;E&quot;</span>,<span class="hljs-string">&quot;F&quot;</span>,<span class="hljs-string">&quot;G&quot;</span>], n = <span class="hljs-number">2</span>输出：<span class="hljs-number">16</span>解释：一种可能的解决方案是：     A<span class="hljs-function"> -&gt;</span> B<span class="hljs-function"> -&gt;</span> C<span class="hljs-function"> -&gt;</span> A<span class="hljs-function"> -&gt;</span> D<span class="hljs-function"> -&gt;</span> E<span class="hljs-function"> -&gt;</span> A<span class="hljs-function"> -&gt;</span> F<span class="hljs-function"> -&gt;</span> G<span class="hljs-function"> -&gt;</span> A<span class="hljs-function"> -&gt;</span> <span class="hljs-function"><span class="hljs-params">(待命)</span> -&gt;</span> <span class="hljs-function"><span class="hljs-params">(待命)</span> -&gt;</span> A<span class="hljs-function"> -&gt;</span> <span class="hljs-function"><span class="hljs-params">(待命)</span> -&gt;</span> <span class="hljs-function"><span class="hljs-params">(待命)</span> -&gt;</span> A</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= task.length &lt;= 104</code></li><li><code>tasks[i]</code> 是大写英文字母</li><li><code>n</code> 的取值范围为 <code>[0, 100]</code></li></ul><p>解题思路</p><pre><code class="hljs plain"></code></pre><p><code>Java</code></p><pre><code class="hljs Java"></code></pre><p><code>Golang</code></p><pre><code class="hljs Golang"></code></pre><p><code>Python</code></p><pre><code class="hljs Python"></code></pre><h6 id="面试题-17-09-第-k-个数"><a href="#面试题-17-09-第-k-个数" class="headerlink" title="面试题 17.09. 第 k 个数"></a><a href="https://leetcode-cn.com/problems/get-kth-magic-number-lcci/">面试题 17.09. 第 k 个数</a></h6><p>有些数的素因子只有 3，5，7，请设计一个算法找出第 k 个数。注意，不是必须有这些素因子，而是必须不包含其他的素因子。例如，前几个数按顺序应该是 1，3，5，7，9，15，21。</p><p><strong>示例 1:</strong></p><pre><code class="hljs angelscript">输入: k = <span class="hljs-number">5</span>输出: <span class="hljs-number">9</span></code></pre><p>解题思路</p><pre><code class="hljs plain">智力题   熟悉数字规则即可</code></pre><p><code>Java</code></p><pre><code class="hljs Java"></code></pre><p><code>Golang</code></p><pre><code class="hljs Golang"></code></pre><p><code>Python</code></p><pre><code class="hljs Python"></code></pre><h6 id="859-亲密字符串"><a href="#859-亲密字符串" class="headerlink" title="859. 亲密字符串"></a><a href="https://leetcode-cn.com/problems/buddy-strings/">859. 亲密字符串</a></h6><p>给定两个由小写字母构成的字符串 A 和 B ，只要我们可以通过交换 A 中的两个字母得到与 B 相等的结果，就返回 true ；否则返回 false 。</p><p>交换字母的定义是取两个下标 i 和 j （下标从 0 开始），只要<code>i!=j</code>就交换<code>A[i]</code>和<code>A[j] </code>处的字符。例如，在 <code>&quot;abcd&quot;</code> 中交换下标 0 和下标 2 的元素可以生成 <code>&quot;cbad&quot; </code>。</p><p><strong>示例 1：</strong></p><pre><code class="hljs prolog">输入： <span class="hljs-symbol">A</span> = <span class="hljs-string">&quot;ab&quot;</span>, <span class="hljs-symbol">B</span> = <span class="hljs-string">&quot;ba&quot;</span>输出： true解释： 你可以交换 <span class="hljs-symbol">A</span>[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;a&#x27;</span> 和 <span class="hljs-symbol">A</span>[<span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;b&#x27;</span> 生成 <span class="hljs-string">&quot;ba&quot;</span>，此时 <span class="hljs-symbol">A</span> 和 <span class="hljs-symbol">B</span> 相等。</code></pre><p><strong>示例 2：</strong></p><pre><code class="hljs prolog">输入： <span class="hljs-symbol">A</span> = <span class="hljs-string">&quot;ab&quot;</span>, <span class="hljs-symbol">B</span> = <span class="hljs-string">&quot;ab&quot;</span>输出： false解释： 你只能交换 <span class="hljs-symbol">A</span>[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;a&#x27;</span> 和 <span class="hljs-symbol">A</span>[<span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;b&#x27;</span> 生成 <span class="hljs-string">&quot;ba&quot;</span>，此时 <span class="hljs-symbol">A</span> 和 <span class="hljs-symbol">B</span> 不相等。</code></pre><p><strong>示例 3：</strong></p><pre><code class="hljs vbnet">输入： A = <span class="hljs-string">&quot;aa&quot;</span>, B = <span class="hljs-string">&quot;aa&quot;</span>输出： <span class="hljs-literal">true</span>解释： 你可以交换 A[<span class="hljs-number">0</span>] = <span class="hljs-comment">&#x27;a&#x27; 和 A[1] = &#x27;a&#x27; 生成 &quot;aa&quot;，此时 A 和 B 相等。</span></code></pre><p><strong>示例 4：</strong></p><pre><code class="hljs nix">输入： <span class="hljs-attr">A</span> = <span class="hljs-string">&quot;aaaaaaabc&quot;</span>, <span class="hljs-attr">B</span> = <span class="hljs-string">&quot;aaaaaaacb&quot;</span>输出： <span class="hljs-literal">true</span></code></pre><p><strong>示例 5：</strong></p><pre><code class="hljs nix">输入： <span class="hljs-attr">A</span> = <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-attr">B</span> = <span class="hljs-string">&quot;aa&quot;</span>输出： <span class="hljs-literal">false</span></code></pre><p><strong>提示：</strong></p><ol><li><code>0 &lt;= A.length &lt;= 20000</code></li><li><code>0 &lt;= B.length &lt;= 20000</code></li><li><code>A</code> 和 <code>B</code> 仅由小写字母构成。</li></ol><p>解题思路</p><pre><code class="hljs plain"></code></pre><p><code>Java</code></p><pre><code class="hljs Java"></code></pre><p><code>Golang</code></p><pre><code class="hljs Golang"></code></pre><p><code>Python</code></p><pre><code class="hljs Python"></code></pre><h6 id="860-柠檬水找零"><a href="#860-柠檬水找零" class="headerlink" title="860. 柠檬水找零"></a><a href="https://leetcode-cn.com/problems/lemonade-change/">860. 柠檬水找零</a></h6><p>在柠檬水摊上，每一杯柠檬水的售价为 5 美元。</p><p>顾客排队购买你的产品，（按账单 bills 支付的顺序）一次购买一杯。</p><p>每位顾客只买一杯柠檬水，然后向你付 5 美元、10 美元或 20 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 5 美元。</p><p>注意，一开始你手头没有任何零钱。</p><p>如果你能给每位顾客正确找零，返回 true ，否则返回 false 。</p><p><strong>示例 1：</strong></p><pre><code class="hljs angelscript">输入：[<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,<span class="hljs-number">10</span>,<span class="hljs-number">20</span>]输出：<span class="hljs-literal">true</span>解释：前 <span class="hljs-number">3</span> 位顾客那里，我们按顺序收取 <span class="hljs-number">3</span> 张 <span class="hljs-number">5</span> 美元的钞票。第 <span class="hljs-number">4</span> 位顾客那里，我们收取一张 <span class="hljs-number">10</span> 美元的钞票，并返还 <span class="hljs-number">5</span> 美元。第 <span class="hljs-number">5</span> 位顾客那里，我们找还一张 <span class="hljs-number">10</span> 美元的钞票和一张 <span class="hljs-number">5</span> 美元的钞票。由于所有客户都得到了正确的找零，所以我们输出 <span class="hljs-literal">true</span>。</code></pre><p><strong>示例 2：</strong></p><pre><code class="hljs angelscript">输入：[<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,<span class="hljs-number">10</span>]输出：<span class="hljs-literal">true</span></code></pre><p><strong>示例 3：</strong></p><pre><code class="hljs angelscript">输入：[<span class="hljs-number">10</span>,<span class="hljs-number">10</span>]输出：<span class="hljs-literal">false</span></code></pre><p><strong>示例 4：</strong></p><pre><code class="hljs angelscript">输入：[<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,<span class="hljs-number">10</span>,<span class="hljs-number">10</span>,<span class="hljs-number">20</span>]输出：<span class="hljs-literal">false</span>解释：前 <span class="hljs-number">2</span> 位顾客那里，我们按顺序收取 <span class="hljs-number">2</span> 张 <span class="hljs-number">5</span> 美元的钞票。对于接下来的 <span class="hljs-number">2</span> 位顾客，我们收取一张 <span class="hljs-number">10</span> 美元的钞票，然后返还 <span class="hljs-number">5</span> 美元。对于最后一位顾客，我们无法退回 <span class="hljs-number">15</span> 美元，因为我们现在只有两张 <span class="hljs-number">10</span> 美元的钞票。由于不是每位顾客都得到了正确的找零，所以答案是 <span class="hljs-literal">false</span>。</code></pre><p><strong>提示：</strong></p><ul><li><code>0 &lt;= bills.length &lt;= 10000</code></li><li><code>bills[i]</code> 不是 <code>5</code> 就是 <code>10</code> 或是 <code>20</code> </li></ul><p>解题思路</p><pre><code class="hljs plain">贪心算法</code></pre><p><code>Java</code></p><pre><code class="hljs Java"></code></pre><p><code>Golang</code></p><pre><code class="hljs Golang"></code></pre><p><code>Python</code></p><pre><code class="hljs Python"></code></pre><h6 id="969-煎饼排序"><a href="#969-煎饼排序" class="headerlink" title="969. 煎饼排序"></a><a href="https://leetcode-cn.com/problems/pancake-sorting/">969. 煎饼排序</a></h6><p>给你一个整数数组<code>arr</code>，请使用<strong>煎饼翻转</strong>完成对数组的排序。</p><p>一次煎饼翻转的执行过程如下：</p><ul><li>选择一个整数<code>k</code>，<code>1 &lt;= k &lt;= arr.length</code></li><li>反转子数组 <code>arr[0...k-1]</code>（<strong>下标从 0 开始</strong>）</li></ul><p>例如，<code>arr = [3,2,1,4]</code>，选择<code>k = 3</code>进行一次煎饼翻转，反转子数组<code>[3,2,1]</code>，得到<code>arr = [1,2,3,4]</code>。</p><p>以数组形式返回能使<code>arr</code>有序的煎饼翻转操作所对应的<code>k</code>值序列。任何将数组排序且翻转次数在<code>10 * arr.length</code>范围内的有效答案都将被判断为正确。</p><p><strong>示例 1：</strong></p><pre><code class="hljs angelscript">输入：[<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">1</span>]输出：[<span class="hljs-number">4</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>]解释：我们执行 <span class="hljs-number">4</span> 次煎饼翻转，k 值分别为 <span class="hljs-number">4</span>，<span class="hljs-number">2</span>，<span class="hljs-number">4</span>，和 <span class="hljs-number">3</span>。初始状态 arr = [<span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>]第一次翻转后（k = <span class="hljs-number">4</span>）：arr = [<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]第二次翻转后（k = <span class="hljs-number">2</span>）：arr = [<span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]第三次翻转后（k = <span class="hljs-number">4</span>）：arr = [<span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>]第四次翻转后（k = <span class="hljs-number">3</span>）：arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]，此时已完成排序。</code></pre><p><strong>示例 1：</strong></p><pre><code class="hljs angelscript">输入：[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]输出：[]解释：输入已经排序，因此不需要翻转任何内容。请注意，其他可能的答案，如 [<span class="hljs-number">3</span>，<span class="hljs-number">3</span>] ，也将被判断为正确。</code></pre><p>提示：</p><ul><li><code>1 &lt;= arr.length &lt;= 100</code></li><li><code>1 &lt;= arr[i] &lt;= arr.length</code></li><li><code>arr</code>中的所有整数互不相同（即<code>arr</code>是从<code>1</code>到<code>arr.length</code>整数的一个排列）</li></ul><p>解题思路</p><pre><code class="hljs basic"><span class="hljs-symbol">984132657 </span>排序</code></pre><p><code>Java</code></p><pre><code class="hljs Java"></code></pre><p><code>Golang</code></p><pre><code class="hljs Golang"></code></pre><p><code>Python</code></p><pre><code class="hljs Python"></code></pre><h4 id="递归与栈（Stack）：解决表达式求值"><a href="#递归与栈（Stack）：解决表达式求值" class="headerlink" title="递归与栈（Stack）：解决表达式求值"></a>递归与栈（Stack）：解决表达式求值</h4><h5 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h5><p>栈适合解决什么问题？</p><p>处理一种具有完全包含关系的问题。</p><h5 id="栈结构基础应用"><a href="#栈结构基础应用" class="headerlink" title="栈结构基础应用"></a>栈结构基础应用</h5><h6 id="227-基本计算器-II"><a href="#227-基本计算器-II" class="headerlink" title="227. 基本计算器 II"></a><a href="https://leetcode-cn.com/problems/basic-calculator-ii/">227. 基本计算器 II</a></h6><p>给你一个字符串表达式 <code>s</code> ，请你实现一个基本计算器来计算并返回它的值。</p><p>整数除法仅保留整数部分。</p><p><strong>示例 1：</strong></p><pre><code class="hljs lsl">输入：s = <span class="hljs-string">&quot;3+2*2&quot;</span>输出：<span class="hljs-number">7</span></code></pre><p><strong>示例 2：</strong></p><pre><code class="hljs lsl">输入：s = <span class="hljs-string">&quot; 3/2 &quot;</span>输出：<span class="hljs-number">1</span></code></pre><p><strong>示例 3：</strong></p><pre><code class="hljs lsl">输入：s = <span class="hljs-string">&quot; 3+5 / 2 &quot;</span>输出：<span class="hljs-number">5</span></code></pre><p>解题思路</p><pre><code class="hljs plain"></code></pre><p><code>Java</code></p><pre><code class="hljs Java"></code></pre><p><code>Golang</code></p><pre><code class="hljs Golang"></code></pre><p><code>Python</code></p><pre><code class="hljs Python"></code></pre><h6 id="面试题-03-04-化栈为队"><a href="#面试题-03-04-化栈为队" class="headerlink" title="面试题 03.04. 化栈为队"></a><a href="https://leetcode-cn.com/problems/implement-queue-using-stacks-lcci/">面试题 03.04. 化栈为队</a></h6><p>实现一个MyQueue类，该类用两个栈来实现一个队列。</p><p><strong>示例：</strong></p><pre><code class="hljs arduino">MyQueue <span class="hljs-built_in">queue</span> = <span class="hljs-keyword">new</span> MyQueue();<span class="hljs-built_in">queue</span>.push(<span class="hljs-number">1</span>);<span class="hljs-built_in">queue</span>.push(<span class="hljs-number">2</span>);<span class="hljs-built_in">queue</span>.<span class="hljs-built_in">peek</span>();  <span class="hljs-comment">// 返回 1</span><span class="hljs-built_in">queue</span>.pop();   <span class="hljs-comment">// 返回 1</span><span class="hljs-built_in">queue</span>.empty(); <span class="hljs-comment">// 返回 false</span></code></pre><p><strong>说明：</strong></p><ul><li>你只能使用标准的栈操作 – 也就是只有 <code>push to top</code>, <code>peek/pop from top</code>, <code>size</code> 和 <code>is empty</code> 操作是合法的。</li><li>你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。</li><li>假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）。</li></ul><p>解题思路</p><pre><code class="hljs plain"></code></pre><p><code>Java</code></p><pre><code class="hljs Java"></code></pre><p><code>Golang</code></p><pre><code class="hljs Golang"></code></pre><p><code>Python</code></p><pre><code class="hljs Python"></code></pre><h6 id="682-棒球比赛"><a href="#682-棒球比赛" class="headerlink" title="682. 棒球比赛"></a><a href="https://leetcode-cn.com/problems/baseball-game/">682. 棒球比赛</a></h6><p>你现在是一场采用特殊赛制棒球比赛的记录员。这场比赛由若干回合组成，过去几回合的得分可能会影响以后几回合的得分。</p><p>比赛开始时，记录是空白的。你会得到一个记录操作的字符串列表 <code>ops</code>，其中 <code>ops[i]</code> 是你需要记录的第 <code>i</code> 项操作，<code>ops</code> 遵循下述规则：</p><ol><li>整数 <code>x</code> - 表示本回合新获得分数 <code>x</code></li><li><code>&quot;+&quot;</code> - 表示本回合新获得的得分是前两次得分的总和。题目数据保证记录此操作时前面总是存在两个有效的分数。</li><li><code>&quot;D&quot;</code> - 表示本回合新获得的得分是前一次得分的两倍。题目数据保证记录此操作时前面总是存在一个有效的分数。</li><li><code>&quot;C&quot;</code> - 表示前一次得分无效，将其从记录中移除。题目数据保证记录此操作时前面总是存在一个有效的分数。</li></ol><p>请你返回记录中所有得分的总和。</p><p><strong>示例 1：</strong></p><pre><code class="hljs lsl">输入：ops = [<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;C&quot;</span>,<span class="hljs-string">&quot;D&quot;</span>,<span class="hljs-string">&quot;+&quot;</span>]输出：<span class="hljs-number">30</span>解释：<span class="hljs-string">&quot;5&quot;</span> - 记录加 <span class="hljs-number">5</span> ，记录现在是 [<span class="hljs-number">5</span>]<span class="hljs-string">&quot;2&quot;</span> - 记录加 <span class="hljs-number">2</span> ，记录现在是 [<span class="hljs-number">5</span>, <span class="hljs-number">2</span>]<span class="hljs-string">&quot;C&quot;</span> - 使前一次得分的记录无效并将其移除，记录现在是 [<span class="hljs-number">5</span>].<span class="hljs-string">&quot;D&quot;</span> - 记录加 <span class="hljs-number">2</span> * <span class="hljs-number">5</span> = <span class="hljs-number">10</span> ，记录现在是 [<span class="hljs-number">5</span>, <span class="hljs-number">10</span>].<span class="hljs-string">&quot;+&quot;</span> - 记录加 <span class="hljs-number">5</span> + <span class="hljs-number">10</span> = <span class="hljs-number">15</span> ，记录现在是 [<span class="hljs-number">5</span>, <span class="hljs-number">10</span>, <span class="hljs-number">15</span>].所有得分的总和 <span class="hljs-number">5</span> + <span class="hljs-number">10</span> + <span class="hljs-number">15</span> = <span class="hljs-number">30</span></code></pre><p><strong>示例 2：</strong></p><pre><code class="hljs lsl">输入：ops = [<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;-2&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;C&quot;</span>,<span class="hljs-string">&quot;D&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;+&quot;</span>,<span class="hljs-string">&quot;+&quot;</span>]输出：<span class="hljs-number">27</span>解释：<span class="hljs-string">&quot;5&quot;</span> - 记录加 <span class="hljs-number">5</span> ，记录现在是 [<span class="hljs-number">5</span>]<span class="hljs-string">&quot;-2&quot;</span> - 记录加 <span class="hljs-number">-2</span> ，记录现在是 [<span class="hljs-number">5</span>, <span class="hljs-number">-2</span>]<span class="hljs-string">&quot;4&quot;</span> - 记录加 <span class="hljs-number">4</span> ，记录现在是 [<span class="hljs-number">5</span>, <span class="hljs-number">-2</span>, <span class="hljs-number">4</span>]<span class="hljs-string">&quot;C&quot;</span> - 使前一次得分的记录无效并将其移除，记录现在是 [<span class="hljs-number">5</span>, <span class="hljs-number">-2</span>]<span class="hljs-string">&quot;D&quot;</span> - 记录加 <span class="hljs-number">2</span> * <span class="hljs-number">-2</span> = <span class="hljs-number">-4</span> ，记录现在是 [<span class="hljs-number">5</span>, <span class="hljs-number">-2</span>, <span class="hljs-number">-4</span>]<span class="hljs-string">&quot;9&quot;</span> - 记录加 <span class="hljs-number">9</span> ，记录现在是 [<span class="hljs-number">5</span>, <span class="hljs-number">-2</span>, <span class="hljs-number">-4</span>, <span class="hljs-number">9</span>]<span class="hljs-string">&quot;+&quot;</span> - 记录加 <span class="hljs-number">-4</span> + <span class="hljs-number">9</span> = <span class="hljs-number">5</span> ，记录现在是 [<span class="hljs-number">5</span>, <span class="hljs-number">-2</span>, <span class="hljs-number">-4</span>, <span class="hljs-number">9</span>, <span class="hljs-number">5</span>]<span class="hljs-string">&quot;+&quot;</span> - 记录加 <span class="hljs-number">9</span> + <span class="hljs-number">5</span> = <span class="hljs-number">14</span> ，记录现在是 [<span class="hljs-number">5</span>, <span class="hljs-number">-2</span>, <span class="hljs-number">-4</span>, <span class="hljs-number">9</span>, <span class="hljs-number">5</span>, <span class="hljs-number">14</span>]所有得分的总和 <span class="hljs-number">5</span> + <span class="hljs-number">-2</span> + <span class="hljs-number">-4</span> + <span class="hljs-number">9</span> + <span class="hljs-number">5</span> + <span class="hljs-number">14</span> = <span class="hljs-number">27</span></code></pre><p><strong>示例 3：</strong></p><pre><code class="hljs lsl">输入：ops = [<span class="hljs-string">&quot;1&quot;</span>]输出：<span class="hljs-number">1</span></code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= ops.length &lt;= 1000</code></li><li><code>ops[i]</code> 为 <code>&quot;C&quot;</code>、<code>&quot;D&quot;</code>、<code>&quot;+&quot;</code>，或者一个表示整数的字符串。整数范围是 <code>[-3 * 10^4, 3 * 10^4]</code></li><li>对于 <code>&quot;+&quot;</code> 操作，题目数据保证记录此操作时前面总是存在两个有效的分数</li><li>对于 <code>&quot;C&quot;</code> 和 <code>&quot;D&quot;</code> 操作，题目数据保证记录此操作时前面总是存在一个有效的分数</li></ul><p>解题思路</p><pre><code class="hljs plain"></code></pre><p><code>Java</code></p><pre><code class="hljs Java"></code></pre><p><code>Golang</code></p><pre><code class="hljs Golang"></code></pre><p><code>Python</code></p><pre><code class="hljs Python"></code></pre><h6 id="844-比较含退格的字符串"><a href="#844-比较含退格的字符串" class="headerlink" title="844. 比较含退格的字符串"></a><a href="https://leetcode-cn.com/problems/backspace-string-compare/">844. 比较含退格的字符串</a></h6><p>给定 <code>S</code> 和 <code>T</code> 两个字符串，当它们分别被输入到空白的文本编辑器后，判断二者是否相等，并返回结果。 <code>#</code> 代表退格字符。</p><p><strong>注意：</strong>如果对空文本输入退格字符，文本继续为空。</p><p><strong>示例 1：</strong></p><pre><code class="hljs livescript">输入：S = <span class="hljs-string">&quot;ab<span class="hljs-subst">#c</span>&quot;</span>, T = <span class="hljs-string">&quot;ad<span class="hljs-subst">#c</span>&quot;</span>输出：<span class="hljs-literal">true</span>解释：S 和 T 都会变成 “ac”。</code></pre><p><strong>示例 2：</strong></p><pre><code class="hljs nix">输入：<span class="hljs-attr">S</span> = <span class="hljs-string">&quot;ab##&quot;</span>, <span class="hljs-attr">T</span> = <span class="hljs-string">&quot;c#d#&quot;</span>输出：<span class="hljs-literal">true</span>解释：S 和 T 都会变成 “”。</code></pre><p><strong>示例 3：</strong></p><pre><code class="hljs livescript">输入：S = <span class="hljs-string">&quot;a#<span class="hljs-subst">#c</span>&quot;</span>, T = <span class="hljs-string">&quot;<span class="hljs-subst">#a</span><span class="hljs-subst">#c</span>&quot;</span>输出：<span class="hljs-literal">true</span>解释：S 和 T 都会变成 “c”。</code></pre><p><strong>示例 4：</strong></p><pre><code class="hljs nix">输入：<span class="hljs-attr">S</span> = <span class="hljs-string">&quot;a#c&quot;</span>, <span class="hljs-attr">T</span> = <span class="hljs-string">&quot;b&quot;</span>输出：<span class="hljs-literal">false</span>解释：S 会变成 “c”，但 T 仍然是 “b”。</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= S.length &lt;= 200</code></li><li><code>1 &lt;= T.length &lt;= 200</code></li><li><code>S</code> 和 <code>T</code> 只含有小写字母以及字符 <code>&#39;#&#39;</code>。</li></ul><p><strong>进阶：</strong></p><ul><li>你可以用 <code>O(N)</code> 的时间复杂度和 <code>O(1)</code> 的空间复杂度解决该问题吗？</li></ul><p>解题思路</p><pre><code class="hljs plain"></code></pre><p><code>Java</code></p><pre><code class="hljs Java"></code></pre><p><code>Golang</code></p><pre><code class="hljs Golang"></code></pre><p><code>Python</code></p><pre><code class="hljs Python"></code></pre><h6 id="946-验证栈序列"><a href="#946-验证栈序列" class="headerlink" title="946. 验证栈序列"></a><a href="https://leetcode-cn.com/problems/validate-stack-sequences/">946. 验证栈序列</a></h6><p>给定 pushed 和 popped 两个序列，每个序列中的 值都不重复，只有当它们可能是在最初空栈上进行的推入 push 和弹出 pop 操作序列的结果时，返回 true；否则，返回 false 。</p><p><strong>示例 1：</strong></p><pre><code class="hljs livescript">输入：pushed = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>], popped = [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]输出：<span class="hljs-literal">true</span>解释：我们可以按以下顺序执行：push<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">1</span>)</span>, <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-number">2</span>)</span>, <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-number">3</span>)</span>, <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-number">4</span>)</span>, <span class="hljs-title">pop</span><span class="hljs-params">()</span> -&gt;</span> <span class="hljs-number">4</span>,push<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">5</span>)</span>, <span class="hljs-title">pop</span><span class="hljs-params">()</span> -&gt;</span> <span class="hljs-number">5</span>, pop<span class="hljs-function"><span class="hljs-params">()</span> -&gt;</span> <span class="hljs-number">3</span>, pop<span class="hljs-function"><span class="hljs-params">()</span> -&gt;</span> <span class="hljs-number">2</span>, pop<span class="hljs-function"><span class="hljs-params">()</span> -&gt;</span> <span class="hljs-number">1</span></code></pre><p><strong>示例 2：</strong></p><pre><code class="hljs angelscript">输入：pushed = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>], popped = [<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]输出：<span class="hljs-literal">false</span>解释：<span class="hljs-number">1</span> 不能在 <span class="hljs-number">2</span> 之前弹出。</code></pre><p>提示：</p><p><code>0 &lt;= pushed.length == popped.length &lt;= 1000</code><br><code>0 &lt;= pushed[i], popped[i] &lt; 1000</code><br><code>pushed</code> 是 <code>popped </code>的排列。</p><p>解题思路</p><pre><code class="hljs plain"></code></pre><p><code>Java</code></p><pre><code class="hljs Java"></code></pre><p><code>Golang</code></p><pre><code class="hljs Golang"></code></pre><p><code>Python</code></p><pre><code class="hljs Python"></code></pre><h6 id><a href="#" class="headerlink" title></a></h6><h5 id="栈结构扩展应用"><a href="#栈结构扩展应用" class="headerlink" title="栈结构扩展应用"></a>栈结构扩展应用</h5><h6 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a><a href="https://leetcode-cn.com/problems/valid-parentheses/">20. 有效的括号</a></h6><p>给定一个只包括 <code>&#39;(&#39;，&#39;)&#39;，&#39;&#123;&#39;，&#39;&#125;&#39;，&#39;[&#39;，&#39;]&#39; </code>的字符串 s ，判断字符串是否有效。</p><p>有效字符串需满足：</p><p>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。</p><p><strong>示例 1：</strong></p><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;()&quot;</span>输出：<span class="hljs-literal">true</span></code></pre><p><strong>示例 2：</strong></p><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;()[]&#123;&#125;&quot;</span>输出：<span class="hljs-literal">true</span></code></pre><p><strong>示例 3：</strong></p><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;(]&quot;</span>输出：<span class="hljs-literal">false</span></code></pre><p><strong>示例 4：</strong></p><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;([)]&quot;</span>输出：<span class="hljs-literal">false</span></code></pre><p><strong>示例 5：</strong></p><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;&#123;[]&#125;&quot;</span>输出：<span class="hljs-literal">true</span></code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 104</code></li><li><code>s</code> 仅由括号 <code>&#39;()[]&#123;&#125;&#39;</code> 组成</li></ul><p>解题思路</p><pre><code class="hljs plain"></code></pre><p><code>Java</code></p><pre><code class="hljs Java"></code></pre><p><code>Golang</code></p><pre><code class="hljs Golang"></code></pre><p><code>Python</code></p><pre><code class="hljs Python"></code></pre><h6 id="1021-删除最外层的括号"><a href="#1021-删除最外层的括号" class="headerlink" title="1021. 删除最外层的括号"></a><a href="https://leetcode-cn.com/problems/remove-outermost-parentheses/">1021. 删除最外层的括号</a></h6><p>有效括号字符串为空 <code>(&quot;&quot;)</code>、<code>&quot;(&quot; + A + &quot;)&quot;</code> 或 <code>A + B</code>，其中 <code>A</code> 和 <code>B</code> 都是有效的括号字符串，<code>+</code> 代表字符串的连接。例如，<code>&quot;&quot;</code>，<code>&quot;()&quot;</code>，<code>&quot;(())()&quot;</code> 和 <code>&quot;(()(()))&quot;</code> 都是有效的括号字符串。</p><p>如果有效字符串 <code>S</code> 非空，且不存在将其拆分为 <code>S = A+B</code> 的方法，我们称其为<strong>原语（primitive）</strong>，其中 <code>A</code> 和 <code>B</code> 都是非空有效括号字符串。</p><p>给出一个非空有效字符串 <code>S</code>，考虑将其进行原语化分解，使得：<code>S = P_1 + P_2 + ... + P_k</code>，其中 <code>P_i</code> 是有效括号字符串原语。</p><p>对 <code>S</code> 进行原语化分解，删除分解中每个原语字符串的最外层括号，返回 <code>S</code>。</p><p><strong>示例 1：</strong></p><pre><code class="hljs 1c">输入：<span class="hljs-string">&quot;(()())(())&quot;</span>输出：<span class="hljs-string">&quot;()()()&quot;</span>解释：输入字符串为 <span class="hljs-string">&quot;(()())(())&quot;</span>，原语化分解得到 <span class="hljs-string">&quot;(()())&quot;</span> + <span class="hljs-string">&quot;(())&quot;</span>，删除每个部分中的最外层括号后得到 <span class="hljs-string">&quot;()()&quot;</span> + <span class="hljs-string">&quot;()&quot;</span> = <span class="hljs-string">&quot;()()()&quot;</span>。</code></pre><p><strong>示例 2：</strong></p><pre><code class="hljs 1c">输入：<span class="hljs-string">&quot;(()())(())(()(()))&quot;</span>输出：<span class="hljs-string">&quot;()()()()(())&quot;</span>解释：输入字符串为 <span class="hljs-string">&quot;(()())(())(()(()))&quot;</span>，原语化分解得到 <span class="hljs-string">&quot;(()())&quot;</span> + <span class="hljs-string">&quot;(())&quot;</span> + <span class="hljs-string">&quot;(()(()))&quot;</span>，删除每个部分中的最外层括号后得到 <span class="hljs-string">&quot;()()&quot;</span> + <span class="hljs-string">&quot;()&quot;</span> + <span class="hljs-string">&quot;()(())&quot;</span> = <span class="hljs-string">&quot;()()()()(())&quot;</span>。</code></pre><p><strong>示例 3：</strong></p><pre><code class="hljs 1c">输入：<span class="hljs-string">&quot;()()&quot;</span>输出：<span class="hljs-string">&quot;&quot;</span>解释：输入字符串为 <span class="hljs-string">&quot;()()&quot;</span>，原语化分解得到 <span class="hljs-string">&quot;()&quot;</span> + <span class="hljs-string">&quot;()&quot;</span>，删除每个部分中的最外层括号后得到 <span class="hljs-string">&quot;&quot;</span> + <span class="hljs-string">&quot;&quot;</span> = <span class="hljs-string">&quot;&quot;</span>。</code></pre><p><strong>提示：</strong></p><ol><li><code>S.length &lt;= 10000</code></li><li><code>S[i]</code> 为 <code>&quot;(&quot;</code> 或 <code>&quot;)&quot;</code></li><li><code>S</code> 是一个有效括号字符串</li></ol><p>解题思路</p><pre><code class="hljs plain"></code></pre><p><code>Java</code></p><pre><code class="hljs Java"></code></pre><p><code>Golang</code></p><pre><code class="hljs Golang"></code></pre><p><code>Python</code></p><pre><code class="hljs Python"></code></pre><h6 id="1249-移除无效的括号"><a href="#1249-移除无效的括号" class="headerlink" title="1249. 移除无效的括号"></a><a href="https://leetcode-cn.com/problems/minimum-remove-to-make-valid-parentheses/">1249. 移除无效的括号</a></h6><p>给你一个由 <code>&#39;(&#39;</code>、<code>&#39;)&#39;</code> 和小写字母组成的字符串 <code>s</code>。</p><p>你需要从字符串中删除最少数目的 <code>&#39;(&#39;</code> 或者 <code>&#39;)&#39;</code> （可以删除任意位置的括号)，使得剩下的「括号字符串」有效。</p><p>请返回任意一个合法字符串。</p><p>有效「括号字符串」应当符合以下 <strong>任意一条</strong> 要求:</p><ul><li>空字符串或只包含小写字母的字符串</li><li>可以被写作 <code>AB</code>（<code>A</code> 连接 <code>B</code>）的字符串，其中 <code>A</code> 和 <code>B</code> 都是有效「括号字符串」</li><li>可以被写作 <code>(A)</code> 的字符串，其中 <code>A</code> 是一个有效的「括号字符串」</li></ul><p><strong>示例 1：</strong></p><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;lee(t(c)o)de)&quot;</span>输出：<span class="hljs-string">&quot;lee(t(c)o)de&quot;</span>解释：<span class="hljs-string">&quot;lee(t(co)de)&quot;</span> , <span class="hljs-string">&quot;lee(t(c)ode)&quot;</span> 也是一个可行答案。</code></pre><p><strong>示例 2：</strong></p><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;a)b(c)d&quot;</span>输出：<span class="hljs-string">&quot;ab(c)d&quot;</span></code></pre><p><strong>示例 3：</strong></p><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;))((&quot;</span>输出：<span class="hljs-string">&quot;&quot;</span>解释：空字符串也是有效的</code></pre><p><strong>示例 4：</strong></p><pre><code class="hljs smalltalk">输入：s = <span class="hljs-comment">&quot;(a(b(c)d)&quot;</span>输出：<span class="hljs-comment">&quot;a(b(c)d)&quot;</span></code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 10^5</code></li><li><code>s[i]</code> 可能是 <code>&#39;(&#39;</code>、<code>&#39;)&#39;</code> 或英文小写字母</li></ul><p>解题思路</p><pre><code class="hljs plain"></code></pre><p><code>Java</code></p><pre><code class="hljs Java"></code></pre><p><code>Golang</code></p><pre><code class="hljs Golang"></code></pre><p><code>Python</code></p><pre><code class="hljs Python"></code></pre><h6 id="145-二叉树的后序遍历"><a href="#145-二叉树的后序遍历" class="headerlink" title="145. 二叉树的后序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/">145. 二叉树的后序遍历</a></h6><p>给定一个二叉树，返回它的 <em>后序</em> 遍历。</p><p><strong>示例:</strong></p><pre><code class="hljs yaml"><span class="hljs-string">输入:</span> [<span class="hljs-number">1</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]     <span class="hljs-number">1</span>    <span class="hljs-string">\</span>     <span class="hljs-number">2</span>    <span class="hljs-string">/</span>   <span class="hljs-number">3</span> <span class="hljs-string">输出:</span> [<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]</code></pre><p><strong>进阶:</strong> 递归算法很简单，你可以通过迭代算法完成吗？</p><p>解题思路</p><pre><code class="hljs plain"></code></pre><p><code>Java</code></p><pre><code class="hljs Java"></code></pre><p><code>Golang</code></p><pre><code class="hljs Golang"></code></pre><p><code>Python</code></p><pre><code class="hljs Python"></code></pre><h6 id="331-验证二叉树的前序序列化"><a href="#331-验证二叉树的前序序列化" class="headerlink" title="331. 验证二叉树的前序序列化"></a><a href="https://leetcode-cn.com/problems/verify-preorder-serialization-of-a-binary-tree/">331. 验证二叉树的前序序列化</a></h6><p>序列化二叉树的一种方法是使用前序遍历。当我们遇到一个非空节点时，我们可以记录下这个节点的值。如果它是一个空节点，我们可以使用一个标记值记录，例如 <code>#</code>。</p><pre><code class="hljs livescript">     _9_    /   <span class="hljs-string">\</span>   <span class="hljs-number">3</span>     <span class="hljs-number">2</span>  / <span class="hljs-string">\</span>   / <span class="hljs-string">\</span> <span class="hljs-number">4</span>   <span class="hljs-number">1</span>  <span class="hljs-comment">#  6</span>/ <span class="hljs-string">\</span> / <span class="hljs-string">\</span>   / <span class="hljs-string">\</span><span class="hljs-comment"># # # #   # #</span></code></pre><p>例如，上面的二叉树可以被序列化为字符串 <code>&quot;9,3,4,#,#,1,#,#,2,#,6,#,#&quot;</code>，其中 <code>#</code> 代表一个空节点。</p><p>给定一串以逗号分隔的序列，验证它是否是正确的二叉树的前序序列化。编写一个在不重构树的条件下的可行算法。</p><p>每个以逗号分隔的字符或为一个整数或为一个表示 null 指针的<code>&#39;#&#39;</code>。</p><p>你可以认为输入格式总是有效的，例如它永远不会包含两个连续的逗号，比如<code>&quot;1,,3&quot;</code>。</p><p><strong>示例 1:</strong></p><pre><code class="hljs actionscript">输入: <span class="hljs-string">&quot;9,3,4,#,#,1,#,#,2,#,6,#,#&quot;</span>输出: <span class="hljs-literal">true</span></code></pre><p><strong>示例 2:</strong></p><pre><code class="hljs actionscript">输入: <span class="hljs-string">&quot;1,#&quot;</span>输出: <span class="hljs-literal">false</span></code></pre><p><strong>示例 3:</strong></p><pre><code class="hljs actionscript">输入: <span class="hljs-string">&quot;9,#,#,1&quot;</span>输出: <span class="hljs-literal">false</span></code></pre><p>解题思路</p><pre><code class="hljs plain"></code></pre><p><code>Java</code></p><pre><code class="hljs Java"></code></pre><p><code>Golang</code></p><pre><code class="hljs Golang"></code></pre><p><code>Python</code></p><pre><code class="hljs Python"></code></pre><h6 id="636-函数的独占时间"><a href="#636-函数的独占时间" class="headerlink" title="636. 函数的独占时间"></a><a href="https://leetcode-cn.com/problems/exclusive-time-of-functions/">636. 函数的独占时间</a></h6><p>给出一个非抢占单线程CPU的 <strong>n</strong> 个函数运行日志，找到函数的独占时间。</p><p>每个函数都有一个唯一的 Id，从 <strong>0</strong> 到 <strong>n-1</strong>，函数可能会递归调用或者被其他函数调用。</p><p>日志是具有以下格式的字符串：<code>function_id：start_or_end：timestamp。</code>例如：<code>&quot;0:start:0&quot;</code> 表示函数 0 从 0 时刻开始运行。<code>&quot;0:end:0&quot;</code> 表示函数 0 在 0 时刻结束。</p><p>函数的独占时间定义是在该方法中花费的时间，调用其他函数花费的时间不算该函数的独占时间。你需要根据函数的 Id 有序地返回每个函数的独占时间。</p><p><strong>示例 1:</strong></p><pre><code class="hljs angelscript">输入:n = <span class="hljs-number">2</span>logs = <span class="hljs-string">[&quot;0:start:0&quot;,</span><span class="hljs-string"> &quot;1:start:2&quot;,</span><span class="hljs-string"> &quot;1:end:5&quot;,</span><span class="hljs-string"> &quot;0:end:6&quot;]</span>输出:[<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]说明：函数 <span class="hljs-number">0</span> 在时刻 <span class="hljs-number">0</span> 开始，在执行了  <span class="hljs-number">2</span>个时间单位结束于时刻 <span class="hljs-number">1</span>。现在函数 <span class="hljs-number">0</span> 调用函数 <span class="hljs-number">1</span>，函数 <span class="hljs-number">1</span> 在时刻 <span class="hljs-number">2</span> 开始，执行 <span class="hljs-number">4</span> 个时间单位后结束于时刻 <span class="hljs-number">5</span>。函数 <span class="hljs-number">0</span> 再次在时刻 <span class="hljs-number">6</span> 开始执行，并在时刻 <span class="hljs-number">6</span> 结束运行，从而执行了 <span class="hljs-number">1</span> 个时间单位。所以函数 <span class="hljs-number">0</span> 总共的执行了 <span class="hljs-number">2</span> +<span class="hljs-number">1</span> =<span class="hljs-number">3</span> 个时间单位，函数 <span class="hljs-number">1</span> 总共执行了 <span class="hljs-number">4</span> 个时间单位。</code></pre><p>说明：</p><ol><li>输入的日志会根据时间戳排序，而不是根据日志Id排序。</li><li>你的输出会根据函数Id排序，也就意味着你的输出数组中序号为 0 的元素相当于函数 0 的执行时间。</li><li>两个函数不会在同时开始或结束。</li><li>函数允许被递归调用，直到运行结束。</li><li>1 &lt;= n &lt;= 100</li></ol><p>解题思路</p><pre><code class="hljs plain"></code></pre><p><code>Java</code></p><pre><code class="hljs Java"></code></pre><p><code>Golang</code></p><pre><code class="hljs Golang"></code></pre><p><code>Python</code></p><pre><code class="hljs Python"></code></pre><h5 id="-1"><a href="#-1" class="headerlink" title></a></h5><h6 id="1124-表现良好的最长时间段"><a href="#1124-表现良好的最长时间段" class="headerlink" title="1124. 表现良好的最长时间段"></a><a href="https://leetcode-cn.com/problems/longest-well-performing-interval/">1124. 表现良好的最长时间段</a></h6><p>给你一份工作时间表 <code>hours</code>，上面记录着某一位员工每天的工作小时数。</p><p>我们认为当员工一天中的工作小时数大于 <code>8</code> 小时的时候，那么这一天就是「<strong>劳累的一天</strong>」。</p><p>所谓「表现良好的时间段」，意味在这段时间内，「劳累的天数」是严格 <strong>大于</strong>「不劳累的天数」。</p><p>请你返回「表现良好时间段」的最大长度。</p><p><strong>示例 1：</strong></p><pre><code class="hljs angelscript">输入：hours = [<span class="hljs-number">9</span>,<span class="hljs-number">9</span>,<span class="hljs-number">6</span>,<span class="hljs-number">0</span>,<span class="hljs-number">6</span>,<span class="hljs-number">6</span>,<span class="hljs-number">9</span>]输出：<span class="hljs-number">3</span>解释：最长的表现良好时间段是 [<span class="hljs-number">9</span>,<span class="hljs-number">9</span>,<span class="hljs-number">6</span>]。</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= hours.length &lt;= 10000</code></li><li><code>0 &lt;= hours[i] &lt;= 16</code></li></ul><p>解题思路</p><pre><code class="hljs plain"></code></pre><p><code>Java</code></p><pre><code class="hljs Java"></code></pre><p><code>Golang</code></p><pre><code class="hljs Golang"></code></pre><p><code>Python</code></p><pre><code class="hljs Python"></code></pre>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Go</tag>
      
      <tag>Java</tag>
      
      <tag>LeetCode</tag>
      
      <tag>scala</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Go】学习笔记</title>
    <link href="/2021/02/07/golang/"/>
    <url>/2021/02/07/golang/</url>
    
    <content type="html"><![CDATA[<blockquote><p> “Go has indeed become the language of cloud infrastructure” - Rob Pike interview<a id="more"></a></p></blockquote><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><h4 id="var与"><a href="#var与" class="headerlink" title="var与:="></a>var与:=</h4><ul><li>:=方式较为简洁，但只能在函数内使用该方式，var方式没有这个限制，var方式定义在汉书外的变量属于包内部的变量</li><li>函数中以:=方式定义变量为主</li></ul><h4 id="内建变量类型"><a href="#内建变量类型" class="headerlink" title="内建变量类型"></a>内建变量类型</h4><ul><li>bool,string</li><li>(u)int, (u)int8, (u)int16, (u)int32, (u)int, uintptr</li><li>byte, rune</li><li>float32, float64, complex64, complex128</li><li>变量类型写在变量名之后</li><li>编译器可推测变量类型</li><li>没有char, 只有rune</li><li>原生支持复数类型</li></ul><pre><code class="hljs golang"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;math&quot;</span><span class="hljs-string">&quot;math/cmplx&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">euler</span><span class="hljs-params">()</span></span>  &#123;<span class="hljs-comment">// 欧拉公式 e^(i*Pi) + 1 = 0</span>fmt.Println(cmplx.Exp(<span class="hljs-number">1i</span> * math.Pi) + <span class="hljs-number">1</span>)  fmt.Println(cmplx.Pow(math.E, <span class="hljs-number">1i</span> * math.Pi) + <span class="hljs-number">1</span>)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;euler()&#125;<span class="hljs-comment">// 打印内容</span>(<span class="hljs-number">0</span>+<span class="hljs-number">1.2246467991473515e-16i</span>)(<span class="hljs-number">0</span>+<span class="hljs-number">1.2246467991473515e-16i</span>)</code></pre><h4 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h4><p>go语言需要开发时强制类型转换，不会自动隐式转换</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">triangle</span><span class="hljs-params">()</span></span>  &#123;a, b := <span class="hljs-number">3</span>, <span class="hljs-number">4</span><span class="hljs-keyword">var</span> c <span class="hljs-keyword">int</span> c = math.Sqrt(a*a + b*b)                    <span class="hljs-comment">// 会在编译前idea便提示报错</span>  c = <span class="hljs-keyword">int</span>(math.Sqrt(<span class="hljs-keyword">float64</span>(a * a + b * b)))  <span class="hljs-comment">// 正确写法</span>fmt.Println(c)&#125;</code></pre><p>常量未声明类型，其类型是不确定的（数值可以作各种类型使用）</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">consts</span><span class="hljs-params">()</span></span>  &#123;<span class="hljs-comment">// 强制类型转换</span><span class="hljs-keyword">const</span> a, b = <span class="hljs-number">3</span>, <span class="hljs-number">4</span><span class="hljs-keyword">var</span> c <span class="hljs-keyword">int</span>c = <span class="hljs-keyword">int</span>(math.Sqrt(a * a + b * b))    <span class="hljs-comment">// a * a + b * b 部分可以不用加上强制类型转换</span>fmt.Println(c)&#125;</code></pre><p>可以利用常量申明枚举类型</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">enums</span><span class="hljs-params">()</span></span>  &#123;<span class="hljs-keyword">const</span> (golang = <span class="hljs-literal">iota</span>_javapython)fmt.Println(golang, java, python)&#125;<span class="hljs-comment">// 输出</span><span class="hljs-number">0</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span></code></pre><p>可以以<code>iota</code>为基础，生成一系列枚举数</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">enums</span><span class="hljs-params">()</span></span>  &#123;<span class="hljs-keyword">const</span> (b = <span class="hljs-number">1</span> &lt;&lt; (<span class="hljs-number">10</span> * <span class="hljs-literal">iota</span>)kbmbgbtb)fmt.Println(b, kb, mb, gb, tb)&#125;<span class="hljs-comment">// 输出</span><span class="hljs-number">1</span> <span class="hljs-number">1024</span> <span class="hljs-number">1048576</span> <span class="hljs-number">1073741824</span> <span class="hljs-number">1099511627776</span></code></pre><p><a href="https://github.com/weitrue/note/blob/master/go/variable.go">https://github.com/weitrue/note/blob/master/go/variable.go</a></p><h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p>指针不能运算</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> a <span class="hljs-keyword">int</span> = <span class="hljs-number">2</span><span class="hljs-keyword">var</span> pa *<span class="hljs-keyword">int</span> = &amp;a*pa = <span class="hljs-number">3</span>fmt.Println(a)&#125;<span class="hljs-comment">// 运行结果</span><span class="hljs-number">3</span></code></pre><p>参数传递—只有<em>值传递</em>一种方式</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">swapV</span><span class="hljs-params">(a, b <span class="hljs-keyword">int</span>)</span></span> &#123;b, a = a, bfmt.Println(<span class="hljs-string">&quot;in &quot;</span>, a, b, &amp;a, &amp;b)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">swapRN</span><span class="hljs-params">(a, b *<span class="hljs-keyword">int</span>)</span></span> &#123;<span class="hljs-comment">// 局部变量交换值（地址）</span>b, a = a, bfmt.Println(<span class="hljs-string">&quot;in &quot;</span>, a, b, *a, *b)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">swapR</span><span class="hljs-params">(a, b *<span class="hljs-keyword">int</span>)</span></span> &#123;<span class="hljs-comment">// 交换变量值（地址）指向的值</span>*b, *a = *a, *bfmt.Println(<span class="hljs-string">&quot;in &quot;</span>, a, b, *a, *b)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">pointerSwap</span><span class="hljs-params">()</span></span>  &#123;a, b := <span class="hljs-number">3</span>, <span class="hljs-number">4</span>swapV(a, b)fmt.Println(<span class="hljs-string">&quot;out&quot;</span>, a, b, &amp;a, &amp;b)a, b = <span class="hljs-number">3</span>, <span class="hljs-number">4</span>swapRN(&amp;a, &amp;b)fmt.Println(<span class="hljs-string">&quot;out&quot;</span>, a, b, &amp;a, &amp;b)a, b = <span class="hljs-number">3</span>, <span class="hljs-number">4</span>swapR(&amp;a, &amp;b)fmt.Println(<span class="hljs-string">&quot;out&quot;</span>, a, b, &amp;a, &amp;b)&#125;<span class="hljs-comment">// 输出</span>in  <span class="hljs-number">4</span> <span class="hljs-number">3</span> <span class="hljs-number">0xc00001e0c8</span> <span class="hljs-number">0xc00001e0d0</span>out <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">0xc00001e0b8</span> <span class="hljs-number">0xc00001e0c0</span>in  <span class="hljs-number">0xc00001e0c0</span> <span class="hljs-number">0xc00001e0b8</span> <span class="hljs-number">4</span> <span class="hljs-number">3</span>out <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">0xc00001e0b8</span> <span class="hljs-number">0xc00001e0c0</span>in  <span class="hljs-number">0xc00001e0b8</span> <span class="hljs-number">0xc00001e0c0</span> <span class="hljs-number">4</span> <span class="hljs-number">3</span>out <span class="hljs-number">4</span> <span class="hljs-number">3</span> <span class="hljs-number">0xc00001e0b8</span> <span class="hljs-number">0xc00001e0c0</span></code></pre><p><a href="https://github.com/weitrue/note/blob/master/go/pointer.go">https://github.com/weitrue/note/blob/master/go/pointer.go</a></p><h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>数组定义</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">define</span><span class="hljs-params">()</span></span>  &#123;<span class="hljs-keyword">var</span> arr1 [<span class="hljs-number">5</span>]<span class="hljs-keyword">int</span>arr2 := [<span class="hljs-number">3</span>]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>&#125;arr3 := [...]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>, <span class="hljs-number">10</span>&#125;<span class="hljs-keyword">var</span> grid [<span class="hljs-number">4</span>][<span class="hljs-number">5</span>]<span class="hljs-keyword">bool</span>fmt.Println(arr1, arr2, arr3)fmt.Println(grid)&#125;<span class="hljs-comment">// 输出</span>[<span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span>] [<span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span>] [<span class="hljs-number">2</span> <span class="hljs-number">4</span> <span class="hljs-number">6</span> <span class="hljs-number">8</span> <span class="hljs-number">10</span>][[<span class="hljs-literal">false</span> <span class="hljs-literal">false</span> <span class="hljs-literal">false</span> <span class="hljs-literal">false</span> <span class="hljs-literal">false</span>] [<span class="hljs-literal">false</span> <span class="hljs-literal">false</span> <span class="hljs-literal">false</span> <span class="hljs-literal">false</span> <span class="hljs-literal">false</span>] [<span class="hljs-literal">false</span> <span class="hljs-literal">false</span> <span class="hljs-literal">false</span> <span class="hljs-literal">false</span> <span class="hljs-literal">false</span>] [<span class="hljs-literal">false</span> <span class="hljs-literal">false</span> <span class="hljs-literal">false</span> <span class="hljs-literal">false</span> <span class="hljs-literal">false</span>]]</code></pre><p>[5]int和[10]int是不同类型</p><p>调用func f(arr [10]int)会<em>拷贝</em>数组</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printArr</span><span class="hljs-params">(arr [5]<span class="hljs-keyword">int</span>)</span></span>  &#123;arr[<span class="hljs-number">0</span>] = <span class="hljs-number">100</span><span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> arr &#123;fmt.Println(i, v)&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">arrTest</span><span class="hljs-params">()</span></span>  &#123;<span class="hljs-keyword">var</span> arr1 [<span class="hljs-number">5</span>]<span class="hljs-keyword">int</span>arr2 := [...]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>, <span class="hljs-number">10</span>&#125;fmt.Println()printArr(arr2)fmt.Println()<span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> arr1 &#123;fmt.Println(i, v)&#125;&#125;<span class="hljs-comment">// 输出</span><span class="hljs-number">0</span> <span class="hljs-number">100</span><span class="hljs-number">1</span> <span class="hljs-number">0</span><span class="hljs-number">2</span> <span class="hljs-number">0</span><span class="hljs-number">3</span> <span class="hljs-number">0</span><span class="hljs-number">4</span> <span class="hljs-number">0</span><span class="hljs-number">0</span> <span class="hljs-number">100</span><span class="hljs-number">1</span> <span class="hljs-number">4</span><span class="hljs-number">2</span> <span class="hljs-number">6</span><span class="hljs-number">3</span> <span class="hljs-number">8</span><span class="hljs-number">4</span> <span class="hljs-number">10</span><span class="hljs-number">0</span> <span class="hljs-number">0</span><span class="hljs-number">1</span> <span class="hljs-number">0</span><span class="hljs-number">2</span> <span class="hljs-number">0</span><span class="hljs-number">3</span> <span class="hljs-number">0</span><span class="hljs-number">4</span> <span class="hljs-number">0</span></code></pre><p>若要改变数组的值 需要传入数组的地址，因此go语言一般不使用数组</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printArrR</span><span class="hljs-params">(arr *[5]<span class="hljs-keyword">int</span>)</span></span>  &#123;arr[<span class="hljs-number">0</span>] = <span class="hljs-number">100</span><span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> arr &#123;fmt.Println(i, v)&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">arrTest</span><span class="hljs-params">()</span></span>  &#123;<span class="hljs-keyword">var</span> arr1 [<span class="hljs-number">5</span>]<span class="hljs-keyword">int</span>printArrR(&amp;arr1)fmt.Println()fmt.Println(arr1)&#125;<span class="hljs-comment">// 输出</span><span class="hljs-number">0</span> <span class="hljs-number">100</span><span class="hljs-number">1</span> <span class="hljs-number">0</span><span class="hljs-number">2</span> <span class="hljs-number">0</span><span class="hljs-number">3</span> <span class="hljs-number">0</span><span class="hljs-number">4</span> <span class="hljs-number">0</span>[<span class="hljs-number">100</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span>]</code></pre><p><a href="https://github.com/weitrue/note/blob/master/go/collections/array.go">https://github.com/weitrue/note/blob/master/go/collections/array.go</a></p><h4 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h4><ul><li><p>slice可以向后扩展，但不能向前扩展</p></li><li><p>s[i]不可超越len(s)，向后扩展不可以超越底层数组cap(s)</p></li></ul><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">slice</span><span class="hljs-params">()</span></span> &#123;arr := [...]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>&#125;s1 := arr[<span class="hljs-number">2</span>: <span class="hljs-number">6</span>]fmt.Println(s1)s2 := s1[<span class="hljs-number">3</span>: <span class="hljs-number">5</span>]fmt.Println(s2)  s3 := s1[<span class="hljs-number">3</span>:<span class="hljs-number">6</span>]fmt.Println(s3)&#125;<span class="hljs-comment">//输出</span>[<span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span>][<span class="hljs-number">6</span> <span class="hljs-number">7</span>]<span class="hljs-built_in">panic</span>: runtime error: slice bounds out of <span class="hljs-keyword">range</span> [:<span class="hljs-number">6</span>] with capacity <span class="hljs-number">5</span>goroutine <span class="hljs-number">1</span> [running]:main.sliceDefine()        ~/Projects/golang/src/offer/note/slices.<span class="hljs-keyword">go</span>:<span class="hljs-number">20</span> +<span class="hljs-number">0x164</span>main.main()        ~/Projects/golang/src/offer/note/ab_test_func.<span class="hljs-keyword">go</span>:<span class="hljs-number">28</span> +<span class="hljs-number">0x20</span></code></pre><p><img src="/images/golang/slice.png"></p><ul><li><p>向slice添加元素，如果超越cap，系统会自动分配更大的底层数组</p></li><li><p>由于值传递的原因，必须接收append的返回值<code>s=append(s, val)</code></p></li></ul><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sliceAppend</span><span class="hljs-params">()</span></span> &#123;arr := [...]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>&#125;s1 := arr[<span class="hljs-number">2</span>: <span class="hljs-number">6</span>]fmt.Println(s1, <span class="hljs-built_in">cap</span>(s1), <span class="hljs-built_in">len</span>(s1))s2 := s1[<span class="hljs-number">3</span>: <span class="hljs-number">5</span>]fmt.Println(s2)s3 := <span class="hljs-built_in">append</span>(s2, <span class="hljs-number">10</span>)s4 := <span class="hljs-built_in">append</span>(s3, <span class="hljs-number">11</span>)s5 := <span class="hljs-built_in">append</span>(s4, <span class="hljs-number">12</span>)fmt.Println(<span class="hljs-string">&quot;s3, s4, s5=&quot;</span>, s3, s4, s5)fmt.Println(arr)    s6 := <span class="hljs-built_in">append</span>(s1, <span class="hljs-number">10</span>)s7 := <span class="hljs-built_in">append</span>(s6, <span class="hljs-number">11</span>)s8 := <span class="hljs-built_in">append</span>(s7, <span class="hljs-number">12</span>)fmt.Println(<span class="hljs-string">&quot;s6, s7, s8=&quot;</span>, s6, s7, s8)fmt.Println(<span class="hljs-string">&quot;cap(s6), cap(s7), cap(s8) =&quot;</span>, <span class="hljs-built_in">cap</span>(s6), <span class="hljs-built_in">cap</span>(s7), <span class="hljs-built_in">cap</span>(s8))fmt.Println(arr)&#125;<span class="hljs-comment">// 输出</span>[<span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span>] <span class="hljs-number">6</span> <span class="hljs-number">4</span>[<span class="hljs-number">6</span> <span class="hljs-number">7</span>]s3, s4, s5= [<span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">10</span>] [<span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">10</span> <span class="hljs-number">11</span>] [<span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">10</span> <span class="hljs-number">11</span> <span class="hljs-number">12</span>]<span class="hljs-built_in">cap</span>(s3), <span class="hljs-built_in">cap</span>(s4), <span class="hljs-built_in">cap</span>(s5) = <span class="hljs-number">3</span> <span class="hljs-number">6</span> <span class="hljs-number">6</span>[<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">10</span>]s6, s7, s8= [<span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">10</span>] [<span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">10</span> <span class="hljs-number">11</span>] [<span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">10</span> <span class="hljs-number">11</span> <span class="hljs-number">12</span>]<span class="hljs-built_in">cap</span>(s6), <span class="hljs-built_in">cap</span>(s7), <span class="hljs-built_in">cap</span>(s8) = <span class="hljs-number">6</span> <span class="hljs-number">6</span> <span class="hljs-number">12</span>[<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">10</span> <span class="hljs-number">11</span>]</code></pre><ul><li>Zero value for slice is nil</li></ul><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sliceDefine</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> s []<span class="hljs-keyword">int</span><span class="hljs-keyword">for</span> i :=<span class="hljs-number">0</span>; i &lt;<span class="hljs-number">10</span>; i++ &#123;fmt.Printf(<span class="hljs-string">&quot;%v, cap(s) = %d, len(s) = %d\n&quot;</span>, s, <span class="hljs-built_in">cap</span>(s), <span class="hljs-built_in">len</span>(s))s = <span class="hljs-built_in">append</span>(s, <span class="hljs-number">2</span>*i + <span class="hljs-number">1</span>)&#125;s1 := []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;fmt.Printf(<span class="hljs-string">&quot;%v, cap(s1) = %d, len(s1) = %d\n&quot;</span>, s1, <span class="hljs-built_in">cap</span>(s1), <span class="hljs-built_in">len</span>(s1))s2 := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">8</span>)fmt.Printf(<span class="hljs-string">&quot;%v, cap(s2) = %d, len(s2) = %d\n&quot;</span>, s2, <span class="hljs-built_in">cap</span>(s2), <span class="hljs-built_in">len</span>(s2))s3 := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">8</span>, <span class="hljs-number">32</span>)fmt.Printf(<span class="hljs-string">&quot;%v, cap(s3) = %d, len(s3) = %d\n&quot;</span>, s3, <span class="hljs-built_in">cap</span>(s3), <span class="hljs-built_in">len</span>(s3))<span class="hljs-comment">// 拷贝</span><span class="hljs-built_in">copy</span>(s2, s1)fmt.Printf(<span class="hljs-string">&quot;%v, cap(s2) = %d, len(s2) = %d\n&quot;</span>, s2, <span class="hljs-built_in">cap</span>(s2), <span class="hljs-built_in">len</span>(s2))<span class="hljs-comment">// 删除 没有内建函数，只能通过截取+append</span>s4 := <span class="hljs-built_in">append</span>(s2[:<span class="hljs-number">2</span>], s2[<span class="hljs-number">3</span>:]...)fmt.Printf(<span class="hljs-string">&quot;%v, cap(s4) = %d, len(s4) = %d\n&quot;</span>, s4, <span class="hljs-built_in">cap</span>(s4), <span class="hljs-built_in">len</span>(s4))&#125;<span class="hljs-comment">//输出</span>[], <span class="hljs-built_in">cap</span>(s) = <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(s) = <span class="hljs-number">0</span>[<span class="hljs-number">1</span>], <span class="hljs-built_in">cap</span>(s) = <span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(s) = <span class="hljs-number">1</span>[<span class="hljs-number">1</span> <span class="hljs-number">3</span>], <span class="hljs-built_in">cap</span>(s) = <span class="hljs-number">2</span>, <span class="hljs-built_in">len</span>(s) = <span class="hljs-number">2</span>[<span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span>], <span class="hljs-built_in">cap</span>(s) = <span class="hljs-number">4</span>, <span class="hljs-built_in">len</span>(s) = <span class="hljs-number">3</span>[<span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span> <span class="hljs-number">7</span>], <span class="hljs-built_in">cap</span>(s) = <span class="hljs-number">4</span>, <span class="hljs-built_in">len</span>(s) = <span class="hljs-number">4</span>[<span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span> <span class="hljs-number">7</span> <span class="hljs-number">9</span>], <span class="hljs-built_in">cap</span>(s) = <span class="hljs-number">8</span>, <span class="hljs-built_in">len</span>(s) = <span class="hljs-number">5</span>[<span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span> <span class="hljs-number">7</span> <span class="hljs-number">9</span> <span class="hljs-number">11</span>], <span class="hljs-built_in">cap</span>(s) = <span class="hljs-number">8</span>, <span class="hljs-built_in">len</span>(s) = <span class="hljs-number">6</span>[<span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span> <span class="hljs-number">7</span> <span class="hljs-number">9</span> <span class="hljs-number">11</span> <span class="hljs-number">13</span>], <span class="hljs-built_in">cap</span>(s) = <span class="hljs-number">8</span>, <span class="hljs-built_in">len</span>(s) = <span class="hljs-number">7</span>[<span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span> <span class="hljs-number">7</span> <span class="hljs-number">9</span> <span class="hljs-number">11</span> <span class="hljs-number">13</span> <span class="hljs-number">15</span>], <span class="hljs-built_in">cap</span>(s) = <span class="hljs-number">8</span>, <span class="hljs-built_in">len</span>(s) = <span class="hljs-number">8</span>[<span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span> <span class="hljs-number">7</span> <span class="hljs-number">9</span> <span class="hljs-number">11</span> <span class="hljs-number">13</span> <span class="hljs-number">15</span> <span class="hljs-number">17</span>], <span class="hljs-built_in">cap</span>(s) = <span class="hljs-number">16</span>, <span class="hljs-built_in">len</span>(s) = <span class="hljs-number">9</span>[<span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span>], <span class="hljs-built_in">cap</span>(s1) = <span class="hljs-number">3</span>, <span class="hljs-built_in">len</span>(s1) = <span class="hljs-number">3</span>[<span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span>], <span class="hljs-built_in">cap</span>(s2) = <span class="hljs-number">8</span>, <span class="hljs-built_in">len</span>(s2) = <span class="hljs-number">8</span>[<span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span>], <span class="hljs-built_in">cap</span>(s3) = <span class="hljs-number">32</span>, <span class="hljs-built_in">len</span>(s3) = <span class="hljs-number">8</span>[<span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span>], <span class="hljs-built_in">cap</span>(s2) = <span class="hljs-number">8</span>, <span class="hljs-built_in">len</span>(s2) = <span class="hljs-number">8</span>[<span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span>], <span class="hljs-built_in">cap</span>(s4) = <span class="hljs-number">8</span>, <span class="hljs-built_in">len</span>(s4) = <span class="hljs-number">7</span></code></pre><p><a href="https://github.com/weitrue/note/blob/master/go/collections/slices.go">https://github.com/weitrue/note/blob/master/go/collections/slices.go</a></p><h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><ul><li><p>创建<code>make(map[type]type)</code></p></li><li><p>key不存在时，获取value类型的初始值，需要<code>if value, ok := m[key]; ok &#123;...&#125;</code> 判断是否存在key</p></li><li><p>map使用哈希表，必须可以比较相等</p></li><li><p>除了slice, map,function的内建类型都可以作为map的key,Struct类型不包含上述字段时，也可作为key</p></li></ul><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mapDefine</span><span class="hljs-params">()</span></span>  &#123;m := <span class="hljs-keyword">map</span>[<span class="hljs-keyword">int</span>]<span class="hljs-keyword">string</span>&#123;<span class="hljs-number">1</span>: <span class="hljs-string">&quot;aa&quot;</span>,<span class="hljs-number">2</span>: <span class="hljs-string">&quot;bb&quot;</span>,&#125;<span class="hljs-keyword">if</span> v, ok := m[<span class="hljs-number">3</span>]; ok &#123;fmt.Println(v)&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;key not exists&quot;</span>)&#125;&#125;<span class="hljs-comment">//输出</span><span class="hljs-built_in">panic</span>: key not existsgoroutine <span class="hljs-number">1</span> [running]:main.mapDefine()        /Users/wangpeng/Projects/golang/src/offer/note/maps.<span class="hljs-keyword">go</span>:<span class="hljs-number">20</span> +<span class="hljs-number">0x1f6</span>main.main()        /Users/wangpeng/Projects/golang/src/offer/note/ab_test_func.<span class="hljs-keyword">go</span>:<span class="hljs-number">32</span> +<span class="hljs-number">0x20</span></code></pre><p><a href="https://github.com/weitrue/note/blob/master/go/collections/maps.go">https://github.com/weitrue/note/blob/master/go/collections/maps.go</a></p><h4 id="Rune"><a href="#Rune" class="headerlink" title="Rune"></a>Rune</h4><p>字符串在UTF-8编码中，一个中文占三个字节，</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">strByte</span><span class="hljs-params">(s <span class="hljs-keyword">string</span>)</span></span>  &#123;<span class="hljs-keyword">if</span> s == <span class="hljs-string">&quot;&quot;</span> &#123;s = <span class="hljs-string">&quot;yes,我喜欢你！&quot;</span>&#125;<span class="hljs-keyword">for</span> i, ch := <span class="hljs-keyword">range</span> []<span class="hljs-keyword">byte</span>(s) &#123;fmt.Printf(<span class="hljs-string">&quot;(%d, %X)&quot;</span>, i, ch)&#125;fmt.Println()  <span class="hljs-keyword">for</span> i, ch := <span class="hljs-keyword">range</span> s &#123; <span class="hljs-comment">// ch is a rune 其实是将s进行utf-8解码，解码后的字符会转成unicode,然后放入rune中</span>fmt.Printf(<span class="hljs-string">&quot;(%d, %X)&quot;</span>, i, ch)&#125;fmt.Println()  bytes := []<span class="hljs-keyword">byte</span>(s)<span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(bytes) &gt;<span class="hljs-number">0</span> &#123;ch, size := utf8.DecodeRune(bytes)bytes = bytes[size:]fmt.Printf(<span class="hljs-string">&quot;%c &quot;</span>, ch)&#125;fmt.Println()<span class="hljs-keyword">for</span> i, ch := <span class="hljs-keyword">range</span> []<span class="hljs-keyword">rune</span>(s) &#123;fmt.Printf(<span class="hljs-string">&quot;(%d, %X)&quot;</span>, i, ch)&#125;&#125;<span class="hljs-comment">// 输出</span>(<span class="hljs-number">0</span>, <span class="hljs-number">79</span>)(<span class="hljs-number">1</span>, <span class="hljs-number">65</span>)(<span class="hljs-number">2</span>, <span class="hljs-number">73</span>)(<span class="hljs-number">3</span>, <span class="hljs-number">2</span>C)(<span class="hljs-number">4</span>, E6)(<span class="hljs-number">5</span>, <span class="hljs-number">88</span>)(<span class="hljs-number">6</span>, <span class="hljs-number">91</span>)(<span class="hljs-number">7</span>, E5)(<span class="hljs-number">8</span>, <span class="hljs-number">96</span>)(<span class="hljs-number">9</span>, <span class="hljs-number">9</span>C)(<span class="hljs-number">10</span>, E6)(<span class="hljs-number">11</span>, AC)(<span class="hljs-number">12</span>, A2)(<span class="hljs-number">13</span>, E4)(<span class="hljs-number">14</span>, BD)(<span class="hljs-number">15</span>, A0)(<span class="hljs-number">16</span>, EF)(<span class="hljs-number">17</span>, BC)(<span class="hljs-number">18</span>, <span class="hljs-number">81</span>)(<span class="hljs-number">0</span>, <span class="hljs-number">79</span>)(<span class="hljs-number">1</span>, <span class="hljs-number">65</span>)(<span class="hljs-number">2</span>, <span class="hljs-number">73</span>)(<span class="hljs-number">3</span>, <span class="hljs-number">2</span>C)(<span class="hljs-number">4</span>, <span class="hljs-number">6211</span>)(<span class="hljs-number">7</span>, <span class="hljs-number">559</span>C)(<span class="hljs-number">10</span>, <span class="hljs-number">6</span>B22)(<span class="hljs-number">13</span>, <span class="hljs-number">4</span>F60)(<span class="hljs-number">16</span>, FF01)y e s , 我 喜 欢 你 ！(<span class="hljs-number">0</span>, <span class="hljs-number">79</span>)(<span class="hljs-number">1</span>, <span class="hljs-number">65</span>)(<span class="hljs-number">2</span>, <span class="hljs-number">73</span>)(<span class="hljs-number">3</span>, <span class="hljs-number">2</span>C)(<span class="hljs-number">4</span>, <span class="hljs-number">6211</span>)(<span class="hljs-number">5</span>, <span class="hljs-number">559</span>C)(<span class="hljs-number">6</span>, <span class="hljs-number">6</span>B22)(<span class="hljs-number">7</span>, <span class="hljs-number">4</span>F60)(<span class="hljs-number">8</span>, FF01)</code></pre><p>因此在需要使用rune</p><pre><code class="hljs go"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Version: 1.0.0</span><span class="hljs-comment"> * Description: 获取字符串中不重复字串最大长度</span><span class="hljs-comment"> **/</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxNoRepeated</span><span class="hljs-params">(s <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">int</span></span> &#123;  <span class="hljs-comment">// 仅支持英文字符</span><span class="hljs-comment">// 字符下标映射</span>  chNotRepeatIndex := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">byte</span>] <span class="hljs-keyword">int</span>)<span class="hljs-comment">// 最长串起始位置</span>  start := <span class="hljs-number">0</span>  <span class="hljs-comment">// 最长串长度</span>maxLength := <span class="hljs-number">0</span> <span class="hljs-keyword">for</span> i, ch := <span class="hljs-keyword">range</span> []<span class="hljs-keyword">byte</span>(s) &#123; <span class="hljs-keyword">if</span> lastI, ok := chNotRepeatIndex[ch]; ok &amp;&amp; lastI &gt;= start &#123; start = lastI + <span class="hljs-number">1</span>&#125;<span class="hljs-keyword">if</span> i - start + <span class="hljs-number">1</span> &gt; maxLength &#123;maxLength = i - start + <span class="hljs-number">1</span>&#125;chNotRepeatIndex[ch] = i &#125; <span class="hljs-keyword">return</span> maxLength&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxNoRepeatedChn</span><span class="hljs-params">(s <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">int</span></span> &#123;  <span class="hljs-comment">// 通过rune</span>chNotRepeatIndex := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">rune</span>] <span class="hljs-keyword">int</span>)start := <span class="hljs-number">0</span>maxLength := <span class="hljs-number">0</span><span class="hljs-keyword">for</span> i, ch := <span class="hljs-keyword">range</span> []<span class="hljs-keyword">rune</span>(s) &#123;<span class="hljs-keyword">if</span> lastI, ok := chNotRepeatIndex[ch]; ok &amp;&amp; lastI &gt;= start &#123;start = lastI + <span class="hljs-number">1</span>&#125;<span class="hljs-keyword">if</span> i - start + <span class="hljs-number">1</span> &gt; maxLength &#123;maxLength = i - start + <span class="hljs-number">1</span>&#125;chNotRepeatIndex[ch] = i&#125;<span class="hljs-keyword">return</span> maxLength&#125;</code></pre><p><a href="https://github.com/weitrue/note/blob/master/go/collections/strings.go">https://github.com/weitrue/note/blob/master/go/collections/strings.go</a></p><h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><p>仅<em>支持封装</em>，不支持继承和多态</p><pre><code class="hljs go"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-keyword">type</span> Node <span class="hljs-keyword">struct</span> &#123;Value       <span class="hljs-keyword">int</span>Left, Right *Node&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(node Node)</span> <span class="hljs-title">Print</span><span class="hljs-params">()</span></span> &#123;fmt.Print(node.Value, <span class="hljs-string">&quot; &quot;</span>)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(node *Node)</span> <span class="hljs-title">SetValue</span><span class="hljs-params">(value <span class="hljs-keyword">int</span>)</span></span> &#123;  <span class="hljs-comment">// 接收者使用指针才可以改变结构内容</span><span class="hljs-keyword">if</span> node == <span class="hljs-literal">nil</span> &#123;fmt.Println(<span class="hljs-string">&quot;Setting Value to nil node. Ignored.&quot;</span>)<span class="hljs-keyword">return</span>&#125;node.Value = value&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(node Node)</span> <span class="hljs-title">SetValueNotUpdate</span><span class="hljs-params">(value <span class="hljs-keyword">int</span>)</span></span> &#123;  <span class="hljs-comment">// 值传递 node内容无法改变</span><span class="hljs-keyword">if</span> &amp;node == <span class="hljs-literal">nil</span> &#123;fmt.Println(<span class="hljs-string">&quot;Setting Value to nil node. Ignored.&quot;</span>)<span class="hljs-keyword">return</span>&#125;node.Value = value&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">CreateNode</span><span class="hljs-params">(value <span class="hljs-keyword">int</span>)</span> *<span class="hljs-title">Node</span></span> &#123;  <span class="hljs-comment">// 返回局部变量地址，这样变量会在堆中声明，可以传到外部</span><span class="hljs-keyword">return</span> &amp;Node&#123;Value: value&#125;&#125;</code></pre><p>方法有接收者（值/指针接收者），需要改变内容必须使用指针接收者，结构体过大考虑用指针接收者</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;  node := Node&#123;&#125;node.Print()node.SetValueNotUpdate(<span class="hljs-number">10</span>)node.Print()node.SetValue(<span class="hljs-number">10</span>)node.Print()&#125;<span class="hljs-comment">// 输出</span><span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">10</span></code></pre><p>nil也可以调用方法</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;  <span class="hljs-keyword">var</span> pNode *NodepNode.SetValue(<span class="hljs-number">30</span>)&#125;<span class="hljs-comment">// 输出</span>Setting Value to <span class="hljs-literal">nil</span> node. Ignored.</code></pre><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;  <span class="hljs-keyword">var</span> pNode *NodepNode.SetValueNotUpdate(<span class="hljs-number">20</span>)&#125;<span class="hljs-comment">// 输出</span><span class="hljs-built_in">panic</span>: runtime error: invalid memory address or <span class="hljs-literal">nil</span> pointer dereference[signal SIGSEGV: segmentation violation code=<span class="hljs-number">0x1</span> addr=<span class="hljs-number">0x0</span> pc=<span class="hljs-number">0x109d0af</span>]goroutine <span class="hljs-number">1</span> [running]:main.main()        ～/Projects/golang/src/offer/note/ab_test_func.<span class="hljs-keyword">go</span>:<span class="hljs-number">50</span> +<span class="hljs-number">0x1f</span></code></pre><p><a href="https://github.com/weitrue/note/blob/master/go/object/tree.go">https://github.com/weitrue/note/blob/master/go/object/tree.go</a></p><h4 id="封装与包"><a href="#封装与包" class="headerlink" title="封装与包"></a>封装与包</h4><p>首字母大写:public，首字母小写:private</p><p>为结构体定义的方法需要放在一个包下（可以是不同的文件）</p><p>扩充系统类型或者自定义类型方式：定义别名和使用组合</p><pre><code class="hljs go"><span class="hljs-keyword">type</span> Queue []<span class="hljs-keyword">int</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(q *Queue)</span><span class="hljs-title">Push</span><span class="hljs-params">(val <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">error</span></span> &#123;*q = <span class="hljs-built_in">append</span>(*q, val)<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(q *Queue)</span><span class="hljs-title">Pop</span><span class="hljs-params">()</span> <span class="hljs-params">(<span class="hljs-keyword">int</span>,<span class="hljs-keyword">bool</span>)</span></span> &#123;<span class="hljs-keyword">if</span> q.IsEmpty() &#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>, <span class="hljs-literal">false</span>&#125;head := (*q)[<span class="hljs-number">0</span>]*q = (*q)[<span class="hljs-number">1</span>:]<span class="hljs-keyword">return</span> head, <span class="hljs-literal">true</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(q *Queue)</span><span class="hljs-title">IsEmpty</span><span class="hljs-params">()</span> <span class="hljs-title">bool</span></span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(*q) == <span class="hljs-number">0</span>&#125;</code></pre><pre><code class="hljs go"><span class="hljs-keyword">type</span> Node <span class="hljs-keyword">struct</span> &#123;Value       <span class="hljs-keyword">int</span>Left, Right *Node&#125;<span class="hljs-keyword">type</span> MyNode <span class="hljs-keyword">struct</span> &#123;node *Node&#125;</code></pre><p><a href="https://github.com/weitrue/note/blob/master/go/object/queue.go">https://github.com/weitrue/note/blob/master/go/object/queue.go</a></p><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><h4 id="鸭子类型"><a href="#鸭子类型" class="headerlink" title="鸭子类型"></a>鸭子类型</h4><h5 id="Duck-Typing"><a href="#Duck-Typing" class="headerlink" title="Duck Typing"></a>Duck Typing</h5><p>接口由使用者定义</p><p>​    Python的在运行时才能知道被调用的对象是否实现某个方法</p><p>​    Java中编译前，调用的对象就必须实现接口所有方法</p><p>接口变量自带指针（参数传递也是值传递），因此几乎不需要使用接口指针    </p><p><img src="/images/golang/interface.png"></p><pre><code class="hljs go"><span class="hljs-comment">// offer/note/interfaces/mock/duck.go</span><span class="hljs-keyword">package</span> mock<span class="hljs-keyword">type</span> Duck <span class="hljs-keyword">struct</span> &#123;Name <span class="hljs-keyword">string</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d *Duck)</span> <span class="hljs-title">GetName</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span> &#123;  <span class="hljs-comment">// 实现者没有指明实现了哪个接口</span><span class="hljs-keyword">if</span> d.Name != <span class="hljs-string">&quot;&quot;</span> &#123;<span class="hljs-keyword">return</span> d.Name&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;这是一个鸭子！&quot;</span>&#125;&#125;<span class="hljs-comment">// offer/note/interfaces/duckI.go</span><span class="hljs-keyword">package</span> interfaces<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-keyword">type</span> DuckI <span class="hljs-keyword">interface</span> &#123;  <span class="hljs-comment">// 使用接口者 定义方法</span>GetName() <span class="hljs-keyword">string</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">FindDuck</span><span class="hljs-params">(d DuckI)</span></span>  &#123; <span class="hljs-comment">// 接口变量自带指针</span>name := d.GetName()fmt.Println(name)&#125;<span class="hljs-comment">// offer/note/main.go</span><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;offer/note/interfaces&quot;</span><span class="hljs-string">&quot;offer/note/interfaces/mock&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;  interfaces.FindDuck(&amp;mock.Duck&#123;&#125;)  interfaces.FindDuck(&amp;mock.Duck&#123;Name:<span class="hljs-string">&quot;这是一只假鸭子&quot;</span>&#125;)&#125;<span class="hljs-comment">// 输出</span>这是一个鸭子！这是一只假鸭子</code></pre><h5 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h5><pre><code class="hljs go"><span class="hljs-keyword">type</span> MemberRights <span class="hljs-keyword">interface</span> &#123; Information () <span class="hljs-keyword">string</span>&#125;<span class="hljs-keyword">type</span> BronzeMember <span class="hljs-keyword">struct</span> &#123; Discount <span class="hljs-keyword">uint8</span>&#125;<span class="hljs-keyword">type</span> SilverMember <span class="hljs-keyword">struct</span> &#123; Discount <span class="hljs-keyword">uint8</span>&#125;<span class="hljs-keyword">type</span> GoldMember <span class="hljs-keyword">struct</span> &#123; Discount <span class="hljs-keyword">uint8</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b *BronzeMember)</span> <span class="hljs-title">Information</span> <span class="hljs-params">()</span> <span class="hljs-title">string</span></span> &#123; <span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;Discount:%d&quot;</span>, b.Discount)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *SilverMember)</span> <span class="hljs-title">Information</span> <span class="hljs-params">()</span> <span class="hljs-title">string</span></span> &#123; <span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;Discount:%d&quot;</span>, s.Discount)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(g *GoldMember)</span> <span class="hljs-title">Information</span> <span class="hljs-params">()</span> <span class="hljs-title">string</span></span> &#123; <span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;Discount:%d&quot;</span>, g.Discount)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Price</span> <span class="hljs-params">(m MemberRights)</span></span> &#123; fmt.Println(m.Information())&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span></span> &#123; b := &amp;BronzeMember&#123;Discount: <span class="hljs-number">9</span>&#125; Price(b) s := &amp;SilverMember&#123;<span class="hljs-number">8</span>&#125; Price(s) g := <span class="hljs-built_in">new</span>(GoldMember) g.Discount = <span class="hljs-number">7</span> Price(g)&#125;</code></pre><h4 id="任何类型"><a href="#任何类型" class="headerlink" title="任何类型"></a>任何类型</h4><p><code>interface&#123;&#125;</code></p><pre><code class="hljs go"><span class="hljs-keyword">type</span> Queue []<span class="hljs-keyword">interface</span>&#123;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(q *Queue)</span><span class="hljs-title">Push</span><span class="hljs-params">(val <span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">error</span></span> &#123;*q = <span class="hljs-built_in">append</span>(*q, val)<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(q *Queue)</span><span class="hljs-title">Pop</span><span class="hljs-params">()</span> <span class="hljs-params">(<span class="hljs-keyword">interface</span>&#123;&#125;,<span class="hljs-keyword">bool</span>)</span></span> &#123;<span class="hljs-keyword">if</span> q.IsEmpty() &#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>, <span class="hljs-literal">false</span>&#125;head := (*q)[<span class="hljs-number">0</span>]*q = (*q)[<span class="hljs-number">1</span>:]<span class="hljs-keyword">return</span> head, <span class="hljs-literal">true</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(q *Queue)</span><span class="hljs-title">IsEmpty</span><span class="hljs-params">()</span> <span class="hljs-title">bool</span></span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(*q) == <span class="hljs-number">0</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;  q := interfaces.Queue&#123;&#125;_ = q.Push(<span class="hljs-string">&quot;asd&quot;</span>)_ = q.Push(<span class="hljs-number">123</span>)<span class="hljs-keyword">if</span> v, ok := q.Pop(); ok &#123;fmt.Println(v)&#125;<span class="hljs-keyword">if</span> v, ok := q.Pop(); ok &#123;fmt.Println(v)&#125;&#125;<span class="hljs-comment">// 输出</span>asd<span class="hljs-number">123</span></code></pre><h4 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h4><pre><code class="hljs go"><span class="hljs-comment">// offer/note/interfaces/animals.go</span><span class="hljs-keyword">package</span> animal<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-keyword">type</span> AnimalsI <span class="hljs-keyword">interface</span> &#123;DuckIBehaviorI&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">DuckBehavior</span><span class="hljs-params">(a AnimalsI)</span></span>  &#123;name := a.GetName()dark := a.Shout(<span class="hljs-string">&quot;呱呱乱叫&quot;</span>)fmt.Println(name, dark)  fmt.Println(a.String())&#125;<span class="hljs-comment">// offer/note/interfaces/behaviorI.go</span><span class="hljs-keyword">package</span> animal<span class="hljs-keyword">type</span> BehaviorI <span class="hljs-keyword">interface</span> &#123;Shout(dark <span class="hljs-keyword">string</span>) <span class="hljs-keyword">string</span>&#125;<span class="hljs-comment">// offer/note/interfaces/duckI.go</span><span class="hljs-keyword">package</span> animal<span class="hljs-keyword">type</span> DuckI <span class="hljs-keyword">interface</span> &#123;GetName() <span class="hljs-keyword">string</span>&#125;<span class="hljs-comment">// offer/note/interfaces/mock/duck.go</span><span class="hljs-keyword">package</span> mock<span class="hljs-keyword">type</span> Duck <span class="hljs-keyword">struct</span> &#123;name <span class="hljs-keyword">string</span>bark <span class="hljs-keyword">string</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d *Duck)</span> <span class="hljs-title">GetName</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span> &#123;<span class="hljs-keyword">if</span> d.name != <span class="hljs-string">&quot;&quot;</span> &#123;<span class="hljs-keyword">return</span> d.name&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;这是一个鸭子&quot;</span>&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d *Duck)</span> <span class="hljs-title">Shout</span><span class="hljs-params">(dark <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">string</span></span> &#123;<span class="hljs-keyword">if</span> d.bark == <span class="hljs-string">&quot;&quot;</span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;呱呱呱呱的叫&quot;</span>&#125;<span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">return</span> dark&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d *Duck)</span> <span class="hljs-title">String</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span> &#123;<span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;Duck: &#123; name = %s, bark = %s &#125;&quot;</span>, d.name, d.bark)&#125;<span class="hljs-comment">// 输出</span>这是一个鸭子 呱呱呱呱的叫Duck: &#123; name = , bark =  &#125;</code></pre><p><a href="https://github.com/weitrue/note/tree/master/go/interfaces">https://github.com/weitrue/note/tree/master/go/interfaces</a></p><h4 id="常用接口"><a href="#常用接口" class="headerlink" title="常用接口"></a>常用接口</h4><ul><li><code>Stringer</code>相当于toString()</li></ul><pre><code class="hljs go"><span class="hljs-keyword">type</span> Stringer <span class="hljs-keyword">interface</span> &#123;String() <span class="hljs-keyword">string</span>&#125;</code></pre><ul><li><code>Reader</code></li><li><code>Writer</code></li></ul><pre><code class="hljs go"><span class="hljs-comment">// io/io.go</span><span class="hljs-comment">// Reader is the interface that wraps the basic Read method.</span><span class="hljs-comment">//</span><span class="hljs-comment">// Read reads up to len(p) bytes into p. It returns the number of bytes</span><span class="hljs-comment">// read (0 &lt;= n &lt;= len(p)) and any error encountered. Even if Read</span><span class="hljs-comment">// returns n &lt; len(p), it may use all of p as scratch space during the call.</span><span class="hljs-comment">// If some data is available but not len(p) bytes, Read conventionally</span><span class="hljs-comment">// returns what is available instead of waiting for more.</span><span class="hljs-comment">//</span><span class="hljs-comment">// When Read encounters an error or end-of-file condition after</span><span class="hljs-comment">// successfully reading n &gt; 0 bytes, it returns the number of</span><span class="hljs-comment">// bytes read. It may return the (non-nil) error from the same call</span><span class="hljs-comment">// or return the error (and n == 0) from a subsequent call.</span><span class="hljs-comment">// An instance of this general case is that a Reader returning</span><span class="hljs-comment">// a non-zero number of bytes at the end of the input stream may</span><span class="hljs-comment">// return either err == EOF or err == nil. The next Read should</span><span class="hljs-comment">// return 0, EOF.</span><span class="hljs-comment">//</span><span class="hljs-comment">// Callers should always process the n &gt; 0 bytes returned before</span><span class="hljs-comment">// considering the error err. Doing so correctly handles I/O errors</span><span class="hljs-comment">// that happen after reading some bytes and also both of the</span><span class="hljs-comment">// allowed EOF behaviors.</span><span class="hljs-comment">//</span><span class="hljs-comment">// Implementations of Read are discouraged from returning a</span><span class="hljs-comment">// zero byte count with a nil error, except when len(p) == 0.</span><span class="hljs-comment">// Callers should treat a return of 0 and nil as indicating that</span><span class="hljs-comment">// nothing happened; in particular it does not indicate EOF.</span><span class="hljs-comment">//</span><span class="hljs-comment">// Implementations must not retain p.</span><span class="hljs-keyword">type</span> Reader <span class="hljs-keyword">interface</span> &#123;Read(p []<span class="hljs-keyword">byte</span>) (n <span class="hljs-keyword">int</span>, err error)&#125;<span class="hljs-comment">// Writer is the interface that wraps the basic Write method.</span><span class="hljs-comment">//</span><span class="hljs-comment">// Write writes len(p) bytes from p to the underlying data stream.</span><span class="hljs-comment">// It returns the number of bytes written from p (0 &lt;= n &lt;= len(p))</span><span class="hljs-comment">// and any error encountered that caused the write to stop early.</span><span class="hljs-comment">// Write must return a non-nil error if it returns n &lt; len(p).</span><span class="hljs-comment">// Write must not modify the slice data, even temporarily.</span><span class="hljs-comment">//</span><span class="hljs-comment">// Implementations must not retain p.</span><span class="hljs-keyword">type</span> Writer <span class="hljs-keyword">interface</span> &#123;Write(p []<span class="hljs-keyword">byte</span>) (n <span class="hljs-keyword">int</span>, err error)&#125;<span class="hljs-comment">// ReadWriter is the interface that groups the basic Read and Write methods.</span><span class="hljs-keyword">type</span> ReadWriter <span class="hljs-keyword">interface</span> &#123;ReaderWriter&#125;</code></pre><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><ul><li>函数可以有多个返回值，并且这些返回值可以起别名（别名多用于简单函数），别名与调用者的申明变量并无关联</li></ul><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">eval</span><span class="hljs-params">(a, b <span class="hljs-keyword">int</span>, op <span class="hljs-keyword">string</span>)</span> <span class="hljs-params">(<span class="hljs-keyword">int</span>, error)</span></span> &#123;<span class="hljs-keyword">switch</span> op &#123;<span class="hljs-keyword">case</span> <span class="hljs-string">&quot;+&quot;</span>:<span class="hljs-keyword">return</span>  a + b, <span class="hljs-literal">nil</span><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;-&quot;</span>:<span class="hljs-keyword">return</span> a - b, <span class="hljs-literal">nil</span><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;*&quot;</span>:<span class="hljs-keyword">return</span> a * b, <span class="hljs-literal">nil</span><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;/&quot;</span>:r, _ := div(a, b)<span class="hljs-keyword">return</span> r, <span class="hljs-literal">nil</span><span class="hljs-keyword">default</span>:<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>, fmt.Errorf(<span class="hljs-string">&quot;unsupported operation&quot;</span>)&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">div</span><span class="hljs-params">(a, b <span class="hljs-keyword">int</span>)</span> <span class="hljs-params">(q, r <span class="hljs-keyword">int</span>)</span></span> &#123;<span class="hljs-keyword">return</span> a/b, a%b&#125;</code></pre><ul><li><em>一等公民</em> :变量、参数、返回值均可以是函数</li></ul><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;math&quot;</span><span class="hljs-string">&quot;reflect&quot;</span><span class="hljs-string">&quot;runtime&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">apply</span><span class="hljs-params">(op <span class="hljs-keyword">func</span>(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">float64</span>, <span class="hljs-title">a</span>, <span class="hljs-title">b</span> <span class="hljs-title">int</span>) <span class="hljs-title">float64</span></span> &#123;<span class="hljs-comment">//</span>p := reflect.ValueOf(op).Pointer()opName := runtime.FuncForPC(p).Name()fmt.Printf(<span class="hljs-string">&quot;Calling function %s with params (%d, %d)\n&quot;</span>, opName, a, b)<span class="hljs-keyword">return</span> op(<span class="hljs-keyword">int</span>(a), <span class="hljs-keyword">int</span>(b))&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">pow</span><span class="hljs-params">(a, b <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">float64</span></span> &#123;<span class="hljs-keyword">return</span> math.Pow(<span class="hljs-keyword">float64</span>(a), <span class="hljs-keyword">float64</span>(b))&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;fmt.Println(apply(pow, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>))<span class="hljs-comment">// 匿名函数方式</span>fmt.Println(apply(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(f, f2 <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">float64</span></span> &#123;<span class="hljs-keyword">return</span> math.Pow(<span class="hljs-keyword">float64</span>(f), <span class="hljs-keyword">float64</span>(f2))&#125;, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>))&#125;<span class="hljs-comment">// 打印结果</span>Calling function main.pow with params (<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)<span class="hljs-number">81</span>Calling function main.main.func1 with params (<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)<span class="hljs-number">81</span></code></pre><ul><li>可变参数列表，类似于Python中的*args</li></ul><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sum</span><span class="hljs-params">(nums ...<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<span class="hljs-comment">// 函数可变参数列表</span>sum := <span class="hljs-number">0</span><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> nums &#123;sum += nums[i]&#125;<span class="hljs-keyword">return</span> sum&#125;</code></pre><p><a href="https://github.com/weitrue/note/blob/master/go/functions/func.go">https://github.com/weitrue/note/blob/master/go/functions/func.go</a></p><h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><p><img src="/images/golang/func.png"></p><p>其中，<code>func(i int)</code>中<code>i</code>为局部变量，<code>sum</code>为自由变量</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">adder</span><span class="hljs-params">()</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;sum := <span class="hljs-number">0</span><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;sum += i<span class="hljs-keyword">return</span> sum&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestAdder</span><span class="hljs-params">()</span></span>  &#123;a := adder()<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span> ; i++ &#123;fmt.Printf(<span class="hljs-string">&quot;0 + ... + %d = %d \n&quot;</span>, i, a(i))&#125;&#125;<span class="hljs-comment">// 输出</span><span class="hljs-number">0</span> + ... + <span class="hljs-number">0</span> = <span class="hljs-number">0</span> <span class="hljs-number">0</span> + ... + <span class="hljs-number">1</span> = <span class="hljs-number">1</span> <span class="hljs-number">0</span> + ... + <span class="hljs-number">2</span> = <span class="hljs-number">3</span> <span class="hljs-number">0</span> + ... + <span class="hljs-number">3</span> = <span class="hljs-number">6</span> <span class="hljs-number">0</span> + ... + <span class="hljs-number">4</span> = <span class="hljs-number">10</span> <span class="hljs-number">0</span> + ... + <span class="hljs-number">5</span> = <span class="hljs-number">15</span> <span class="hljs-number">0</span> + ... + <span class="hljs-number">6</span> = <span class="hljs-number">21</span> <span class="hljs-number">0</span> + ... + <span class="hljs-number">7</span> = <span class="hljs-number">28</span> <span class="hljs-number">0</span> + ... + <span class="hljs-number">8</span> = <span class="hljs-number">36</span> <span class="hljs-number">0</span> + ... + <span class="hljs-number">9</span> = <span class="hljs-number">45</span> <span class="hljs-comment">// 正统函数式编程</span><span class="hljs-keyword">type</span> iAdder <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span> <span class="hljs-params">(<span class="hljs-keyword">int</span>, iAdder)</span></span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">iAdd</span><span class="hljs-params">(base <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">iAdder</span></span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(v <span class="hljs-keyword">int</span>)</span> <span class="hljs-params">(<span class="hljs-keyword">int</span>, iAdder)</span></span> &#123;<span class="hljs-keyword">return</span> base +v, iAdd(base+v)&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestAdder</span><span class="hljs-params">()</span></span> &#123;a2 := iAdd(<span class="hljs-number">0</span>)<span class="hljs-keyword">var</span> s <span class="hljs-keyword">int</span><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;<span class="hljs-number">10</span>; i++ &#123;s, a2 = a2(i)fmt.Printf(<span class="hljs-string">&quot;0 + ... + %d = %d \n&quot;</span>, i, s)&#125;&#125;<span class="hljs-comment">// 输出</span><span class="hljs-number">0</span> + ... + <span class="hljs-number">1</span> = <span class="hljs-number">1</span> <span class="hljs-number">0</span> + ... + <span class="hljs-number">2</span> = <span class="hljs-number">3</span> <span class="hljs-number">0</span> + ... + <span class="hljs-number">3</span> = <span class="hljs-number">6</span> <span class="hljs-number">0</span> + ... + <span class="hljs-number">4</span> = <span class="hljs-number">10</span> <span class="hljs-number">0</span> + ... + <span class="hljs-number">5</span> = <span class="hljs-number">15</span> <span class="hljs-number">0</span> + ... + <span class="hljs-number">6</span> = <span class="hljs-number">21</span> <span class="hljs-number">0</span> + ... + <span class="hljs-number">7</span> = <span class="hljs-number">28</span> <span class="hljs-number">0</span> + ... + <span class="hljs-number">8</span> = <span class="hljs-number">36</span> <span class="hljs-number">0</span> + ... + <span class="hljs-number">9</span> = <span class="hljs-number">45</span></code></pre><p><a href="https://github.com/weitrue/note/blob/master/go/functions/closure.go">https://github.com/weitrue/note/blob/master/go/functions/closure.go</a></p><h5 id="Python中的闭包"><a href="#Python中的闭包" class="headerlink" title="Python中的闭包"></a>Python中的闭包</h5><p>Python原生支持闭包</p><p><code>__closure__</code>可以查看闭包内容</p><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">adder</span>():</span>    s = <span class="hljs-number">0</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span>(<span class="hljs-params">v: <span class="hljs-built_in">int</span></span>):</span>        <span class="hljs-keyword">nonlocal</span> s        s += v        <span class="hljs-keyword">return</span> s    <span class="hljs-keyword">return</span> f<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:    a = adder()    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):        print(i, a(i), a.__closure__)        <span class="hljs-comment"># 输出</span><span class="hljs-number">0</span> <span class="hljs-number">0</span> (&lt;cell at <span class="hljs-number">0x7f9048e7d3d0</span>: <span class="hljs-built_in">int</span> <span class="hljs-built_in">object</span> at <span class="hljs-number">0x106eb6290</span>&gt;,)<span class="hljs-number">1</span> <span class="hljs-number">1</span> (&lt;cell at <span class="hljs-number">0x7f9048e7d3d0</span>: <span class="hljs-built_in">int</span> <span class="hljs-built_in">object</span> at <span class="hljs-number">0x106eb62b0</span>&gt;,)<span class="hljs-number">2</span> <span class="hljs-number">3</span> (&lt;cell at <span class="hljs-number">0x7f9048e7d3d0</span>: <span class="hljs-built_in">int</span> <span class="hljs-built_in">object</span> at <span class="hljs-number">0x106eb62f0</span>&gt;,)<span class="hljs-number">3</span> <span class="hljs-number">6</span> (&lt;cell at <span class="hljs-number">0x7f9048e7d3d0</span>: <span class="hljs-built_in">int</span> <span class="hljs-built_in">object</span> at <span class="hljs-number">0x106eb6350</span>&gt;,)<span class="hljs-number">4</span> <span class="hljs-number">10</span> (&lt;cell at <span class="hljs-number">0x7f9048e7d3d0</span>: <span class="hljs-built_in">int</span> <span class="hljs-built_in">object</span> at <span class="hljs-number">0x106eb63d0</span>&gt;,)<span class="hljs-number">5</span> <span class="hljs-number">15</span> (&lt;cell at <span class="hljs-number">0x7f9048e7d3d0</span>: <span class="hljs-built_in">int</span> <span class="hljs-built_in">object</span> at <span class="hljs-number">0x106eb6470</span>&gt;,)<span class="hljs-number">6</span> <span class="hljs-number">21</span> (&lt;cell at <span class="hljs-number">0x7f9048e7d3d0</span>: <span class="hljs-built_in">int</span> <span class="hljs-built_in">object</span> at <span class="hljs-number">0x106eb6530</span>&gt;,)<span class="hljs-number">7</span> <span class="hljs-number">28</span> (&lt;cell at <span class="hljs-number">0x7f9048e7d3d0</span>: <span class="hljs-built_in">int</span> <span class="hljs-built_in">object</span> at <span class="hljs-number">0x106eb6610</span>&gt;,)<span class="hljs-number">8</span> <span class="hljs-number">36</span> (&lt;cell at <span class="hljs-number">0x7f9048e7d3d0</span>: <span class="hljs-built_in">int</span> <span class="hljs-built_in">object</span> at <span class="hljs-number">0x106eb6710</span>&gt;,)<span class="hljs-number">9</span> <span class="hljs-number">45</span> (&lt;cell at <span class="hljs-number">0x7f9048e7d3d0</span>: <span class="hljs-built_in">int</span> <span class="hljs-built_in">object</span> at <span class="hljs-number">0x106eb6830</span>&gt;,)</code></pre><h5 id="Java中的闭包"><a href="#Java中的闭包" class="headerlink" title="Java中的闭包"></a>Java中的闭包</h5><p>1.8以后，可以使用Function接口和Lambda表达式可以创建函数对象；</p><p>1.8之前，可以使用Lambda表达式或者匿名内部类也可以实现闭包；</p><pre><code class="hljs Java"><span class="hljs-keyword">import</span> javax.xml.ws.Holder;<span class="hljs-keyword">import</span> java.util.function.Function;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyTest</span> </span>&#123;    <span class="hljs-keyword">final</span> Holder&lt;Integer&gt; sum = <span class="hljs-keyword">new</span> Holder&lt;&gt;(<span class="hljs-number">0</span>);    <span class="hljs-keyword">public</span>  Function&lt;Integer, Integer&gt;testClosure()&#123;        <span class="hljs-comment">// 闭包  使用Function接口和Lambda表达式可以创建函数对象</span>        <span class="hljs-keyword">return</span> (Integer value) -&gt; &#123;            sum.value += value;            <span class="hljs-keyword">return</span> sum.value;        &#125;;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        MyTest mt = <span class="hljs-keyword">new</span> MyTest();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;            System.out.println(i +<span class="hljs-string">&quot;, &quot;</span>+ mt.testClosure().apply(<span class="hljs-keyword">new</span> Integer(i)));        &#125;    &#125;&#125;</code></pre><h4 id="闭包应用"><a href="#闭包应用" class="headerlink" title="闭包应用"></a>闭包应用</h4><h6 id="为函数实现接口"><a href="#为函数实现接口" class="headerlink" title="为函数实现接口"></a>为函数实现接口</h6><h6 id="实现函数遍历二叉树"><a href="#实现函数遍历二叉树" class="headerlink" title="实现函数遍历二叉树"></a>实现函数遍历二叉树</h6><h3 id="defer-recover在简单web服务应用"><a href="#defer-recover在简单web服务应用" class="headerlink" title="defer/recover在简单web服务应用"></a>defer/recover在简单web服务应用</h3><p>代码结构<img src="/images/golang/web.jpg"></p><p><a href="https://github.com/weitrue/note/tree/master/go/web/">https://github.com/weitrue/note/tree/master/go/web/</a></p><h3 id="包管理"><a href="#包管理" class="headerlink" title="包管理"></a>包管理</h3><h4 id="gopm-获取无法下载的包"><a href="#gopm-获取无法下载的包" class="headerlink" title="gopm 获取无法下载的包"></a>gopm 获取无法下载的包</h4><p><code>go get -v github.com/gpmgo/gopm</code></p><p>github地址：<a href="https://github.com/gpmgo/gopm">https://github.com/gpmgo/gopm</a></p><p>文档路径：<a href="https://github.com/gpmgo/docs/tree/master/zh-CN">https://github.com/gpmgo/docs/tree/master/zh-CN</a></p><p>安装踩坑：</p><pre><code class="hljs zsh">github.com/codegangsta/cli: github.com/codegangsta/cli@v1.22.5: parsing go.mod:module declares its path as: github.com/urfave/cli        but was required as: github.com/codegangsta/cli</code></pre><p>关闭go mod即可成功安装</p><h3 id="笔试题"><a href="#笔试题" class="headerlink" title="笔试题"></a>笔试题</h3><h4 id="选择题"><a href="#选择题" class="headerlink" title="选择题"></a>选择题</h4><p>1.[primary] 下面属于关键字的是（）<br>A. func<br>B. def<br>C. struct<br>D. class​</p><p>AC</p><p>2.[primary] 定义一个包内全局字符串变量，下面语法正确的是 （）<br>A. var str string<br>B. str := “”<br>C. str = “”<br>D. var str = “”</p><p>AD</p><p>3.[primary] 通过指针变量 p 访问其成员变量 name，下面语法正确的是（）<br>A. p.name<br>B. (*p).name<br>C. (&amp;p).name<br>D. p-&gt;name</p><p>AB</p><p>4.[primary] 关于接口和类的说法，下面说法正确的是（）<br>A. 一个类只需要实现了接口要求的所有函数，我们就说这个类实现了该接口<br>B. 实现类的时候，只需要关心自己应该提供哪些方法，不用再纠结接口需要拆得多细才合理<br>C. 类实现接口时，需要导入接口所在的包<br>D. 接口由使用方按自身需求来定义，使用方无需关心是否有其他模块定义过类似的接口</p><p>ABD</p><p>5.[primary] 关于字符串连接，下面语法正确的是（）<br>A. str := ‘abc’ + ‘123’<br>B. str := “abc” + “123”<br>C. str ：= ‘123’ + “abc”<br>D. fmt.Sprintf(“abc%d”, 123)</p><p>BD</p><p>6.[primary] 关于协程，下面说法正确是（）<br>A. 协程和线程都可以实现程序的并发执行<br>B. 线程比协程更轻量级<br>C. 协程不存在死锁问题<br>D. 通过channel来进行协程间的通信</p><p>AD</p><p>7.[intermediate] 关于init函数，下面说法正确的是（）<br>A. 一个包中，可以包含多个init函数<br>B. 程序编译时，先执行导入包的init函数，再执行本包内的init函数<br>C. main包中，不能有init函数<br>D. init函数可以被其他函数调用</p><p>AB</p><p>8.[primary] 关于循环语句，下面说法正确的有（）<br>A. 循环语句既支持for关键字，也支持while和do-while<br>B. 关键字for的基本使用方法与C/C++中没有任何差异<br>C. for循环支持continue和break来控制循环，但是它提供了一个更高级的break，可以选择中断哪一个循环<br>D. for循环不支持以逗号为间隔的多个赋值语句，必须使用平行赋值的方式来初始化多个变量</p><p>CD</p><p>9.[intermediate] 对于函数定义：</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">add</span><span class="hljs-params">(args ...<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;        sum := <span class="hljs-number">0</span>        <span class="hljs-keyword">for</span> _, arg := <span class="hljs-keyword">range</span> args &#123;            sum += arg        &#125;        <span class="hljs-keyword">return</span> sum&#125;</code></pre><p>下面对add函数调用正确的是（）</p><p> A. add(1, 2)<br> B. add(1, 3, 7)<br> C. add([]int{1, 2})<br> D. add([]int{1, 3, 7}…)</p><p>ABD</p><p>10.[primary] 关于类型转化，下面语法正确的是（）<br>A.</p><pre><code class="hljs go"><span class="hljs-keyword">type</span> MyInt <span class="hljs-keyword">int</span><span class="hljs-keyword">var</span> i <span class="hljs-keyword">int</span> = <span class="hljs-number">1</span><span class="hljs-keyword">var</span> j MyInt = i</code></pre><p>B.</p><pre><code class="hljs go"><span class="hljs-keyword">type</span> MyInt <span class="hljs-keyword">int</span><span class="hljs-keyword">var</span> i <span class="hljs-keyword">int</span> = <span class="hljs-number">1</span><span class="hljs-keyword">var</span> j MyInt = (MyInt)i</code></pre><p>C.</p><pre><code class="hljs go"><span class="hljs-keyword">type</span> MyInt <span class="hljs-keyword">int</span><span class="hljs-keyword">var</span> i <span class="hljs-keyword">int</span> = <span class="hljs-number">1</span><span class="hljs-keyword">var</span> j MyInt = MyInt(i)</code></pre><p>D.</p><pre><code class="hljs go"><span class="hljs-keyword">type</span> MyInt <span class="hljs-keyword">int</span><span class="hljs-keyword">var</span> i <span class="hljs-keyword">int</span> = <span class="hljs-number">1</span><span class="hljs-keyword">var</span> j MyInt = i.(MyInt)   <span class="hljs-comment">// Invalid type assertion: i.(MyInt) (non-interface type int on left)</span></code></pre><p>C</p><p>11.[primary] 关于局部变量的初始化，下面正确的使用方式是（）<br>A. var i int = 10<br>B. var i = 10<br>C. i := 10<br>D. i = 10</p><p>12.[primary] 关于const常量定义，下面正确的使用方式是（）<br>A.</p><pre><code class="hljs go"><span class="hljs-keyword">const</span> Pi <span class="hljs-keyword">float64</span> = <span class="hljs-number">3.14159265358979323846</span><span class="hljs-keyword">const</span> zero = <span class="hljs-number">0.0</span></code></pre><p>B.</p><pre><code class="hljs go"><span class="hljs-keyword">const</span> (        size <span class="hljs-keyword">int64</span> = <span class="hljs-number">1024</span>        eof = <span class="hljs-number">-1</span>)</code></pre><p>C.</p><pre><code class="hljs go"><span class="hljs-keyword">const</span> (        ERR_ELEM_EXIST error = errors.New(<span class="hljs-string">&quot;element already exists&quot;</span>)        ERR_ELEM_NT_EXIST error = errors.New(<span class="hljs-string">&quot;element not exists&quot;</span>)) <span class="hljs-comment">// Const initializer &#x27;errors.New(&quot;element already exists&quot;)&#x27; is not a constant</span></code></pre><p>D.</p><pre><code class="hljs go"><span class="hljs-keyword">const</span> u, v <span class="hljs-keyword">float32</span> = <span class="hljs-number">0</span>, <span class="hljs-number">3</span><span class="hljs-keyword">const</span> a, b, c = <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-string">&quot;foo&quot;</span></code></pre><p>ABD</p><p>13.[primary] 关于布尔变量b的赋值，下面错误的用法是（）<br>A. b = true<br>B. b = 1     //  Cannot use ‘1’ (type untyped int) as type bool in assignment<br>C. b = bool(1)   //Cannot convert expression of type int to type bool<br>D. b = (1 == 2)</p><p>BC</p><p>14.[intermediate] 下面的程序的运行结果是（）</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;        <span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) &#123;            <span class="hljs-keyword">defer</span> fmt.Printf(<span class="hljs-string">&quot;1&quot;</span>)        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">defer</span> fmt.Printf(<span class="hljs-string">&quot;2&quot;</span>)        &#125;        fmt.Printf(<span class="hljs-string">&quot;3&quot;</span>)&#125;</code></pre><p>A. 321<br>B. 32<br>C. 31<br>D. 13</p><p>C</p><p>15.[primary] 关于switch语句，下面说法正确的有（）<br>A. 条件表达式必须为常量或者整数<br>B. 单个case中，可以出现多个结果选项<br>C. 需要用break来明确退出一个case<br>D. 只有在case中明确添加fallthrough关键字，才会继续执行紧跟的下一个case</p><p>BD</p><p>16.[intermediate] golang中没有隐藏的this指针，这句话的含义是（）<br>A. 方法施加的对象显式传递，没有被隐藏起来<br>B. golang沿袭了传统面向对象编程中的诸多概念，比如继承、虚函数和构造函数<br>C. golang的面向对象表达更直观，对于面向过程只是换了一种语法形式来表达<br>D. 方法施加的对象不需要非得是指针，也不用非得叫this</p><p>ACD</p><p>17.[intermediate] golang中的引用类型包括（）<br>A. 数组切片<br>B. map<br>C. channel<br>D. interface</p><p>ABCD</p><p>18.[intermediate] golang中的指针运算包括（）<br>A. 可以对指针进行自增或自减运算<br>B. 可以通过“&amp;”取指针的地址<br>C. 可以通过“*”取指针指向的数据<br>D. 可以对指针进行下标运算</p><p>BC</p><p>19.[primary] 关于main函数（可执行程序的执行起点），下面说法正确的是（）<br>A. main函数不能带参数<br>B. main函数不能定义返回值<br>C. main函数所在的包必须为main包<br>D. main函数中可以使用flag包来获取和解析命令行参数</p><p>ABCD</p><p>20.[intermediate] 下面赋值正确的是（）<br>A. var x = nil<br>B. var x interface{} = nil<br>C. var x string = nil<br>D. var x error = nil</p><p>BD</p><p>21.[intermediate] 关于整型切片的初始化，下面正确的是（）<br>A. s := make([]int)<br>B. s := make([]int, 0)<br>C. s := make([]int, 5, 10)<br>D. s := []int{1, 2, 3, 4, 5}</p><p>BCD</p><p>22.[intermediate] 从切片中删除一个元素，下面的算法实现正确的是（）<br>A.</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *Slice)</span><span class="hljs-title">Remove</span><span class="hljs-params">(value <span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">error</span></span> &#123;        <span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> *s &#123;            <span class="hljs-keyword">if</span> isEqual(value, v) &#123;                <span class="hljs-keyword">if</span> i== <span class="hljs-built_in">len</span>(*s) - <span class="hljs-number">1</span> &#123;                    *s = (*s)[:i]                &#125;<span class="hljs-keyword">else</span> &#123;                    *s = <span class="hljs-built_in">append</span>((*s)[:i],(*s)[i + <span class="hljs-number">2</span>:]...)                &#125;                <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>            &#125;        &#125;        <span class="hljs-keyword">return</span> ERR_ELEM_NT_EXIST&#125;</code></pre><p>B.</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *Slice)</span><span class="hljs-title">Remove</span><span class="hljs-params">(value <span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">error</span></span> &#123;        <span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> *s &#123;            <span class="hljs-keyword">if</span> isEqual(value, v) &#123;                *s = <span class="hljs-built_in">append</span>((*s)[:i],(*s)[i + <span class="hljs-number">1</span>:])                <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>            &#125;        &#125;        <span class="hljs-keyword">return</span> ERR_ELEM_NT_EXIST&#125;</code></pre><p>C.</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *Slice)</span><span class="hljs-title">Remove</span><span class="hljs-params">(value <span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">error</span></span> &#123;        <span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> *s &#123;            <span class="hljs-keyword">if</span> isEqual(value, v) &#123;                <span class="hljs-built_in">delete</span>(*s, v)                <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>            &#125;        &#125;        <span class="hljs-keyword">return</span> ERR_ELEM_NT_EXIST&#125;</code></pre><p>D.</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *Slice)</span><span class="hljs-title">Remove</span><span class="hljs-params">(value <span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">error</span></span> &#123;        <span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> *s &#123;            <span class="hljs-keyword">if</span> isEqual(value, v) &#123;                *s = <span class="hljs-built_in">append</span>((*s)[:i],(*s)[i + <span class="hljs-number">1</span>:]...)                <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>            &#125;        &#125;        <span class="hljs-keyword">return</span> ERR_ELEM_NT_EXIST&#125;</code></pre><p>D</p><p>23.[primary] 关于变量的自增和自减操作，下面语句正确的是（）<br>A.<br>i := 1<br>i++<br>B.</p><p>i := 1<br>j = i++      // ‘,’, ‘;’, new line or ‘}’ expected, got ‘++’<br>C.</p><p>i := 1<br>++i<br>D.</p><p>i := 1<br>i–</p><p>BD</p><p>24.[intermediate] 关于函数声明，下面语法错误的是（）<br>A. func f(a, b int) (value int, err error)<br>B. func f(a int, b int) (value int, err error)<br>C. func f(a, b int) (value int, error)<br>D. func f(a int, b int) (int, int, error)</p><p>C</p><p>25.[intermediate] 如果Add函数的调用代码为：</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;        <span class="hljs-keyword">var</span> a Integer = <span class="hljs-number">1</span>        <span class="hljs-keyword">var</span> b Integer = <span class="hljs-number">2</span>        <span class="hljs-keyword">var</span> i <span class="hljs-keyword">interface</span>&#123;&#125; = &amp;a        sum := i.(*Integer).Add(b)        fmt.Println(sum)&#125;</code></pre><p>则Add函数定义正确的是（）<br>A.</p><pre><code class="hljs go"><span class="hljs-keyword">type</span> Integer <span class="hljs-keyword">int</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a Integer)</span> <span class="hljs-title">Add</span><span class="hljs-params">(b Integer)</span> <span class="hljs-title">Integer</span></span> &#123;        <span class="hljs-keyword">return</span> a + b&#125;</code></pre><p>B.</p><pre><code class="hljs go"><span class="hljs-keyword">type</span> Integer <span class="hljs-keyword">int</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a Integer)</span> <span class="hljs-title">Add</span><span class="hljs-params">(b *Integer)</span> <span class="hljs-title">Integer</span></span> &#123;        <span class="hljs-keyword">return</span> a + *b&#125;</code></pre><p>C.</p><pre><code class="hljs go"><span class="hljs-keyword">type</span> Integer <span class="hljs-keyword">int</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a *Integer)</span> <span class="hljs-title">Add</span><span class="hljs-params">(b Integer)</span> <span class="hljs-title">Integer</span></span> &#123;        <span class="hljs-keyword">return</span> *a + b&#125;</code></pre><p>D.</p><pre><code class="hljs go"><span class="hljs-keyword">type</span> Integer <span class="hljs-keyword">int</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a *Integer)</span> <span class="hljs-title">Add</span><span class="hljs-params">(b *Integer)</span> <span class="hljs-title">Integer</span></span> &#123;        <span class="hljs-keyword">return</span> *a + *b&#125;</code></pre><p>AC<br>26.[intermediate] 如果Add函数的调用代码为：</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;        <span class="hljs-keyword">var</span> a Integer = <span class="hljs-number">1</span>        <span class="hljs-keyword">var</span> b Integer = <span class="hljs-number">2</span>        <span class="hljs-keyword">var</span> i <span class="hljs-keyword">interface</span>&#123;&#125; = a        sum := i.(Integer).Add(b)        fmt.Println(sum)&#125;</code></pre><p>则Add函数定义正确的是（）<br>A.</p><pre><code class="hljs go"><span class="hljs-keyword">type</span> Integer <span class="hljs-keyword">int</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a Integer)</span> <span class="hljs-title">Add</span><span class="hljs-params">(b Integer)</span> <span class="hljs-title">Integer</span></span> &#123;        <span class="hljs-keyword">return</span> a + b&#125;</code></pre><p>B.</p><pre><code class="hljs go"><span class="hljs-keyword">type</span> Integer <span class="hljs-keyword">int</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a Integer)</span> <span class="hljs-title">Add</span><span class="hljs-params">(b *Integer)</span> <span class="hljs-title">Integer</span></span> &#123;        <span class="hljs-keyword">return</span> a + *b&#125;</code></pre><p>C.</p><pre><code class="hljs go"><span class="hljs-keyword">type</span> Integer <span class="hljs-keyword">int</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a *Integer)</span> <span class="hljs-title">Add</span><span class="hljs-params">(b Integer)</span> <span class="hljs-title">Integer</span></span> &#123;        <span class="hljs-keyword">return</span> *a + b&#125;</code></pre><p>D.</p><pre><code class="hljs go"><span class="hljs-keyword">type</span> Integer <span class="hljs-keyword">int</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a *Integer)</span> <span class="hljs-title">Add</span><span class="hljs-params">(b *Integer)</span> <span class="hljs-title">Integer</span></span> &#123;        <span class="hljs-keyword">return</span> *a + *b&#125;</code></pre><p>AC</p><p>27.[intermediate] 关于GetPodAction定义，下面赋值正确的是（）</p><pre><code class="hljs go"><span class="hljs-keyword">type</span> Fragment <span class="hljs-keyword">interface</span> &#123;        Exec(transInfo *TransInfo) error&#125;<span class="hljs-keyword">type</span> GetPodAction <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(g GetPodAction)</span> <span class="hljs-title">Exec</span><span class="hljs-params">(transInfo *TransInfo)</span> <span class="hljs-title">error</span></span> &#123;        ...        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>&#125;</code></pre><p>A. var fragment Fragment = new(GetPodAction)<br>B. var fragment Fragment = GetPodAction<br>C. var fragment Fragment = &amp;GetPodAction{}<br>D. var fragment Fragment = GetPodAction{}</p><p>ACD</p><p>28.[intermediate] 关于GoMock，下面说法正确的是（）<br>A. GoMock可以对interface打桩<br>B. GoMock可以对类的成员函数打桩<br>C. GoMock可以对函数打桩<br>D. GoMock打桩后的依赖注入可以通过GoStub完成</p><p>[AD]</p><p>29.[intermediate] 关于接口，下面说法正确的是（）<br>A. 只要两个接口拥有相同的方法列表（次序不同不要紧），那么它们就是等价的，可以相互赋值<br>B. 如果接口A的方法列表是接口B的方法列表的子集，那么接口B可以赋值给接口A<br>C. 接口查询是否成功，要在运行期才能够确定<br>D. 接口赋值是否可行，要在运行期才能够确定</p><p>[ABC]</p><p>30.[primary] 关于channel，下面语法正确的是（）<br>A. var ch chan int<br>B. ch := make(chan int)<br>C. &lt;- ch<br>D. ch &lt;-<br>ABC</p><p>31.[primary] 关于同步锁，下面说法正确的是（）<br>A. 当一个goroutine获得了Mutex后，其他goroutine就只能乖乖的等待，除非该goroutine释放这个Mutex<br>B. RWMutex在读锁占用的情况下，会阻止写，但不阻止读<br>C. RWMutex在写锁占用情况下，会阻止任何其他goroutine（无论读和写）进来，整个锁相当于由该goroutine独占<br>D. Lock()操作需要保证有Unlock()或RUnlock()调用与之对应</p><p>ABC</p><p>32.[intermediate] golang中大多数数据类型都可以转化为有效的JSON文本，下面几种类型除外（）<br>A. 指针<br>B. channel<br>C. complex<br>D. 函数</p><p>BCD</p><p>33.[intermediate] 关于go vendor，下面说法正确的是（）<br>A. 基本思路是将引用的外部包的源代码放在当前工程的vendor目录下面<br>B. 编译go代码会优先从vendor目录先寻找依赖包<br>C. 可以指定引用某个特定版本的外部包<br>D. 有了vendor目录后，打包当前的工程代码到其他机器的$GOPATH/src下都可以通过编译</p><p>ABD</p><p>34.[primary] flag是bool型变量，下面if表达式符合编码规范的是（）<br>A. if flag == 1<br>B. if flag<br>C. if flag == false<br>D. if !flag</p><p>BD</p><p>35.[primary] value是整型变量，下面if表达式符合编码规范的是（）<br>A. if value == 0<br>B. if value<br>C. if value != 0<br>D. if !value</p><p>AC</p><p>36.[intermediate] 关于函数返回值的错误设计，下面说法正确的是（）<br>A. 如果失败原因只有一个，则返回bool<br>B. 如果失败原因超过一个，则返回error<br>C. 如果没有失败原因，则不返回bool或error<br>D. 如果重试几次可以避免失败，则不要立即返回bool或error</p><p>37.[intermediate] 关于异常设计，下面说法正确的是（）<br>A. 在程序开发阶段，坚持速错，让程序异常崩溃<br>B. 在程序部署后，应恢复异常避免程序终止<br>C. 一切皆错误，不用进行异常设计<br>D. 对于不应该出现的分支，使用异常处理</p><p>[intermediate] 关于slice或map操作，下面正确的是（）<br>A.</p><p>var s []int<br>s = append(s,1)<br>1<br>2<br>B.</p><p>var m map[string]int<br>m[“one”] = 1<br>1<br>2<br>C.</p><p>var s []int<br>s = make([]int, 0)<br>s = append(s,1)<br>1<br>2<br>3<br>D.</p><p>var m map[string]int<br>m = make(map[string]int)<br>m[“one”] = 1<br>1<br>2<br>3<br>[intermediate] 关于channel的特性，下面说法正确的是（）<br>A. 给一个 nil channel 发送数据，造成永远阻塞<br>B. 从一个 nil channel 接收数据，造成永远阻塞<br>C. 给一个已经关闭的 channel 发送数据，引起 panic<br>D. 从一个已经关闭的 channel 接收数据，如果缓冲区中为空，则返回一个零值</p><p>[intermediate] 关于无缓冲和有冲突的channel，下面说法正确的是（）<br>A. 无缓冲的channel是默认的缓冲为1的channel<br>B. 无缓冲的channel和有缓冲的channel都是同步的<br>C. 无缓冲的channel和有缓冲的channel都是非同步的<br>D. 无缓冲的channel是同步的，而有缓冲的channel是非同步的</p><p>答案下载链接 ：<a href="https://wws.lanzous.com/ifgqgmunf8d">https://wws.lanzous.com/ifgqgmunf8d</a></p><p>[intermediate] 关于异常的触发，下面说法正确的是（）<br>A. 空指针解析<br>B. 下标越界<br>C. 除数为0<br>D. 调用panic函数</p><p>[intermediate] 关于cap函数的适用类型，下面说法正确的是（）<br>A. array<br>B. slice<br>C. map<br>D. channel</p><p>[intermediate] 关于beego框架，下面说法正确的是（）<br>A. beego是一个golang实现的轻量级HTTP框架<br>B. beego可以通过注释路由、正则路由等多种方式完成url路由注入<br>C. 可以使用bee new工具生成空工程，然后使用bee run命令自动热编译<br>D. beego框架只提供了对url路由的处理， 而对于MVC架构中的数据库部分未提供框架支持</p><p>[intermediate] 关于goconvey，下面说法正确的是（）<br>A. goconvey是一个支持golang的单元测试框架<br>B. goconvey能够自动监控文件修改并启动测试，并可以将测试结果实时输出到web界面<br>C. goconvey提供了丰富的断言简化测试用例的编写<br>D. goconvey无法与go test集成</p><p>[intermediate] 关于go vet，下面说法正确的是（）<br>A. go vet是golang自带工具go tool vet的封装<br>B. 当执行go vet database时，可以对database所在目录下的所有子文件夹进行递归检测<br>C. go vet可以使用绝对路径、相对路径或相对GOPATH的路径指定待检测的包<br>D. go vet可以检测出死代码</p><p>[intermediate] 关于map，下面说法正确的是（）<br>A. map反序列化时json.unmarshal的入参必须为map的地址<br>B. 在函数调用中传递map，则子函数中对map元素的增加不会导致父函数中map的修改<br>C. 在函数调用中传递map，则子函数中对map元素的修改不会导致父函数中map的修改<br>D. 不能使用内置函数delete删除map的元素</p><p>[intermediate] 关于GoStub，下面说法正确的是（）<br>A. GoStub可以对全局变量打桩<br>B. GoStub可以对函数打桩<br>C. GoStub可以对类的成员方法打桩<br>D. GoStub可以打动态桩，比如对一个函数打桩后，多次调用该函数会有不同的行为</p><p>[primary] 关于select机制，下面说法正确的是（）<br>A. select机制用来处理异步IO问题<br>B. select机制最大的一条限制就是每个case语句里必须是一个IO操作<br>C. golang在语言级别支持select关键字<br>D. select关键字的用法与switch语句非常类似，后面要带判断条件</p><p>[primary] 关于内存泄露，下面说法正确的是（）<br>A. golang有自动垃圾回收，不存在内存泄露<br>B. golang中检测内存泄露主要依靠的是pprof包<br>C. 内存泄露可以在编译阶段发现<br>D. 应定期使用浏览器来查看系统的实时内存信息，及时发现内存泄露问题</p><p>[primary] 对于局部变量整型切片x的赋值，下面定义正确的是（）<br>A.</p><p>x := []int{<br>        1, 2, 3,<br>        4, 5, 6,<br>}<br>1<br>2<br>3<br>4<br>B.</p><p>x := []int{<br>        1, 2, 3,<br>        4, 5, 6<br>}<br>1<br>2<br>3<br>4<br>C.</p><p>x := []int{<br>        1, 2, 3,<br>        4, 5, 6}<br>1<br>2<br>3<br>D.</p><p>x := []int{1, 2, 3, 4, 5, 6,}</p><p>[primary] 声明一个整型变量i ?</p><p>[primary] 声明一个含有10个元素的整型数组a ?</p><p>[primary] 声明一个整型数组切片s?</p><p>[primary] 声明一个整型指针变量p?</p><p>[primary] 声明一个key为字符串型value为整型的map变量m?</p><p>[primary] 声明一个入参和返回值均为整型的函数变量 f?</p><p>[primary] 声明一个只用于读取int数据的单向channel变量ch?</p><p>[primary] 假设源文件的命名为slice.go，则测试文件的命名为?</p><p>[primary] go test要求测试函数的前缀必须命名为?</p><p>[intermediate] 下面的程序的运行结果是?</p><p>for i := 0; i &lt; 5; i++ {<br>        defer fmt.Printf(“%d “, i)<br>}<br>1<br>2<br>3<br>[intermediate] 下面的程序的运行结果是?<br>func main() {<br>        x := 1<br>        {<br>            x := 2<br>            fmt.Print(x)<br>        }<br>        fmt.Println(x)<br>}<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>[intermediate] 下面的程序的运行结果是?<br>func main() {<br>        strs := []string{“one”, “two”, “three”}</p><pre><code>    for _, s := range strs &#123;        go func() &#123;            time.Sleep(1 * time.Second)            fmt.Printf(&quot;%s &quot;, s)        &#125;()    &#125;    time.Sleep(3 * time.Second)</code></pre><p>}<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>[intermediate] 下面的程序的运行结果是?<br>func main() {<br>        x := []string{“a”, “b”, “c”}<br>        for v := range x {<br>            fmt.Print(v)<br>        }<br>}<br>1<br>2<br>3<br>4<br>5<br>6<br>[intermediate] 下面的程序的运行结果是？<br>func main() {<br>        x := []string{“a”, “b”, “c”}<br>        for _, v := range x {<br>            fmt.Print(v)<br>        }<br>}<br>1<br>2<br>3<br>4<br>5<br>6<br>[primary] 下面的程序的运行结果是？<br>func main() {<br>       i := 1<br>       j := 2<br>       i, j = j, i<br>       fmt.Printf(“%d%d\n”, i, j)<br>}<br>1<br>2<br>3<br>4<br>5<br>6<br>[primary] 下面的程序的运行结果是？<br>func incr(p *int) int {<br>        *p++<br>        return *p<br>}<br>func main() {<br>        v := 1<br>        incr(&amp;v)<br>        fmt.Println(v)<br>}<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>[primary] 启动一个goroutine的关键字是？</p><p>[intermediate] 下面的程序的运行结果是？</p><p>type Slice []int<br>func NewSlice() Slice {<br>         return make(Slice, 0)<br>}<br>func (s* Slice) Add(elem int) *Slice {<br>         *s = append(*s, elem)<br>         fmt.Print(elem)<br>         return s<br>}<br>func main() {<br>         s := NewSlice()<br>         defer s.Add(1).Add(2)<br>         s.Add(3)<br>}</p><ol start="3"><li>判断题<br>[primary] 数组是一个值类型（）</li></ol><p>[primary] 使用map不需要引入任何库（）</p><p>[intermediate] 内置函数delete可以删除数组切片内的元素（）</p><p>[primary] 指针是基础类型（）</p><p>[primary] interface{}是可以指向任意对象的Any类型（）</p><p>[intermediate] 下面关于文件操作的代码可能触发异常（）</p><p>file, err := os.Open(“test.go”)<br>defer file.Close()<br>if err != nil {<br>        fmt.Println(“open file failed:”, err)<br>        return<br>}<br>…<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>[primary] Golang不支持自动垃圾回收（）</p><p>[primary] Golang支持反射，反射最常见的使用场景是做对象的序列化（）</p><p>[primary] Golang可以复用C/C++的模块，这个功能叫Cgo（）</p><p>[primary] 下面代码中两个斜点之间的代码，比如json:”x”，作用是X字段在从结构体实例编码到JSON数据格式的时候，使用x作为名字，这可以看作是一种重命名的方式（）</p><p>type Position struct {<br>        X int <code>json:&quot;x&quot;</code><br>        Y int <code>json:&quot;y&quot;</code><br>        Z int <code>json:&quot;z&quot;</code><br>}<br>1<br>2<br>3<br>4<br>5<br>[primary] 通过成员变量或函数首字母的大小写来决定其作用域（）</p><p>[primary] 对于常量定义zero(const zero = 0.0)，zero是浮点型常量（）</p><p>[primary] 对变量x的取反操作是~x（）</p><p>[primary] 下面的程序的运行结果是xello（）</p><p>func main() {<br>        str := “hello”<br>        str[0] = ‘x’<br>        fmt.Println(str)<br>}<br>1<br>2<br>3<br>4<br>5<br>[primary] golang支持goto语句（）</p><p>[primary] 下面代码中的指针p为野指针，因为返回的栈内存在函数结束时会被释放（）</p><p>type TimesMatcher struct {<br>        base int<br>}<br>func NewTimesMatcher(base int) *TimesMatcher{<br>        return &amp;TimesMatcher{base:base}<br>}<br>func main() {<br>        p := NewTimesMatcher(3)<br>        …<br>}<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>[primary] 匿名函数可以直接赋值给一个变量或者直接执行（）</p><p>[primary] 如果调用方调用了一个具有多返回值的方法，但是却不想关心其中的某个返回值，可以简单地用一个下划线“_”来跳过这个返回值，该下划线对应的变量叫匿名变量（）</p><p>[primary] 在函数的多返回值中，如果有error或bool类型，则一般放在最后一个（）</p><p>[primary] 错误是业务过程的一部分，而异常不是（）</p><p>[primary] 函数执行时，如果由于panic导致了异常，则延迟函数不会执行（）</p><p>[intermediate] 当程序运行时，如果遇到引用空指针、下标越界或显式调用panic函数等情况，则先触发panic函数的执行，然后调用延迟函数。调用者继续传递panic，因此该过程一直在调用栈中重复发生：函数停止执行，调用延迟执行函数。如果一路在延迟函数中没有recover函数的调用，则会到达该携程的起点，该携程结束，然后终止其他所有携程，其他携程的终止过程也是重复发生：函数停止执行，调用延迟执行函数（）</p><p>[primary] 同级文件的包名不允许有多个（）</p><p>[intermediate] 可以给任意类型添加相应的方法（）</p><p>[primary] golang虽然没有显式的提供继承语法，但是通过匿名组合实现了继承（）</p><p>[primary] 使用for range迭代map时每次迭代的顺序可能不一样，因为map的迭代是随机的（）</p><p>[primary] switch后面可以不跟表达式（）</p><p>[intermediate] 结构体在序列化时非导出变量（以小写字母开头的变量名）不会被encode，因此在decode时这些非导出变量的值为其类型的零值（）</p><p>[primary] golang中没有构造函数的概念，对象的创建通常交由一个全局的创建函数来完成，以NewXXX来命名（）</p><p>[intermediate] 当函数deferDemo返回失败时，并不能destroy已create成功的资源（）</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">deferDemo</span><span class="hljs-params">()</span> <span class="hljs-title">error</span></span> &#123;        err := createResource1()        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;            <span class="hljs-keyword">return</span> ERR_CREATE_RESOURCE1_FAILED        &#125;        <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;            <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;                destroyResource1()            &#125;        &#125;()    err = createResource2()    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;        <span class="hljs-keyword">return</span> ERR_CREATE_RESOURCE2_FAILED    &#125;    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;            destroyResource2()        &#125;    &#125;()    err = createResource3()    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;        <span class="hljs-keyword">return</span> ERR_CREATE_RESOURCE3_FAILED    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>&#125;</code></pre><p>[intermediate] channel本身必然是同时支持读写的，所以不存在单向channel（）</p><p>[primary] import后面的最后一个元素是包名（）</p>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>ADT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【ML】机器学习概述与简单应用</title>
    <link href="/2021/01/11/ml/"/>
    <url>/2021/01/11/ml/</url>
    
    <content type="html"><![CDATA[<h3 id="什么是机器学习"><a href="#什么是机器学习" class="headerlink" title="什么是机器学习"></a><a id="more"></a>什么是机器学习</h3><h4 id="直观视角下的机器学习"><a href="#直观视角下的机器学习" class="headerlink" title="直观视角下的机器学习"></a>直观视角下的机器学习</h4><p>大众视角：</p><p><img src="/images/ml/1.jpg" alt="1"></p><p>程序员视角：</p><p><img src="/images/ml/2.jpg" alt="2"></p><p><img src="/images/ml/2.png" alt="2"></p><p>目前机器学习已经应用到了生活的各个方面。</p><p>百度搜索：其背后有这复杂的机器学习系统在努力地进行这个跟我们目标关键词相关的检索、排序工作；</p><p>美图、美拍这样的照相软件：使用了机器学习来识别面部并进行一定程度的美化；</p><p>垃圾箱里躺着的垃圾邮件：它们都不是我们主动拖拽移动进去的，而是机器学习帮我们自动地识别了垃圾邮件；</p><p>京东、天猫购物时，推荐的一些我们感兴趣的商品：促成我们更加便捷地购买，机器学习的推荐算法在其中发挥作用；</p><p>还有，新闻的推荐系统、语音识别、自然语言处理、无人驾驶、机器翻译等众多领域都有机器学习的影子。</p><p>维基百科：<a href="https://zh.wikipedia.org/wiki/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0">https://zh.wikipedia.org/wiki/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0</a></p><p>百度百科：<a href="https://baike.baidu.com/item/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/217599">https://baike.baidu.com/item/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/217599</a></p><p>机器学习实际上是一门”教会”计算机学习而不需要明确地进行编程的科学。比如，扫地机器人，它应该怎样帮助我们清扫我们的房子呢？一种办法是让它学习我们如何清扫，让它看看我们都捡起了什么东西，然后把它们又放到什么地方，而不需要编写固定的程序让它们识别垃圾，并将它们移动到固定的垃圾桶。</p><p>机器学习——实际上在很多问题上都是一种通用解决方案。</p><p>它只需要通过大量的实例就可以以很高的精度逼近准确的解决方案。它带来的好处是不需要严格地去分析具体问题并构造精确解，它以一种通用的解决方案框架来对问题进行抽象建模，并通过大量的实例来纠正模型中的参数，并最终以该模型来逼近精确解，最终达到应用标准。</p><p><img src="/images/ml/1-2.jpg" alt="1-2"></p><h4 id="人工智能、机器学习与深度学习"><a href="#人工智能、机器学习与深度学习" class="headerlink" title="人工智能、机器学习与深度学习"></a>人工智能、机器学习与深度学习</h4><p><img src="/images/ml/2-1.jpg" alt="2-1"></p><p><img src="/images/ml/2-2.jpg" alt="2-2"></p><p><img src="/images/ml/2-3.jpg" alt="2-3"></p><p><img src="/images/ml/2-4.jpg" alt="2-4"></p><p><img src="/images/ml/2-5.jpg" alt="2-5"></p><h4 id="机器学习分类"><a href="#机器学习分类" class="headerlink" title="机器学习分类"></a>机器学习分类</h4><p>机器学习根据训练方法大致可以分为3大类：</p><ol><li>监督学习</li><li>非监督学习</li><li>强化学习</li></ol><p>除此之外，大家可能还听过“半监督学习”之类的说法，但是那些都是基于上面3类的变种，本质没有改变。</p><h5 id="监督学习"><a href="#监督学习" class="headerlink" title="监督学习"></a>监督学习</h5><p>监督学习是指我们给算法一个数据集，并且给定正确答案。机器通过数据来学习正确答案的计算方法。</p><p><img src="/images/ml/1-31.png" alt="1-31"></p><p><img src="/images/ml/1-312.png" alt="1-312"></p><p>监督式学习采用分类和回归技术开发预测模型。</p><p>   <strong>分类技术</strong>可预测离散的响应 — 例如，电子邮件是不是垃圾邮件，肿瘤是恶性还是良性的。分类模型可将输入数据划分成不同类别。典型的应用包括医学成像、语音识别和信用评估。</p><p>如果您的数据能进行标记、分类或分为特定的组或类，则使用分类。例如，笔迹识别的应用程序使用分类来识别字母和数字。在图像处理和计算机视觉中，<a href="https://ww2.mathworks.cn/discovery/pattern-recognition.html">无监督模式识别</a>技术用于对象检测和图像分割。</p><p>  <strong>回归技术</strong>可预测连续的响应 — 例如，温度的变化或电力需求中的波动。典型的应用包括电力系统负荷预测和算法交易。</p><p>如果您在处理一个数据范围，或您的响应性质是一个实数（比如温度，或一件设备发生故障前的运行时间），则使用回归方法。</p><h5 id="非监督学习"><a href="#非监督学习" class="headerlink" title="非监督学习"></a>非监督学习</h5><p>非监督学习中，给定的数据集没有“正确答案”，所有的数据都是一样的。无监督学习的任务是从给定的数据集中，挖掘出潜在的结构。</p><p><img src="/images/ml/1-32.png" alt="1-32"></p><p><img src="/images/ml/1-322.png" alt="1-322"></p><p>  <strong>聚类</strong>是一种最常用的无监督学习技术。这种技术可通过探索性数据分析发现数据中隐藏的模式或分组。<a href="https://ww2.mathworks.cn/discovery/cluster-analysis.html">聚类分析</a>的应用包括基因序列分析、市场调查和对象识别。</p><p>  <strong>降维</strong>就是指采用某种映射方法，将原高维空间中的数据点映射到低维度的空间中。降维的本质是学习一个映射函数 f : x-&gt;y，其中x是原始数据点的表达，目前最多使用向量表达形式。</p><p>目前大部分降维算法处理向量表达的数据，也有一些降维算法处理高阶张量表达的数据。之所以使用降维后的数据表示是因为在原始的高维空间中，包含有冗余信息以及噪音信息，在实际应用例如图像识别中造成了误差，降低了准确率；而通过降维,我们希望减少 <a href="http://www.hudong.com/wiki/%E5%86%97%E4%BD%99%E4%BF%A1%E6%81%AF">冗余信息</a> 所造成的误差,提高识别（或其他应用）的精度。又或者希望通过降维算法来寻找数据内部的本质结构特征。</p><h5 id="强化学习"><a href="#强化学习" class="headerlink" title="强化学习"></a>强化学习</h5><p>强化学习更接近生物学习的本质，因此有望获得更高的智能。它关注的是智能体如何在环境中采取一系列行为，从而获得最大的累积回报。通过强化学习，一个智能体应该知道在什么状态下应该采取什么行为。</p><p><img src="/images/ml/1-33.jpg" alt="1-33"></p><h3 id="怎样由数据和答案得到规则？"><a href="#怎样由数据和答案得到规则？" class="headerlink" title="怎样由数据和答案得到规则？"></a>怎样由数据和答案得到规则？</h3><h4 id="数据收集"><a href="#数据收集" class="headerlink" title="数据收集"></a>数据收集</h4><h5 id="公司历史数据积累"><a href="#公司历史数据积累" class="headerlink" title="公司历史数据积累"></a>公司历史数据积累</h5><h5 id="常见公开数据集"><a href="#常见公开数据集" class="headerlink" title="常见公开数据集"></a>常见公开数据集</h5><p><a href="https://www.infoq.cn/article/zCGdpvyxJJl7*ja4RQAZ">https://www.infoq.cn/article/zCGdpvyxJJl7*ja4RQAZ</a></p><p><a href="https://zhuanlan.zhihu.com/p/34497496">https://zhuanlan.zhihu.com/p/34497496</a></p><h5 id="网络爬虫"><a href="#网络爬虫" class="headerlink" title="网络爬虫"></a>网络爬虫</h5><h4 id="特征表达（去噪、特征提取与选择）"><a href="#特征表达（去噪、特征提取与选择）" class="headerlink" title="特征表达（去噪、特征提取与选择）"></a>特征表达（去噪、特征提取与选择）</h4><p>其实，说白了，就是我们人眼可见的特征转化为数字特征（可以用数学公式）的过程，并且这一过程是机器学习最重要的环节。</p><p>  <strong>去噪</strong>：去除影响机器学习结果的原始数据。</p><p>  <strong>分类变量特征提取</strong>：房价预测中房子的面积、朝向、位置、装修、楼层等等，它是标记的变量，不是连续的。</p><p>  <strong>文字特征提取</strong>：很多机器学习问题涉及自然语言处理（NLP），必然要处理文字信息。文字必须转换成可以量化的特征向量。例如咱们公司的研发部算法组做的垃圾广告屏蔽器。</p><p>  <strong>图片特征提取</strong>：做图像识别时，我们人眼看到的时图片，但是在机器中则是一个数字表示的二维矩阵。</p><p>  <strong>数据标准化</strong>：主要用于对提取后的数字特征进行处理，因为提取好的数字特征可能会差距比较大，那么训练模型时，得到的特征权重会比较大或者比较小，同时也影响计算速度。</p><h4 id="模型选择"><a href="#模型选择" class="headerlink" title="模型选择"></a>模型选择</h4><p>选择正确的算法看似难以驾驭——需要从几十种监督式和非监督机器学习算法中选择，每种算法又包含不同的学习方法。</p><p>没有最佳方法或万全之策。找到正确的算法只是试错过程的一部分——即使是经验丰富的数据科学家，也无法说出某种算法是否无需试错即可使用。但算法的选择还取决于您要处理的数据的大小和类型、您要从数据中获得的洞察力以及如何运用这些洞察力。</p><p><img src="/images/ml/3-31.png" alt="3-31"></p><h4 id="模型训练"><a href="#模型训练" class="headerlink" title="模型训练"></a>模型训练</h4><p>房价预测为例</p><p><img src="/images/ml/3-4-1.png" alt="3-4-1"></p><p>算法模型以简单多变量线性回归为例</p><table><thead><tr><th>面积(㎡)</th><th>卧室数</th><th>卫生间数</th><th>房龄</th><th>售价(百万元)</th></tr></thead><tbody><tr><td>62.47</td><td>2</td><td>1</td><td>12</td><td>213</td></tr><tr><td>58.05</td><td>1</td><td>1</td><td>20</td><td>180</td></tr><tr><td>55.87</td><td>1</td><td>1</td><td>16</td><td>152</td></tr><tr><td>68.04</td><td>2</td><td>2</td><td>18</td><td>198</td></tr></tbody></table><p><img src="/images/ml/3-4-2.jpg" alt="3-4-2"></p><p>那么，这里的假设函数</p><p><img src="/images/ml/3-4-3.jpg" alt="3-4-3"></p><p>假设值与真实值之间的差就是这个模型的误差（代价）</p><p><img src="/images/ml/3-4-4.jpg" alt="3-4-4"></p><p>当代价函数的值趋近于0时，模型就比较完美了</p><h4 id="参数调整"><a href="#参数调整" class="headerlink" title="参数调整"></a>参数调整</h4><p>那怎样能是代价函数最小化？</p><p>梯度下降</p><p>共轭梯度</p><p>拟牛顿迭代法（BFGS）</p><p>L-BFGS</p><p>……</p><p>这里，我们已梯度下降法为例：</p><p><img src="/images/ml/3-4-5.jpg" alt="3-4-5"></p><h4 id><a href="#" class="headerlink" title></a><img src="/images/ml/3-4-6.jpg" alt="3-4-6"></h4><h4 id="模型评估"><a href="#模型评估" class="headerlink" title="模型评估"></a>模型评估</h4><p>对于分类问题：</p><p>正确率、召回率、F1值等等</p><p><img src="/images/ml/3-4-8.jpg" alt="3-4-8"></p><p><img src="/images/ml/3-4-7.jpg" alt="3-4-7"></p><p>对于回归问题：</p><p><img src="/images/ml/3-4-9.jpg" alt="3-6-3"></p><p><img src="/images/ml/3-4-10.jpg" alt="3-6-4"></p><p>与过拟合对应的，就有欠拟合</p><h4 id="实际预测"><a href="#实际预测" class="headerlink" title="实际预测"></a>实际预测</h4><p>直接将样本参数带入h假设函数，便可以得到预测值</p><h3 id="简单线性回归实现"><a href="#简单线性回归实现" class="headerlink" title="简单线性回归实现"></a>简单线性回归实现</h3><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<span class="hljs-keyword">import</span> matplotlibmatplotlib.rcParams[<span class="hljs-string">&#x27;font.sans-serif&#x27;</span>] = [<span class="hljs-string">&#x27;SimHei&#x27;</span>]matplotlib.rcParams[<span class="hljs-string">&#x27;font.family&#x27;</span>] = <span class="hljs-string">&#x27;sans-serif&#x27;</span>matplotlib.rcParams[<span class="hljs-string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="hljs-literal">False</span><span class="hljs-keyword">from</span> mpl_toolkits.mplot3d <span class="hljs-keyword">import</span> axes3d<span class="hljs-keyword">from</span> matplotlib <span class="hljs-keyword">import</span> cmimport matplotlib.ticker <span class="hljs-keyword">as</span> mtick<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">loadDataSet</span>(<span class="hljs-params">filename</span>):</span>    X = []    Y = []    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(filename, <span class="hljs-string">&#x27;rb&#x27;</span>) <span class="hljs-keyword">as</span> f:        <span class="hljs-keyword">for</span> idx, line <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(f):            line = line.decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>).strip()            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> line:                <span class="hljs-keyword">continue</span>            eles = line.split()            <span class="hljs-keyword">if</span> idx == <span class="hljs-number">0</span>:                numFea = <span class="hljs-built_in">len</span>(eles)            eles = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">float</span>, eles))            X.append(eles[:<span class="hljs-number">-1</span>])            Y.append([eles[<span class="hljs-number">-1</span>]])    <span class="hljs-keyword">return</span> np.array(X), np.array(Y)<span class="hljs-comment"># 假设函数</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">h</span>(<span class="hljs-params">theta, X</span>):</span>    <span class="hljs-keyword">return</span> np.dot(X, theta)<span class="hljs-comment"># 代价函数</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">J</span>(<span class="hljs-params">theta, X, Y</span>):</span>    m = <span class="hljs-built_in">len</span>(X)    <span class="hljs-keyword">return</span> np.<span class="hljs-built_in">sum</span>(np.dot((h(theta, X) - Y).T, (h(theta, X) - Y)) / (<span class="hljs-number">2</span> * m))<span class="hljs-comment"># 梯度下降更新公式</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bgd</span>(<span class="hljs-params">alpha, maxloop, epsilon, X, Y</span>):</span>    m, n = X.shape  <span class="hljs-comment"># m是样本数，n是特征数(包括了全部是1的x0)，其实也就是参数theta的个数</span>    theta = np.zeros((n, <span class="hljs-number">1</span>))  <span class="hljs-comment"># 参数theta全部初始化为0</span>    count = <span class="hljs-number">0</span>  <span class="hljs-comment"># 记录迭代轮次</span>    converged = <span class="hljs-literal">False</span>  <span class="hljs-comment"># 是否已经收敛的标志</span>    error = np.inf  <span class="hljs-comment"># 当前的代价函数值</span>    errors = [J(theta, X, Y), ]  <span class="hljs-comment"># 记录每一次迭代得代价函数值</span>    thetas = &#123;&#125;    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):        thetas[i] = [theta[i, <span class="hljs-number">0</span>], ]  <span class="hljs-comment"># 记录每一个theta j的历史更新</span>    <span class="hljs-keyword">while</span> count &lt;= maxloop:        <span class="hljs-keyword">if</span> (converged):            <span class="hljs-keyword">break</span>        count = count + <span class="hljs-number">1</span>        <span class="hljs-comment"># 这里，我们的梯度计算统一了</span>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):            deriv = np.dot(X[:, j].T, (h(theta, X) - Y)).<span class="hljs-built_in">sum</span>() / m            thetas[j].append(theta[j, <span class="hljs-number">0</span>] - alpha * deriv)        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):            theta[j, <span class="hljs-number">0</span>] = thetas[j][<span class="hljs-number">-1</span>]        error = J(theta, X, Y)        errors.append(error)        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(errors[<span class="hljs-number">-1</span>] - errors[<span class="hljs-number">-2</span>]) &lt; epsilon):            converged = <span class="hljs-literal">True</span>    <span class="hljs-keyword">return</span> theta, errors, thetas<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">standarize</span>(<span class="hljs-params">X</span>):</span>    <span class="hljs-string">&quot;&quot;&quot;特征标准化处理</span><span class="hljs-string"></span><span class="hljs-string">    Args:</span><span class="hljs-string">        X 样本集</span><span class="hljs-string">    Returns:</span><span class="hljs-string">        标准后的样本集</span><span class="hljs-string">    &quot;&quot;&quot;</span>    m, n = X.shape    <span class="hljs-comment"># 归一化每一个特征</span>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):        features = X[:, j]        meanVal = features.mean(axis=<span class="hljs-number">0</span>)        std = features.std(axis=<span class="hljs-number">0</span>)        <span class="hljs-keyword">if</span> std != <span class="hljs-number">0</span>:            X[:, j] = (features - meanVal) / std        <span class="hljs-keyword">else</span>:            X[:, j] = <span class="hljs-number">0</span>    <span class="hljs-keyword">return</span> X<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:    data_set = os.path.dirname(os.path.abspath(__file__))+<span class="hljs-string">&#x27;/houses.txt&#x27;</span>    ori_X, Y = loadDataSet(data_set)  <span class="hljs-comment"># 从南京链家抓取的夫子庙附近的房屋数据</span>    print(ori_X.shape)    print(Y.shape)    m, n = ori_X.shape    X = standarize(ori_X.copy())    X = np.concatenate((np.ones((m, <span class="hljs-number">1</span>)), X), axis=<span class="hljs-number">1</span>)    alpha = <span class="hljs-number">1</span>  <span class="hljs-comment"># 学习率</span>    maxloop = <span class="hljs-number">5000</span>  <span class="hljs-comment"># 最大迭代次数</span>    epsilon = <span class="hljs-number">0.000001</span>  <span class="hljs-comment"># 收敛判断条件</span>    result = bgd(alpha, maxloop, epsilon, X, Y)    theta, errors, thetas = result    <span class="hljs-comment"># 预测</span>    normalizedSize = (<span class="hljs-number">70</span> - ori_X[:, <span class="hljs-number">0</span>].mean(<span class="hljs-number">0</span>)) / ori_X[:, <span class="hljs-number">0</span>].std(<span class="hljs-number">0</span>)    normalizedBr = (<span class="hljs-number">2</span> - ori_X[:, <span class="hljs-number">1</span>].mean(<span class="hljs-number">0</span>)) / ori_X[:, <span class="hljs-number">1</span>].std(<span class="hljs-number">0</span>)    predicateX = np.matrix([[<span class="hljs-number">1</span>, normalizedSize, normalizedBr]])    price = h(theta, predicateX)    print(<span class="hljs-string">&#x27;70㎡两居估价: ￥%.4f万元&#x27;</span> % price)    <span class="hljs-comment"># %matplotlib</span>    <span class="hljs-comment"># 打印拟合平面</span>    fittingFig = plt.figure(figsize=(<span class="hljs-number">16</span>, <span class="hljs-number">12</span>))    title = <span class="hljs-string">&#x27;bgd: rate=%.3f, maxloop=%d, epsilon=%.3f \n&#x27;</span> % (alpha, maxloop, epsilon)    ax = fittingFig.gca(projection=<span class="hljs-string">&#x27;3d&#x27;</span>)    xx = np.linspace(<span class="hljs-number">0</span>, <span class="hljs-number">200</span>, <span class="hljs-number">25</span>)    yy = np.linspace(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>, <span class="hljs-number">25</span>)    zz = np.zeros((<span class="hljs-number">25</span>, <span class="hljs-number">25</span>))    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">25</span>):        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">25</span>):            normalizedSize = (xx[i] - ori_X[:, <span class="hljs-number">0</span>].mean(<span class="hljs-number">0</span>)) / ori_X[:, <span class="hljs-number">0</span>].std(<span class="hljs-number">0</span>)            normalizedSize = (xx[i] - ori_X[:, <span class="hljs-number">0</span>].mean(<span class="hljs-number">0</span>)) / ori_X[:, <span class="hljs-number">0</span>].std(<span class="hljs-number">0</span>)            x = np.matrix([[<span class="hljs-number">1</span>, normalizedSize, normalizedBr]])            zz[i, j] = h(theta, x)    xx, yy = np.meshgrid(xx, yy)    ax.zaxis.set_major_formatter(mtick.FormatStrFormatter(<span class="hljs-string">&#x27;%.2e&#x27;</span>))    ax.plot_surface(xx, yy, zz, rstride=<span class="hljs-number">1</span>, cstride=<span class="hljs-number">1</span>, cmap=cm.rainbow, alpha=<span class="hljs-number">0.1</span>, antialiased=<span class="hljs-literal">True</span>)    xs = ori_X[:, <span class="hljs-number">0</span>].flatten()    ys = ori_X[:, <span class="hljs-number">1</span>].flatten()    zs = Y[:, <span class="hljs-number">0</span>].flatten()    ax.scatter(xs, ys, zs, c=<span class="hljs-string">&#x27;b&#x27;</span>, marker=<span class="hljs-string">&#x27;o&#x27;</span>)    ax.set_xlabel(<span class="hljs-string">u&#x27;面积&#x27;</span>)    ax.set_ylabel(<span class="hljs-string">u&#x27;卧室数&#x27;</span>)    ax.set_zlabel(<span class="hljs-string">u&#x27;估价&#x27;</span>)    plt.show()    errorsFig = plt.figure()    ax = errorsFig.add_subplot(<span class="hljs-number">111</span>)    ax.yaxis.set_major_formatter(mtick.FormatStrFormatter(<span class="hljs-string">&#x27;%.2e&#x27;</span>))    ax.plot(<span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(errors)), errors)    ax.set_xlabel(<span class="hljs-string">u&#x27;迭代次数&#x27;</span>)    ax.set_ylabel(<span class="hljs-string">u&#x27;代价函数&#x27;</span>)    plt.show()</code></pre><p><img src="/images/ml/3-6-1.jpg" alt="3-6-1"></p><p><img src="/images/ml/3-6-2.jpg" alt="3-6-2"></p>]]></content>
    
    
    <categories>
      
      <category>ML</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>ML</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Mac】vim环境设置</title>
    <link href="/2021/01/10/vim/"/>
    <url>/2021/01/10/vim/</url>
    
    <content type="html"><![CDATA[<h2 id="开发神器vim工具"><a href="#开发神器vim工具" class="headerlink" title="开发神器vim工具"></a><a id="more"></a>开发神器vim工具</h2><p><img src="/images/vim/vim-keymap.png"></p><h3 id="安装MacVim来替代系统自带vim"><a href="#安装MacVim来替代系统自带vim" class="headerlink" title="安装MacVim来替代系统自带vim"></a>安装MacVim来替代系统自带vim</h3><p>一般情况下，Mac 自带的Vim不能满足大多的需求，所以选择安装MacVim</p><p>通过一下命令可以查看预装vim的信息</p><pre><code class="hljs zsh"><span class="hljs-comment"># 查看预装vim版本</span>vim --version<span class="hljs-comment"># 查看预装vim路径</span><span class="hljs-built_in">where</span> vim</code></pre><h4 id="MacVim安装"><a href="#MacVim安装" class="headerlink" title="MacVim安装"></a>MacVim安装</h4><p>有两种方式来安装macvim:</p><ol><li>Github上下载<a href="https://macvim-dev.github.io/macvim"><code>macvim.dmg</code></a>安装包进行安装</li><li>使用<a href="https://brew.sh/">Homebrew</a>安装【推荐】</li></ol><p>brew安装macvim</p><pre><code class="hljs zsh">brew install macvim</code></pre><p>为macvim中的vim创建别名，覆盖掉系统自带的vim，在~/.bash_profile中添加以下命令</p><pre><code class="hljs zsh"><span class="hljs-built_in">alias</span> vi=vim<span class="hljs-built_in">alias</span> vim=mvim<span class="hljs-built_in">alias</span> mvim=<span class="hljs-string">&#x27;/usr/local/bin/mvim -v&#x27;</span><span class="hljs-comment"># 刷新配置文件</span><span class="hljs-built_in">source</span> ~/.bash_profile</code></pre><h4 id="MacVim配置"><a href="#MacVim配置" class="headerlink" title="MacVim配置"></a>MacVim配置</h4><p>在vim启动过程中，首先将查找配置文件并执行其中的命令，而这些初始化文件一般有vimrc、gvimrc和exrc三种。通过<code>:version</code>命令可以查看vim的配置文件信息。</p><p>vim的配置文件有全局和用户两种版本，分别存放于<code>$VIM</code>和<code>$HOME</code>目录中，用户配置文件默认是没有的，必要时由用户自己在<code>$HOME</code>目录下创建。可以使用<code>:echo</code>命令查看他们的路径，使用<code>:e</code>命令进入目录。</p><pre><code class="hljs zsh">:<span class="hljs-built_in">echo</span> <span class="hljs-variable">$VIM</span>/usr/<span class="hljs-built_in">local</span>/Cellar/macvim/8.2-166_1/MacVim.app/Contents/Resources/vim:<span class="hljs-built_in">echo</span> <span class="hljs-variable">$HOME</span>/Users/wangpeng<span class="hljs-comment"># 可以通过:scriptname查看各脚本的加载顺序</span>:scriptname/usr/<span class="hljs-built_in">local</span>/Cellar/macvim/8.2-166_1/MacVim.app/Contents/Resources/vim/vimrc  2: ~/.vimrc  3: /usr/<span class="hljs-built_in">local</span>/Cellar/macvim/8.2-166_1/MacVim.app/Contents/Resources/vim/runtime/syntax/syntax.vim  4: /usr/<span class="hljs-built_in">local</span>/Cellar/macvim/8.2-166_1/MacVim.app/Contents/Resources/vim/runtime/syntax/synload.vim  5: /usr/<span class="hljs-built_in">local</span>/Cellar/macvim/8.2-166_1/MacVim.app/Contents/Resources/vim/runtime/syntax/syncolor.vim  6: /usr/<span class="hljs-built_in">local</span>/Cellar/macvim/8.2-166_1/MacVim.app/Contents/Resources/vim/runtime/filetype.vim  7: ~/.vim/colors/solarized.vim  8: /usr/<span class="hljs-built_in">local</span>/Cellar/macvim/8.2-166_1/MacVim.app/Contents/Resources/vim/runtime/ftoff.vim  9: ~/.vim/bundle/Vundle.vim/<span class="hljs-built_in">autoload</span>/vundle.vim 10: ~/.vim/bundle/Vundle.vim/<span class="hljs-built_in">autoload</span>/vundle/config.vim 11: /usr/<span class="hljs-built_in">local</span>/Cellar/macvim/8.2-166_1/MacVim.app/Contents/Resources/vim/runtime/ftplugin.vim 12: /usr/<span class="hljs-built_in">local</span>/Cellar/macvim/8.2-166_1/MacVim.app/Contents/Resources/vim/runtime/indent.vim 13: ~/.vim/bundle/nerdtree/plugin/NERD_tree.vim 14: ~/.vim/bundle/nerdtree/<span class="hljs-built_in">autoload</span>/nerdtree.vim 15: ~/.vim/bundle/nerdtree/lib/nerdtree/path.vim 16: ~/.vim/bundle/nerdtree/lib/nerdtree/menu_controller.vim 17: ~/.vim/bundle/nerdtree/lib/nerdtree/menu_item.vim 18: ~/.vim/bundle/nerdtree/lib/nerdtree/key_map.vim 19: ~/.vim/bundle/nerdtree/lib/nerdtree/bookmark.vim 20: ~/.vim/bundle/nerdtree/lib/nerdtree/tree_file_node.vim 21: ~/.vim/bundle/nerdtree/lib/nerdtree/tree_dir_node.vim 22: ~/.vim/bundle/nerdtree/lib/nerdtree/opener.vim 23: ~/.vim/bundle/nerdtree/lib/nerdtree/creator.vim 24: ~/.vim/bundle/nerdtree/lib/nerdtree/flag_set.vim 25: ~/.vim/bundle/nerdtree/lib/nerdtree/nerdtree.vim 26: ~/.vim/bundle/nerdtree/lib/nerdtree/ui.vim 27: ~/.vim/bundle/nerdtree/lib/nerdtree/event.vim 28: ~/.vim/bundle/nerdtree/lib/nerdtree/notifier.vim 29: ~/.vim/bundle/nerdtree/<span class="hljs-built_in">autoload</span>/nerdtree/ui_glue.vim 30: ~/.vim/bundle/nerdtree/nerdtree_plugin/exec_menuitem.vim 31: ~/.vim/bundle/nerdtree/nerdtree_plugin/fs_menu.vim 32: ~/.vim/bundle/nerdtree/nerdtree_plugin/vcs.vim 33: ~/.vim/bundle/nerdtree-git-plugin/nerdtree_plugin/git_status.vim 34: ~/.vim/bundle/nerdtree-git-plugin/<span class="hljs-built_in">autoload</span>/gitstatus.vim 35: ~/.vim/bundle/nerdtree-git-plugin/<span class="hljs-built_in">autoload</span>/gitstatus/log.vim 36: ~/.vim/bundle/nerdtree-git-plugin/<span class="hljs-built_in">autoload</span>/gitstatus/listener.vim 37: ~/.vim/bundle/vim-autopep8/plugin/python_autopep8.vim 38: /usr/<span class="hljs-built_in">local</span>/Cellar/macvim/8.2-166_1/MacVim.app/Contents/Resources/vim/runtime/plugin/getscriptPlugin.vim 39: /usr/<span class="hljs-built_in">local</span>/Cellar/macvim/8.2-166_1/MacVim.app/Contents/Resources/vim/runtime/plugin/gzip.vim 40: /usr/<span class="hljs-built_in">local</span>/Cellar/macvim/8.2-166_1/MacVim.app/Contents/Resources/vim/runtime/plugin/logiPat.vim 41: /usr/<span class="hljs-built_in">local</span>/Cellar/macvim/8.2-166_1/MacVim.app/Contents/Resources/vim/runtime/plugin/manpager.vim 42: /usr/<span class="hljs-built_in">local</span>/Cellar/macvim/8.2-166_1/MacVim.app/Contents/Resources/vim/runtime/plugin/matchparen.vim 43: /usr/<span class="hljs-built_in">local</span>/Cellar/macvim/8.2-166_1/MacVim.app/Contents/Resources/vim/runtime/plugin/netrwPlugin.vim 44: /usr/<span class="hljs-built_in">local</span>/Cellar/macvim/8.2-166_1/MacVim.app/Contents/Resources/vim/runtime/plugin/rrhelper.vim 45: /usr/<span class="hljs-built_in">local</span>/Cellar/macvim/8.2-166_1/MacVim.app/Contents/Resources/vim/runtime/plugin/spellfile.vim 46: /usr/<span class="hljs-built_in">local</span>/Cellar/macvim/8.2-166_1/MacVim.app/Contents/Resources/vim/runtime/plugin/tarPlugin.vim 47: /usr/<span class="hljs-built_in">local</span>/Cellar/macvim/8.2-166_1/MacVim.app/Contents/Resources/vim/runtime/plugin/tohtml.vim 48: /usr/<span class="hljs-built_in">local</span>/Cellar/macvim/8.2-166_1/MacVim.app/Contents/Resources/vim/runtime/plugin/vimballPlugin.vim 49: /usr/<span class="hljs-built_in">local</span>/Cellar/macvim/8.2-166_1/MacVim.app/Contents/Resources/vim/runtime/plugin/zipPlugin.vim 50: ~/.vim/bundle/indentLine/after/plugin/indentLine.vim 51: ~/.vim/bundle/nerdtree/syntax/nerdtree.vim 52: ~/.vim/bundle/nerdtree-git-plugin/after/syntax/nerdtree.vim 53: ~/.vim/bundle/nerdtree-git-plugin/<span class="hljs-built_in">autoload</span>/gitstatus/util.vim 54: ~/.vim/bundle/nerdtree-git-plugin/<span class="hljs-built_in">autoload</span>/gitstatus/job.vim</code></pre><h5 id="用户配置文件"><a href="#用户配置文件" class="headerlink" title="用户配置文件"></a>用户配置文件</h5><pre><code class="hljs zsh"><span class="hljs-comment"># 切换至用户目录</span><span class="hljs-built_in">cd</span> ~<span class="hljs-comment"># 使用vim创建并打开.vimrc</span>vim .vimrc</code></pre><h5 id="设置主题"><a href="#设置主题" class="headerlink" title="设置主题"></a>设置主题</h5><pre><code class="hljs zsh">colorscheme solarized</code></pre><h5 id="显示帮助为中文"><a href="#显示帮助为中文" class="headerlink" title="显示帮助为中文"></a>显示帮助为中文</h5><p>下载<a href="https://sourceforge.net/projects/vimcdoc/?source=typ_redirect">vimdoc</a></p><p><img src="/images/vim/doc.png"></p><p>将文件解压到~/.vim/doc，若路径不存在则创建</p><p>打开vim执行:helptags ~/.vim/doc</p><p>在~/.vimrc中进行配置：</p><pre><code class="hljs zsh"><span class="hljs-built_in">set</span> helplang=cn <span class="hljs-keyword">if</span> version &gt;= 603    <span class="hljs-built_in">set</span> helplang=cn    <span class="hljs-built_in">set</span> encoding=utf-8endif</code></pre><p>常见的vim快捷键可以看<a href="https://stackoverflow.com/questions/5400806/what-are-the-most-used-vim-commands-keypresses/5400978#5400978">这里</a></p><h5 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h5><p>enc,fenc,fencs,tenc,一般乱码多是因这些参数设置不正确引起：</p><ol><li>enc，vim内部使用的编码，如buffer，寄存器中的字符串，windows一般是gbk，mac是utf-8</li><li>fenc，当前打开文件自身的编码，如果enc和fenc不一致，vim会做编码转换，转换成fenc编码保存文件</li><li>fencs，一个字符编码列表，编码的自动识别就是通过它实现的</li><li>tenc，终端使用的编码，或者说vim用于屏幕显示时的编码，显示时vim会把内部编码转换为屏幕编码进行输出，默认为enc</li></ol><pre><code class="hljs zsh"><span class="hljs-string">&quot; 将enc设置为utf-8</span><span class="hljs-string">set enc=utf-8</span></code></pre><h4 id="vim插件管理器—Vundle"><a href="#vim插件管理器—Vundle" class="headerlink" title="vim插件管理器—Vundle"></a>vim插件管理器—Vundle</h4><p><a href="http://github.com/VundleVim/Vundle.vim">Vundle</a> is short for <em>Vim bundle</em> and is a <a href="http://www.vim.org/">Vim</a> plugin manager.</p><p><a href="http://github.com/VundleVim/Vundle.vim">Vundle</a> allows you to…</p><ul><li>keep track of and <a href="https://github.com/VundleVim/Vundle.vim/blob/v0.10.2/doc/vundle.txt#L126-L233">configure</a> your plugins right in the <code>.vimrc</code></li><li><a href="https://github.com/VundleVim/Vundle.vim/blob/v0.10.2/doc/vundle.txt#L234-L254">install</a> configured plugins (a.k.a. scripts/bundle)</li><li><a href="https://github.com/VundleVim/Vundle.vim/blob/v0.10.2/doc/vundle.txt#L255-L265">update</a> configured plugins</li><li><a href="https://github.com/VundleVim/Vundle.vim/blob/v0.10.2/doc/vundle.txt#L266-L295">search</a> by name all available <a href="http://vim-scripts.org/vim/scripts.html">Vim scripts</a></li><li><a href="https://github.com/VundleVim/Vundle.vim/blob/v0.10.2/doc/vundle.txt#L303-L318">clean</a> unused plugins up</li><li>run the above actions in a <em>single keypress</em> with <a href="https://github.com/VundleVim/Vundle.vim/blob/v0.10.2/doc/vundle.txt#L319-L360">interactive mode</a></li></ul><p><a href="http://github.com/VundleVim/Vundle.vim">Vundle</a> automatically…</p><ul><li>manages the <a href="http://vimdoc.sourceforge.net/htmldoc/options.html#'runtimepath'">runtime path</a> of your installed scripts</li><li>regenerates <a href="http://vimdoc.sourceforge.net/htmldoc/helphelp.html#:helptags">help tags</a> after installing and updating</li></ul><p><a href="http://github.com/VundleVim/Vundle.vim">Vundle</a> is undergoing an <a href="https://github.com/VundleVim/Vundle.vim/blob/v0.10.2/doc/vundle.txt#L372-L396">interface change</a>, please stay up to date to get latest changes.</p><h5 id="安装Vundle"><a href="#安装Vundle" class="headerlink" title="安装Vundle"></a>安装Vundle</h5><pre><code class="hljs zsh">git <span class="hljs-built_in">clone</span> https://github.com/gmarik/Vundle.vim.git ~/.vim/bundle/Vundle.vim</code></pre><p>下载Vundle插件管理器，将其放置在Vim编辑器bundles文件夹中。现在，可以通过.vimrc配置文件来管理所有扩展了。</p><h5 id="配置Vundle"><a href="#配置Vundle" class="headerlink" title="配置Vundle"></a>配置Vundle</h5><pre><code class="hljs zsh"><span class="hljs-built_in">set</span> nocompatible              <span class="hljs-string">&quot; required</span><span class="hljs-string">filetype off                  &quot;</span> required<span class="hljs-string">&quot; set the runtime path to include Vundle and initialize</span><span class="hljs-string">set rtp+=~/.vim/bundle/Vundle.vim</span><span class="hljs-string">call vundle#begin()</span><span class="hljs-string"></span><span class="hljs-string">&quot;</span> alternatively, pass a path <span class="hljs-built_in">where</span> Vundle should install plugins<span class="hljs-string">&quot;call vundle#begin(&#x27;~/some/path/here&#x27;)</span><span class="hljs-string"></span><span class="hljs-string">&quot;</span> <span class="hljs-built_in">let</span> Vundle manage Vundle, requiredPlugin <span class="hljs-string">&#x27;gmarik/Vundle.vim&#x27;</span><span class="hljs-string">&quot; Add all your plugins here (note older versions of Vundle used Bundle instead of Plugin)</span><span class="hljs-string"></span><span class="hljs-string"></span><span class="hljs-string">&quot;</span> All of your Plugins must be added before the following linecall vundle<span class="hljs-comment">#end()            &quot; required</span>filetype plugin indent on    <span class="hljs-string">&quot; required</span></code></pre><h5 id="使用Vundle"><a href="#使用Vundle" class="headerlink" title="使用Vundle"></a>使用Vundle</h5><p>将想要安装的插件，按照地址填写方法，将地址填写在<strong>vundle#begin</strong>和<strong>vundle#end</strong>之间就可以</p><p>运行 :PluginInstall</p><pre><code class="hljs zsh">:PlugInstall</code></pre><p>执行<code>:PluginInstall</code>后的截图</p><p><img src="/images/vim/vundle.png"></p><h5 id="移除不需要的插件"><a href="#移除不需要的插件" class="headerlink" title="移除不需要的插件"></a>移除不需要的插件</h5><ol><li>编辑.vimrc文件移除的你要移除的插件所对应的plugin那一行</li><li>输入命令<code>:BundleClean</code></li></ol><h5 id="其他常用命令"><a href="#其他常用命令" class="headerlink" title="其他常用命令"></a>其他常用命令</h5><pre><code class="hljs zsh">:BundleList              -列举列表(也就是.vimrc)中配置的所有插件:BundleInstall          -安装列表中的全部插件:BundleInstall!         -更新列表中的全部插件:BundleSearch foo   -查找foo插件:BundleSearch! foo  -刷新foo插件缓存:BundleClean           -清除列表中没有的插件:BundleClean!          -清除列表中没有的插件</code></pre><h4 id="安装插件—打造IDE"><a href="#安装插件—打造IDE" class="headerlink" title="安装插件—打造IDE"></a>安装插件—打造IDE</h4><h5 id="添加目录树—NERDTree"><a href="#添加目录树—NERDTree" class="headerlink" title="添加目录树—NERDTree"></a>添加目录树—NERDTree</h5><p>NERDTree的作用就是列出当前路径的目录树，一般IDE都是有的。可以方便的浏览项目的总体的目录结构和创建删除重命名文件或文件名</p><h6 id="安装NERDTree"><a href="#安装NERDTree" class="headerlink" title="安装NERDTree"></a>安装NERDTree</h6><p>添加目录树：<a href="https://github.com/preservim/nerdtree">nerdtree</a></p><pre><code class="hljs bash">Plugin <span class="hljs-string">&#x27;scrooloose/nerdtree&#x27;</span></code></pre><p>添加git状态图标：<a href="https://github.com/Xuyuanp/nerdtree-git-plugin">nerdtree-git</a></p><pre><code class="hljs bash">Plugin <span class="hljs-string">&#x27;Xuyuanp/nerdtree-git-plugin&#x27;</span></code></pre><h6 id="配置NERDTree"><a href="#配置NERDTree" class="headerlink" title="配置NERDTree"></a>配置NERDTree</h6><pre><code class="hljs zsh"><span class="hljs-string">&quot;使用F3键快速调出和隐藏它</span><span class="hljs-string">map &lt;F3&gt; :NERDTreeToggle&lt;CR&gt;</span><span class="hljs-string"></span><span class="hljs-string">let NERDTreeChDirMode=1</span><span class="hljs-string"></span><span class="hljs-string">&quot;</span>显示书签<span class="hljs-string">&quot;</span><span class="hljs-string">let NERDTreeShowBookmarks=1</span><span class="hljs-string"></span><span class="hljs-string">&quot;</span>设置忽略文件类型<span class="hljs-string">&quot;</span><span class="hljs-string">let NERDTreeIgnore=[&#x27;\~$&#x27;, &#x27;\.pyc$&#x27;, &#x27;\.swp$&#x27;]</span><span class="hljs-string"></span><span class="hljs-string">&quot;</span>窗口大小<span class="hljs-string">&quot;</span><span class="hljs-string">let NERDTreeWinSize=25</span><span class="hljs-string"></span><span class="hljs-string">&quot;</span> 修改默认箭头<span class="hljs-built_in">let</span> g:NERDTreeDirArrowExpandable = <span class="hljs-string">&#x27;▸&#x27;</span><span class="hljs-built_in">let</span> g:NERDTreeDirArrowCollapsible = <span class="hljs-string">&#x27;▾&#x27;</span><span class="hljs-string">&quot;How can I open a NERDTree automatically when vim starts up if no files were specified?</span><span class="hljs-string">autocmd StdinReadPre * let s:std_in=1</span><span class="hljs-string">autocmd VimEnter * if argc() == 0 &amp;&amp; !exists(&quot;</span>s:std_in<span class="hljs-string">&quot;) | NERDTree | endif</span><span class="hljs-string"></span><span class="hljs-string">&quot;</span> 打开vim时自动打开NERDTreeautocmd vimenter * NERDTree           <span class="hljs-string">&quot;How can I open NERDTree automatically when vim starts up on opening a directory?</span><span class="hljs-string">autocmd StdinReadPre * let s:std_in=1</span><span class="hljs-string">autocmd VimEnter * if argc() == 1 &amp;&amp; isdirectory(argv()[0]) &amp;&amp; !exists(&quot;</span>s:std_in<span class="hljs-string">&quot;) | exe &#x27;NERDTree&#x27; argv()[0] | wincmd p | ene | endif</span><span class="hljs-string"></span><span class="hljs-string">&quot;</span> 关闭vim时，如果打开的文件除了NERDTree没有其他文件时，它自动关闭，减少多次按:q!autocmd bufenter * <span class="hljs-keyword">if</span> (winnr(<span class="hljs-string">&quot;$&quot;</span>) == 1 &amp;&amp; exists(<span class="hljs-string">&quot;b:NERDTree&quot;</span>) &amp;&amp; b:NERDTree.isTabTree()) | q | endif<span class="hljs-string">&quot; 开发的过程中，我们希望git信息直接在NERDTree中显示出来， 和Eclipse一样，修改的文件和增加的文件都给出相应的标注， 这时需要安装的插件就是 nerdtree-git-plugin,配置信息如下</span><span class="hljs-string">let g:NERDTreeIndicatorMapCustom = &#123;</span><span class="hljs-string">    \ &quot;</span>Modified<span class="hljs-string">&quot;  : &quot;</span>✹<span class="hljs-string">&quot;,</span><span class="hljs-string">    \ &quot;</span>Staged<span class="hljs-string">&quot;    : &quot;</span>✚<span class="hljs-string">&quot;,</span><span class="hljs-string">    \ &quot;</span>Untracked<span class="hljs-string">&quot; : &quot;</span>✭<span class="hljs-string">&quot;,</span><span class="hljs-string">    \ &quot;</span>Renamed<span class="hljs-string">&quot;   : &quot;</span>➜<span class="hljs-string">&quot;,</span><span class="hljs-string">    \ &quot;</span>Unmerged<span class="hljs-string">&quot;  : &quot;</span>═<span class="hljs-string">&quot;,</span><span class="hljs-string">    \ &quot;</span>Deleted<span class="hljs-string">&quot;   : &quot;</span>✖<span class="hljs-string">&quot;,</span><span class="hljs-string">    \ &quot;</span>Dirty<span class="hljs-string">&quot;     : &quot;</span>✗<span class="hljs-string">&quot;,</span><span class="hljs-string">    \ &quot;</span>Clean<span class="hljs-string">&quot;     : &quot;</span>✔︎<span class="hljs-string">&quot;,</span><span class="hljs-string">    \ &quot;</span>Unknown<span class="hljs-string">&quot;   : &quot;</span>?<span class="hljs-string">&quot;</span><span class="hljs-string">    \ &#125;</span><span class="hljs-string"></span><span class="hljs-string">&quot;</span> 显示行号<span class="hljs-built_in">let</span> NERDTreeShowLineNumbers=1<span class="hljs-built_in">let</span> NERDTreeAutoCenter=1<span class="hljs-string">&quot; 在终端启动vim时，共享NERDTree</span><span class="hljs-string">let g:nerdtree_tabs_open_on_console_startup=1</span></code></pre><h5 id="分割布局"><a href="#分割布局" class="headerlink" title="分割布局"></a>分割布局</h5><p>不用安装额外插件，只需要在.vimrc设置即可</p><pre><code class="hljs zsh"><span class="hljs-string">&quot; 指定屏幕上可以进行分割布局的区域</span><span class="hljs-string">set splitbelow               &quot;</span> 允许在下部分割布局<span class="hljs-built_in">set</span> splitright               <span class="hljs-string">&quot; 允许在右侧分隔布局</span><span class="hljs-string"></span><span class="hljs-string">&quot;</span> 组合快捷键：nnoremap &lt;C-J&gt; &lt;C-W&gt;&lt;C-J&gt;    <span class="hljs-string">&quot; 组合快捷键：- Ctrl-j 切换到下方的分割窗口</span><span class="hljs-string">nnoremap &lt;C-K&gt; &lt;C-W&gt;&lt;C-K&gt;    &quot;</span> 组合快捷键：- Ctrl-k 切换到上方的分割窗口nnoremap &lt;C-L&gt; &lt;C-W&gt;&lt;C-L&gt;    <span class="hljs-string">&quot; 组合快捷键：- Ctrl-l 切换到右侧的分割窗口</span><span class="hljs-string">nnoremap &lt;C-H&gt; &lt;C-W&gt;&lt;C-H&gt;    &quot;</span> 组合快捷键：- Ctrl-h 切换到左侧的分割窗口</code></pre><p>nnoremap将一个组合快捷键映射为另一个快捷键。no部分，指的是在Vim的正常模式（Normal Mode）下，<br>而不是可视模式下重新映射，更多信息请看<a href="https://stackoverflow.com/questions/3776117/what-is-the-difference-between-the-remap-noremap-nnoremap-and-vnoremap-mapping">这里</a></p><h5 id="python代码缩进"><a href="#python代码缩进" class="headerlink" title="python代码缩进"></a>python代码缩进</h5><p>代码的正确缩进是至关重要的，我们将从以下几个方面为vim配置代码缩进功能：</p><ol><li>python代码的自动缩进</li><li>遵从<a href="https://www.cnblogs.com/ajianbeyourself/p/4377933.html">PEP8</a>代码风格标准</li><li>自动格式化为PEP8代码</li></ol><h6 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a><strong>安装插件</strong></h6><p>自动缩进有用，但是在某些情况下（比如函数定义有多行的时候），并不总是会达到你想要的效果，尤其是在符合PEP8标准方面。我们可以利用<a href="https://github.com/vim-scripts/indentpython.vim"><code>indentpython.vim</code></a>插件，来解决这个问题：</p><pre><code class="hljs zsh">Plugin <span class="hljs-string">&#x27;vim-scripts/indentpython.vim&#x27;</span></code></pre><p>将python代码自动格式化为符合pep8标准的代码用到<a href="https://github.com/tell-k/vim-autopep8"><code>tell-k/vim-autopep8</code></a>插件：</p><pre><code class="hljs zsh">Plugin <span class="hljs-string">&#x27;tell-k/vim-autopep8&#x27;</span></code></pre><p>要使用<code>tell-k/vim-autopep8</code>插件必须先在电脑上安装python的第三方包<a href="https://pypi.org/project/autopep8/"><code>autopep8</code></a>。但奇怪的是用pip安装时找不到这个包，我们使用<code>easy-install</code>来安装，只需要在m某个python环境下安装一次即可，实测在其他环境下也可用：</p><pre><code class="hljs zsh">easy_install autopep8</code></pre><h6 id="配置插件"><a href="#配置插件" class="headerlink" title="配置插件"></a>配置插件</h6><p>.vimrc文件中添加下面的配置。这些设置将让Vim中的Tab键就相当于4个标准的空格符，确保每行代码长度不超过80个字符，并且会以unix格式储存文件，避免在推送到Github或分享给其他用户时出现文件转换问题。</p><pre><code class="hljs zsh"><span class="hljs-string">&quot; 按照PEP8标准来配置vim</span><span class="hljs-string">au BufNewFile,BufRead *.py set tabstop=4 |set softtabstop=4|set shiftwidth=4|set textwidth=79|set expandtab|set autoindent|set fileformat=unix</span></code></pre><p>对于全栈开发，你可以设置针对每种文件类型设置au命令：</p><pre><code class="hljs zsh">au BufNewFile,BufRead *.js, *.html, *.css <span class="hljs-built_in">set</span> tabstop=2|<span class="hljs-built_in">set</span> softtabstop=2|<span class="hljs-built_in">set</span> shiftwidth=2</code></pre><p>下面来配置vim-autopep8</p><pre><code class="hljs zsh"><span class="hljs-string">&quot; Disable show diff window</span><span class="hljs-string">let g:autopep8_disable_show_diff=1</span><span class="hljs-string"></span><span class="hljs-string">&quot;</span> vim-autopep8自1.11版本之后取消了F8快捷键，需要用户自己为:Autopep8设置快捷键：autocmd FileType python noremap &lt;buffer&gt; &lt;F8&gt; :call Autopep8()&lt;CR&gt;</code></pre><h6 id="使用插件"><a href="#使用插件" class="headerlink" title="使用插件"></a>使用插件</h6><p>在使用macvim编辑<code>*.py</code>文件时：</p><ul><li>代码自动按照PEP8规则进行缩进；</li><li>tap键相当于4个标准空格，每行代码不超过80字符；</li><li>使用<code>:Autopep8</code>命令或者<code>F8</code>快捷键自动按照PEP8标准格式化python代码</li></ul><p>在使用macvim编辑<code>*.js</code>, <code>*.html</code>, <code>*.css</code>文件时,tap键相当于2个标准空格</p><h5 id="添加代码缩进指示线"><a href="#添加代码缩进指示线" class="headerlink" title="添加代码缩进指示线"></a>添加代码缩进指示线</h5><h6 id="安装indentline"><a href="#安装indentline" class="headerlink" title="安装indentline"></a>安装indentline</h6><p>indentLine是一款缩进指示线，由纯字符实现，效果比较完美</p><pre><code class="hljs bash">Plugin <span class="hljs-string">&#x27;Yggdroot/indentLine&#x27;</span></code></pre><h6 id="配置indentline"><a href="#配置indentline" class="headerlink" title="配置indentline"></a>配置indentline</h6><p><a href="https://github.com/Yggdroot/indentLine"><code>indentLine</code></a>默认是关闭的，因此需要在.vimrc中配置才能看到效果：</p><pre><code class="hljs bash"><span class="hljs-string">&quot; 支持任意ASCII码，也可以使用特殊字符：¦, ┆, or │ ，但只在utf-8编码下有效</span><span class="hljs-string">let g:indentLine_char=&#x27;¦&#x27;   </span><span class="hljs-string"></span><span class="hljs-string">&quot;</span> 使indentline生效<span class="hljs-built_in">let</span> g:indentLine_enabled = 1</code></pre><h6 id="使用indentline"><a href="#使用indentline" class="headerlink" title="使用indentline"></a>使用indentline</h6><p>在代码缩进处，自动生成缩进指示线</p><h5 id="代码折叠"><a href="#代码折叠" class="headerlink" title="代码折叠"></a>代码折叠</h5><p>大多数“现代”集成开发环境（IDE）都提供对方法（methods）或类（classes）进行折叠的手段，只显示类或方法的定义部分，而不是全部的代码。</p><h6 id="安装插件-1"><a href="#安装插件-1" class="headerlink" title="安装插件"></a>安装插件</h6><p>本身不用安装额外插件，但为避免出现超过你所希望的折叠数目，我们推荐<a href="https://github.com/tmhedberg/SimpylFold"><code>SimplyFold</code></a>来解决这个问题：</p><pre><code class="hljs bash">Plugin <span class="hljs-string">&#x27;tmhedberg/SimpylFold&#x27;</span></code></pre><h6 id="配置插件-1"><a href="#配置插件-1" class="headerlink" title="配置插件"></a>配置插件</h6><pre><code class="hljs bash"><span class="hljs-string">&quot; 必须手动输入za来折叠（和取消折叠）</span><span class="hljs-string">set foldmethod=indent                &quot;</span> 根据每行的缩进开启折叠<span class="hljs-built_in">set</span> foldlevel=99<span class="hljs-string">&quot; 使用空格键会是更好的选择,所以在你的配置文件中加上这一行命令吧：</span><span class="hljs-string">nnoremap &lt;space&gt; za</span><span class="hljs-string"></span><span class="hljs-string">&quot;</span> 希望看到折叠代码的文档字符串？<span class="hljs-built_in">let</span> g:SimpylFold_docstring_preview=1</code></pre><h6 id="使用插件-1"><a href="#使用插件-1" class="headerlink" title="使用插件"></a>使用插件</h6><p>在程序块处会显示折叠线，当光标放于折叠线时，按空格键可以切换在该折叠线处是否折叠。</p><h5 id="括号自动补全"><a href="#括号自动补全" class="headerlink" title="括号自动补全"></a>括号自动补全</h5><p><a href="https://github.com/jiangmiao/auto-pairs">auto-pairs</a>主要功能是括号和引号自动补全，输入左引号和左括号自动补全另外一半,安装好就可以无需额外配置</p><pre><code class="hljs bash">Plugin <span class="hljs-string">&#x27;jiangmiao/auto-pairs&#x27;</span></code></pre><h5 id="多行注释"><a href="#多行注释" class="headerlink" title="多行注释"></a>多行注释</h5><h6 id="安装插件-2"><a href="#安装插件-2" class="headerlink" title="安装插件"></a>安装插件</h6><pre><code class="hljs bash">Plugin <span class="hljs-string">&#x27;scrooloose/nerdcommenter&#x27;</span></code></pre><h6 id="配置插件-2"><a href="#配置插件-2" class="headerlink" title="配置插件"></a>配置插件</h6><pre><code class="hljs xml">&quot; nerdcommenter默认热键<span class="hljs-tag">&lt;<span class="hljs-name">leader</span>&gt;</span>为&#x27;\&#x27;，这里将热键设置为&#x27;,&#x27;let mapleader=&#x27;,&#x27;&quot; 设置注释快捷键map <span class="hljs-tag">&lt;<span class="hljs-name">F4</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">leader</span>&gt;</span>ci<span class="hljs-tag">&lt;<span class="hljs-name">CR</span>&gt;</span></code></pre><h6 id="使用插件-2"><a href="#使用插件-2" class="headerlink" title="使用插件"></a>使用插件</h6><p>在normal模式下按v并移动光标选择需要注释的行，再按F4就可以为所有选中的行添加注释</p>]]></content>
    
    
    <categories>
      
      <category>Develop</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vim</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【ALL】CAP分布式一致性</title>
    <link href="/2020/11/25/cap/"/>
    <url>/2020/11/25/cap/</url>
    
    <content type="html"><![CDATA[<h3 id><a href="#" class="headerlink" title></a><a id="more"></a></h3>]]></content>
    
    
    <categories>
      
      <category>Develop</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Paxos</tag>
      
      <tag>Raft</tag>
      
      <tag>ZAB</tag>
      
      <tag>Zookeeper</tag>
      
      <tag>Etcd</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【ALL】MR&amp;Yarn:Hadoop计算框架与资源调度框架</title>
    <link href="/2020/11/25/hadoop-MR/"/>
    <url>/2020/11/25/hadoop-MR/</url>
    
    <content type="html"><![CDATA[<h3 id><a href="#" class="headerlink" title></a><a id="more"></a></h3>]]></content>
    
    
    <categories>
      
      <category>Bdata</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hadoop</tag>
      
      <tag>大数据</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Python】设计模式</title>
    <link href="/2020/11/20/design-pattern-python/"/>
    <url>/2020/11/20/design-pattern-python/</url>
    
    <content type="html"><![CDATA[<blockquote><p>Patterns mean “I have run out of language.” - Rich Hickey</p><p><strong>Design patterns</strong> are typical solutions to common problemsin software design. Each pattern is like a blueprintthat you can customize to solve a particulardesign problem in your code.<a id="more"></a> </p></blockquote><h3 id="创建型"><a href="#创建型" class="headerlink" title="创建型"></a>创建型</h3><h4 id="Method-工厂方法"><a href="#Method-工厂方法" class="headerlink" title="Method(工厂方法)"></a>Method(工厂方法)</h4><p>执行单独的函数，通过传参提供需要的对象的信息。</p><pre><code class="hljs Python"><span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">Module Description: 工厂方法</span><span class="hljs-string">Problem:在工厂方法模式中，我们执行函数，传入一个参数，但不需要知道任何关于对象如何实现以及对象来自哪里的细节</span><span class="hljs-string">Solution：</span><span class="hljs-string">Date: 2020/1/8 </span><span class="hljs-string">Author: Wang P</span><span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-keyword">import</span> json<span class="hljs-keyword">import</span> xml.etree.ElementTree <span class="hljs-keyword">as</span> etree<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Connector</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, filepath</span>):</span>        factory = <span class="hljs-literal">None</span>        <span class="hljs-keyword">try</span>:            factory = self.connector_factory(filepath)        <span class="hljs-keyword">except</span> ValueError <span class="hljs-keyword">as</span> e:            print(e)        self.factory = factory    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">connector_factory</span>(<span class="hljs-params">self, filepath</span>):</span>        <span class="hljs-keyword">if</span> filepath.endswith(<span class="hljs-string">&#x27;json&#x27;</span>):            connector = self.JSONConnector        <span class="hljs-keyword">elif</span> filepath.endswith(<span class="hljs-string">&#x27;xml&#x27;</span>):            connector = self.XMLConnector        <span class="hljs-keyword">else</span>:            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&#x27;Cannot connect to &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(filepath))        <span class="hljs-keyword">return</span> connector(filepath)    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JSONConnector</span>:</span>        <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">        JSON工厂</span><span class="hljs-string">        &quot;&quot;&quot;</span>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, filepath</span>):</span>            self.data = <span class="hljs-built_in">dict</span>()            <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(filepath, mode=<span class="hljs-string">&#x27;r&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> f:                self.data = json.load(f)<span class="hljs-meta">        @property</span>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">parsed_data</span>(<span class="hljs-params">self</span>):</span>            <span class="hljs-keyword">return</span> self.data    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">XMLConnector</span>:</span>        <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">        XML工厂</span><span class="hljs-string">        &quot;&quot;&quot;</span>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, filepath</span>):</span>            self.tree = etree.parse(filepath)<span class="hljs-meta">        @property</span>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">parsed_date</span>(<span class="hljs-params">self</span>):</span>            <span class="hljs-keyword">return</span> self.tree<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span>    xml_factory = Connector(<span class="hljs-string">&#x27;data/person.xml&#x27;</span>)    xml_data = xml_factory.factory.parsed_date    smiths = xml_data.findall(<span class="hljs-string">&quot;.//&#123;&#125;[&#123;&#125;=&#x27;&#123;&#125;&#x27;]&quot;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-string">&#x27;person&#x27;</span>, <span class="hljs-string">&#x27;lastName&#x27;</span>, <span class="hljs-string">&#x27;Smith&#x27;</span>))    print(<span class="hljs-string">&#x27;found: &#123;&#125; persons&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">len</span>(smiths)))    <span class="hljs-keyword">for</span> smith <span class="hljs-keyword">in</span> smiths:        print(<span class="hljs-string">&#x27;first name:&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(smith.find(<span class="hljs-string">&#x27;firstName&#x27;</span>).text))        print(<span class="hljs-string">&#x27;last name:&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(smith.find(<span class="hljs-string">&#x27;lastName&#x27;</span>).text))    print()    json_factory = Connector(<span class="hljs-string">&#x27;data/donut.json&#x27;</span>)    json_data = json_factory.factory.parsed_data    print(<span class="hljs-string">&#x27;find: &#123;&#125; donuts. &#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">len</span>(json_data)))    <span class="hljs-keyword">for</span> donut <span class="hljs-keyword">in</span> json_data:        print(<span class="hljs-string">&#x27;name:&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(donut[<span class="hljs-string">&#x27;name&#x27;</span>]))        print(<span class="hljs-string">&#x27;ppu:&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(donut[<span class="hljs-string">&#x27;ppu&#x27;</span>]))<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:    main()</code></pre><h4 id="Abstract-Factory-抽象工厂-解决复杂对象创建问题"><a href="#Abstract-Factory-抽象工厂-解决复杂对象创建问题" class="headerlink" title="Abstract Factory(抽象工厂: 解决复杂对象创建问题)"></a>Abstract Factory(抽象工厂: 解决复杂对象创建问题)</h4><p>工厂方法适合对象种类较少的情况，如果有多种不同类型对象需要创建，使用抽象工厂模式。</p><pre><code class="hljs Python"><span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">Module Description: 抽象工厂（实际上一个抽象工厂其实是一组工厂方法，每个工厂方法负责生产不同类型的对象）</span><span class="hljs-string">Problem:</span><span class="hljs-string">Solution：</span><span class="hljs-string">Date: 2020/1/8 </span><span class="hljs-string">Author: Wang P</span><span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Frog</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span>    <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">    游戏角色对象-青蛙</span><span class="hljs-string">    &quot;&quot;&quot;</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, name</span>):</span>        self.name = name    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__str__</span>(<span class="hljs-params">self</span>):</span>        <span class="hljs-keyword">return</span> self.name    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">interact_with</span>(<span class="hljs-params">self, obstacle</span>):</span>        print(<span class="hljs-string">&#x27;&#123;&#125; the Frog encounters &#123;&#125; and &#123;&#125;!&#x27;</span>.<span class="hljs-built_in">format</span>(self, obstacle, obstacle.action()))<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bug</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span>    <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">    障碍物对象-虫子</span><span class="hljs-string">    &quot;&quot;&quot;</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__str__</span>(<span class="hljs-params">self</span>):</span>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;a bug&#x27;</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">action</span>(<span class="hljs-params">self</span>):</span>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;eats it&#x27;</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FrogWorld</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span>    <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">    抽象工厂，负责创建游戏角色与障碍物对象</span><span class="hljs-string">    make_character()和make_obstacle()动态改变当前激活的工厂</span><span class="hljs-string">    在静态语言中，抽象工厂是抽象类/接口，具有一些空方法，Python中无须如此</span><span class="hljs-string">    &quot;&quot;&quot;</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, name</span>):</span>        print(self)        self.player_name = name    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__str__</span>(<span class="hljs-params">self</span>):</span>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;\n\n\t------- Frog Word -------&#x27;</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">make_character</span>(<span class="hljs-params">self</span>):</span>        <span class="hljs-keyword">return</span> Frog(self.player_name)    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">make_obstacle</span>(<span class="hljs-params">self</span>):</span>        <span class="hljs-keyword">return</span> Bug()<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Wizard</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span>    <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">    游戏角色对象-男巫</span><span class="hljs-string">    &quot;&quot;&quot;</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, name</span>):</span>        self.name = name    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__str__</span>(<span class="hljs-params">self</span>):</span>        <span class="hljs-keyword">return</span> self.name    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">interact_with</span>(<span class="hljs-params">self, obstacle</span>):</span>        print(<span class="hljs-string">&#x27;&#123;&#125; the Wizard battles against &#123;&#125; and &#123;&#125;!&#x27;</span>.<span class="hljs-built_in">format</span>(self, obstacle, obstacle.action()))<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Ork</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span>    <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">    障碍物对象-怪兽</span><span class="hljs-string">    &quot;&quot;&quot;</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__str__</span>(<span class="hljs-params">self</span>):</span>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;an evil ork&#x27;</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">action</span>(<span class="hljs-params">self</span>):</span>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;kills it&#x27;</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WizardWorld</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span>    <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">    抽象工厂，负责创建游戏角色与障碍物对象</span><span class="hljs-string">    make_character()和make_obstacle()动态改变当前激活的工厂</span><span class="hljs-string">    在静态语言中，抽象工厂是抽象类/接口，具有一些空方法，Python中无须如此</span><span class="hljs-string">    &quot;&quot;&quot;</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, name</span>):</span>        print(self)        self.player_name = name    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__str__</span>(<span class="hljs-params">self</span>):</span>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;\n\n\t------- Wizard Word -------&#x27;</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">make_character</span>(<span class="hljs-params">self</span>):</span>        <span class="hljs-keyword">return</span> Wizard(self.player_name)    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">make_obstacle</span>(<span class="hljs-params">self</span>):</span>        <span class="hljs-keyword">return</span> Ork()<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GameEnvironment</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span>    <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">    游戏的主入口，接收factory为输入</span><span class="hljs-string">    &quot;&quot;&quot;</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, factory</span>):</span>        self.hero = factory.make_character()        self.obstacle = factory.make_obstacle()    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">play</span>(<span class="hljs-params">self</span>):</span>        self.hero.interact_with(self.obstacle)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">validate_age</span>(<span class="hljs-params">name</span>):</span>    <span class="hljs-keyword">try</span>:        age = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;Welcome &#123;&#125;. How old are you? &quot;</span>.<span class="hljs-built_in">format</span>(name))        age = <span class="hljs-built_in">int</span>(age)    <span class="hljs-keyword">except</span> ValueError <span class="hljs-keyword">as</span> e:        print(<span class="hljs-string">&quot;Age &#123;&#125; is invalid, please try again...&quot;</span>.<span class="hljs-built_in">format</span>(age))        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>, age    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>, age<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span>    name = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;Hello. What&#x27;s your name?&quot;</span>)    valid_input = <span class="hljs-literal">False</span>    age = <span class="hljs-number">0</span>    <span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> valid_input:        valid_input, age = validate_age(name)    game = FrogWorld <span class="hljs-keyword">if</span> age &lt; <span class="hljs-number">18</span> <span class="hljs-keyword">else</span> WizardWorld    environment = GameEnvironment(game(name))    environment.play()<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:    main()</code></pre><h4 id="The-Builder-Pattern-构造模式-控制复杂对象的构造"><a href="#The-Builder-Pattern-构造模式-控制复杂对象的构造" class="headerlink" title="The Builder Pattern(构造模式: 控制复杂对象的构造)"></a>The Builder Pattern(构造模式: 控制复杂对象的构造)</h4><p>当对象需要多个部分组合起来一步步创建，并且创建和表示分离的时候。可以这么理解，你要买电脑，工厂模式直接返回一个你需要型号的电脑，但是构造模式允许你自定义电脑各种配置类型，组装完成后给你。这个过程可以传入builder从而自定义创建的方式。</p><pre><code class="hljs Python"><span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">Module Description:建造者设计模式demo</span><span class="hljs-string">Problem:当需要创建一个由多个部分构成的对象，而且它的构造需要一步接一步的完成；只有当各个部分都创建好，这个对象才算完整</span><span class="hljs-string">Solution：</span><span class="hljs-string">Extension:工厂模式与创建者的区别为（1）工厂模式一但个步骤创建对象；创建者以多个步骤创建对象，并且几乎始终会使用一个指挥者。</span><span class="hljs-string">                              （2）工厂模式下会立即返回一个创建好的对象，建造者仅在客户端代码才显式请求指挥者返回的最终对象</span><span class="hljs-string">                               例如：假设你想买个电脑，如果决定买一台特定配置的电脑，则使用工厂模式；如果你要购买一台定制的PC，</span><span class="hljs-string">                               你式指挥者，会向制造商提供指令说明心中理想的电脑规格。</span><span class="hljs-string">Date: 2020/1/8</span><span class="hljs-string">Author: Wang P</span><span class="hljs-string">&quot;&quot;&quot;</span>MINI14 = <span class="hljs-string">&#x27;1.4GHz Mac Mini&#x27;</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppleFactory</span>:</span>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MacMini14</span>:</span>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span>            self.memory = <span class="hljs-number">4</span>            self.hdd = <span class="hljs-number">500</span>            self.gpu = <span class="hljs-string">&#x27;Intel HD Graphics 5000&#x27;</span>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__str__</span>(<span class="hljs-params">self</span>):</span>            info = (<span class="hljs-string">&#x27;Model: &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(MINI14),                    <span class="hljs-string">&#x27;Memory: &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(self.memory),                    <span class="hljs-string">&#x27;Hard Disk: &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(self.hdd),                    <span class="hljs-string">&#x27;Graphics Card: &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(self.gpu))            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;\n&#x27;</span>.join(info)    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">build_computer</span>(<span class="hljs-params">self, model</span>):</span>        <span class="hljs-keyword">if</span> model == MINI14:            <span class="hljs-keyword">return</span> self.MacMini14()        <span class="hljs-keyword">else</span>:            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;I dont&#x27;t know how to build &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(model)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">apple_computer_use_factory</span>():</span>    afac = AppleFactory()    mac_mini = afac.build_computer(MINI14)    print(mac_mini)<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Computer</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, serial_number</span>):</span>        self.serial_number = serial_number        self.memory = <span class="hljs-literal">None</span>        self.hdd = <span class="hljs-literal">None</span>        self.gpu = <span class="hljs-literal">None</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__str__</span>(<span class="hljs-params">self</span>):</span>        info = (<span class="hljs-string">&#x27;Serial: &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(self.serial_number),                <span class="hljs-string">&#x27;Memory: &#123;&#125;GB&#x27;</span>.<span class="hljs-built_in">format</span>(self.memory),                <span class="hljs-string">&#x27;Hard Disk: &#123;&#125;GB&#x27;</span>.<span class="hljs-built_in">format</span>(self.hdd),                <span class="hljs-string">&#x27;Graphics Card: &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(self.gpu))        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;\n&#x27;</span>.join(info)<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ComputerBuilder</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span>        self.computer = Computer(<span class="hljs-string">&#x27;AI563924&#x27;</span>)    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">conf_memory</span>(<span class="hljs-params">self, amount</span>):</span>        self.computer.memory = amount    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">conf_hdd</span>(<span class="hljs-params">self, amount</span>):</span>        self.computer.hdd = amount    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">conf_gpu</span>(<span class="hljs-params">self, model</span>):</span>        self.computer.gpu = model<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HardwareEngineer</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span>        self.builder = <span class="hljs-literal">None</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">construct_computer</span>(<span class="hljs-params">self, memory, hdd, gpu</span>):</span>        self.builder = ComputerBuilder()        self.builder.conf_memory(memory)        self.builder.conf_hdd(hdd)        self.builder.conf_gpu(gpu)<span class="hljs-meta">    @property</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">computer</span>(<span class="hljs-params">self</span>):</span>        <span class="hljs-keyword">return</span> self.builder.computer<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">apple_computer_use_builder</span>():</span>    engineer = HardwareEngineer()    engineer.construct_computer(memory=<span class="hljs-number">8</span>, hdd=<span class="hljs-number">500</span>, gpu=<span class="hljs-string">&#x27;GeForce GTX 650 Ti&#x27;</span>)    computer = engineer.computer    print(computer)<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:    apple_computer_use_builder()    print(<span class="hljs-string">&#x27;*&#x27;</span>*<span class="hljs-number">50</span>)    apple_computer_use_factory()</code></pre><h4 id="单例模式-使得一个类最多生成一个实例"><a href="#单例模式-使得一个类最多生成一个实例" class="headerlink" title="单例模式: 使得一个类最多生成一个实例"></a>单例模式: 使得一个类最多生成一个实例</h4><p>(基于元类)单例模式</p><pre><code class="hljs Python"><span class="hljs-comment"># -*- coding:utf-8 -*-</span><span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">Module Description:(基于元类)单例模式</span><span class="hljs-string">Problem:</span><span class="hljs-string">Solution:</span><span class="hljs-string">Date: 2020/1/6 </span><span class="hljs-string">Author: Wang P</span><span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span>(<span class="hljs-params"><span class="hljs-built_in">type</span></span>):</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">cls, *args, **kwargs</span>):</span>        print(<span class="hljs-string">&quot;__init__ &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(cls.__name__))        cls.__instance = <span class="hljs-literal">None</span>        <span class="hljs-built_in">super</span>().__init__(*args, **kwargs)    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__call__</span>(<span class="hljs-params">cls, *args, **kwargs</span>):</span>        <span class="hljs-keyword">if</span> cls.__instance <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:            print(<span class="hljs-string">&quot;__call__ &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(cls.__name__))            cls.__instance = <span class="hljs-built_in">super</span>(Singleton, cls).__call__(*args, **kwargs)        <span class="hljs-keyword">return</span> cls.__instance<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Instance</span>(<span class="hljs-params">metaclass=Singleton</span>):</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, name</span>):</span>        self.name = name<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:    i1 = Instance(<span class="hljs-string">&#x27;zhang san&#x27;</span>)    i2 = Instance(<span class="hljs-string">&#x27;li si&#x27;</span>)    print(i1 <span class="hljs-keyword">is</span> i2)</code></pre><p>通过new函数实现简单的单例模式</p><pre><code class="hljs Python"><span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">Module Description: 通过new函数实现简单的单例模式</span><span class="hljs-string">Problem:</span><span class="hljs-string">Solution：</span><span class="hljs-string">Date: 2020/1/20 </span><span class="hljs-string">Author: Wang P</span><span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__new__</span>(<span class="hljs-params">cls, name, *args, **kwargs</span>):</span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">hasattr</span>(cls, <span class="hljs-string">&#x27;_instance&#x27;</span>):            cls._instance = <span class="hljs-built_in">super</span>().__new__(cls, *args, **kwargs)        print(<span class="hljs-string">&quot;__call__ &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(cls.__class__))        <span class="hljs-keyword">return</span> cls._instance    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, name</span>):</span>        print(<span class="hljs-string">&quot;__init__ &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(self.__str__()))        <span class="hljs-built_in">super</span>().__init__()        self.name = name<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:    ins1 = Singleton(<span class="hljs-string">&#x27;zhang san&#x27;</span>)    ins2 = Singleton(<span class="hljs-string">&#x27;li si&#x27;</span>)    print(<span class="hljs-built_in">id</span>(ins1), <span class="hljs-built_in">id</span>(ins2))    print(ins1.name)    print(ins2.name)</code></pre><p>装饰器实现</p><pre><code class="hljs Python"><span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">Module Description: 通过装饰器方式实现单例模式</span><span class="hljs-string">Problem:</span><span class="hljs-string">Solution：</span><span class="hljs-string">Date: 2020/2/20 </span><span class="hljs-string">Author: Wang P</span><span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-comment"># 装饰器实现</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">singleton</span>(<span class="hljs-params">class_</span>):</span>    instances = &#123;&#125;    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getinstance</span>(<span class="hljs-params">*args, **kwargs</span>):</span>        <span class="hljs-keyword">if</span> class_ <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> instances:            instances[class_] = class_(*args, **kwargs)        <span class="hljs-keyword">return</span> instances[class_]    <span class="hljs-keyword">return</span> getinstance<span class="hljs-meta">@singleton</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span>:</span>    <span class="hljs-keyword">pass</span><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:    i1 = MyClass()    i2 = MyClass()    print(i1 <span class="hljs-keyword">is</span> i2)</code></pre><h4 id="The-Prototype-Pattern-原型模式-解决对象拷贝问题"><a href="#The-Prototype-Pattern-原型模式-解决对象拷贝问题" class="headerlink" title="The Prototype Pattern(原型模式:解决对象拷贝问题)"></a>The Prototype Pattern(原型模式:解决对象拷贝问题)</h4><h3 id="行为型"><a href="#行为型" class="headerlink" title="行为型"></a>行为型</h3><h4 id="The-Observer-Pattern-观察者模式：用来处理多个对象之间的发布订阅问题"><a href="#The-Observer-Pattern-观察者模式：用来处理多个对象之间的发布订阅问题" class="headerlink" title="The Observer Pattern(观察者模式：用来处理多个对象之间的发布订阅问题)"></a>The Observer Pattern(观察者模式：用来处理多个对象之间的发布订阅问题)</h4><pre><code class="hljs Python"><span class="hljs-comment"># -*- coding:utf-8 -*-</span><span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">Module Description: </span><span class="hljs-string">Date: 2019/12/13 </span><span class="hljs-string">Author: Wang P</span><span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WaterHeater</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span>    <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">    热水器：战胜寒冬的有利武器</span><span class="hljs-string">    &quot;&quot;&quot;</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span>        self.__observers = []        self.__temperature = <span class="hljs-number">25</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getTemperature</span>(<span class="hljs-params">self</span>):</span>        <span class="hljs-keyword">return</span> self.__temperature    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">setTemperature</span>(<span class="hljs-params">self, temperature</span>):</span>        self.__temperature = temperature        print(<span class="hljs-string">&quot;current temperature is:&quot;</span>, self.__temperature)        self.notifies()    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">addObserver</span>(<span class="hljs-params">self, observer</span>):</span>        self.__observers.append(observer)    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">notifies</span>(<span class="hljs-params">self</span>):</span>        <span class="hljs-keyword">for</span> o <span class="hljs-keyword">in</span> self.__observers:            o.update(self)<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Observer</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span>    <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">    洗澡模式和饮用模式的父类</span><span class="hljs-string">    &quot;&quot;&quot;</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">update</span>(<span class="hljs-params">self, waterHeater</span>):</span>        <span class="hljs-keyword">pass</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WashingMode</span>(<span class="hljs-params">Observer</span>):</span>    <span class="hljs-string">&quot;&quot;&quot;该模式用于洗澡用&quot;&quot;&quot;</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">update</span>(<span class="hljs-params">self, waterHeater</span>):</span>        <span class="hljs-keyword">if</span> <span class="hljs-number">50</span> &lt;= waterHeater.getTemperature() &lt; <span class="hljs-number">70</span>:            print(<span class="hljs-string">&quot;水已烧好，温度正好！可以用来洗澡了。&quot;</span>)<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DrinkingMode</span>(<span class="hljs-params">Observer</span>):</span>    <span class="hljs-string">&quot;&quot;&quot;该模式用于饮用&quot;&quot;&quot;</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">update</span>(<span class="hljs-params">self, waterHeater</span>):</span>        <span class="hljs-keyword">if</span> waterHeater.getTemperature() &gt;= <span class="hljs-number">100</span>:            print(<span class="hljs-string">&quot;水已烧开！可以用来饮用了。&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_water_heater</span>():</span>    heater = WaterHeater()    washing_obser = WashingMode()    drinking_obser = DrinkingMode()    heater.addObserver(washing_obser)    heater.addObserver(drinking_obser)    heater.setTemperature(<span class="hljs-number">40</span>)    heater.setTemperature(<span class="hljs-number">60</span>)    heater.setTemperature(<span class="hljs-number">100</span>)<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:    test_water_heater()</code></pre><h4 id="The-State-Pattern-状态模式：实现有限状态机"><a href="#The-State-Pattern-状态模式：实现有限状态机" class="headerlink" title="The State Pattern(状态模式：实现有限状态机)"></a>The State Pattern(状态模式：实现有限状态机)</h4><h4 id="The-Strategy-Pattern-策略模式：动态选择算法策略"><a href="#The-Strategy-Pattern-策略模式：动态选择算法策略" class="headerlink" title="The Strategy Pattern(策略模式：动态选择算法策略)"></a>The Strategy Pattern(策略模式：动态选择算法策略)</h4><h4 id="The-Chain-of-Responsibility-Pattern-责任链模式-创建链式对象用来接收广播消息"><a href="#The-Chain-of-Responsibility-Pattern-责任链模式-创建链式对象用来接收广播消息" class="headerlink" title="The Chain of Responsibility Pattern (责任链模式:创建链式对象用来接收广播消息)"></a>The Chain of Responsibility Pattern (责任链模式:创建链式对象用来接收广播消息)</h4><h4 id="The-Command-Pattern-命令模式：用来给应用添加Undo操作"><a href="#The-Command-Pattern-命令模式：用来给应用添加Undo操作" class="headerlink" title="The Command Pattern(命令模式：用来给应用添加Undo操作)"></a>The Command Pattern(命令模式：用来给应用添加Undo操作)</h4><h4 id="The-Interpreter-Pattern-解释器模式：用来实现Domain-Specific-Language-DSL"><a href="#The-Interpreter-Pattern-解释器模式：用来实现Domain-Specific-Language-DSL" class="headerlink" title="The Interpreter Pattern(解释器模式：用来实现Domain Specific Language(DSL))"></a>The Interpreter Pattern(解释器模式：用来实现Domain Specific Language(DSL))</h4><h4 id="The-Template-Pattern-模板模式：抽象出算法公共部分从而实现代码复用"><a href="#The-Template-Pattern-模板模式：抽象出算法公共部分从而实现代码复用" class="headerlink" title="The Template Pattern(模板模式：抽象出算法公共部分从而实现代码复用)"></a>The Template Pattern(模板模式：抽象出算法公共部分从而实现代码复用)</h4><h3 id="结构性"><a href="#结构性" class="headerlink" title="结构性"></a>结构性</h3><h4 id="The-Adapter-Pattern-适配器模式-解决接口不兼容问题"><a href="#The-Adapter-Pattern-适配器模式-解决接口不兼容问题" class="headerlink" title="The Adapter Pattern(适配器模式: 解决接口不兼容问题)"></a>The Adapter Pattern(适配器模式: 解决接口不兼容问题)</h4><h4 id="The-Decorator-Pattern-装饰器模式：-无需子类化实现扩展对象功能问题"><a href="#The-Decorator-Pattern-装饰器模式：-无需子类化实现扩展对象功能问题" class="headerlink" title="The Decorator Pattern(装饰器模式： 无需子类化实现扩展对象功能问题)"></a>The Decorator Pattern(装饰器模式： 无需子类化实现扩展对象功能问题)</h4><h4 id="The-Facade-Pattern-外观模式-简化复杂对象的访问问题"><a href="#The-Facade-Pattern-外观模式-简化复杂对象的访问问题" class="headerlink" title="The Facade Pattern(外观模式: 简化复杂对象的访问问题)"></a>The Facade Pattern(外观模式: 简化复杂对象的访问问题)</h4><h4 id="The-Flyweight-Pattern-享元模式-实现对象复用从而改善资源使用"><a href="#The-Flyweight-Pattern-享元模式-实现对象复用从而改善资源使用" class="headerlink" title="The Flyweight Pattern(享元模式: 实现对象复用从而改善资源使用)"></a>The Flyweight Pattern(享元模式: 实现对象复用从而改善资源使用)</h4><h4 id="The-Model-View-Controller-Pattern-mvc模式：解耦展示逻辑和业务逻辑"><a href="#The-Model-View-Controller-Pattern-mvc模式：解耦展示逻辑和业务逻辑" class="headerlink" title="The Model-View-Controller Pattern(mvc模式：解耦展示逻辑和业务逻辑)"></a>The Model-View-Controller Pattern(mvc模式：解耦展示逻辑和业务逻辑)</h4><h4 id="The-Proxy-Pattern-代理模式：通过一层间接保护层实现更安全的接口访问）"><a href="#The-Proxy-Pattern-代理模式：通过一层间接保护层实现更安全的接口访问）" class="headerlink" title="The Proxy Pattern(代理模式：通过一层间接保护层实现更安全的接口访问）"></a>The Proxy Pattern(代理模式：通过一层间接保护层实现更安全的接口访问）</h4>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Python】基本数据结构和算法</title>
    <link href="/2020/11/20/adt-python/"/>
    <url>/2020/11/20/adt-python/</url>
    
    <content type="html"><![CDATA[<p>How to select datastructures for ADT</p><ol><li>Dose the data structure provide for the storage requirements as specified by the domain of the ADT?</li><li>Does the data structure provide the data access and manipulation functionality to fully implement the ADT?</li><li>Effcient implemention? based on complexity analysis.<a id="more"></a></li></ol><h3 id="Strings"><a href="#Strings" class="headerlink" title="Strings"></a>Strings</h3><pre><code class="hljs Python"><span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">Module Description: 字符串相关</span><span class="hljs-string">Problem:</span><span class="hljs-string">Solution：</span><span class="hljs-string">Date: 2020/2/18 </span><span class="hljs-string">Author: Wang P</span><span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReverseString</span>:</span>    <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">    字符数组反转</span><span class="hljs-string">    &quot;&quot;&quot;</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reverse_string</span>(<span class="hljs-params">self, x, reverse=<span class="hljs-literal">False</span></span>):</span>        <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">        :param x: 字符数组</span><span class="hljs-string">        :param reverse: 是否之用内置库</span><span class="hljs-string">        :return:</span><span class="hljs-string">        &quot;&quot;&quot;</span>        <span class="hljs-keyword">if</span> reverse:            x.reverse()            <span class="hljs-keyword">return</span> x        <span class="hljs-keyword">else</span>:            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> x:                <span class="hljs-keyword">return</span>            beg, end = <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(x)<span class="hljs-number">-1</span>            <span class="hljs-keyword">while</span> beg &lt; end:                x[beg], x[end] = x[end], x[beg]                beg += <span class="hljs-number">1</span>                end -= <span class="hljs-number">1</span>            <span class="hljs-keyword">return</span> x<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Palindrome</span>:</span>    <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">    判断字符串是否是回文</span><span class="hljs-string">    &quot;&quot;&quot;</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">is_palindrome</span>(<span class="hljs-params">self, x</span>):</span>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(x, <span class="hljs-built_in">int</span>) <span class="hljs-keyword">and</span> x &lt; <span class="hljs-number">0</span>:            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>        xx = <span class="hljs-built_in">str</span>(x)        beg, end = <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(xx)<span class="hljs-number">-1</span>        <span class="hljs-keyword">while</span> beg &lt; end:            <span class="hljs-keyword">if</span> xx[beg] == xx[end]:                beg += <span class="hljs-number">1</span>                end -= <span class="hljs-number">1</span>            <span class="hljs-keyword">else</span>:                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:    r = ReverseString()    print(r.reverse_string([<span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;h&#x27;</span>, <span class="hljs-string">&#x27;s&#x27;</span>, <span class="hljs-string">&#x27;j&#x27;</span>, <span class="hljs-string">&#x27;f&#x27;</span>], <span class="hljs-literal">False</span>))</code></pre><p><a href="https://github.com/weitrue/note/blob/master/python/algorithm/data_structure/strings.py">https://github.com/weitrue/note/blob/master/python/algorithm/data_structure/strings.py</a></p><h3 id="Array-and-List"><a href="#Array-and-List" class="headerlink" title="Array and List"></a>Array and List</h3><h4 id="array"><a href="#array" class="headerlink" title="array"></a>array</h4><p>定长，操作有限，但是节省内存；貌似我的生涯中还没用过，不过python3.5中我试了确实有array类，可以用import array直接导入。</p><h4 id="list"><a href="#list" class="headerlink" title="list"></a>list</h4><p>会预先分配内存，操作丰富，但是耗费内存。用sys.getsizeof做实验可以发现该结构非常类似C++ STL里的vector，是使用最频繁的数据结构。</p><ul><li>list.append: 如果之前没有分配够内存，会重新开辟新区域，然后复制之前的数据，复杂度退化</li><li>list.insert: 会移动被插入区域后所有元素,O(n)</li><li>list.pop: pop不同位置需要的复杂度不同pop(0)是O(1)复杂度,pop()首位O(n)复杂度</li><li>list[]: slice操作copy数据（预留空间）到另一个list</li></ul><p><a href="https://github.com/weitrue/note/blob/master/python/algorithm/data_structure/array_and_list.py">https://github.com/weitrue/note/blob/master/python/algorithm/data_structure/array_and_list.py</a></p><h3 id="Sets-and-Maps"><a href="#Sets-and-Maps" class="headerlink" title="Sets and Maps"></a>Sets and Maps</h3><h4 id="sets-ADT"><a href="#sets-ADT" class="headerlink" title="sets ADT"></a>sets ADT</h4><p>A set is a container that stores a collection of unique values over a given comparable domain in which the stored values have no particular ordering.</p><h4 id="Maps-or-Dict-ADT"><a href="#Maps-or-Dict-ADT" class="headerlink" title="Maps or Dict ADT"></a>Maps or Dict ADT</h4><p>python内部采用hash实现。</p><pre><code class="hljs Python"><span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">Module Description: 基于collections.OrderedDict实现LRU_cache(最近最少使用缓存算法)</span><span class="hljs-string">Problem:</span><span class="hljs-string">Solution：</span><span class="hljs-string">Date: 2020/2/13 </span><span class="hljs-string">Author: Wang P</span><span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> OrderedDict<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LURCache</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, capacity=<span class="hljs-number">128</span></span>):</span>        self._od = OrderedDict()        self._capacity = capacity    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get</span>(<span class="hljs-params">self, key</span>):</span>        <span class="hljs-keyword">if</span> key <span class="hljs-keyword">in</span> self._od:            val = self._od[key]            self._od.move_to_end(key)            <span class="hljs-keyword">return</span> val        <span class="hljs-keyword">else</span>:            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">push</span>(<span class="hljs-params">self, key, value</span>):</span>        <span class="hljs-keyword">if</span> key <span class="hljs-keyword">in</span> self._od:            <span class="hljs-keyword">del</span> self._od[key]            self._od[key] = value        <span class="hljs-keyword">else</span>:  <span class="hljs-comment"># insert</span>            self._od[key] = value            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(self._od) &gt; self._capacity:                self._od.popitem(last=<span class="hljs-literal">False</span>)    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">items</span>(<span class="hljs-params">self</span>):</span>        <span class="hljs-keyword">return</span> self._od.items()<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:    lru_cache = LURCache(<span class="hljs-number">3</span>)    lru_cache.push(<span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-number">1</span>)    lru_cache.push(<span class="hljs-string">&quot;2&quot;</span>, <span class="hljs-number">2</span>)    lru_cache.push(<span class="hljs-string">&quot;3&quot;</span>, <span class="hljs-number">3</span>)    lru_cache.push(<span class="hljs-string">&quot;4&quot;</span>, <span class="hljs-number">4</span>)    lru_cache.get(<span class="hljs-string">&quot;2&quot;</span>)    print(lru_cache.items())</code></pre><p><a href="https://github.com/weitrue/note/blob/master/python/algorithm/collections_examples/lru_cache.py">https://github.com/weitrue/note/blob/master/python/algorithm/collections_examples/lru_cache.py</a></p><h3 id="Algorithm-Analysis"><a href="#Algorithm-Analysis" class="headerlink" title="Algorithm Analysis"></a>Algorithm Analysis</h3><p>一般使用大O标记法来衡量算法的平均时间复杂度, 1 &lt; log(n) &lt; n &lt; nlog(n) &lt; n^2 &lt; n^3 &lt; a^n。 了解常用数据结构操作的平均时间复杂度有利于使用更高效的数据结构，当然有时候需要在时间和空间上进行衡量，有些操作甚至还会退化，比如list的append操作，如果list空间不够，会去开辟新的空间，操作复杂度退化到O(n)，有时候还需要使用均摊分析(amortized)。</p><h3 id="Searching"><a href="#Searching" class="headerlink" title="Searching"></a>Searching</h3><p>python内置了in操作符和bisect二分操作模块实现查找。</p><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">Module Description: 二分查找算法</span><span class="hljs-string">Problem:</span><span class="hljs-string">Solution：</span><span class="hljs-string">Date: 2020/1/20 </span><span class="hljs-string">Author: Wang P</span><span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">binary_search</span>(<span class="hljs-params">arr, target</span>):</span>    n = <span class="hljs-built_in">len</span>(arr)    left = <span class="hljs-number">0</span>    right = n - <span class="hljs-number">1</span>    <span class="hljs-keyword">while</span> left &lt;= right:        mid = (left + right) // <span class="hljs-number">2</span>        <span class="hljs-keyword">if</span> arr[mid] &lt; target:            left = mid + <span class="hljs-number">1</span>        <span class="hljs-keyword">elif</span> arr[mid] &gt; target:            right = mid - <span class="hljs-number">1</span>        <span class="hljs-keyword">else</span>:            print(<span class="hljs-string">f&quot;index: <span class="hljs-subst">&#123;mid&#125;</span>, value:<span class="hljs-subst">&#123;arr[mid]&#125;</span>&quot;</span>)            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:    l = [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>]    binary_search(l, <span class="hljs-number">8</span>)</code></pre><p><a href="https://github.com/weitrue/note/blob/master/python/algorithm/search/binary_search.py">https://github.com/weitrue/note/blob/master/python/algorithm/search/binary_search.py</a></p><h3 id="Sorting"><a href="#Sorting" class="headerlink" title="Sorting"></a>Sorting</h3><p>python内置了sorted方法来实现排序操作。</p><pre><code class="hljs Python"><span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">Module Description: 冒泡排序</span><span class="hljs-string">Problem:</span><span class="hljs-string">Solution：</span><span class="hljs-string">Date: 2020/3/23 </span><span class="hljs-string">Author: Wang P</span><span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-keyword">import</span> random<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BubbleSort</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bubble_sort</span>(<span class="hljs-params">self, arr</span>):</span>        <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">        冒泡排序</span><span class="hljs-string">        :param arr:</span><span class="hljs-string">        :return:</span><span class="hljs-string">        &quot;&quot;&quot;</span>        n = <span class="hljs-built_in">len</span>(arr)        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n-i<span class="hljs-number">-1</span>):                <span class="hljs-keyword">if</span> arr[j] &gt; arr[j+<span class="hljs-number">1</span>]:                    arr[j], arr[j+<span class="hljs-number">1</span>] = arr[j+<span class="hljs-number">1</span>], arr[j]<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:    list_a = [random.randint(<span class="hljs-number">0</span>, <span class="hljs-number">8</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>)]    print(list_a)    bs = BubbleSort()    bs.bubble_sort(list_a)    print(list_a)</code></pre><pre><code class="hljs Python"><span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">Module Description: 归并排序算法-分治法</span><span class="hljs-string">Problem:</span><span class="hljs-string">Solution：</span><span class="hljs-string">Date: 2020/2/15 </span><span class="hljs-string">Author: Wang P</span><span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MergeSort</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">merge_sort</span>(<span class="hljs-params">self, arr</span>):</span>        <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">        分治法分三步走，要注意出口</span><span class="hljs-string">        :param arr:</span><span class="hljs-string">        :return:</span><span class="hljs-string">        &quot;&quot;&quot;</span>        <span class="hljs-comment"># 递归出口</span>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(arr) &lt;= <span class="hljs-number">1</span>:            <span class="hljs-keyword">return</span> arr        <span class="hljs-keyword">else</span>:            mid = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">len</span>(arr)/<span class="hljs-number">2</span>)            left_half = self.merge_sort(arr[:mid])            right_half = self.merge_sort(arr[mid:])            <span class="hljs-keyword">return</span> self.merge_sorted_list(left_half, right_half)    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">merge_sorted_list</span>(<span class="hljs-params">self, list_a, list_b</span>):</span>        <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">        合并两个有序序列</span><span class="hljs-string">        :param list_a:</span><span class="hljs-string">        :param list_b:</span><span class="hljs-string">        :return:</span><span class="hljs-string">        &quot;&quot;&quot;</span>        length_a = <span class="hljs-built_in">len</span>(list_a)        length_b = <span class="hljs-built_in">len</span>(list_b)        a = b = <span class="hljs-number">0</span>        new_list = []        <span class="hljs-keyword">while</span> a &lt; length_a <span class="hljs-keyword">and</span> b &lt; length_b:            <span class="hljs-keyword">if</span> list_a[a] &lt; list_b[b]:                new_list.append(list_a[a])                a += <span class="hljs-number">1</span>            <span class="hljs-keyword">else</span>:                new_list.append(list_b[b])                b += <span class="hljs-number">1</span>        <span class="hljs-keyword">if</span> a &lt; length_a:            new_list.extend(list_a[a:])        <span class="hljs-keyword">if</span> b &lt; length_b:            new_list.extend(list_b[b:])        <span class="hljs-keyword">return</span> new_list<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:    <span class="hljs-keyword">import</span> random    ms = MergeSort()    ll = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>))    random.shuffle(ll)    print(ll)    ll = ms.merge_sort(ll)    print(ll)</code></pre><pre><code class="hljs Python"><span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">Module Description: 快速排序算法-分治法</span><span class="hljs-string">Problem:</span><span class="hljs-string">Solution：Partition:选择基准分割数组为两个字数组，小于基准和大于基准</span><span class="hljs-string">         对两个字数组分别快排</span><span class="hljs-string">         合并结果</span><span class="hljs-string">Date: 2020/2/15 </span><span class="hljs-string">Author: Wang P</span><span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-keyword">import</span> random<span class="hljs-keyword">import</span> pysnooper  <span class="hljs-comment"># 调试神器</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QuickSort</span>:</span><span class="hljs-meta">    @pysnooper.snoop()</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">quick_sort</span>(<span class="hljs-params">self, arr</span>):</span>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(arr) &lt; <span class="hljs-number">2</span>:            <span class="hljs-keyword">return</span> arr        pivot_index = <span class="hljs-number">0</span>  <span class="hljs-comment"># 第一个数作为pivot</span>        pivot = arr[pivot_index]        less_part = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> arr[pivot_index+<span class="hljs-number">1</span>:] <span class="hljs-keyword">if</span> i &lt; pivot]        great_part = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> arr[pivot_index+<span class="hljs-number">1</span>:] <span class="hljs-keyword">if</span> i &gt;= pivot]        <span class="hljs-keyword">return</span> self.quick_sort(less_part) + [pivot] + self.quick_sort(great_part)<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:    qs = QuickSort()    ll = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>))    random.shuffle(ll)    print(ll)    ll = qs.quick_sort(ll)    print(ll)</code></pre><pre><code class="hljs Python"><span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">Module Description: 拓扑排序</span><span class="hljs-string">Problem: 对应于该图的拓扑排序,每一个有向无环图都至少存在一种拓扑排序</span><span class="hljs-string">Solution：</span><span class="hljs-string">Date: 2020/3/23 </span><span class="hljs-string">Author: Wang P</span><span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-keyword">import</span> pysnooper<span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> Mapping<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TopologicalSort</span>:</span><span class="hljs-meta">    @pysnooper.snoop()  # pysnooper 调试神器</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">topological_sort</span>(<span class="hljs-params">self, graph: Mapping</span>):</span>        <span class="hljs-comment"># in_degrees = &#123;&#x27;a&#x27;： 0, &#x27;b&#x27;： 0, &#x27;c&#x27;： 0, &#x27;d&#x27;： 0, &#x27;e&#x27;： 0, &#x27;f&#x27;： 0&#125;</span>        in_degrees = <span class="hljs-built_in">dict</span>((u, <span class="hljs-number">0</span>) <span class="hljs-keyword">for</span> u <span class="hljs-keyword">in</span> graph)        <span class="hljs-keyword">for</span> u <span class="hljs-keyword">in</span> graph:            <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> graph[u]:  <span class="hljs-comment"># 根据键找出值也就是下级节点</span>                in_degrees[v] += <span class="hljs-number">1</span>  <span class="hljs-comment"># 对获取到的下级节点的入度加 1</span>        <span class="hljs-comment"># 循环结束之后的结果： &#123;&#x27;a&#x27;： 0, &#x27;b&#x27;： 1, &#x27;c&#x27;： 1, &#x27;d&#x27;： 2, &#x27;e&#x27;： 1, &#x27;f&#x27;： 4&#125;</span>        Q = [u <span class="hljs-keyword">for</span> u <span class="hljs-keyword">in</span> graph <span class="hljs-keyword">if</span> in_degrees[u] == <span class="hljs-number">0</span>]  <span class="hljs-comment"># 入度为 0 的节点</span>        in_degrees_zero = []        <span class="hljs-keyword">while</span> Q:            u = Q.pop()  <span class="hljs-comment"># 默认从最后一个移除</span>            in_degrees_zero.append(u)  <span class="hljs-comment"># 存储入度为 0 的节点</span>            <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> graph[u]:                in_degrees[v] -= <span class="hljs-number">1</span>  <span class="hljs-comment"># 删除入度为 0 的节点，以及移除其指向</span>                <span class="hljs-keyword">if</span> in_degrees[v] == <span class="hljs-number">0</span>:                    Q.append(v)        <span class="hljs-keyword">return</span> in_degrees_zero<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:    <span class="hljs-comment"># 用字典的键值表示图的节点之间的关系，键当前节点。值是后续节点。</span>    graph_dict = &#123;        <span class="hljs-string">&#x27;a&#x27;</span>: <span class="hljs-string">&#x27;bf&#x27;</span>,  <span class="hljs-comment"># 表示 a 指向 b 和 f</span>        <span class="hljs-string">&#x27;b&#x27;</span>: <span class="hljs-string">&#x27;cdf&#x27;</span>,        <span class="hljs-string">&#x27;c&#x27;</span>: <span class="hljs-string">&#x27;d&#x27;</span>,        <span class="hljs-string">&#x27;d&#x27;</span>: <span class="hljs-string">&#x27;ef&#x27;</span>,        <span class="hljs-string">&#x27;e&#x27;</span>: <span class="hljs-string">&#x27;f&#x27;</span>,        <span class="hljs-string">&#x27;f&#x27;</span>: <span class="hljs-string">&#x27;&#x27;</span>    &#125;    ts = TopologicalSort()    t = ts.topological_sort(graph_dict)    print(t)</code></pre><p><a href="https://github.com/weitrue/note/tree/master/python/algorithm/sort">https://github.com/weitrue/note/tree/master/python/algorithm/sort</a></p><h3 id="Linked-Structure"><a href="#Linked-Structure" class="headerlink" title="Linked Structure"></a>Linked Structure</h3><p>list是最常用的数据结构，但是list在中间增减元素的时候效率会很低，这时候linked list会更适合，缺点就是获取元素的平均时间复杂度变成了O(n)。</p><pre><code class="hljs Python"><span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">Module Description: 链表 </span><span class="hljs-string">Problem:</span><span class="hljs-string">Solution：</span><span class="hljs-string">Date: 2020/2/16 </span><span class="hljs-string">Author: Wang P</span><span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListNode</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, val</span>):</span>        self.val = val        self.<span class="hljs-built_in">next</span> = <span class="hljs-literal">None</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DeleteNode</span>:</span>    <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">    链表中删除一个节点（已知要删除的节点，不知链表的head）</span><span class="hljs-string">    思路：将要删除的链表节点node的值修改为node.next的值</span><span class="hljs-string">         node.next指向node.next.next</span><span class="hljs-string">         这样相当于删除了node节点</span><span class="hljs-string">    &quot;&quot;&quot;</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, node_list=<span class="hljs-literal">None</span>, node=<span class="hljs-literal">None</span></span>):</span>        <span class="hljs-keyword">if</span> node_list <span class="hljs-keyword">and</span> <span class="hljs-built_in">isinstance</span>(node_list, <span class="hljs-built_in">list</span>):            self._head = ListNode(node_list[<span class="hljs-number">0</span>])            cur_index = self._head            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(node_list)):                <span class="hljs-keyword">if</span> cur_index.val == node:                    self._node = cur_index                cur_index.<span class="hljs-built_in">next</span> = ListNode(node_list[i])                cur_index = cur_index.<span class="hljs-built_in">next</span>        <span class="hljs-keyword">else</span>:            self._head = <span class="hljs-literal">None</span>            self._node = <span class="hljs-literal">None</span><span class="hljs-meta">    @staticmethod</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">delete_node_in_a_linked_list</span>(<span class="hljs-params">node</span>):</span>        next_node = node.<span class="hljs-built_in">next</span>        next_next_node = node.<span class="hljs-built_in">next</span>.<span class="hljs-built_in">next</span>        node.val = next_node.val        node.<span class="hljs-built_in">next</span> = next_next_node    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">traversal</span>(<span class="hljs-params">self</span>):</span>        cur = self._head        link_list = []        <span class="hljs-keyword">while</span> cur:            link_list.append(cur.val)            cur = cur.<span class="hljs-built_in">next</span>        print(link_list)<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MergeLinkedList</span>:</span>    <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">    合并两个有序链表</span><span class="hljs-string">    思路：新建一个链表root，将list_one, list_two遍历，按大小放入root</span><span class="hljs-string">    &quot;&quot;&quot;</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, list_one=<span class="hljs-literal">None</span>, list_two=<span class="hljs-literal">None</span></span>):</span>        <span class="hljs-keyword">if</span> list_one <span class="hljs-keyword">and</span> <span class="hljs-built_in">isinstance</span>(list_one, <span class="hljs-built_in">list</span>) <span class="hljs-keyword">and</span> list_two <span class="hljs-keyword">and</span> <span class="hljs-built_in">isinstance</span>(list_two, <span class="hljs-built_in">list</span>):            self.list_one = ListNode(list_one[<span class="hljs-number">0</span>])            cur_index = self.list_one            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(list_one)):                cur_index.<span class="hljs-built_in">next</span> = ListNode(list_one[i])                cur_index = cur_index.<span class="hljs-built_in">next</span>            self.list_two = ListNode(list_two[<span class="hljs-number">0</span>])            cur_index = self.list_two            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(list_two)):                cur_index.<span class="hljs-built_in">next</span> = ListNode(list_two[i])                cur_index = cur_index.<span class="hljs-built_in">next</span>        <span class="hljs-keyword">else</span>:            self.list_one = <span class="hljs-literal">None</span>            self.list_two = <span class="hljs-literal">None</span>        self._head = <span class="hljs-literal">None</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">merge_linked_list</span>(<span class="hljs-params">self</span>):</span>        one_cur_val = self.list_one        two_cur_val = self.list_two        self._head = ListNode(<span class="hljs-literal">None</span>)        cur = self._head        <span class="hljs-keyword">while</span> one_cur_val <span class="hljs-keyword">and</span> two_cur_val:            <span class="hljs-keyword">if</span> one_cur_val.val &lt; two_cur_val.val:                node = ListNode(one_cur_val.val)                one_cur_val = one_cur_val.<span class="hljs-built_in">next</span>            <span class="hljs-keyword">else</span>:                node = ListNode(two_cur_val.val)                two_cur_val = two_cur_val.<span class="hljs-built_in">next</span>            cur.<span class="hljs-built_in">next</span> = node            cur = node        cur.<span class="hljs-built_in">next</span> = one_cur_val <span class="hljs-keyword">or</span> two_cur_val    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">traversal</span>(<span class="hljs-params">self</span>):</span>        cur = self._head.<span class="hljs-built_in">next</span>        link_list = []        <span class="hljs-keyword">while</span> cur:            link_list.append(cur.val)            cur = cur.<span class="hljs-built_in">next</span>        print(link_list)<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReverseLinkList</span>:</span>    <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">    单链表反转</span><span class="hljs-string">    &quot;&quot;&quot;</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, head=<span class="hljs-literal">None</span></span>):</span>        <span class="hljs-string">&quot;&quot;&quot;链表的头部&quot;&quot;&quot;</span>        self._head = head    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">self, val: <span class="hljs-built_in">int</span></span>):</span>        <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">        给链表添加元素</span><span class="hljs-string">        ：param val： 传过来的数字</span><span class="hljs-string">        ：return：</span><span class="hljs-string">        &quot;&quot;&quot;</span>        <span class="hljs-comment"># 创建一个节点</span>        node = ListNode(val)        <span class="hljs-keyword">if</span> self._head <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:            self._head = node        <span class="hljs-keyword">else</span>:            cur = self._head            <span class="hljs-keyword">while</span> cur.<span class="hljs-built_in">next</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:                cur = cur.<span class="hljs-built_in">next</span>  <span class="hljs-comment"># 移动游标</span>            cur.<span class="hljs-built_in">next</span> = node  <span class="hljs-comment"># 如果 next 后面没了证明以及到最后一个节点了</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">traversal</span>(<span class="hljs-params">self</span>):</span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self._head:            <span class="hljs-keyword">return</span>        cur = self._head        link_list = []        <span class="hljs-keyword">while</span> cur:            link_list.append(cur.val)            cur = cur.<span class="hljs-built_in">next</span>        print(link_list)    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">size</span>(<span class="hljs-params">self</span>):</span>        <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">        获取链表的大小</span><span class="hljs-string">        ：return：</span><span class="hljs-string">        &quot;&quot;&quot;</span>        count = <span class="hljs-number">0</span>        <span class="hljs-keyword">if</span> self._head <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:            <span class="hljs-keyword">return</span> count        <span class="hljs-keyword">else</span>:            cur = self._head            <span class="hljs-keyword">while</span> cur <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:                count += <span class="hljs-number">1</span>                cur = cur.<span class="hljs-built_in">next</span>            <span class="hljs-keyword">return</span> count    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reverse_link</span>(<span class="hljs-params">self</span>):</span>        <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">        单链表反转</span><span class="hljs-string">        思路：</span><span class="hljs-string">        让 cur.next 先断开即指向 none，指向设定 pre 游标指向断开的元素，然后</span><span class="hljs-string">        cur.next 指向断开的元素，再把开始 self._head 再最后一个元素的时候.</span><span class="hljs-string">        ：return：</span><span class="hljs-string">        &quot;&quot;&quot;</span>        <span class="hljs-keyword">if</span> self._head <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">or</span> self.size() == <span class="hljs-number">1</span>:            <span class="hljs-keyword">return</span>        <span class="hljs-keyword">else</span>:            pre = <span class="hljs-literal">None</span>            cur = self._head            <span class="hljs-keyword">while</span> cur <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:                post = cur.<span class="hljs-built_in">next</span>                cur.<span class="hljs-built_in">next</span> = pre                pre = cur                cur = post            self._head = pre  <span class="hljs-comment"># 逆向后的头节点</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LinkListIntersectionNode</span>:</span><span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">两个链表的的交叉节点</span><span class="hljs-string">&quot;&quot;&quot;</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_intersection_node</span>(<span class="hljs-params">self, headA, headB</span>):</span>        <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">        cur1、cur2，2 个指针的初始位置是链表 headA、headB 头结点，cur1、cur2 两个指针一直往后遍历。</span><span class="hljs-string">        直到 cur1 指针走到链表的末尾，然后 cur1 指向 headB；</span><span class="hljs-string">        直到 cur2 指针走到链表的末尾，然后 cur2 指向 headA；</span><span class="hljs-string">        然后再继续遍历；</span><span class="hljs-string">        每次 cur1、cur2 指向 None，则将 cur1、cur2 分别指向 headB、headA。</span><span class="hljs-string">        循环的次数越多，cur1、cur2 的距离越接近，直到 cur1 等于 cur2。则是两个链表的相交点。</span><span class="hljs-string">        ：tye head1, head1： ListNode</span><span class="hljs-string">        ：rtye： ListNode</span><span class="hljs-string">        &quot;&quot;&quot;</span>        <span class="hljs-keyword">if</span> headA <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> headB <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:            cur1, cur2 = headA, headB            <span class="hljs-keyword">while</span> cur1 != cur2:                cur1 = cur1.<span class="hljs-built_in">next</span> <span class="hljs-keyword">if</span> cur1 <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">else</span> headA                cur2 = cur2.<span class="hljs-built_in">next</span> <span class="hljs-keyword">if</span> cur2 <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">else</span> headB            <span class="hljs-keyword">return</span> cur1<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:    dn = DeleteNode([<span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">9</span>], <span class="hljs-number">3</span>)    dn.traversal()    dn.delete_node_in_a_linked_list(dn._node)    dn.traversal()    mn = MergeLinkedList([<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">7</span>])    mn.merge_linked_list()    mn.traversal()    r_link = ReverseLinkList()    r_link.add(<span class="hljs-number">3</span>)    r_link.add(<span class="hljs-number">5</span>)    r_link.add(<span class="hljs-number">6</span>)    r_link.add(<span class="hljs-number">7</span>)    r_link.add(<span class="hljs-number">8</span>)    print(<span class="hljs-string">&quot;对链表进行遍历&quot;</span>)    r_link.traversal()    print(<span class="hljs-string">f&quot;size：<span class="hljs-subst">&#123;r_link.size()&#125;</span>&quot;</span>)    print(<span class="hljs-string">&quot;对链表进行逆向操作之后&quot;</span>)    r_link.reverse_link()    r_link.traversal()</code></pre><p><a href="https://github.com/weitrue/note/blob/master/python/algorithm/data_structure/link_list_cases.py">https://github.com/weitrue/note/blob/master/python/algorithm/data_structure/link_list_cases.py</a></p><h3 id="Advanced-Linked-Lists"><a href="#Advanced-Linked-Lists" class="headerlink" title="Advanced Linked Lists"></a>Advanced Linked Lists</h3><h4 id="Doubly-Linked-List"><a href="#Doubly-Linked-List" class="headerlink" title="Doubly Linked List"></a>Doubly Linked List</h4><p>双链表，每个节点多了个prev指向前一个节点。双链表可以用来编写文本编辑器的buffer。</p><h4 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h4><p>利用循环双端链表我们可以实现一个经典的缓存失效算法，lru：</p><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span>      <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, prev=<span class="hljs-literal">None</span>, <span class="hljs-built_in">next</span>=<span class="hljs-literal">None</span>, key=<span class="hljs-literal">None</span>, value=<span class="hljs-literal">None</span></span>):</span>        self.prev, self.<span class="hljs-built_in">next</span>, self.key, self.value = prev, <span class="hljs-built_in">next</span>, key, value               <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CircularDoubleLinkedList</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span>      <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span>        node = Node()        node.prev, node.<span class="hljs-built_in">next</span> = node, node        self.rootnode = node            <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">headnode</span>(<span class="hljs-params">self</span>):</span>        <span class="hljs-keyword">return</span> self.rootnode.<span class="hljs-built_in">next</span>          <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">tailnode</span>(<span class="hljs-params">self</span>):</span>        <span class="hljs-keyword">return</span> self.rootnode.prev          <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">remove</span>(<span class="hljs-params">self, node</span>):</span>        <span class="hljs-keyword">if</span> node <span class="hljs-keyword">is</span> self.rootnode:            <span class="hljs-keyword">return</span>        <span class="hljs-keyword">else</span>:            node.prev.<span class="hljs-built_in">next</span> = node.<span class="hljs-built_in">next</span>            node.<span class="hljs-built_in">next</span>.prev = node.prev                <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">append</span>(<span class="hljs-params">self, node</span>):</span>        tailnode = self.tailnode()        tailnode.<span class="hljs-built_in">next</span> = node        node.<span class="hljs-built_in">next</span> = self.rootnode        self.rootnode.prev = node                <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LRUCache</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span>      <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, maxsize=<span class="hljs-number">16</span></span>):</span>        self.maxsize = maxsize        self.cache = &#123;&#125;        self.access = CircularDoubleLinkedList()        self.isfull = <span class="hljs-built_in">len</span>(self.cache) &gt;= self.maxsize            <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__call__</span>(<span class="hljs-params">self, func</span>):</span>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wrapper</span>(<span class="hljs-params">n</span>):</span>            cachenode = self.cache.get(n)            <span class="hljs-keyword">if</span> cachenode <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:  <span class="hljs-comment"># hit</span>                self.access.remove(cachenode)                self.access.append(cachenode)                <span class="hljs-keyword">return</span> cachenode.value            <span class="hljs-keyword">else</span>:  <span class="hljs-comment"># miss</span>                value = func(n)                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.isfull:                    tailnode = self.access.tailnode()                    newnode = Node(tailnode, self.access.rootnode, n, value)                    self.access.append(newnode)                    self.cache[n] = newnode                    self.isfull = <span class="hljs-built_in">len</span>(self.cache) &gt;= self.maxsize                    <span class="hljs-keyword">return</span> value                <span class="hljs-keyword">else</span>:  <span class="hljs-comment"># full</span>                    lru_node = self.access.headnode()                    <span class="hljs-keyword">del</span> self.cache[lru_node.key]                    self.access.remove(lru_node)                    tailnode = self.access.tailnode()                    newnode = Node(tailnode, self.access.rootnode, n, value)                    self.access.append(newnode)                    self.cache[n] = newnode                <span class="hljs-keyword">return</span> value        <span class="hljs-keyword">return</span> wrapper            <span class="hljs-meta">@LRUCache()</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fib</span>(<span class="hljs-params">n</span>):</span>    <span class="hljs-keyword">if</span> n &lt;= <span class="hljs-number">2</span>:        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>    <span class="hljs-keyword">else</span>:        <span class="hljs-keyword">return</span> fib(n - <span class="hljs-number">1</span>) + fib(n - <span class="hljs-number">2</span>)            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>):    print(fib(i))        <span class="hljs-comment"># 输出</span><span class="hljs-number">1</span><span class="hljs-number">1</span><span class="hljs-number">2</span><span class="hljs-number">3</span><span class="hljs-number">5</span><span class="hljs-number">8</span><span class="hljs-number">13</span><span class="hljs-number">21</span><span class="hljs-number">34</span></code></pre><h3 id="Stacks"><a href="#Stacks" class="headerlink" title="Stacks"></a>Stacks</h3><p>栈，一种后进先出的数据结构。</p><pre><code class="hljs Python"><span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">Module Description: 基队列实现栈</span><span class="hljs-string">Problem:</span><span class="hljs-string">Solution：基于collections.deque实现栈</span><span class="hljs-string">          基于 2 个队列实现</span><span class="hljs-string">          基于 1 个队列实现</span><span class="hljs-string">Date: 2020/2/15 </span><span class="hljs-string">Author: Wang P</span><span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> deque<span class="hljs-keyword">from</span> queue <span class="hljs-keyword">import</span> Queue<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Stack</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span>        self.items = deque()    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">push</span>(<span class="hljs-params">self, val</span>):</span>        self.items.append(val)    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">top</span>(<span class="hljs-params">self</span>):</span>        <span class="hljs-keyword">return</span> self.items[<span class="hljs-number">-1</span>]    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pop</span>(<span class="hljs-params">self</span>):</span>        <span class="hljs-keyword">return</span> self.items.pop()    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">empty</span>(<span class="hljs-params">self</span>):</span>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(self.items) == <span class="hljs-number">0</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyStack</span>:</span>    <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">    使用 2 个队列实现</span><span class="hljs-string">    &quot;&quot;&quot;</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span>        <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">        初始化</span><span class="hljs-string">        &quot;&quot;&quot;</span>        <span class="hljs-comment"># q1 作为进栈出栈，q2 作为中转站</span>        self.q1 = Queue()        self.q2 = Queue()    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">push</span>(<span class="hljs-params">self, x</span>):</span>        <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">        入栈</span><span class="hljs-string">        ：type x： int</span><span class="hljs-string">        ：rtype： void</span><span class="hljs-string">        &quot;&quot;&quot;</span>        self.q1.put(x)    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pop</span>(<span class="hljs-params">self</span>):</span>        <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">        出栈</span><span class="hljs-string">        ：rtype： int</span><span class="hljs-string">        &quot;&quot;&quot;</span>        <span class="hljs-keyword">while</span> self.q1.qsize() &gt; <span class="hljs-number">1</span>:            self.q2.put(self.q1.get())  <span class="hljs-comment"># 将 q1 中除尾元素外的所有元素转到 q2 中</span>        <span class="hljs-keyword">if</span> self.q1.qsize() == <span class="hljs-number">1</span>:            res = self.q1.get()  <span class="hljs-comment"># 弹出 q1 的最后一个元素</span>            self.q1, self.q2 = self.q2, self.q1  <span class="hljs-comment"># 交换 q1,q2</span>            <span class="hljs-keyword">return</span> res    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">top</span>(<span class="hljs-params">self</span>):</span>        <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">        栈顶</span><span class="hljs-string">        ：rtype： int</span><span class="hljs-string">        &quot;&quot;&quot;</span>        <span class="hljs-keyword">while</span> self.q1.qsize() &gt; <span class="hljs-number">1</span>:            self.q2.put(self.q1.get())  <span class="hljs-comment"># 将 q1 中除尾元素外的所有元素转到 q2 中</span>        <span class="hljs-keyword">if</span> self.q1.qsize() == <span class="hljs-number">1</span>:            res = self.q1.get()  <span class="hljs-comment"># 弹出 q1 的最后一个元素</span>            self.q2.put(res)  <span class="hljs-comment"># 与 pop 唯一不同的是需要将 q1 最后一个元素保存到 q2 中</span>            self.q1, self.q2 = self.q2, self.q1  <span class="hljs-comment"># 交换 q1,q2</span>            <span class="hljs-keyword">return</span> res    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">empty</span>(<span class="hljs-params">self</span>):</span>        <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">        判断是否为空</span><span class="hljs-string">        ：rtype： bool</span><span class="hljs-string">        &quot;&quot;&quot;</span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">bool</span>(self.q1.qsize() + self.q2.qsize())  <span class="hljs-comment"># 为空返回 True，不为空返回 False</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyStack2</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span>    <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">    使用 1 个队列实现</span><span class="hljs-string">    &quot;&quot;&quot;</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span>        <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">        初始化</span><span class="hljs-string">        &quot;&quot;&quot;</span>        self.sq1 = Queue()    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">push</span>(<span class="hljs-params">self, x</span>):</span>        <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">        入栈</span><span class="hljs-string">        ：type x： int</span><span class="hljs-string">        ：rtype： void</span><span class="hljs-string">        &quot;&quot;&quot;</span>        self.sq1.put(x)    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pop</span>(<span class="hljs-params">self</span>):</span>        <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">        出栈</span><span class="hljs-string">        ：rtype： int</span><span class="hljs-string">        &quot;&quot;&quot;</span>        count = self.sq1.qsize()        <span class="hljs-keyword">if</span> count == <span class="hljs-number">0</span>:            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>        <span class="hljs-keyword">while</span> count &gt; <span class="hljs-number">1</span>:            x = self.sq1.get()            self.sq1.put(x)            count -= <span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> self.sq1.get()    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">top</span>(<span class="hljs-params">self</span>):</span>        <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">        Get the top element.</span><span class="hljs-string">        ：rtype： int</span><span class="hljs-string">        &quot;&quot;&quot;</span>        count = self.sq1.qsize()        <span class="hljs-keyword">if</span> count == <span class="hljs-number">0</span>:            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>        <span class="hljs-keyword">while</span> count:            x = self.sq1.get()            self.sq1.put(x)            count -= <span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> x    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">empty</span>(<span class="hljs-params">self</span>):</span>        <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">        Returns whether the stack is empty.</span><span class="hljs-string">        ：rtype： bool</span><span class="hljs-string">        &quot;&quot;&quot;</span>        <span class="hljs-keyword">return</span> self.sq1.empty()<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:    obj = MyStack2()    obj.push(<span class="hljs-number">1</span>)    obj.push(<span class="hljs-number">3</span>)    print(obj.pop())    obj.push(<span class="hljs-number">4</span>)    print(obj.pop())    print(obj.pop())    print(obj.empty())</code></pre><p><a href="https://github.com/weitrue/note/blob/master/python/algorithm/data_structure/stack_cases.py">https://github.com/weitrue/note/blob/master/python/algorithm/data_structure/stack_cases.py</a></p><h3 id="Queues"><a href="#Queues" class="headerlink" title="Queues"></a>Queues</h3><p>队列也是经常使用的数据结构，比如发送消息等，celery可以使用redis提供的list实现消息队列。</p><pre><code class="hljs Python"><span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">Module Description: 基于collections.deque实现队列</span><span class="hljs-string">                    基于栈实现队列</span><span class="hljs-string">Problem:</span><span class="hljs-string">Solution：</span><span class="hljs-string">Date: 2020/2/15 </span><span class="hljs-string">Author: Wang P</span><span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> deque<span class="hljs-keyword">from</span> examples.example_0x_cases.algorithm.data_structure.stack_cases <span class="hljs-keyword">import</span> Stack<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Queue</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span>        self.items = deque()    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">push</span>(<span class="hljs-params">self, val</span>):</span>        self.items.append(val)    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pop</span>(<span class="hljs-params">self</span>):</span>        <span class="hljs-keyword">return</span> self.items.popleft()    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">empty</span>(<span class="hljs-params">self</span>):</span>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(self.items) == <span class="hljs-number">0</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QueueByStack</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span>        self.stack_one = Stack()        self.stack_two = Stack()    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">push</span>(<span class="hljs-params">self, val</span>):</span>        self.stack_one.push(val)    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pop</span>(<span class="hljs-params">self</span>):</span>        <span class="hljs-keyword">if</span> self.stack_two.empty():            <span class="hljs-keyword">if</span> self.stack_one.empty():                <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;nil&#x27;</span>            <span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> self.stack_one.empty():                self.stack_two.push(self.stack_one.pop())        <span class="hljs-keyword">return</span> self.stack_two.pop()    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">peek</span>(<span class="hljs-params">self</span>):</span>        <span class="hljs-keyword">if</span> self.stack_two.empty():            <span class="hljs-keyword">if</span> self.stack_one.empty():                <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;nil&#x27;</span>            <span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> self.stack_one.empty():                self.stack_two.push(self.stack_one.pop())        <span class="hljs-keyword">return</span> self.stack_two.top()    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">empty</span>(<span class="hljs-params">self</span>):</span>        <span class="hljs-keyword">return</span> self.stack_two<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:    qu = QueueByStack()    qu.push(<span class="hljs-number">1</span>)    qu.push(<span class="hljs-number">2</span>)    qu.push(<span class="hljs-number">3</span>)    print(qu.pop())    print(qu.peek())    print(qu.pop())    print(qu.pop())    print(qu.pop())</code></pre><p><a href="https://github.com/weitrue/note/blob/master/python/algorithm/data_structure/queue_cases.py">https://github.com/weitrue/note/blob/master/python/algorithm/data_structure/queue_cases.py</a></p><h2 id="Binary-Tree"><a href="#Binary-Tree" class="headerlink" title="Binary Tree"></a>Binary Tree</h2><p>二叉树，每个节点做多只有两个子节点</p><pre><code class="hljs Python"><span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">Module Description: 二叉树的遍历：前序、中序、后序、层次遍历</span><span class="hljs-string">                    二叉树的反转</span><span class="hljs-string">Problem:</span><span class="hljs-string">Solution：</span><span class="hljs-string">Date: 2020/2/16 </span><span class="hljs-string">Author: Wang P</span><span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, val, left, right</span>):</span>        self.val, self.left, self.right = val, left, right<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BinTreeTravel</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, node_list=<span class="hljs-literal">None</span></span>):</span>        <span class="hljs-keyword">if</span> node_list <span class="hljs-keyword">and</span> <span class="hljs-built_in">isinstance</span>(node_list, <span class="hljs-built_in">list</span>):            tree_node_list = []            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(node_list)):                tree_node_list.append(TreeNode(node_list[i], <span class="hljs-literal">None</span>, <span class="hljs-literal">None</span>))            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(node_list)):                <span class="hljs-keyword">if</span> i * <span class="hljs-number">2</span> + <span class="hljs-number">1</span> &lt;= <span class="hljs-built_in">len</span>(tree_node_list) - <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> i * <span class="hljs-number">2</span> + <span class="hljs-number">2</span> &lt;= <span class="hljs-built_in">len</span>(tree_node_list) - <span class="hljs-number">1</span>:                    tree_node_list[i].left = tree_node_list[i * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>]                    tree_node_list[i].right = tree_node_list[i * <span class="hljs-number">2</span> + <span class="hljs-number">2</span>]                <span class="hljs-keyword">elif</span> i * <span class="hljs-number">2</span> + <span class="hljs-number">1</span> &lt;= <span class="hljs-built_in">len</span>(tree_node_list) - <span class="hljs-number">1</span> &lt; i * <span class="hljs-number">2</span> + <span class="hljs-number">2</span>:                    tree_node_list[i].left = tree_node_list[i * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>]                <span class="hljs-keyword">else</span>:                    <span class="hljs-keyword">break</span>            self.root = tree_node_list[<span class="hljs-number">0</span>]    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pre_order_travel</span>(<span class="hljs-params">self, sub_tree</span>):</span>        <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">        先序遍历</span><span class="hljs-string">        :param sub_tree:</span><span class="hljs-string">        :return:</span><span class="hljs-string">        &quot;&quot;&quot;</span>        <span class="hljs-keyword">if</span> sub_tree:            print(sub_tree.val)            self.pre_order_travel(sub_tree.left)            self.pre_order_travel(sub_tree.right)    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">in_order_travel</span>(<span class="hljs-params">self, sub_tree</span>):</span>        <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">        中序遍历</span><span class="hljs-string">        :param sub_tree:</span><span class="hljs-string">        :return:</span><span class="hljs-string">        &quot;&quot;&quot;</span>        <span class="hljs-keyword">if</span> sub_tree:            self.in_order_travel(sub_tree.left)            print(sub_tree.val)            self.in_order_travel(sub_tree.right)    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">post_order_travel</span>(<span class="hljs-params">self, sub_tree</span>):</span>        <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">        后序遍历</span><span class="hljs-string">        :param sub_tree:</span><span class="hljs-string">        :return:</span><span class="hljs-string">        &quot;&quot;&quot;</span>        <span class="hljs-keyword">if</span> sub_tree:            self.post_order_travel(sub_tree.left)            self.post_order_travel(sub_tree.right)            print(sub_tree.val)    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">level_order_travel</span>(<span class="hljs-params">self, root</span>):</span>        <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">        层次遍历</span><span class="hljs-string">        :param root:</span><span class="hljs-string">        :return: list[list[int]]</span><span class="hljs-string">        &quot;&quot;&quot;</span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:            print([])            <span class="hljs-keyword">return</span>        cur_nodes = [root]        next_nodes = []        print([i.val <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> cur_nodes])        <span class="hljs-keyword">while</span> cur_nodes <span class="hljs-keyword">or</span> next_nodes:            <span class="hljs-keyword">for</span> node <span class="hljs-keyword">in</span> cur_nodes:                <span class="hljs-keyword">if</span> node.left:                    next_nodes.append(node.left)                <span class="hljs-keyword">if</span> node.right:                    next_nodes.append(node.right)            <span class="hljs-keyword">if</span> next_nodes:                print([i.val <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> next_nodes])            cur_nodes = next_nodes            next_nodes = []<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReverseBinaryTree</span>:</span>    <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">    反转二叉树</span><span class="hljs-string">               1                         1</span><span class="hljs-string">            3     4                   4     3</span><span class="hljs-string">         5   7  8   9      =&gt;       9  8  7   5</span><span class="hljs-string">      10                                        10</span><span class="hljs-string">    &quot;&quot;&quot;</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, node_list=<span class="hljs-literal">None</span></span>):</span>        <span class="hljs-keyword">if</span> node_list <span class="hljs-keyword">and</span> <span class="hljs-built_in">isinstance</span>(node_list, <span class="hljs-built_in">list</span>):            tree_node_list = []            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(node_list)):                tree_node_list.append(TreeNode(node_list[i], <span class="hljs-literal">None</span>, <span class="hljs-literal">None</span>))            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(node_list)):                <span class="hljs-keyword">if</span> i * <span class="hljs-number">2</span> + <span class="hljs-number">1</span> &lt;= <span class="hljs-built_in">len</span>(tree_node_list) - <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> i * <span class="hljs-number">2</span> + <span class="hljs-number">2</span> &lt;= <span class="hljs-built_in">len</span>(tree_node_list) - <span class="hljs-number">1</span>:                    tree_node_list[i].left = tree_node_list[i * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>]                    tree_node_list[i].right = tree_node_list[i * <span class="hljs-number">2</span> + <span class="hljs-number">2</span>]                <span class="hljs-keyword">elif</span> i * <span class="hljs-number">2</span> + <span class="hljs-number">1</span> &lt;= <span class="hljs-built_in">len</span>(tree_node_list) - <span class="hljs-number">1</span> &lt; i * <span class="hljs-number">2</span> + <span class="hljs-number">2</span>:                    tree_node_list[i].left = tree_node_list[i * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>]                <span class="hljs-keyword">else</span>:                    <span class="hljs-keyword">break</span>            self.root = tree_node_list[<span class="hljs-number">0</span>]    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reverse_tree</span>(<span class="hljs-params">self, root</span>):</span>        <span class="hljs-keyword">if</span> root <span class="hljs-keyword">and</span> root.left <span class="hljs-keyword">and</span> root.right:            root.left, root.right = root.right, root.left            self.reverse_tree(root.left)            self.reverse_tree(root.right)        self.root = root<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FindTreeKthSmallest</span>:</span>    <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">    二叉搜索树中第 K 小的元素</span><span class="hljs-string">    二叉搜索树按照中序遍历的顺序打印出来正好就是排序好的顺序。所以对其遍历一个节点就进行计数，计数达到 k 的时候就结束。</span><span class="hljs-string">    &quot;&quot;&quot;</span>    count = <span class="hljs-number">0</span>    node_val = <span class="hljs-number">0</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">kth_smallest</span>(<span class="hljs-params">self, root: TreeNode, k</span>):</span>        <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">        ：type root： TreeNode</span><span class="hljs-string">        ：type k： int</span><span class="hljs-string">        ：rtype： int</span><span class="hljs-string">        &quot;&quot;&quot;</span>        self.dfs(root, k)        <span class="hljs-keyword">return</span> self.node_val    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dfs</span>(<span class="hljs-params">self, node: TreeNode, k</span>):</span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node:            <span class="hljs-keyword">return</span>        self.dfs(node.left, k)        self.count = self.count + <span class="hljs-number">1</span>        <span class="hljs-keyword">if</span> self.count == k:            self.node_val = node.val            <span class="hljs-comment"># 将该节点的左右子树置为 None,来结束递归，减少时间复杂度</span>            node.left = <span class="hljs-literal">None</span>            node.right = <span class="hljs-literal">None</span>        self.dfs(node.right, k)<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:    bt = BinTreeTravel([<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>])    bt.pre_order_travel(bt.root)    bt.in_order_travel(bt.root)    bt.post_order_travel(bt.root)    bt.level_order_travel(bt.root)    print(<span class="hljs-string">&quot;#################################################&quot;</span>)    it = ReverseBinaryTree()    it.reverse_tree(bt.root)    bt.pre_order_travel(bt.root)</code></pre><p><a href="https://github.com/weitrue/note/blob/master/python/algorithm/data_structure/tree_cases.py">https://github.com/weitrue/note/blob/master/python/algorithm/data_structure/tree_cases.py</a></p><h3 id="Heap"><a href="#Heap" class="headerlink" title="Heap"></a>Heap</h3><p>二叉树最直接的一个应用就是实现堆。堆就是一颗完全二叉树，最大堆的非叶子节点的值都比孩子大，最小堆的非叶子结点的值都比孩子小。 python内置了heapq模块帮助我们实现堆操作，比如用内置的heapq模块实现个堆排序</p><pre><code class="hljs Python"><span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">Module Description: 获取大量元素中 top-n 大个元素，固定内存</span><span class="hljs-string">Problem:</span><span class="hljs-string">Solution：</span><span class="hljs-string">Date: 2020/2/16 </span><span class="hljs-string">Author: Wang P</span><span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-keyword">import</span> heapq<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TopN</span>:</span>    <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">    先放入元素前n个建立小顶堆</span><span class="hljs-string">    迭代剩余元素：</span><span class="hljs-string">        如果当前元素小于堆顶元素，跳过该元素</span><span class="hljs-string">        否则退换堆顶元素为当前元素，并重新调整堆</span><span class="hljs-string">    &quot;&quot;&quot;</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, iterable, n</span>):</span>        self.min_heap = []        self.capacity = n        self.iterable = iterable    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">push</span>(<span class="hljs-params">self, val</span>):</span>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(self.min_heap) &gt;= self.capacity:            min_val = self.min_heap[<span class="hljs-number">0</span>]            <span class="hljs-keyword">if</span> val &lt; min_val:  <span class="hljs-comment"># 可以省略</span>                <span class="hljs-keyword">pass</span>            <span class="hljs-keyword">else</span>:                heapq.heapreplace(self.min_heap, val)  <span class="hljs-comment"># 返回并且pop堆顶最小值，推入心得val并调整堆</span>        <span class="hljs-keyword">else</span>:            heapq.heapreplace(self.min_heap, val)  <span class="hljs-comment"># 前n个元素直接放入堆中</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_top_n</span>(<span class="hljs-params">self</span>):</span>        <span class="hljs-keyword">for</span> val <span class="hljs-keyword">in</span> self.iterable:            self.push(val)        <span class="hljs-keyword">return</span> self.min_heap</code></pre><p><a href="https://github.com/weitrue/note/blob/master/python/algorithm/data_structure/heap_cases.py">https://github.com/weitrue/note/blob/master/python/algorithm/data_structure/heap_cases.py</a></p><h3 id="Hash-Tables"><a href="#Hash-Tables" class="headerlink" title="Hash Tables"></a>Hash Tables</h3><p>基于比较的搜索（线性搜索，有序数组的二分搜索）最好的时间复杂度只能达到O(logn)，利用hash可以实现O(1)查找，python内置dict的实现方式就是hash，你会发现dict的key必须要是实现了 <code>__hash__</code> 和 <code>__eq__</code> 方法的。</p><p>Hashing: hashing is the process of mapping a search a key to a limited range of array indeices with the goal of providing direct access to the keys.</p><p>hash方法有个hash函数用来给key计算一个hash值，作为数组下标，放到该下标对应的槽中。当不同key根据hash函数计算得到的下标相同时，就出现了冲突。解决冲突有很多方式，比如让每个槽成为链表，每次冲突以后放到该槽链表的尾部，但是查询时间就会退化，不再是O(1)。还有一种探查方式，当key的槽冲突时候，就会根据一种计算方式去寻找下一个空的槽存放，探查方式有线性探查，二次方探查法等，cpython解释器使用的是二次方探查法。还有一个问题就是当python使用的槽数量大于预分配的2/3时候，会重新分配内存并拷贝以前的数据，所以有时候dict的add操作代价还是比较高的，牺牲空间但是可以始终保证O(1)的查询效率。如果有大量的数据，建议还是使用bloomfilter或者redis提供的HyperLogLog。</p><p>如果感兴趣，可以看看这篇文章，介绍c解释器如何实现的python dict对象：<a href="http://www.laurentluce.com/posts/python-dictionary-implementation/">Python dictionary implementation</a>。我们使用Python来实现一个类似的hash结构。</p><h3 id="Recursion"><a href="#Recursion" class="headerlink" title="Recursion"></a>Recursion</h3><p>递归函数：Recursion is a process for solving problems by subdividing a larger problem into smaller cases of the problem itself and then solving the smaller, more trivial parts.</p><p>Properties of Recursion: 使用stack解决的问题都能用递归解决</p><ul><li>A recursive solution must contain a base case; 递归出口，代表最小子问题(n == 0退出打印)</li><li>A recursive solution must contain a recursive case; 可以分解的子问题</li><li>A recursive solution must make progress toward the base case. 递减n使得n像递归出口靠近</li></ul><p>Tail Recursion: occurs when a function includes a single recursive call as the last statement of the function. In this case, a stack is not needed to store values to te used upon the return of the recursive call and thus a solution can be implemented using a iterative loop instead.</p>]]></content>
    
    
    <categories>
      
      <category>ADT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>ADT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【ALL】HDFS:Hadoop分布式文件系统</title>
    <link href="/2020/11/09/Hadoop-HDFS/"/>
    <url>/2020/11/09/Hadoop-HDFS/</url>
    
    <content type="html"><![CDATA[<blockquote><p> HDFS is the primary distributed storage used by Hadoop applications. A HDFS cluster primarily consists of a NameNode that manages the file system metadata and DataNodes that store the actual data. The HDFS Architecture Guide describes HDFS in detail. This user guide primarily deals with the interaction of users and administrators with HDFS clusters. The HDFS architecture diagram depicts basic interactions among NameNode, the DataNodes, and the clients. Clients contact NameNode for file metadata or file modifications and perform actual file I/O directly with the DataNodes.<a id="more"></a> </p></blockquote><h3 id="大数据全链路架构"><a href="#大数据全链路架构" class="headerlink" title="大数据全链路架构"></a>大数据全链路架构</h3><p>数据在生产环境中的流向及处理流程</p><p><img src="/images/hdfs/image-20190629152840146.png"></p><h3 id="大数据主流框架"><a href="#大数据主流框架" class="headerlink" title="大数据主流框架"></a>大数据主流框架</h3><p>1 第一代大数据框架: 各自为战</p><p><img src="/images/hdfs/image-20190629153348534.png"></p><p>2 第二代大数据计算框架</p><p><img src="/images/hdfs/image-20190629153652036.png"></p><p>3 第三代大数据计算框架 Flink</p><p><img src="/images/hdfs/image-20190629153835100.png"></p><h3 id="Hadoop的架构模块"><a href="#Hadoop的架构模块" class="headerlink" title="Hadoop的架构模块"></a>Hadoop的架构模块</h3><div align="center">  <img src="/images/hdfs/image-20200414134203318.png" alt="image-20200414134203318" style="zoom:50%;align: center"></div><ul><li>Hadoop由三个模块组成：**<em>分布式**</em>存储HDFS、分布式计算MapReduce、资源调度引擎Yarn</li></ul><div align="center">  <img src="/images/hdfs/image-20200414134230170.png" alt="image-20200414134230170" style="zoom: 33%;align: center"></div><pre><code class="hljs markdown"><span class="hljs-bullet">-</span> HDFS模块：<span class="hljs-bullet">  -</span>  namenode：主节点，主要负责集群的管理以及元数据信息管理<span class="hljs-bullet">  -</span>  datanode：从节点，主要负责存储用户数据<span class="hljs-bullet">  -</span>  secondaryNameNode：辅助namenode管理元数据信息，以及元数据信息的冷备份<span class="hljs-bullet">-</span> Yarn模块：<span class="hljs-bullet">  -</span> ResourceManager：主节点，主要负责资源分配<span class="hljs-bullet">  -</span> NodeManager：从节点，主要负责执行任务</code></pre><h3 id="HDFS功能模块"><a href="#HDFS功能模块" class="headerlink" title="HDFS功能模块"></a>HDFS功能模块</h3><h4 id="hdfs的架构"><a href="#hdfs的架构" class="headerlink" title="hdfs的架构"></a>hdfs的架构</h4><h5 id="文件分块存储-amp-3副本"><a href="#文件分块存储-amp-3副本" class="headerlink" title="文件分块存储&amp;3副本"></a>文件分块存储&amp;3副本</h5><p><img src="/images/hdfs/block3.gif"></p><p><img src="/images/hdfs/image-20200414151438737.png"></p><ul><li><p>保存文件到HDFS时，会先默认按**<em>128M**</em>的大小对文件进行切分；效果如上图</p><ul><li>数据以block块的形式进统一存储管理，每个block块默认最多可以存储128M的文件。</li><li>如果有一个文件大小为1KB，也是要占用一个block块，但是实际占用磁盘空间还是1KB大小，类似于有一个水桶可以装128斤的水，但是我只装了1斤的水，那么我的水桶里面水的重量就是1斤，而不是128斤</li></ul></li><li><p>每个block块的元数据大小大概为150字节</p></li><li><p>所有的文件都是以block块的方式存放在HDFS文件系统当中，在hadoop1当中，文件的block块默认大小是64M，hadoop2当中，文件的block块大小默认是128M，block块的大小可以通过hdfs-site.xml当中的配置文件进行指定</p></li></ul><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>dfs.block.size<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>块大小 以字节为单位<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><span class="hljs-comment">&lt;!-- 只写数值就可以 --&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span></code></pre><ul><li><p>为了保证block块的安全性，也就是数据的安全性，在hadoop2当中，文件默认保存**<em>三个副本**</em>，我们可以更改副本数以提高数据的安全性</p></li><li><p>在hdfs-site.xml当中修改以下配置属性，即可更改文件的副本数</p></li></ul><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>dfs.replication<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span></code></pre><h5 id="抽象成数据块的好处"><a href="#抽象成数据块的好处" class="headerlink" title="抽象成数据块的好处"></a>抽象成数据块的好处</h5><ol><li><p>一个文件有可能大于集群中任意一个磁盘<br>10T*3/128 = xxx块 2T，2T，2T 文件方式存—–&gt;多个block块，这些block块属于一个文件</p></li><li><p>使用块抽象而不是文件可以简化存储子系统</p><p>hdfs将所有的文件全部抽象成为block块来进行存储，不管文件大小，全部一视同仁都是以block块的形式进行存储，方便我们的分布式文件系统对文件的管理</p></li><li><p>块非常适合用于数据备份进而提供数据容错能力和可用性</p></li></ol><h5 id="HDFS架构"><a href="#HDFS架构" class="headerlink" title="HDFS架构"></a>HDFS架构</h5><p><img src="/images/hdfs/image-20200416160250256.png"></p><ul><li>HDFS集群包括，NameNode和DataNode以及Secondary Namenode。<ul><li>NameNode负责管理整个文件系统的元数据，以及每一个路径（文件）所对应的数据块信息。</li><li>DataNode 负责管理用户的文件数据块，每一个数据块都可以在多个datanode上存储多个副本。</li><li>Secondary NameNode用来监控HDFS状态的辅助后台程序，每隔一段时间获取HDFS元数据的快照。最主要作用是辅助namenode管理元数据信息</li></ul></li><li>NameNode与Datanode的总结概述</li></ul><p><img src="/images/hdfs/image-20200416160339310.png"></p><h5 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h5><p>块缓存</p><ul><li><p>通常DataNode从磁盘中读取块，但对于访问频繁的文件，其对应的块可能被显示的缓存在DataNode的内存中，以堆外块缓存的形式存在。默认情况下，一个块仅缓存在一个DataNode的内存中，当然可以针对每个文件配置DataNode的数量。作业调度器通过在缓存块的DataNode上运行任务，可以利用块缓存的优势提高读操作的性能。</p><p>例如：<br> 连接（join）操作中使用的一个小的查询表就是块缓存的一个很好的候选。<br> 用户或应用通过在缓存池中增加一个cache directive来告诉namenode需要缓存哪些文件及存多久。缓存池（cache pool）是一个拥有管理缓存权限和资源使用的管理性分组</p></li></ul><p>hdfs的文件权限验证</p><ul><li><p>hdfs的文件权限机制与linux系统的文件权限机制类似</p><p>r:read  w:write x:execute 权限x对于文件表示忽略，对于文件夹表示是否有权限访问其内容</p><p>如果linux系统用户zhangsan使用hadoop命令创建一个文件，那么这个文件在HDFS当中的owner就是zhangsan</p><p>HDFS文件权限的目的，防止好人做错事，而不是阻止坏人做坏事。HDFS相信你告诉我你是谁，你就是谁</p></li></ul><h4 id="HDFS的shell命令操作"><a href="#HDFS的shell命令操作" class="headerlink" title="HDFS的shell命令操作"></a>HDFS的shell命令操作</h4><ul><li>HDFS命令有两种风格：<ul><li>hadoop fs开头的</li><li>hdfs dfs开头的</li><li>两种命令均可使用，效果相同</li></ul></li></ul><p>查看hdfs或hadoop子命令的帮助信息，如ls子命令</p><pre><code class="hljs shell">hdfs dfs -help lshadoop fs -help ls #两个命令等价</code></pre><p>查看hdfs文件系统中指定目录的文件列表。对比linux命令ls</p><pre><code class="hljs shell">hdfs dfs -ls /hadoop fs -ls /hdfs dfs -ls -R /</code></pre><p>在hdfs文件系统中创建文件</p><pre><code class="hljs shell">hdfs dfs -touchz /edits.txt</code></pre><p>向HDFS文件中追加内容</p><pre><code class="hljs shell">hadoop fs -appendToFile edit1.xml /edits.txt #将本地磁盘当前目录的edit1.xml内容追加到HDFS根目录 的edits.txt文件</code></pre><p>查看HDFS文件内容</p><pre><code class="hljs shell">hdfs dfs -cat /edits.txt</code></pre><p>从本地路径上传文件至HDFS</p><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">用法：hdfs dfs -put /本地路径 /hdfs路径</span>hdfs dfs -put /linux本地磁盘文件 /hdfs路径文件hdfs dfs -copyFromLocal /linux本地磁盘文件 /hdfs路径文件  #跟put作用一样hdfs dfs -moveFromLocal /linux本地磁盘文件 /hdfs路径文件  #跟put作用一样，只不过，源文件被拷贝成功后，会被删除</code></pre><p>在hdfs文件系统中下载文件</p><pre><code class="hljs shell">hdfs dfs -get /hdfs路径 /本地路径hdfs dfs -copyToLocal /hdfs路径 /本地路径  #根get作用一样</code></pre><p>在hdfs文件系统中创建目录</p><pre><code class="hljs shell">hdfs dfs -mkdir /shell</code></pre><p>在hdfs文件系统中删除文件</p><pre><code class="hljs shell">hdfs dfs -rm /edits.txt</code></pre><p>在hdfs文件系统中修改文件名称（也可以用来移动文件到目录）</p><pre><code class="hljs shell">hdfs dfs -mv /xcall.sh /call.shhdfs dfs -mv /call.sh /shell</code></pre><p>在hdfs中拷贝文件到目录</p><pre><code class="hljs shell">hdfs dfs -cp /xrsync.sh /shell</code></pre><p>递归删除目录</p><pre><code class="hljs shell">hdfs dfs -rm -r /shell</code></pre><p>列出本地文件的内容（默认是hdfs文件系统）</p><pre><code class="hljs shell">hdfs dfs -ls file:///home/hadoop/</code></pre><p>查找文件</p><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> linux find命令</span>find . -name &#x27;edit*&#x27;<span class="hljs-meta">#</span><span class="bash"> HDFS find命令</span>hadoop fs -find / -name part-r-00000 # 在HDFS根目录中，查找part-r-00000文件</code></pre><h4 id="HDFS安全模式"><a href="#HDFS安全模式" class="headerlink" title="HDFS安全模式"></a>HDFS安全模式</h4><ul><li>安全模式是HDFS所处的一种特殊状态，在这种状态下，文件系统只接受读数据请求，而不接受删除、修改等变更请求。在NameNode主节点启动时，HDFS首先进入安全模式，DataNode在启动的时候会向namenode汇报可用的block等状态，当整个系统达到安全标准时，HDFS自动离开安全模式。如果HDFS出于安全模式下，则文件block不能进行任何的副本复制操作，因此达到最小的副本数量要求是基于datanode启动时的状态来判定的，启动时不会再做任何复制（从而达到最小副本数量要求），hdfs集群刚启动的时候，默认30S钟的时间是出于安全期的，只有过了30S之后，集群脱离了安全期，然后才可以对集群进行操作</li><li>何时推出安全模式<ul><li>namenode知道集群共多少个block（不考虑副本），假设值是total；</li><li>namenode启动后，会上报block report，namenode开始累加统计满足最小副本数（默认1）的block个数，假设是num</li><li>当num/total &gt; 99.9%时，推出安全模式</li></ul></li></ul><pre><code class="hljs shell">[hadoop@node01 hadoop]$ hdfs dfsadmin -safemode  Usage: hdfs dfsadmin [-safemode enter | leave | get | wait]</code></pre><h4 id="NameNode和SecondaryNameNode"><a href="#NameNode和SecondaryNameNode" class="headerlink" title="NameNode和SecondaryNameNode"></a>NameNode和SecondaryNameNode</h4><h5 id="namenode与secondaryName"><a href="#namenode与secondaryName" class="headerlink" title="namenode与secondaryName"></a>namenode与secondaryName</h5><ul><li><p>NameNode主要负责集群当中的元数据信息管理，而且元数据信息需要经常随机访问，因为元数据信息必须高效的检索，那么如何保证namenode快速检索呢？？元数据信息保存在哪里能够快速检索呢？？如何保证元数据的持久安全呢？？</p></li><li><p>为了保证元数据信息的快速检索，那么我们就必须将元数据存放在内存当中，因为在内存当中元数据信息能够最快速的检索，那么随着元数据信息的增多（每个block块大概占用150字节的元数据信息），内存的消耗也会越来越多。</p></li><li><p>如果所有的元数据信息都存放内存，服务器断电，内存当中所有数据都消失，为了保证元数据的安全持久，元数据信息必须做可靠的持久化，在hadoop当中为了持久化存储元数据信息，将所有的元数据信息保存在了FSImage文件当中，那么FSImage随着时间推移，必然越来越膨胀，FSImage的操作变得越来越难，为了解决元数据信息的增删改，hadoop当中还引入了元数据操作日志edits文件，edits文件记录了客户端操作元数据的信息，随着时间的推移，edits信息也会越来越大，为了解决edits文件膨胀的问题，hadoop当中引入了secondaryNamenode来专门做fsimage与edits文件的合并</p></li></ul><p><img src="/images/hdfs/checkpoint.gif"></p><h5 id="namenode工作机制"><a href="#namenode工作机制" class="headerlink" title="namenode工作机制"></a>namenode工作机制</h5><p>（1）第一次启动namenode格式化后，创建fsimage和edits文件。如果不是第一次启动，直接加载编辑日志和镜像文件到内存。</p><p>（2）客户端对元数据进行增删改的请求</p><p>（3）namenode记录操作日志，更新滚动日志。</p><p>（4）namenode在内存中对数据进行增删改查</p><h5 id="Secondary-NameNode工作"><a href="#Secondary-NameNode工作" class="headerlink" title="Secondary NameNode工作"></a>Secondary NameNode工作</h5><p>（1）Secondary NameNode询问namenode是否需要checkpoint。直接带回namenode是否检查结果。</p><p>（2）Secondary NameNode请求执行checkpoint。</p><p>（3）namenode滚动正在写的edits日志</p><p>（4）将滚动前的编辑日志和镜像文件拷贝到Secondary NameNode</p><p>（5）Secondary NameNode加载编辑日志和镜像文件到内存，并合并。</p><p>（6）生成新的镜像文件fsimage.chkpoint</p><p>（7） 拷贝fsimage.chkpoint到namenode</p><p>（8）namenode将fsimage.chkpoint重新命名成fsimage</p><h5 id="FSImage与edits详解"><a href="#FSImage与edits详解" class="headerlink" title="FSImage与edits详解"></a>FSImage与edits详解</h5><ul><li>所有的元数据信息都保存在了FsImage与Eidts文件当中，这两个文件就记录了所有的数据的元数据信息，元数据信息的保存目录配置在了hdfs-site.xml当中</li></ul><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>dfs.namenode.name.dir<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>file:///weitrue/install/hadoop-2.6.0-cdh5.14.2/hadoopDatas/namenodeDatas<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>dfs.namenode.edits.dir<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>file:///weitrue/install/hadoop-2.6.0-cdh5.14.2/hadoopDatas/dfs/nn/edits<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span></code></pre><ul><li><p>客户端对hdfs进行写文件时会首先被记录在edits文件中。</p><p>edits修改时元数据也会更新。</p><p>每次hdfs更新时edits先更新后客户端才会看到最新信息。</p><p>fsimage:是namenode中关于元数据的镜像，一般称为检查点。</p><p>一般开始时对namenode的操作都放在edits中，为什么不放在fsimage中呢？</p><p>因为fsimage是namenode的完整的镜像，内容很大，如果每次都加载到内存的话生成树状拓扑结构，这是非常耗内存和CPU。</p><p>fsimage内容包含了namenode管理下的所有datanode中文件及文件block及block所在的datanode的元数据信息。随着edits内容增大，就需要在一定时间点和fsimage合并。</p></li></ul><h5 id="FSimage文件当中的文件信息查看"><a href="#FSimage文件当中的文件信息查看" class="headerlink" title="FSimage文件当中的文件信息查看"></a>FSimage文件当中的文件信息查看</h5><ul><li><p>官方查看文档</p><p><a href="http://archive.cloudera.com/cdh5/cdh/5/hadoop-2.6.0-cdh5.14.0/hadoop-project-dist/hadoop-hdfs/HdfsImageViewer.html">http://archive.cloudera.com/cdh5/cdh/5/hadoop-2.6.0-cdh5.14.2/hadoop-project-dist/hadoop-hdfs/HdfsImageViewer.html</a></p></li><li><p>使用命令 hdfs oiv </p></li></ul><pre><code class="hljs shell">cd  /weitrue/install/hadoop-2.6.0-cdh5.14.2/hadoopDatas/namenodeDatas/currenthdfs oiv -i fsimage_0000000000000000864 -p XML -o hello.xml</code></pre><h5 id="edits当中的文件信息查看"><a href="#edits当中的文件信息查看" class="headerlink" title="edits当中的文件信息查看"></a>edits当中的文件信息查看</h5><ul><li><p>官方查看文档</p><p><a href="http://archive.cloudera.com/cdh5/cdh/5/hadoop-2.6.0-cdh5.14.0/hadoop-project-dist/hadoop-hdfs/HdfsEditsViewer.html">http://archive.cloudera.com/cdh5/cdh/5/hadoop-2.6.0-cdh5.14.2/hadoop-project-dist/hadoop-hdfs/HdfsEditsViewer.html</a></p></li><li><p>查看命令 hdfs oev</p></li></ul><pre><code class="hljs shell">cd /weitrue/install/hadoop-2.6.0-cdh5.14.2/hadoopDatas/dfs/nn/editshdfs oev -i edits_0000000000000000865-0000000000000000866 -o myedit.xml -p XML</code></pre><h5 id="secondarynameNode如何辅助管理FSImage与Edits文件"><a href="#secondarynameNode如何辅助管理FSImage与Edits文件" class="headerlink" title="secondarynameNode如何辅助管理FSImage与Edits文件"></a>secondarynameNode如何辅助管理FSImage与Edits文件</h5><h5 id="namenode元数据信息多目录配置"><a href="#namenode元数据信息多目录配置" class="headerlink" title="namenode元数据信息多目录配置"></a>namenode元数据信息多目录配置</h5><ul><li><p>为了保证元数据的安全性，我们一般都是先确定好我们的磁盘挂载目录，将元数据的磁盘做RAID1</p><p>namenode的本地目录可以配置成多个，且每个目录存放内容相同，增加了可靠性。</p></li><li><p>具体配置如下：</p><p>hdfs-site.xml</p></li></ul><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>dfs.namenode.name.dir<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>file:///weitrue/install/hadoop-2.6.0-cdh5.14.2/hadoopDatas/namenodeDatas<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>Bdata</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hadoop</tag>
      
      <tag>大数据</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Linux】Docker安装与使用</title>
    <link href="/2020/06/24/docker/"/>
    <url>/2020/06/24/docker/</url>
    
    <content type="html"><![CDATA[<blockquote><p>Developers bring their ideas to life with Docker<a id="more"></a> </p></blockquote><h3 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a><strong>官方文档</strong></h3><p><a href="https://links.jianshu.com/go?to=https://docs.docker.com/install/linux/docker-ce/centos/">https://docs.docker.com/install/linux/docker-ce/centos/</a></p><h3 id="安装方式"><a href="#安装方式" class="headerlink" title="安装方式"></a><strong>安装方式</strong></h3><ul><li>设置docker源的方式来安装(简单， 官方推荐)</li><li>下载rpm包的方式安装(适用于离线环境)</li><li>使用脚本安装(适用于测试和开发环境)</li></ul><h4 id="docker源方式安装"><a href="#docker源方式安装" class="headerlink" title="docker源方式安装"></a><strong>docker源方式安装</strong></h4><p>（1）更新yum， 安装依赖</p><pre><code class="hljs shell">yum updateyum install -y yum-utils device-mapper-persistent-data lvm2</code></pre><p><img src="/images/docker/1.png"></p><p>（2）将docker源添加到系统中</p><pre><code class="hljs shell">yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</code></pre><p><img src="/images/docker/1-1.png"></p><p>（3）Docker安装</p><pre><code class="hljs shell">yum install docker-ce docker-ce-cli containerd.io</code></pre><p>此时，可能会报错：</p><p><img src="/images/docker/2.png"></p><p>该图中原因是</p><p>containerd.io此软件包已经安装，并且是较低版本，与要安装的docker-ce所依赖containerd.io的版本不符，因此最好安装较新版本的containerd.io</p><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 下面网址可以看到一系列版本的containerd.io</span>https://download.docker.com/linux/centos/7/x86_64/edge/Packages/<span class="hljs-meta">#</span><span class="bash">wget 命令下载指定版本的containerd.io（如果未安装wget，需要yum -y install wget）</span>wget https://download.docker.com/linux/centos/7/x86_64/edge/Packages/containerd.io-1.2.6-3.3.el7.x86_64.rpm</code></pre><p><img src="/images/docker/3.png"></p><p> 重新执行安装命令</p><pre><code class="hljs shell">yum -y install docker-ce</code></pre><p><img src="/images/docker/4.png"></p><p>（4）Docker启动设置-—启动docker和添加开启自启动</p><pre><code class="hljs shell">systemctl enable dockersystemctl start docker</code></pre><p><img src="/images/docker/5.png"></p><p>（5）查看Docker版本</p><pre><code class="hljs shell">docker -v</code></pre><h3 id="Docker使用"><a href="#Docker使用" class="headerlink" title="Docker使用"></a><strong>Docker使用</strong></h3><h4 id="docker命令"><a href="#docker命令" class="headerlink" title="docker命令"></a><strong>docker命令</strong></h4><p>（1）命令帮助（-h已被弃用）</p><pre><code class="hljs shell">docker --help</code></pre><p>（2）常用选项说明</p><ul><li><p>-d, –detach=false， 指定容器运行于前台还是后台，默认为false</p></li><li><p>-i, –interactive=false， 打开STDIN，用于控制台交互</p></li><li><p>-t, –tty=false， 分配tty设备，该可以支持终端登录，默认为false</p></li><li><p>-u, –user=””， 指定容器的用户</p></li><li><p>-a, –attach=[]， 登录容器（必须是以docker run -d启动的容器）</p></li><li><p>-w, –workdir=””， 指定容器的工作目录</p></li><li><p>-c, –cpu-shares=0， 设置容器CPU权重，在CPU共享场景使用</p></li><li><p>-e, –env=[]， 指定环境变量，容器中可以使用该环境变量</p></li><li><p>-m, –memory=””， 指定容器的内存上限</p></li><li><p>-P, –publish-all=false， 指定容器暴露的端口</p></li><li><p>-p, –publish=[]， 指定容器暴露的端口</p></li><li><p>-h, –hostname=””， 指定容器的主机名</p></li><li><p>-v, –volume=[]， 给容器挂载存储卷，挂载到容器的某个目录</p></li><li><p>–volumes-from=[]， 给容器挂载其他容器上的卷，挂载到容器的某个目录</p></li><li><p>–cap-add=[]， 添加权限，权限清单详见：<a href="http://linux.die.net/man/7/capabilities">http://linux.die.net/man/7/capabilities</a></p></li><li><p>–cap-drop=[]， 删除权限，权限清单详见：<a href="http://linux.die.net/man/7/capabilities">http://linux.die.net/man/7/capabilities</a></p></li><li><p>–cidfile=””， 运行容器后，在指定文件中写入容器PID值，一种典型的监控系统用法</p></li><li><p>–cpuset=””， 设置容器可以使用哪些CPU，此参数可以用来容器独占CPU</p></li><li><p>–device=[]， 添加主机设备给容器，相当于设备直通</p></li><li><p>–dns=[]， 指定容器的dns服务器</p></li><li><p>–dns-search=[]， 指定容器的dns搜索域名，写入到容器的/etc/resolv.conf文件</p></li><li><p>–entrypoint=””， 覆盖image的入口点</p></li><li><p>–env-file=[]， 指定环境变量文件，文件格式为每行一个环境变量</p></li><li><p>–expose=[]， 指定容器暴露的端口，即修改镜像的暴露端口</p></li><li><p>–link=[]， 指定容器间的关联，使用其他容器的IP、env等信息</p></li><li><p>–lxc-conf=[]， 指定容器的配置文件，只有在指定–exec-driver=lxc时使用</p></li><li><p>–name=””， 指定容器名字，后续可以通过名字进行容器管理，links特性需要使用名字</p></li><li><p>–net=”bridge”， 容器网络设置:</p></li><li><ul><li>bridge 使用docker daemon指定的网桥</li><li>host //容器使用主机的网络</li><li>container:NAME_or_ID &gt;//使用其他容器的网路，共享IP和PORT等网络资源</li><li>none 容器使用自己的网络（类似–net=bridge），但是不进行配置</li></ul></li><li><p>–privileged=false， 指定容器是否为特权容器，特权容器拥有所有的capabilities</p></li><li><p>–restart=”no”， 指定容器停止后的重启策略:</p></li><li><ul><li>no：容器退出时不重启</li><li>on-failure：容器故障退出（返回值非零）时重启</li><li>always：容器退出时总是重启</li></ul></li><li><p>–rm=false， 指定容器停止后自动删除容器(不支持以docker run -d启动的容器)</p></li><li><p>–sig-proxy=true， 设置由代理接受并处理信号，但是SIGCHLD、SIGSTOP和SIGKILL不能被代理</p></li></ul><h4 id="部署-运行镜像"><a href="#部署-运行镜像" class="headerlink" title="部署/运行镜像"></a><strong>部署/运行镜像</strong></h4><h5 id="pull方式"><a href="#pull方式" class="headerlink" title="pull方式"></a><strong>pull方式</strong></h5><p>（1）下载命令</p><pre><code class="hljs shell">docker pull 镜像名</code></pre><p>（2）[例如]下载gitlab</p><pre><code class="hljs shell">docker pull gitlab/gitlab-ce</code></pre><p>下载的镜像所在位置（其中一个）</p><pre><code class="hljs shell">cd var/lib/docker/containers</code></pre><p><img src="/images/docker/6.png"></p><p>（3）查看镜像详细信息</p><pre><code class="hljs shell">docker inspect gitlab/gitlab-ce</code></pre><p>（4）运行镜像</p><pre><code class="hljs shell">docker run --detach \  --hostname 127.0.0.1 \  --publish 10443:443 --publish 1080:80 --publish 1022:22 \  --name gitlab \  --restart always \  --volume /srv/gitlab/config:/etc/gitlab \  --volume /srv/gitlab/logs:/var/log/gitlab \  --volume /srv/gitlab/data:/var/opt/gitlab \  gitlab/gitlab-ce:latest</code></pre><p>这里，</p><p>127.0.0.1为服务器IP地址；</p><p>–publish 10443:443 –publish 1080:80 –publish 1022:22 是指将443端口对外映射（暴露）成10443，22端口对外映射（暴露）成1022，80端口对外映射（暴露）成1080。</p><p>（5）访问gitlab</p><p><img src="/images/docker/7.png"></p><h5 id="容器化方式（github-com上项目）"><a href="#容器化方式（github-com上项目）" class="headerlink" title="容器化方式（github.com上项目）"></a><strong>容器化方式（github.com上项目）</strong></h5><blockquote><p>待更新</p></blockquote><h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a><strong>常用命令</strong></h4><p>（1）查看镜像</p><pre><code class="hljs shell">docker ps -a</code></pre><p>这里docker ps 的命令包括： </p><ul><li>-a 列出所有容器 </li><li>-l 列出最新创建容器 </li><li>-n=2 列出最近创建的2个容器 </li><li>-q 仅列出容器ID </li><li>-s 显示容器大小 </li></ul><p><img src="/images/docker/8.png"></p><p>其中，</p><p>CONTAINER ID：容器ID</p><p>IMAGE：镜像名</p><p><strong>注意</strong>：如果容器正在运行是无法删除，需要先停止</p><p>（2）stop容器</p><pre><code class="hljs shell">docker stop&lt;容器ID或容器名&gt;</code></pre><p><img src="/images/docker/9.png"></p><p>（3）删除容器</p><pre><code class="hljs shell">docker rm &lt;容器ID或容器名&gt;</code></pre><p>（4）删除镜像</p><pre><code class="hljs shell">docker rmi &lt;镜像ID或镜像名&gt;</code></pre><p>镜像ID可以通过docker images</p><pre><code class="hljs shell">docker images</code></pre><p><img src="/images/docker/10.png"></p><p>或docker image ls</p><pre><code class="hljs shell">docker image ls</code></pre><p><img src="/images/docker/11.png"></p><p>（5）进入容器Console</p><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 进入控制台</span>docker exec -it [container name] [/bin/sh|bash]<span class="hljs-meta">#</span><span class="bash"> 退出</span>exit</code></pre><h4 id="docker磁盘占用"><a href="#docker磁盘占用" class="headerlink" title="docker磁盘占用"></a><strong>docker磁盘占用</strong></h4><h5 id="查看系统磁盘占用情况"><a href="#查看系统磁盘占用情况" class="headerlink" title="查看系统磁盘占用情况"></a>查看系统磁盘占用情况</h5><pre><code class="hljs shell">[root@docker-app ~]# df -h</code></pre><h5 id="查看docker工作目录占用磁盘情况"><a href="#查看docker工作目录占用磁盘情况" class="headerlink" title="查看docker工作目录占用磁盘情况"></a>查看docker工作目录占用磁盘情况</h5><pre><code class="hljs shell">[root@docker-app ~]# du -hs /var/lib/docker</code></pre><h5 id="docker-system-df"><a href="#docker-system-df" class="headerlink" title="docker system df"></a>docker system df</h5><pre><code class="hljs shell">[root@docker-app ~]# docker system dfTYPE                TOTAL               ACTIVE              SIZE                RECLAIMABLEImages              3                   3                   2.422GB             0B (0%)Containers          3                   3                   1.676MB             0B (0%)Local Volumes       2                   2                   251.4kB             0B (0%)Build Cache         0                   0                   0B                  0B</code></pre><h5 id="自动清理磁盘"><a href="#自动清理磁盘" class="headerlink" title="自动清理磁盘"></a>自动清理磁盘</h5><pre><code class="hljs shell">[root@docker-app ~]# docker system pruneWARNING! This will remove:  - all stopped containers  - all networks not used by at least one container  - all dangling images  - all dangling build cache 该指令默认会清除所有如下资源：已停止的容器（container）未被任何容器所使用的卷（volume）未被任何容器所关联的网络（network）所有悬空镜像（image）该指令默认只会清除悬空镜像，未被使用的镜像不会被删除。添加 -a 或 --all 参数后，可以一并清除所有未使用的镜像和悬空镜像。可以添加 -f 或 --force 参数用以忽略相关告警确认信息注意:docker system prune -a命令清理得更加彻底，可以将没有容器使用Docker镜像都删掉。这两个命令会把你暂时关闭的容器，以及暂时没有用到的Docker镜像都删掉了…所以使用之前一定要想清楚。</code></pre><h5 id="手动清理"><a href="#手动清理" class="headerlink" title="手动清理"></a>手动清理</h5><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 查找<span class="hljs-string">&quot;/&quot;</span>目录下所有大于100M的所有文件</span>[root@docker-app ~]# find / -type f -size +100M -print0 | xargs -0 du -h | sort -nrfind: ‘/proc/7572/task/7572/fdinfo/6’: 没有那个文件或目录find: ‘/proc/7572/fdinfo/5’: 没有那个文件或目录find: ‘/proc/7687’: 没有那个文件或目录184M/srv/gitlab/data/prometheus/data/01F4Q52GBKGYAXCQE37V2GMS70.tmp/chunks/000001138M/var/lib/rpm/Packages102M/usr/lib/locale/locale-archive32G   /var/lib/docker/containers/&#123;container_id&#125;/&#123;container_id&#125;-json.log0/proc/kcore</code></pre><p>发现<code>/var/lib/docker/containers/&#123;container_id&#125;/</code>下存在数据较大的<code>*-json.log</code>日志文件，百度发现这是docker容器运行的<code>标准输入日志</code>，遂删除之。项目中已使用<code>-v</code>的方式挂载项目输出日志文件，因此对容器运行日志没有了需求，研究后发现在构建参数的时候可以对标准输入日志<code>大小</code>与<code>数量</code>进行限制，以减少日志文件对存储空间的占用，以下配置分别为日志文件最大容量、最大日志文件数。</p><pre><code class="hljs shell">docker run ...... --log-opt max-size=10m --log-opt max-file=1</code></pre><p>新建或修改/etc/docker/daemon.json，添加log-dirver和log-opts参数</p><pre><code class="hljs shell">&#123;   &quot;log-driver&quot;:&quot;json-file&quot;,   &quot;log-opts&quot;: &#123;&quot;max-size&quot;:&quot;10m&quot;, &quot;max-file&quot;:&quot;1&quot;&#125;&#125;</code></pre><h4 id="修改映射端口"><a href="#修改映射端口" class="headerlink" title="修改映射端口"></a><strong>修改映射端口</strong></h4><h5 id="重新部署镜像"><a href="#重新部署镜像" class="headerlink" title="重新部署镜像"></a><strong>重新部署镜像</strong></h5><h5 id="修改部署容器配置文件"><a href="#修改部署容器配置文件" class="headerlink" title="修改部署容器配置文件"></a><strong>修改部署容器配置文件</strong></h5><p>（1）停止需要修改的容器</p><pre><code class="hljs shell">docker ps -a docker stop &lt;容器ID或容器名&gt;</code></pre><p>（2）找到hostconfig.json文件</p><pre><code class="hljs shell">cd /var/lib/docker/containers/&lt;容器ID目录,例如651dcd904c5eec9617ea006f2ac3e59a9a015de237cae891fc5ef46a17bd3033&gt;</code></pre><p><img src="/images/docker/12.png"></p><p>（3）修改hostconfig.json文件中”PortBindings”配置</p><pre><code class="hljs shell">vim hostconfig.json</code></pre><p><img src="/images/docker/13.png"></p><p>（4）重启docker[非常重要]，否则修改会失效</p><pre><code class="hljs shell">systemctl restart docker</code></pre><p>（5）启动修改后的容器</p><pre><code class="hljs shell">docker start &lt;容器ID或容器名&gt;</code></pre><p>（6）查看是否修改成功</p><pre><code class="hljs shell">docker ps -a</code></pre><p><img src="/images/docker/14.png"></p><h3 id="Docker镜像部署容器"><a href="#Docker镜像部署容器" class="headerlink" title="Docker镜像部署容器"></a><strong>Docker镜像部署容器</strong></h3><h4 id="拉取远端镜像方式"><a href="#拉取远端镜像方式" class="headerlink" title="拉取远端镜像方式"></a><strong>拉取远端镜像方式</strong></h4><h5 id="部署portainer（docker可视化管理工具）"><a href="#部署portainer（docker可视化管理工具）" class="headerlink" title="部署portainer（docker可视化管理工具）"></a><strong>部署portainer（docker可视化管理工具）</strong></h5><pre><code class="hljs shell">docker pull docker.io/portainer/portainerdocker run --detach \    --hostname 127.0.0.1 \    --publish 9000:9000 \    --name portainer\    --restart=always \    --volume /var/run/docker.sock:/var/run/docker.sock \    docker.io/portainer/portainer</code></pre><h5 id="部署gitlab（私有代码库）"><a href="#部署gitlab（私有代码库）" class="headerlink" title="部署gitlab（私有代码库）"></a><strong>部署gitlab（私有代码库）</strong></h5><h6 id="拉取镜像并启动"><a href="#拉取镜像并启动" class="headerlink" title="拉取镜像并启动"></a>拉取镜像并启动</h6><pre><code class="hljs shell">docker pull gitlab/gitlab-cedocker run --detach \  --publish 443:443 --publish 80:80 --publish 1022:22 \  --name gitlab \  --restart always \  --volume /srv/gitlab/config:/etc/gitlab \  --volume /srv/gitlab/logs:/var/log/gitlab \  --volume /srv/gitlab/data:/var/opt/gitlab \  gitlab/gitlab-ce:latest</code></pre><h6 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h6><blockquote><p>等待docker运行gitlab一小段时间后在操作，否则可能出现文件找不到</p></blockquote><p><strong>gitlab.yml文件</strong></p><pre><code class="hljs shell">vim /srv/gitlab/data/gitlab-rails/etc/gitlab.yml<span class="hljs-meta">#</span><span class="bash"> 找到如下配置</span><span class="hljs-meta">  #</span><span class="bash"><span class="hljs-comment"># GitLab settings</span></span>  gitlab:    ## Web server settings (note: host is the FQDN, do not include http://)    host: xx.xx.xx.xx   # 此处替换为自己的ip    port: 80    https: false</code></pre><p><strong>gitlab.rb文件</strong></p><pre><code class="hljs shell">vim /srv/gitlab/config/gitlab.rb</code></pre><p>找到<code>external_url</code>，默认是被注释的。</p><p>如果打开，填写暴露出去的<code>http://ip:port</code>，<code>IP</code>一定要和<code>gitlab.yml</code>文件配置的相同，<code>port</code>为你启动时指定的，这里使用默认<code>80</code>作为端口。</p><p>最后加上ssh协议下使用的IP和端口(这里的端口是启动时指定的，这里是<code>1022</code>)，最后保存并退出。</p><pre><code class="hljs shell">external_url &#x27;http://xx.xx.xx.xx:80&#x27;gitlab_rails[&#x27;gitlab_ssh_host&#x27;] = &#x27;xx.xx.xx.xx&#x27;gitlab_rails[&#x27;gitlab_shell_ssh_host&#x27;] = &#x27;1022&#x27;</code></pre><h6 id="停止并移除之前启动的gitlab"><a href="#停止并移除之前启动的gitlab" class="headerlink" title="停止并移除之前启动的gitlab"></a>停止并移除之前启动的gitlab</h6><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 停止并移除之前启动的GitLab容器</span>docker rm -f gitlab</code></pre><h6 id="重新启动gitlab"><a href="#重新启动gitlab" class="headerlink" title="重新启动gitlab"></a>重新启动gitlab</h6><pre><code class="hljs shell">docker pull gitlab/gitlab-cedocker run --detach \  --publish 443:443 --publish 80:80 --publish 1022:22 \  --name gitlab \  --restart always \  --volume /srv/gitlab/config:/etc/gitlab \  --volume /srv/gitlab/logs:/var/log/gitlab \  --volume /srv/gitlab/data:/var/opt/gitlab \  gitlab/gitlab-ce:latest</code></pre><p>等待一段时间，就可以访问了，首次需要更改<code>root</code>账户的密码</p><h5 id="部署gitlab-runner"><a href="#部署gitlab-runner" class="headerlink" title="部署gitlab-runner"></a><strong>部署gitlab-runner</strong></h5><h6 id="全局配置"><a href="#全局配置" class="headerlink" title="全局配置"></a><strong>全局配置</strong></h6><p>所有项目都可以一起使用</p><p><img src="/images/docker/runner-all.png"></p><h6 id="拉取Runner镜像并启动"><a href="#拉取Runner镜像并启动" class="headerlink" title="拉取Runner镜像并启动"></a>拉取Runner镜像并启动</h6><pre><code class="hljs shell">docker run -d \--name gitlab-runner \--restart always \    --volume /srv/gitlab-runner/config:/etc/gitlab-runner \    --volume /srv/gitlab-runner/run/docker.sock:/var/run/docker.sock \    gitlab/gitlab-runner:latest</code></pre><h6 id="Runner-注册"><a href="#Runner-注册" class="headerlink" title="Runner 注册"></a>Runner 注册</h6><p><strong>进入Runner容器内</strong></p><pre><code class="hljs shell">docker exec -it gitlab-runner bash</code></pre><p><strong>运行命令进行注册</strong></p><pre><code class="hljs shell">gitlab-runner register</code></pre><p><strong>输入Gitlab实地址</strong></p><p>地址是手动设置Runner区域里面的URL</p><pre><code class="hljs awk">&gt; Please enter the gitlab-ci coordinator URL (e.g. https:<span class="hljs-regexp">//gi</span>tlab.com )http:<span class="hljs-regexp">//</span>xxx</code></pre><p><strong>输入token</strong></p><p>token是手动设置Runner区域里面的令牌</p><pre><code class="hljs kotlin">&gt; Please enter the gitlab-ci token <span class="hljs-keyword">for</span> <span class="hljs-keyword">this</span> runnerxxx</code></pre><p><strong>输入Runner的描述</strong></p><p>Runner的描述，后面可以在GitLab中的UI中进行更改。</p><pre><code class="hljs angelscript">&gt; Please enter the gitlab-ci description <span class="hljs-keyword">for</span> <span class="hljs-keyword">this</span> runner<span class="hljs-string">[hostname]</span> test-runner</code></pre><p><strong>输入与Runner关联的标签</strong></p><p>标签是为了让后期在CI脚本中指定选择某个或者多个Runner，这里设置标签为<code>test</code>。当使用这个 Runner时，在<code>.gitlab-ci.yml</code>的 tag字段里也必须明确指明这些 tags)。</p><pre><code class="hljs kotlin">&gt; Please enter the gitlab-ci tags <span class="hljs-keyword">for</span> <span class="hljs-keyword">this</span> runner (comma separated):test</code></pre><p><strong>输入Runner的执行器</strong></p><p>由于都是基于Docker，所以这里选择执行器为Docker</p><pre><code class="hljs dockerfile">&gt; Please enter the executor: ssh, docker+machine, docker-ssh+machine, kubernetes, docker, parallels, virtualbox, docker-ssh, <span class="hljs-keyword">shell</span><span class="bash">:</span>docker</code></pre><p><strong>设置执行器的版本</strong></p><p>选择Docker作为Runner的executor，还需要指定一个默认的 基础镜像 来运行job (这会在<code>.gitlab-ci.yml</code>中未指明基础镜像时作为默认基础镜像使用)，网上很多人都选的 <code>alpine:latest</code>。如果运行java项目，可以选jdk的镜像。</p><pre><code class="hljs less">&gt; <span class="hljs-selector-tag">Please</span> <span class="hljs-selector-tag">enter</span> <span class="hljs-selector-tag">the</span> <span class="hljs-selector-tag">Docker</span> <span class="hljs-selector-tag">image</span> (eg. <span class="hljs-attribute">ruby</span>:<span class="hljs-number">2.1</span>):<span class="hljs-selector-tag">alpine</span><span class="hljs-selector-pseudo">:latest</span></code></pre><p><strong>退出容器</strong></p><pre><code class="hljs awk"><span class="hljs-keyword">exit</span></code></pre><p>通过以上命令后，就创建成功runner啦。这时候去GitLab中创建Runner的区域刷新就能看到了。</p><p><img src="/images/docker/runner-gitlab.png"></p><h6 id="修改配置文件-1"><a href="#修改配置文件-1" class="headerlink" title="修改配置文件"></a>修改配置文件</h6><pre><code class="hljs shell">vim /srv/gitlab-runner/config/config.toml</code></pre><p>找到<code>volumes</code>配置，修改结果为如下，分别是挂载了宿主机docker的sock文件和Maven的缓存，减少拉取Jar包的时间消耗，其中<code>&quot;/data/.m2/:/.m2/&quot;</code>这块为Maven的Jar包存放地址，左边为宿主机目录，右边为容器内的Jar包存储路径，这个需要根据自己使用的Maven镜像而定</p><pre><code class="hljs shell">volumes = [&quot;/cache&quot;,&quot;/var/run/docker.sock:/var/run/docker.sock&quot;,&quot;/data/.m2/:/.m2/&quot;]</code></pre><p>在<code>volumes</code>配置下方增加一行配置，防止Runner重复拉取镜像</p><pre><code class="hljs shell">pull_policy = &quot;if-not-present&quot;</code></pre><p>最后重启Runner</p><pre><code class="hljs shell">docker restart gitlab-runner</code></pre><h5 id="部署harbor"><a href="#部署harbor" class="headerlink" title="部署harbor"></a>部署harbor</h5><h6 id="安装最新的docker-compose"><a href="#安装最新的docker-compose" class="headerlink" title="安装最新的docker-compose"></a>安装最新的docker-compose</h6><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 下载</span>wget https://github.com/docker/compose/releases/download/1.28.6/docker-compose-Linux-x86_64<span class="hljs-meta">#</span><span class="bash"> 移动到/usr/<span class="hljs-built_in">local</span>/bin</span>mv docker-compose-Linux-x86_64 /usr/local/bin<span class="hljs-meta">#</span><span class="bash"> 改名</span>mv docker-compose-Linux-x86_64 docker-compose</code></pre><p>将可执行权限用于二进制文件</p><pre><code class="hljs shell">sudo chmod +x /usr/local/bin/docker-compose</code></pre><h6 id="下载Harbor"><a href="#下载Harbor" class="headerlink" title="下载Harbor"></a>下载Harbor</h6><p><code>github地址：</code><a href="https://github.com/vmware/harbor/releases/%60">https://github.com/vmware/harbor/releases/`</a></p><pre><code class="hljs shell">wget https://github.com/goharbor/harbor/releases/download/v2.2.1/harbor-online-installer-v2.2.1.tgz</code></pre><h6 id="配置Harbor"><a href="#配置Harbor" class="headerlink" title="配置Harbor"></a>配置Harbor</h6><p>进入Harbor文件夹，找到<code>harbor.yml</code>文件，并配置</p><pre><code class="hljs yml"><span class="hljs-string">cd</span> <span class="hljs-string">/srv/harbor</span><span class="hljs-string">cp</span> <span class="hljs-string">harbor.yml.tmpl</span> <span class="hljs-string">harbor.yml</span><span class="hljs-string">vim</span> <span class="hljs-string">harbor.yml</span><span class="hljs-attr">hostname:</span> <span class="hljs-string">xx.xx.xx.xx</span>   <span class="hljs-comment"># 需要配置</span><span class="hljs-comment"># http related config</span><span class="hljs-attr">http:</span>  <span class="hljs-comment"># port for http, default is 80. If https enabled, this port will redirect to https port</span>  <span class="hljs-attr">port:</span> <span class="hljs-number">5000</span>      <span class="hljs-comment"># 需要配置 确保未安装registry容器</span><span class="hljs-comment"># https需要注释掉</span><span class="hljs-comment"># https related config</span><span class="hljs-comment">#https:</span>  <span class="hljs-comment"># https port for harbor, default is 443</span>  <span class="hljs-comment"># port: 443</span>  <span class="hljs-comment"># The path of cert and key files for nginx</span>  <span class="hljs-comment"># certificate: /your/certificate/path</span>  <span class="hljs-comment"># private_key: /your/private/key/path</span></code></pre><h6 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h6><p>在harbor文件夹执行以下命令启动harbor</p><pre><code class="hljs cmake">./<span class="hljs-keyword">install</span>.sh</code></pre><p>启动完毕后浏览器访问<code>http://你设置的IP或者域名:你设置的端口</code>，账号默认为：admin，密码：Harbor12345，登录后就进入了主页</p><p><img src="/images/docker/habor-container.png"></p><p><img src="/images/docker/habor.png"></p><h6 id="push镜像"><a href="#push镜像" class="headerlink" title="push镜像"></a>push镜像</h6><p><strong>修改下配置</strong></p><p>由于docker的版本从13开始，register只能用https，这里配置的都是http的，所以要先在<code>/etc/docker/</code>目录创建<code>daemon.json</code>文件并加入如下</p><pre><code class="hljs shell">&#123; &quot;insecure-registries&quot;:[&quot;xxx:5000&quot;] &#125;</code></pre><p>重启docker</p><pre><code class="hljs shell">systemctl restart docker</code></pre><p>重启harbor相关的容器，因为重启docker后这些都关闭了，所以我们通过<code>docker ps -a</code>找到所有与harbor相关的镜像，通过<code>docker restart xx xx xx</code>对应容器名重启即可</p><h6 id="报错云集"><a href="#报错云集" class="headerlink" title="报错云集"></a>报错云集</h6><pre><code class="hljs shell">prepare base dir is set to /usr/local/harbordocker: Error response from daemon: OCI runtime create failed: container_linux.go:349: starting container process caused &quot;process_linux.go:449: container init caused \&quot;write /proc/self/attr/keycreate: permission denied\&quot;&quot;: unknown. <span class="hljs-meta">#</span><span class="bash"> 解决办法</span>把/etc/selinux下的config文件中的SELINUX=enforcing  改为 SELINUX=disabled 遇到报错：ERROR:root:Please specify hostname， 那原因是启动harbor时没有修改harbor.yml里的内容。 <span class="hljs-meta">#</span><span class="bash"> 解决办法</span>把配置文件中默认的hostname: reg.mydomain.com， 改为本地的ip。 比如： hostname：xx.xx.xx.xx 遇到报错：ERROR:root:Error: The protocol is https but attribute ssl_cert is not set。 原因是harbor.yml中默认是配置https的端口及证书路径的。<span class="hljs-meta">#</span><span class="bash"> 解决办法</span>把这些配置都注释掉。<span class="hljs-meta">#</span><span class="bash"> https related config</span><span class="hljs-meta">#</span><span class="bash"> https:</span><span class="hljs-meta">  #</span><span class="bash"> https port <span class="hljs-keyword">for</span> harbor, default is 443</span><span class="hljs-meta">  #</span><span class="bash"> port: 443</span><span class="hljs-meta">  #</span><span class="bash"> The path of cert and key files <span class="hljs-keyword">for</span> nginx</span><span class="hljs-meta">  #</span><span class="bash"> certificate: /your/certificate/path</span><span class="hljs-meta">  #</span><span class="bash"> private_key: /your/private/key/path</span> 上述问题都解决，并且install.sh正确运行后， 信息如下：✔ ----Harbor has been installed and started successfully.----</code></pre><h5 id="部署Registry服务器"><a href="#部署Registry服务器" class="headerlink" title="部署Registry服务器"></a>部署Registry服务器</h5><blockquote><p>如果需要安装habor，最好将Registry容器停掉或者 容器名不能为registry.</p></blockquote><p>Docker Registry服务器整合很多服务，配置的参数非常多，包括：存储，Redis，Auth，日志，中间件，监控，HTTP，通知，健康检查，代理，兼容性。</p><p>部署服务器非常简单，只需要一条命令，映射5000端口到容器，restart机制为总是，并分配当前目录下的data目录作为容器卷，存储镜像数据。可以配置HTTPS方式的访问，参考Docker官方文档，如果是在局域网内访问这个方式即可满足需求。</p><h6 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h6><pre><div class="caption"><span>shell ell</span></div><code class="hljs sh">docker run -d \    -p 5000:5000 \    --restart always \    --name registry \    -e  REGISTRY_STORAGE_FILESYSTEM_ROOTDIRECTORY=/srv/registry \    -e REGISTRY_STORAGE_DELETE_ENABLED=<span class="hljs-literal">true</span> \    -v /srv/registry/data:/var/lib/registry \    registry:latest</code></pre><h6 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h6><p>从Docker官方的hub拉取ubuntu镜像，这是简写的方式，完整的命令是这样的<code>docker pull docker.io/library/ubuntu</code>，并命名为<code>localhost:5000/ubuntu</code>。</p><pre><code class="hljs bash">docker pull ubuntu &amp;&amp; docker tag ubuntu localhost:5000/ubuntu</code></pre><p>推送镜像到本地的Registry服务器</p><pre><code class="hljs bash">docker push localhost:5000/ubuntu</code></pre><p>删除宿主机的localhost:5000/ubuntu并拉取Registry服务器的ubuntu镜像</p><pre><code class="hljs bash">docker rmi -f localhost:5000/ubuntudocker pull localhost:5000/ubuntu</code></pre><h6 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h6><p>配置Registry服务器的方式有两种，一种是在运行容器指定环境变量重写配置文件，另一种是直接映射yaml配置文件。</p><p>使用配置文件的方式，迁移方便。</p><p><strong>环境变量重写配置选项</strong></p><p>比如重写配置文件存储选项，文件配置如下所示</p><pre><code class="hljs yaml"><span class="hljs-attr">storage:</span>  <span class="hljs-attr">filesystem:</span>    <span class="hljs-attr">rootdirectory:</span> <span class="hljs-string">/var/lib/registry</span></code></pre><p>那么运行Registery容器时就需要指定环境变量<code>REGISTRY_STORAGE_FILESYSTEM_ROOTDIRECTORY=/somewhere</code></p><pre><code class="hljs bash">docker run -d -p 5000:5000 --restart=always --name registry \  -v /srv/registry/data:/var/lib/registry \  -e  REGISTRY_STORAGE_FILESYSTEM_ROOTDIRECTORY=/srv/registry \  registry:2</code></pre><p><strong>覆盖配置文件</strong></p><p>可以使用挂载卷的方式覆盖配置</p><pre><code class="hljs bash">docker run -d -p 5000:5000 --restart=always --name registry \             -v /srv/registry:/etc/docker/registry \             registry:latest</code></pre><p>挂载当前目录下config.yml覆盖容器的/etc/docker/registry/config.yml文件，下面是整个配置文件</p><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-number">0.1</span><span class="hljs-attr">log:</span> <span class="hljs-comment">## 日志选项</span>  <span class="hljs-attr">level:</span> <span class="hljs-string">debug</span>  <span class="hljs-attr">formatter:</span> <span class="hljs-string">text</span>  <span class="hljs-attr">fields:</span>    <span class="hljs-attr">service:</span> <span class="hljs-string">registry</span>    <span class="hljs-attr">environment:</span> <span class="hljs-string">staging</span>  <span class="hljs-attr">hooks:</span>    <span class="hljs-bullet">-</span> <span class="hljs-attr">type:</span> <span class="hljs-string">mail</span>      <span class="hljs-attr">disabled:</span> <span class="hljs-literal">true</span>      <span class="hljs-attr">levels:</span>        <span class="hljs-bullet">-</span> <span class="hljs-string">panic</span>      <span class="hljs-attr">options:</span>        <span class="hljs-attr">smtp:</span> <span class="hljs-comment">## 邮件通知配置</span>          <span class="hljs-attr">addr:</span> <span class="hljs-string">mail.example.com:25</span>          <span class="hljs-attr">username:</span> <span class="hljs-string">mailuser</span>          <span class="hljs-attr">password:</span> <span class="hljs-string">password</span>          <span class="hljs-attr">insecure:</span> <span class="hljs-literal">true</span>        <span class="hljs-attr">from:</span> <span class="hljs-string">sender@example.com</span>        <span class="hljs-attr">to:</span>          <span class="hljs-bullet">-</span> <span class="hljs-string">errors@example.com</span><span class="hljs-attr">loglevel:</span> <span class="hljs-string">debug</span> <span class="hljs-comment"># 即将弃用: 使用Log替代</span><span class="hljs-attr">storage:</span> <span class="hljs-comment">##存储选项，</span>  <span class="hljs-attr">filesystem:</span> <span class="hljs-comment">## 本地文件系统，也可以是云分布式存储，比如微软Azure，亚马逊S3，swift，OSS</span>    <span class="hljs-attr">rootdirectory:</span> <span class="hljs-string">/var/lib/registry</span>    <span class="hljs-attr">maxthreads:</span> <span class="hljs-number">100</span> <span class="hljs-comment">##最大线程数</span><span class="hljs-attr">auth:</span> <span class="hljs-comment">#用户验证</span>  <span class="hljs-attr">silly:</span>    <span class="hljs-attr">realm:</span> <span class="hljs-string">silly-realm</span>    <span class="hljs-attr">service:</span> <span class="hljs-string">silly-service</span>  <span class="hljs-attr">token:</span>    <span class="hljs-attr">realm:</span> <span class="hljs-string">token-realm</span>    <span class="hljs-attr">service:</span> <span class="hljs-string">token-service</span>    <span class="hljs-attr">issuer:</span> <span class="hljs-string">registry-token-issuer</span>    <span class="hljs-attr">rootcertbundle:</span> <span class="hljs-string">/root/certs/bundle</span>  <span class="hljs-attr">htpasswd:</span>    <span class="hljs-attr">realm:</span> <span class="hljs-string">basic-realm</span>    <span class="hljs-attr">path:</span> <span class="hljs-string">/path/to/htpasswd</span><span class="hljs-attr">middleware:</span> <span class="hljs-comment">##中间件类型有registry，repository，storage三种，每种中间件可以像下面的方式使用</span>  <span class="hljs-attr">registry:</span>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">ARegistryMiddleware</span>      <span class="hljs-attr">options:</span>        <span class="hljs-attr">foo:</span> <span class="hljs-string">bar</span>  <span class="hljs-attr">storage:</span>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">ARegistryMiddleware</span><span class="hljs-attr">reporting:</span> <span class="hljs-comment">##监控，可以使用一些在线的监控工具包括bugsnag，newrelic</span>  <span class="hljs-attr">newrelic:</span>    <span class="hljs-attr">licensekey:</span> <span class="hljs-string">newreliclicensekey</span>    <span class="hljs-attr">name:</span> <span class="hljs-string">newrelicname</span>    <span class="hljs-attr">verbose:</span> <span class="hljs-literal">true</span><span class="hljs-attr">http:</span> <span class="hljs-comment">## 由Nginx提供的HTTP服务，可以把它理解成配置Nginx</span>  <span class="hljs-attr">addr:</span> <span class="hljs-string">localhost:5000</span>  <span class="hljs-attr">prefix:</span> <span class="hljs-string">/my/nested/registry/</span>  <span class="hljs-attr">host:</span> <span class="hljs-string">https://myregistryaddress.org:5000</span>  <span class="hljs-attr">secret:</span> <span class="hljs-string">asecretforlocaldevelopment</span>  <span class="hljs-attr">relativeurls:</span> <span class="hljs-literal">false</span>  <span class="hljs-attr">tls:</span>    <span class="hljs-attr">certificate:</span> <span class="hljs-string">/path/to/x509/public</span>    <span class="hljs-attr">key:</span> <span class="hljs-string">/path/to/x509/private</span>    <span class="hljs-attr">clientcas:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">/path/to/ca.pem</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">/path/to/another/ca.pem</span>    <span class="hljs-attr">letsencrypt:</span>      <span class="hljs-attr">cachefile:</span> <span class="hljs-string">/path/to/cache-file</span>      <span class="hljs-attr">email:</span> <span class="hljs-string">emailused@letsencrypt.com</span>  <span class="hljs-attr">debug:</span>    <span class="hljs-attr">addr:</span> <span class="hljs-string">localhost:5001</span>  <span class="hljs-attr">headers:</span>    <span class="hljs-attr">X-Content-Type-Options:</span> [<span class="hljs-string">nosniff</span>]<span class="hljs-attr">notifications:</span> <span class="hljs-comment">## 事件通知，当Registry服务器发生拉取，推送等时发送事件到endpoints</span>  <span class="hljs-attr">endpoints:</span>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">alistener</span>      <span class="hljs-attr">disabled:</span> <span class="hljs-literal">false</span>      <span class="hljs-attr">url:</span> <span class="hljs-string">https://my.listener.com/event</span>      <span class="hljs-attr">headers:</span> <span class="hljs-string">&lt;http.Header&gt;</span>      <span class="hljs-attr">timeout:</span> <span class="hljs-number">500</span>      <span class="hljs-attr">threshold:</span> <span class="hljs-number">5</span>      <span class="hljs-attr">backoff:</span> <span class="hljs-number">1000</span><span class="hljs-attr">redis:</span> <span class="hljs-comment">##这个用过的都懂</span>  <span class="hljs-attr">addr:</span> <span class="hljs-string">localhost:6379</span>  <span class="hljs-attr">password:</span> <span class="hljs-string">asecret</span>  <span class="hljs-attr">db:</span> <span class="hljs-number">0</span>  <span class="hljs-attr">dialtimeout:</span> <span class="hljs-string">10ms</span>  <span class="hljs-attr">readtimeout:</span> <span class="hljs-string">10ms</span>  <span class="hljs-attr">writetimeout:</span> <span class="hljs-string">10ms</span>  <span class="hljs-attr">pool:</span>    <span class="hljs-attr">maxidle:</span> <span class="hljs-number">16</span>    <span class="hljs-attr">maxactive:</span> <span class="hljs-number">64</span>    <span class="hljs-attr">idletimeout:</span> <span class="hljs-string">300s</span><span class="hljs-attr">health:</span> <span class="hljs-comment">## 健康检查包括存储驱动，file，http服务，tcp的可用性检查</span>  <span class="hljs-attr">storagedriver:</span>    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span>    <span class="hljs-attr">interval:</span> <span class="hljs-string">10s</span>    <span class="hljs-attr">threshold:</span> <span class="hljs-number">3</span>  <span class="hljs-attr">file:</span>    <span class="hljs-bullet">-</span> <span class="hljs-attr">file:</span> <span class="hljs-string">/path/to/checked/file</span>      <span class="hljs-attr">interval:</span> <span class="hljs-string">10s</span>  <span class="hljs-attr">http:</span>    <span class="hljs-bullet">-</span> <span class="hljs-attr">uri:</span> <span class="hljs-string">http://server.to.check/must/return/200</span>      <span class="hljs-attr">headers:</span>        <span class="hljs-attr">Authorization:</span> [<span class="hljs-string">Basic</span> <span class="hljs-string">QWxhZGRpbjpvcGVuIHNlc2FtZQ==</span>]      <span class="hljs-attr">statuscode:</span> <span class="hljs-number">200</span>      <span class="hljs-attr">timeout:</span> <span class="hljs-string">3s</span>      <span class="hljs-attr">interval:</span> <span class="hljs-string">10s</span>      <span class="hljs-attr">threshold:</span> <span class="hljs-number">3</span>  <span class="hljs-attr">tcp:</span>    <span class="hljs-bullet">-</span> <span class="hljs-attr">addr:</span> <span class="hljs-string">redis-server.domain.com:6379</span>      <span class="hljs-attr">timeout:</span> <span class="hljs-string">3s</span>      <span class="hljs-attr">interval:</span> <span class="hljs-string">10s</span>      <span class="hljs-attr">threshold:</span> <span class="hljs-number">3</span><span class="hljs-attr">proxy:</span> <span class="hljs-comment">## 可以镜像Docker Hub的仓库</span>  <span class="hljs-attr">remoteurl:</span> <span class="hljs-string">https://registry-1.docker.io</span>  <span class="hljs-attr">username:</span> [<span class="hljs-string">username</span>]  <span class="hljs-attr">password:</span> [<span class="hljs-string">password</span>]<span class="hljs-attr">compatibility:</span>   <span class="hljs-attr">schema1:</span>    <span class="hljs-attr">signingkeyfile:</span> <span class="hljs-string">/etc/registry/key.json</span></code></pre><h5 id="Gitlab-ci-yml"><a href="#Gitlab-ci-yml" class="headerlink" title="Gitlab-ci.yml"></a>Gitlab-ci.yml</h5><pre><code class="hljs yml"><span class="hljs-comment"># 定义全局变量</span><span class="hljs-attr">variables:</span>  <span class="hljs-attr">PROJECT:</span> <span class="hljs-string">&quot;offer&quot;</span>  <span class="hljs-comment"># 这里定义了Maven的jar包存放地址，与我们构建maven私服的时候设置的存放地址一致</span>  <span class="hljs-attr">MAVEN_REPO:</span> <span class="hljs-string">&quot;/.m2&quot;</span>  <span class="hljs-attr">CI_REGISTRY_USER:</span> <span class="hljs-string">&quot;xxx&quot;</span>  <span class="hljs-attr">CI_REGISTRY_PASSWORD:</span> <span class="hljs-string">&quot;xxx&quot;</span>  <span class="hljs-comment"># 仓库地址</span>  <span class="hljs-attr">CI_REGISTRY:</span> <span class="hljs-string">&quot;xx.xx.xx.xx:5000/&quot;</span>  <span class="hljs-comment"># 镜像全称</span>  <span class="hljs-attr">CI_REGISTRY_IMAGE:</span> <span class="hljs-string">&quot;mlja/offer&quot;</span>  <span class="hljs-attr">CI_COMMIT_REF_SLUG:</span> <span class="hljs-string">&quot;&quot;</span>  <span class="hljs-attr">CI_COMMIT_SHA:</span> <span class="hljs-string">&quot;&quot;</span>  <span class="hljs-comment"># 全局脚本，会运行在各个阶段的script前，如果某个阶段里面存在before_script，那么以那个阶段里的为主</span><span class="hljs-attr">before_script:</span>  <span class="hljs-comment"># 这里定义了打包成功后的Docker镜像名称，每一次提交代码后构建成功的镜像名称都是唯一的</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">export</span> <span class="hljs-string">IMAGE_FULL_NAME=$&#123;CI_REGISTRY_IMAGE&#125;:$&#123;CI_COMMIT_REF_SLUG&#125;-$&#123;CI_COMMIT_SHA&#125;</span><span class="hljs-comment"># 定义CI执行的阶段，这里可以自己根据情况定义多少个阶段</span><span class="hljs-attr">stages:</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">compile</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">build</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">run</span><span class="hljs-comment"># 编译:</span><span class="hljs-attr">compile:</span>  <span class="hljs-comment"># 当前阶段的执行镜像，这是自己构建的镜像</span>  <span class="hljs-attr">image:</span> <span class="hljs-string">xx.xx.xx.xx:5000/root/maven:latest</span>  <span class="hljs-comment"># 属于上面定义的哪一个阶段</span>  <span class="hljs-attr">stage:</span> <span class="hljs-string">compile</span>  <span class="hljs-comment"># 是否允许失败，允许的话如果当前阶段运行失败还会继续执行下一个阶段</span>  <span class="hljs-attr">allow_failure:</span> <span class="hljs-literal">true</span>  <span class="hljs-comment"># 只在哪个分支生效</span>  <span class="hljs-attr">only:</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">master</span>  <span class="hljs-comment"># 这里就是要选择哪个runner来执行了，填写创建runner时候指定的标签</span>  <span class="hljs-attr">tags:</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">test</span>  <span class="hljs-comment"># 运行脚本</span>  <span class="hljs-attr">script:</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">mvn</span> <span class="hljs-string">-Dmaven.repo.local=$MAVEN_REPO</span> <span class="hljs-string">clean</span> <span class="hljs-string">package</span> <span class="hljs-string">-Dmaven.test.skip=true</span>  <span class="hljs-comment"># 因为是Maven编译，所以会有Jar包产物，这里定义产物的过期时间</span>  <span class="hljs-attr">artifacts:</span>    <span class="hljs-attr">name:</span> <span class="hljs-string">$PROJECT</span>    <span class="hljs-attr">expire_in:</span> <span class="hljs-number">7</span> <span class="hljs-string">days</span>    <span class="hljs-attr">paths:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">target/*.jar</span><span class="hljs-comment"># 构建镜像:</span><span class="hljs-attr">build:</span>  <span class="hljs-attr">image:</span> <span class="hljs-string">docker:stable</span>  <span class="hljs-attr">stage:</span> <span class="hljs-string">build</span>  <span class="hljs-attr">script:</span>    <span class="hljs-comment"># 这里的变量会自动获取你当前推送代码的gitlab用户和密码以及仓库地址</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">docker</span> <span class="hljs-string">login</span> <span class="hljs-string">--username</span> <span class="hljs-string">$CI_REGISTRY_USER</span> <span class="hljs-string">--password</span> <span class="hljs-string">$CI_REGISTRY_PASSWORD</span> <span class="hljs-string">$CI_REGISTRY</span>    <span class="hljs-comment"># 这里的变量就是我们全局配置定义的了</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">docker</span> <span class="hljs-string">build</span> <span class="hljs-string">-t</span> <span class="hljs-string">$IMAGE_FULL_NAME</span> <span class="hljs-string">.</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">docker</span> <span class="hljs-string">push</span> <span class="hljs-string">$IMAGE_FULL_NAME</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">rm</span> <span class="hljs-string">-rf</span> <span class="hljs-string">target</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">docker</span> <span class="hljs-string">rmi</span> <span class="hljs-string">$IMAGE_FULL_NAME</span>  <span class="hljs-attr">only:</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">master</span>  <span class="hljs-attr">tags:</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">test</span><span class="hljs-comment"># 运行:</span><span class="hljs-attr">run:</span>  <span class="hljs-attr">image:</span> <span class="hljs-string">docker:stable</span>  <span class="hljs-attr">stage:</span> <span class="hljs-string">run</span>  <span class="hljs-attr">script:</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">docker</span> <span class="hljs-string">run</span> <span class="hljs-string">-d</span> <span class="hljs-string">--name</span> <span class="hljs-string">$PROJECT</span> <span class="hljs-string">-p</span> <span class="hljs-number">7777</span><span class="hljs-string">:7777</span> <span class="hljs-string">$IMAGE_FULL_NAME</span>  <span class="hljs-attr">only:</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">master</span>  <span class="hljs-attr">tags:</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">test</span></code></pre><h5 id="部署jenkins"><a href="#部署jenkins" class="headerlink" title="部署jenkins"></a><strong>部署jenkins</strong></h5><pre><code class="hljs shell">mkdir -p /srv/jenkinschown -R 1000:1000 /srv/jenkins/docker pull jenkins/jenkins:alpinedocker inspect jenkins/jenkins:alpinedocker run --detach \    --publish 8080:8080 --publish 50000:50000 \    --restart unless-stopped \    --name jenkins \    --volume /srv/jenkins:/var/jenkins_home \    jenkins/jenkins:alpine</code></pre><h5 id="部署RabbitMQ"><a href="#部署RabbitMQ" class="headerlink" title="部署RabbitMQ"></a><strong>部署RabbitMQ</strong></h5><p>获取查询的镜像 </p><pre><code class="hljs shell">docker search rabbitmq:management</code></pre><p><img src="/images/docker/15.png"></p><p>拉取镜像 </p><pre><code class="hljs shell">docker pull rabbitmq:management</code></pre><p><img src="/images/docker/16.png"></p><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 运行镜像    </span>docker run -d \    -p 5672:5672 -p 15672:15672 \    --restart=always \    --name rabbitmq \    -v `pwd`/data:/var/lib/rabbitmq \    -e RABBITMQ_DEFAULT_USER=admin -e RABBITMQ_DEFAULT_PASS=2018251 \     rabbitmq:management</code></pre><pre><code class="hljs shell">docker run \-p 6379:6379 \--name myredis \-v /weitrue/install/redis/redis.conf:/etc/redis/redis.conf  \-v /weitrue/install/redis/data:/data \-d redis redis-server /etc/redis/redis.conf \--appendonly yes</code></pre>]]></content>
    
    
    <categories>
      
      <category>Develop</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
      <tag>Linux</tag>
      
      <tag>Center OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Mac】Mac使用</title>
    <link href="/2020/06/22/mac/"/>
    <url>/2020/06/22/mac/</url>
    
    <content type="html"><![CDATA[<blockquote><p>基于XNU<a href="https://baike.baidu.com/item/%E6%B7%B7%E5%90%88%E5%86%85%E6%A0%B8/4239577">混合内核</a>的首个在商用领域成功的<a href="https://baike.baidu.com/item/%E5%9B%BE%E5%BD%A2%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2/3352324">图形用户界面</a>操作系统，并且很少受到电脑病毒的袭击。<a id="more"></a> </p></blockquote><h3 id="Homebrew"><a href="#Homebrew" class="headerlink" title="Homebrew"></a>Homebrew</h3><h4 id="官网"><a href="#官网" class="headerlink" title="官网:"></a>官网:</h4><p><a href="https://docs.brew.sh/Installation.html">https://docs.brew.sh/Installation.html</a></p><h4 id="gihub源"><a href="#gihub源" class="headerlink" title="gihub源"></a>gihub源</h4><p><a href="https://github.com/Homebrew/install">https://github.com/Homebrew/install</a></p><h4 id="homebrew安装"><a href="#homebrew安装" class="headerlink" title="homebrew安装"></a>homebrew安装</h4><pre><code class="hljs awk"><span class="hljs-regexp">/usr/</span>bin<span class="hljs-regexp">/ruby -e &quot;$(curl -fsSL https:/</span><span class="hljs-regexp">/raw.githubusercontent.com/</span>Homebrew<span class="hljs-regexp">/install/m</span>aster/install)<span class="hljs-string">&quot;</span></code></pre><p>可能会出现报错</p><pre><code class="hljs routeros">curl: (7) Failed <span class="hljs-keyword">to</span> connect <span class="hljs-keyword">to</span> raw.githubusercontent.com<span class="hljs-built_in"> port </span>443:<span class="hljs-built_in"> Connection </span>refused</code></pre><p>根据提示可以知道被raw.githubusercontent.com拒绝访问，打开浏览器访问<a href="https://raw.githubusercontent.com也是失败的,所以此时是电脑与https//raw.githubusercontent.com%E7%9A%84%E8%BF%9E%E6%8E%A5%E9%97%AE%E9%A2%98%EF%BC%9A%E5%8F%AF%E4%BB%A5%E8%80%83%E8%99%91ruby%E7%9A%84%E6%9B%B4%E6%96%B0%E6%BA%90">https://raw.githubusercontent.com也是失败的，所以此时是电脑与https://raw.githubusercontent.com的连接问题：可以考虑ruby的更新源</a></p><pre><code class="hljs shell">查看当前更新源gem sources -l                // 默认情况下会显示https://rubygems.org/ 该ruby源在墙内，很多内容无法访问到gem source -a https://gems.ruby-china.com    // 更新更新源为https://gems.ruby-china.comgem sources --remove https://rubygems.org/   // 删除原更新源gem sources -l      　　　　　　               // 检测是否成功</code></pre><p>继续安装</p><p><img src="/images/mac/clipboard.png" alt="img"></p><p><code>brew -v</code>检查是否已安装成功</p><pre><code class="hljs shell">Homebrew 2.4.0 Homebrew/homebrew-core (git revision c948b; last commit 2020-06-13)</code></pre><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><p>基于brew安装的所有软件及其依赖均会安装到目录<code>/usr/local/Cellar</code></p><h5 id="Brew-帮助信息"><a href="#Brew-帮助信息" class="headerlink" title="Brew 帮助信息"></a>Brew 帮助信息</h5><pre><code class="hljs properties"><span class="hljs-meta">$</span> <span class="hljs-string">brew help</span><span class="hljs-attr">Example</span> <span class="hljs-string">usage:</span>  <span class="hljs-attr">brew</span> <span class="hljs-string">search [TEXT|/REGEX/]</span>  <span class="hljs-attr">brew</span> <span class="hljs-string">info [FORMULA...]</span>  <span class="hljs-attr">brew</span> <span class="hljs-string">install FORMULA...</span>  <span class="hljs-attr">brew</span> <span class="hljs-string">update</span>  <span class="hljs-attr">brew</span> <span class="hljs-string">upgrade [FORMULA...]</span>  <span class="hljs-attr">brew</span> <span class="hljs-string">uninstall FORMULA...</span>  <span class="hljs-attr">brew</span> <span class="hljs-string">list [FORMULA...]</span><span class="hljs-attr">Troubleshooting</span>:<span class="hljs-string"></span>  <span class="hljs-attr">brew</span> <span class="hljs-string">config</span>  <span class="hljs-attr">brew</span> <span class="hljs-string">doctor</span>  <span class="hljs-attr">brew</span> <span class="hljs-string">install --verbose --debug FORMULA</span><span class="hljs-attr">Contributing</span>:<span class="hljs-string"></span>  <span class="hljs-attr">brew</span> <span class="hljs-string">create [URL [--no-fetch]]</span>  <span class="hljs-attr">brew</span> <span class="hljs-string">edit [FORMULA...]</span><span class="hljs-attr">Further</span> <span class="hljs-string">help:</span>  <span class="hljs-attr">brew</span> <span class="hljs-string">commands</span>  <span class="hljs-attr">brew</span> <span class="hljs-string">help [COMMAND]</span>  <span class="hljs-attr">man</span> <span class="hljs-string">brew</span>  <span class="hljs-attr">https</span>:<span class="hljs-string">//docs.brew.sh</span></code></pre><h5 id="子命令帮助信息"><a href="#子命令帮助信息" class="headerlink" title="子命令帮助信息"></a>子命令帮助信息</h5><p><code>brew help [COMMAND]或brew [COMMAND] -h</code> 用于查看具体某个子命令的帮助信息。</p><p>例如，查看<code>install</code>命令的帮助详情：</p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> brew install -h</span>Usage: brew install [options] formulaInstall formula. Additional options specific to formula may be appended tothe command.Unless HOMEBREW_NO_INSTALL_CLEANUP is set, brew cleanup will then be run forthe installed formulae or, every 30 days, for all formulae.    -d, --debug                      If brewing fails, open an interactive                                     debugging session with access to IRB or a                                     shell inside the temporary build directory.        --env                        If std is passed, use the standard build                                     environment instead of superenv. If super                                     is passed, use superenv even if the formula                                     specifies the standard build environment.        --ignore-dependencies        An unsupported Homebrew development flag to                                     skip installing any dependencies of any                                     kind. If the dependencies are not already                                     present, the formula will have issues. If                                     you&#x27;re not developing Homebrew, consider                                     adjusting your PATH rather than using this                                     flag.        --only-dependencies          Install the dependencies with specified                                     options but do not install the formula                                     itself.        --cc                         Attempt to compile using the specified                                     compiler, which should be the name of the                                     compiler&#x27;s executable, e.g. gcc-7 for GCC                                     7. In order to use LLVM&#x27;s clang, specify                                     llvm_clang. To use the Apple-provided                                     clang, specify clang. This option will                                     only accept compilers that are provided by                                     Homebrew or bundled with macOS. Please do                                     not file issues if you encounter errors                                     while using this option.    -s, --build-from-source          Compile formula from source even if a                                     bottle is provided. Dependencies will still                                     be installed from bottles if they are                                     available.        --force-bottle               Install from a bottle if it exists for the                                     current or newest version of macOS, even if                                     it would not normally be used for                                     installation.        --include-test               Install testing dependencies required to                                     run brew test formula.        --devel                      If formula defines it, install the                                     development version.        --HEAD                       If formula defines it, install the HEAD                                     version, aka. master, trunk, unstable.        --fetch-HEAD                 Fetch the upstream repository to detect if                                     the HEAD installation of the formula is                                     outdated. Otherwise, the repository&#x27;s HEAD                                     will only be checked for updates when a new                                     stable or development version has been                                     released.        --keep-tmp                   Retain the temporary files created during                                     installation.        --build-bottle               Prepare the formula for eventual bottling                                     during installation, skipping any                                     post-install steps.        --bottle-arch                Optimise bottles for the specified                                     architecture rather than the oldest                                     architecture supported by the version of                                     macOS the bottles are built on.    -f, --force                      Install without checking for previously                                     installed keg-only or non-migrated                                     versions.    -v, --verbose                    Print the verification and postinstall                                     steps.        --display-times              Print install times for each formula at the                                     end of the run.    -i, --interactive                Download and patch formula, then open a                                     shell. This allows the user to run                                     ./configure --help and otherwise                                     determine how to turn the software package                                     into a Homebrew package.    -g, --git                        Create a Git repository, useful for                                     creating patches to the software.    -h, --help                       Show this message.</code></pre><h5 id="搜索软件"><a href="#搜索软件" class="headerlink" title="搜索软件"></a>搜索软件</h5><p> <code>brew search [TEXT|/REGEX/]</code> 用于搜索软件，支持使用正则表达式进行复杂的搜索。</p><p>例如，查询静态博客生成工具hugo：</p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> brew search hugo</span>==&gt; Formulaehugo</code></pre><h5 id="查看软件信息"><a href="#查看软件信息" class="headerlink" title="查看软件信息"></a>查看软件信息</h5><p> <code>brew info [FORMULA...]</code> 用于查询软件的详细信息。</p><p>例如，查看软件hugo的详细信息：</p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> brew search hugo</span>==&gt; Formulaehugo<span class="hljs-meta">$</span><span class="bash"> brew info hugo</span>hugo: stable 0.72.0 (bottled), HEADConfigurable static site generatorhttps://gohugo.io/Not installedFrom: https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-core.git/Formula/hugo.rb==&gt; DependenciesBuild: go ✘==&gt; Options--HEADInstall HEAD version==&gt; Analyticsinstall: 26,782 (30 days), 84,656 (90 days), 287,304 (365 days)install-on-request: 26,266 (30 days), 82,887 (90 days), 279,634 (365 days)build-error: 0 (30 days)</code></pre><p>以上查询所得信息，包含了软件的最新可用版本，本机是否已安装，本机已安装的版本，安装的路径、大小、时间、Tap 源，所依赖的包，以及安装的可选项等详细信息。而这些信息可以帮助我们很方便快捷的了解如何对该软件进行相应的操作。</p><h5 id="安装软件包"><a href="#安装软件包" class="headerlink" title="安装软件包"></a>安装软件包</h5><p> <code>brew install FORMULA... </code>用于安装一个或多个软件。</p><p>例如，安装软件hugo：</p><pre><code class="hljs mipsasm"><span class="hljs-keyword">brew </span><span class="hljs-keyword">install </span>hugo</code></pre><p>安装软件命令执行之前，brew 一般会先检查更新 Homebrew 自身及 Tap 源。</p><h5 id="更新软件包"><a href="#更新软件包" class="headerlink" title="更新软件包"></a>更新软件包</h5><p> <code>brew upgrade [FORMULA...]</code> 用于更新一个或多个软件，不指定软件名则更新所有软件。</p><h5 id="卸载软件包"><a href="#卸载软件包" class="headerlink" title="卸载软件包"></a>卸载软件包</h5><p><code>brew uninstall FORMULA...</code> 用于卸载指定的一个或多个软件</p><p><code>brew uninstall --force FORMULA...</code> 彻底卸载指定软件，包括旧版本</p><h5 id="已安装的软件列表"><a href="#已安装的软件列表" class="headerlink" title="已安装的软件列表"></a>已安装的软件列表</h5><p> <code>brew list</code> 用于查询本机已安装的软件列表</p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> brew list</span>aprgettextlz4pcre2pythonsqliteutf8procapr-utilgomysql-clientperlpython@2subversionxzgdbmlibzipopenssl@1.1pkg-configreadlinetldr</code></pre><h5 id="服务管理"><a href="#服务管理" class="headerlink" title="服务管理"></a>服务管理</h5><p> <code>brew services</code> 用于方便的管理 brew 安装的软件软件，类似于 Linux 下的 service 命令。</p><h5 id="检查可更新的软件列表"><a href="#检查可更新的软件列表" class="headerlink" title="检查可更新的软件列表"></a>检查可更新的软件列表</h5><p> <code>brew outdated</code> 可查询有更新版本的软件</p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> brew outdated </span>gettext (0.20.1) &lt; 0.20.2_1go (1.13.8) &lt; 1.14.3libzip (1.6.1) &lt; 1.7.1mysql-client (8.0.18) &lt; 8.0.19openssl@1.1 (1.1.1d) &lt; 1.1.1gpcre2 (10.34) &lt; 10.35perl (5.30.1) &lt; 5.30.3pkg-config (0.29.2) &lt; 0.29.2_3python (3.7.6_1) &lt; 3.7.7readline (8.0.1) &lt; 8.0.4sqlite (3.30.1) &lt; 3.32.1subversion (1.13.0_1) &lt; 1.14.0_1utf8proc (2.4.0) &lt; 2.5.0xz (5.2.4) &lt; 5.2.5</code></pre><h5 id="清理软件"><a href="#清理软件" class="headerlink" title="清理软件"></a>清理软件</h5><p><code>brew cleanup -n</code> 列出需要清理的内容</p><p><code>brew cleanup</code> 清理所有的过时软件 </p><p><code>brew cleanup [FORMULA]</code> 清理指定软件的过时包</p><h5 id="查看配置信息"><a href="#查看配置信息" class="headerlink" title="查看配置信息"></a>查看配置信息</h5><p><code>brew config</code> 用于查看 brew 所在环境及相关的配置情况</p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> brew config</span>HOMEBREW_VERSION: 2.4.0ORIGIN: https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-cask-drivers.gitHEAD: 28ed0801ed5807e176e62a3ba66e47ec867ec17dLast commit: 3 days agoCore tap ORIGIN: https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-core.gitCore tap HEAD: c948bc65d13a2bdd43e5ef2ed4196930c731283cCore tap last commit: 11 hours agoHOMEBREW_PREFIX: /usr/localHOMEBREW_BOTTLE_DOMAIN: https://mirrors.tuna.tsinghua.edu.cn/homebrew-bottlesHOMEBREW_MAKE_JOBS: 8CPU: octa-core 64-bit kabylakeHomebrew Ruby: 2.6.3 =&gt; /usr/local/Homebrew/Library/Homebrew/vendor/portable-ruby/2.6.3_1/bin/rubyClang: 11.0 build 1103Git: 2.24.1 =&gt; /Library/Developer/CommandLineTools/usr/bin/gitCurl: 7.64.1 =&gt; /usr/bin/curlJava: 1.8.0_212macOS: 10.15.4-x86_64CLT: 1103.0.32.29Xcode: N/A</code></pre><h5 id="诊断问题"><a href="#诊断问题" class="headerlink" title="诊断问题"></a>诊断问题</h5><p> <code>brew doctor</code> 诊断当前 brew 存在哪些问题，并给出解决方案</p><h5 id="仓库管理"><a href="#仓库管理" class="headerlink" title="仓库管理"></a>仓库管理</h5><p><code>brew tap</code> 已安装的仓库列表</p><p><code>brew tap [--full] user/repo [URL]</code> 添加仓库</p><p><code>brew untap tap</code> 移除仓库</p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> brew tap</span>homebrew/caskhomebrew/cask-drivershomebrew/cask-fontshomebrew/corehomebrew/servicestldr-pages/tldr</code></pre><h4 id="镜像源"><a href="#镜像源" class="headerlink" title="镜像源"></a>镜像源</h4><p>清华大学开源软件镜像站</p><p><a href="https://mirrors.tuna.tsinghua.edu.cn/help/homebrew/">Homebrew 镜像使用帮助</a></p><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 替换现有上游</span><span class="hljs-meta">#</span><span class="bash"> 以下针对 mac OS 系统上的 Homebrew</span>git -C &quot;$(brew --repo homebrew/core)&quot; remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-core.gitgit -C &quot;$(brew --repo homebrew/cask)&quot; remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-cask.gitgit -C &quot;$(brew --repo homebrew/cask-fonts)&quot; remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-cask-fonts.gitgit -C &quot;$(brew --repo homebrew/cask-drivers)&quot; remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-cask-drivers.git<span class="hljs-meta">#</span><span class="bash"> 更换后测试工作是否正常</span>brew update<span class="hljs-meta">#</span><span class="bash"> 复原</span><span class="hljs-meta">#</span><span class="bash"> 以下针对 mac OS 系统上的 Homebrew</span>git -C &quot;$(brew --repo homebrew/core)&quot; remote set-url origin https://github.com/Homebrew/homebrew-core.gitgit -C &quot;$(brew --repo homebrew/cask)&quot; remote set-url origin https://github.com/Homebrew/homebrew-cask.gitgit -C &quot;$(brew --repo homebrew/cask-fonts)&quot; remote set-url origin https://github.com/Homebrew/homebrew-cask-fonts.gitgit -C &quot;$(brew --repo homebrew/cask-drivers)&quot; remote set-url origin https://github.com/Homebrew/homebrew-cask-drivers.git<span class="hljs-meta">#</span><span class="bash"> 更换后测试工作是否正常</span>brew update</code></pre><p><a href="https://mirrors.tuna.tsinghua.edu.cn/help/homebrew-bottles/">Homebrew-bottles 镜像使用帮助</a></p><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 临时替换</span>export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.tuna.tsinghua.edu.cn/homebrew-bottles<span class="hljs-meta">#</span><span class="bash"> 长期替换</span>echo &#x27;export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.tuna.tsinghua.edu.cn/homebrew-bottles&#x27; &gt;&gt; ~/.bash_profilesource ~/.bash_profile</code></pre><h3 id="Python虚拟环境（VirtualEnv）"><a href="#Python虚拟环境（VirtualEnv）" class="headerlink" title="Python虚拟环境（VirtualEnv）"></a>Python虚拟环境（VirtualEnv）</h3><h4 id="virtualenv"><a href="#virtualenv" class="headerlink" title="virtualenv"></a>virtualenv</h4><h5 id="安装virtualenv环境"><a href="#安装virtualenv环境" class="headerlink" title="安装virtualenv环境"></a>安装virtualenv环境</h5><pre><code class="hljs shell">pip install virtualenv<span class="hljs-meta">#</span><span class="bash">检查是否安装成功</span>virtualenv --version</code></pre><h5 id="创建以及使用虚拟环境"><a href="#创建以及使用虚拟环境" class="headerlink" title="创建以及使用虚拟环境"></a>创建以及使用虚拟环境</h5><h6 id="创建时指定位置方式"><a href="#创建时指定位置方式" class="headerlink" title="创建时指定位置方式"></a>创建时指定位置方式</h6><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 创建python3环境</span>virtualenv -p python3 ~/Projects/PythonEnv/py3_normal/<span class="hljs-meta">#</span><span class="bash"> 进入虚拟环境</span>cd ~/Projects/PythonEnv/py3_normal/binsource activate<span class="hljs-meta">#</span><span class="bash"> 退出环境</span>deactivate</code></pre><h6 id="虚拟环境管理器方式"><a href="#虚拟环境管理器方式" class="headerlink" title="虚拟环境管理器方式"></a>虚拟环境管理器方式</h6><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 安装虚拟环境管理器</span>pip install virtualenvwrapper<span class="hljs-meta">#</span><span class="bash"> 配置虚拟环境管理器环境-添加配置</span>vim ~/.bash_profileWORKON_HOME=~/Projects/PythonEnvPROJECT_HOME=~/Projects/MyPythonexport WORKON_HOMEexport PROJECT_HOMEVIRTUALENVWRAPPER_PYTHON=/usr/local/bin/python3source /usr/local/bin/virtualenvwrapper.sh<span class="hljs-meta">#</span><span class="bash">保存-生效配置</span>source ~/.bash_profile<span class="hljs-meta">#</span><span class="bash"> 创建虚拟环境</span><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment"># 创建python2的虚拟环境</span></span>mkvirtualenv &lt;虚拟环境名&gt;<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment"># 创建python3的虚拟环境</span></span>mkvirtualenv -p python3 &lt;虚拟环境名&gt;<span class="hljs-meta">#</span><span class="bash"> 进入/切换虚拟环境</span>workon &lt;虚拟环境名&gt;<span class="hljs-meta">#</span><span class="bash"> 退出虚拟环境</span>deactivate<span class="hljs-meta">#</span><span class="bash"> 其他命令</span>lsvirtualenv   # 查看虚拟环境列表lssitepackages # 查看当前环境中安装的那些包（启动虚拟环境后）rmvirtualenv   # 虚拟环境名 删除虚拟环境</code></pre><h4 id="Anaconda-or-Miniconda"><a href="#Anaconda-or-Miniconda" class="headerlink" title="Anaconda or Miniconda"></a>Anaconda or Miniconda</h4><h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><p>清华大学开源软件镜像站 <a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/miniconda/">https://mirrors.tuna.tsinghua.edu.cn/anaconda/miniconda/</a></p><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> Download</span>wget https://mirrors.tuna.tsinghua.edu.cn/anaconda/miniconda/Miniconda-3.4.2-MacOSX-x86_64.sh<span class="hljs-meta">#</span><span class="bash"> Install</span>bash Miniconda-3.4.2-MacOSX-x86_64.sh<span class="hljs-meta">#</span><span class="bash"> Activate</span>source .bashrc</code></pre><h5 id="创建以及使用虚拟环境-1"><a href="#创建以及使用虚拟环境-1" class="headerlink" title="创建以及使用虚拟环境"></a>创建以及使用虚拟环境</h5><pre><code class="hljs shell">- Create a new environment, installing named packages into it:    conda create --name environment_name python=2.7 matplotlib- List all environments:    conda info --envs- Load or unload an environment:    conda activate|deactivate environment_name- Delete an environment (remove all packages):    conda remove --name environment_name --all- Search conda channels for a package by name:    conda search package_name- Install packages into the current environment:    conda install python=3.4 numpy- List currently installed packages in current environment:    conda list- Delete unused packages and caches:    conda clean --all</code></pre><h3 id="Python-pip-配置国内源-pip-install-Read-timed-out"><a href="#Python-pip-配置国内源-pip-install-Read-timed-out" class="headerlink" title="Python pip 配置国内源[pip install Read timed out]"></a>Python pip 配置国内源[pip install Read timed out]</h3><h4 id="【方式一】临时生效"><a href="#【方式一】临时生效" class="headerlink" title="【方式一】临时生效"></a>【方式一】临时生效</h4><pre><code class="hljs awk"><span class="hljs-comment"># 在安装时加上镜像源</span>pip install &lt;库名&gt; -i https:<span class="hljs-regexp">//</span>pypi.douban.com<span class="hljs-regexp">/simple/</span> --trusted-host pypi.douban.compyth</code></pre><p><strong>方式二】永久指定</strong></p><h5 id="国内源列表（推荐用阿里云的）"><a href="#国内源列表（推荐用阿里云的）" class="headerlink" title="国内源列表（推荐用阿里云的）"></a>国内源列表（推荐用阿里云的）</h5><p>阿里云<code>http://mirrors.aliyun.com/pypi/simple/</code></p><p>中国科技大学 <code>https://pypi.mirrors.ustc.edu.cn/simple/</code></p><p>豆瓣 (douban) <code>https://pypi.douban.com/simple/</code></p><p>清华大学 <code>https://pypi.tuna.tsinghua.edu.cn/simple/</code></p><p>中国科学技术大学 <code>http://pypi.mirrors.ustc.edu.cn/simple/</code></p><h5 id="永久指定方式"><a href="#永久指定方式" class="headerlink" title="永久指定方式"></a>永久指定方式</h5><pre><code class="hljs shell">mkdir .pip# 在家目录下创建一个.pip目录~ cd pip~ touch pip.conf # 创建一个pip配置文件<span class="hljs-meta">#</span><span class="bash"> 写入配置</span>[global]index-url = http://mirrors.aliyun.com/pypi/simple/[install]trusted-host = mirrors.aliyun.com</code></pre><h3 id="更新Python版本后-命令行下pip-命令报错"><a href="#更新Python版本后-命令行下pip-命令报错" class="headerlink" title="更新Python版本后,命令行下pip 命令报错"></a>更新Python版本后,命令行下pip 命令报错</h3><p>电脑中Python3由3.7更新到3.9后，在命令行下使用<code>pip list</code>报以下错误</p><pre><code class="hljs gradle">zsh: <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/bin/</span>pip: bad interpreter: <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/opt/</span>python<span class="hljs-regexp">/bin/</span>python3.<span class="hljs-number">7</span>: no such <span class="hljs-keyword">file</span> or directory</code></pre><p>但是命令<code>pip3 list</code>可以正常使用，这是需要考虑<code>pip</code>指向的python设置是否正确</p><pre><code class="hljs zsh"><span class="hljs-comment"># 查看pip命令配置文件</span><span class="hljs-built_in">which</span> pip/usr/<span class="hljs-built_in">local</span>/bin/pip<span class="hljs-comment"># 查看pip3命令配置文件</span>/usr/<span class="hljs-built_in">local</span>/bin/pip3</code></pre><p>对比发现/usr/local/bin/pip指向的python版本时3.7，/usr/local/bin/pip3指向的是正确的。因此，将/usr/local/bin/pip指向python版本的配置修改成/usr/local/bin/pip3指向的配置。</p><h3 id="开发配置"><a href="#开发配置" class="headerlink" title="开发配置"></a>开发配置</h3><h4 id="Iterm2"><a href="#Iterm2" class="headerlink" title="Iterm2"></a>Iterm2</h4><h4 id="oh-my-zsh"><a href="#oh-my-zsh" class="headerlink" title="oh-my-zsh"></a>oh-my-zsh</h4><h4 id="tldr"><a href="#tldr" class="headerlink" title="tldr"></a>tldr</h4><h3 id="Catalina升级Sur-Big遇到的坑"><a href="#Catalina升级Sur-Big遇到的坑" class="headerlink" title="Catalina升级Sur Big遇到的坑"></a>Catalina升级Sur Big遇到的坑</h3><h4 id="Homebrew-1"><a href="#Homebrew-1" class="headerlink" title="Homebrew"></a>Homebrew</h4><h5 id="brew报错：-initialize’-Version-value-must-be-a-string-got-a-NilClass-TypeError"><a href="#brew报错：-initialize’-Version-value-must-be-a-string-got-a-NilClass-TypeError" class="headerlink" title="brew报错：`initialize’: Version value must be a string; got a NilClass () (TypeError)"></a>brew报错：`initialize’: Version value must be a string; got a NilClass () (TypeError)</h5><pre><code class="hljs Python">brew <span class="hljs-built_in">list</span>Traceback (most recent call last):    <span class="hljs-number">11</span>: <span class="hljs-keyword">from</span> /usr/local/Homebrew/Library/Homebrew/brew.rb:<span class="hljs-number">23</span>:<span class="hljs-keyword">in</span> `&lt;main&gt;<span class="hljs-string">&#x27;</span><span class="hljs-string">    10: from /usr/local/Homebrew/Library/Homebrew/brew.rb:23:in `require_relative&#x27;</span>     <span class="hljs-number">9</span>: <span class="hljs-keyword">from</span> /usr/local/Homebrew/Library/Homebrew/<span class="hljs-keyword">global</span>.rb:<span class="hljs-number">29</span>:<span class="hljs-keyword">in</span> `&lt;top (required)&gt;<span class="hljs-string">&#x27;</span><span class="hljs-string">     8: from /System/Library/Frameworks/Ruby.framework/Versions/2.6/usr/lib/ruby/2.6.0/rubygems/core_ext/kernel_require.rb:54:in `require&#x27;</span>     <span class="hljs-number">7</span>: <span class="hljs-keyword">from</span> /System/Library/Frameworks/Ruby.framework/Versions/<span class="hljs-number">2.6</span>/usr/lib/ruby/<span class="hljs-number">2.6</span><span class="hljs-number">.0</span>/rubygems/core_ext/kernel_require.rb:<span class="hljs-number">54</span>:<span class="hljs-keyword">in</span> `require<span class="hljs-string">&#x27;</span><span class="hljs-string">     6: from /usr/local/Homebrew/Library/Homebrew/os.rb:3:in `&lt;top (required)&gt;&#x27;</span>     <span class="hljs-number">5</span>: <span class="hljs-keyword">from</span> /usr/local/Homebrew/Library/Homebrew/os.rb:<span class="hljs-number">21</span>:<span class="hljs-keyword">in</span> `&lt;module:OS&gt;<span class="hljs-string">&#x27;</span><span class="hljs-string">     4: from /usr/local/Homebrew/Library/Homebrew/os/mac.rb:58:in `prerelease?&#x27;</span>     <span class="hljs-number">3</span>: <span class="hljs-keyword">from</span> /usr/local/Homebrew/Library/Homebrew/os/mac.rb:<span class="hljs-number">24</span>:<span class="hljs-keyword">in</span> `version<span class="hljs-string">&#x27;</span><span class="hljs-string">     2: from /usr/local/Homebrew/Library/Homebrew/os/mac.rb:24:in `new&#x27;</span>     <span class="hljs-number">1</span>: <span class="hljs-keyword">from</span> /usr/local/Homebrew/Library/Homebrew/os/mac/version.rb:<span class="hljs-number">26</span>:<span class="hljs-keyword">in</span> `initialize<span class="hljs-string">&#x27;</span><span class="hljs-string">/usr/local/Homebrew/Library/Homebrew/version.rb:368:in `initialize&#x27;</span>: Version value must be a string; got a NilClass () (TypeError)</code></pre><p>根据Traceback信息可以发现/usr/local/Homebrew/Library/Homebrew/os/mac/version.rb中报错,vim打开该文件</p><pre><code class="hljs Python">vim /usr/local/Homebrew/Library/Homebrew/os/mac/version.rb<span class="hljs-comment"># typed: true</span><span class="hljs-comment"># frozen_string_literal: true</span>require <span class="hljs-string">&quot;hardware&quot;</span>require <span class="hljs-string">&quot;version&quot;</span>module OS  module Mac    <span class="hljs-comment"># A macOS version.</span>    <span class="hljs-comment">#</span>    <span class="hljs-comment"># @api private</span>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Version</span> &lt; :</span>:Version      SYMBOLS =         catalina:    <span class="hljs-string">&quot;10.15&quot;</span>,        mojave:      <span class="hljs-string">&quot;10.14&quot;</span>,        high_sierra: <span class="hljs-string">&quot;10.13&quot;</span>,        sierra:      <span class="hljs-string">&quot;10.12&quot;</span>,        el_capitan:  <span class="hljs-string">&quot;10.11&quot;</span>,        yosemite:    <span class="hljs-string">&quot;10.10&quot;</span>,      &#125;.freeze      <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">self</span>.<span class="hljs-title">from_symbol</span>(<span class="hljs-params">sym</span>)</span>        str = SYMBOLS.fetch(sym) &#123; raise MacOSVersionError, sym &#125;        new(<span class="hljs-built_in">str</span>)      end      <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">initialize</span>(<span class="hljs-params">value</span>)</span><span class="hljs-function">        <span class="hljs-title">super</span>(<span class="hljs-params">value</span>)</span><span class="hljs-function"></span>        raise MacOSVersionError, value unless value.match?(/\A1\d+(?:\.\d+)&#123;0,2&#125;\Z/)</code></pre><p>从代码中可以看出,该版本的Homebrew不支持Sur Big系统,于是解决方案是更新Homebrew</p><pre><code class="hljs bash">brew update-reset</code></pre><p>结果,brew没了,命令输入brew报错</p><pre><code class="hljs bash">zsh:brew: <span class="hljs-built_in">command</span> not found</code></pre><p>无奈只能重新安装</p><p>但是这次就没有那么幸运,ruby源已更换成国内的</p><p>使用科学上网,也无法访问<a href="https://raw.githubusercontent.com/">https://raw.githubusercontent.com</a></p><p>于是只能另寻方法,Google上找到.bash脚本</p><p>桌面创建.bash文件</p><pre><code class="hljs awk">vim <span class="hljs-regexp">/Desktop/</span>brew_install.sh</code></pre><p>脚本内容</p><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><span class="hljs-built_in">set</span> -u<span class="hljs-comment"># First check if the OS is Linux.</span><span class="hljs-keyword">if</span> [[ <span class="hljs-string">&quot;<span class="hljs-subst">$(uname)</span>&quot;</span> = <span class="hljs-string">&quot;Linux&quot;</span> ]]; <span class="hljs-keyword">then</span>  HOMEBREW_ON_LINUX=1<span class="hljs-keyword">fi</span><span class="hljs-comment"># Check if macOS is ARM</span><span class="hljs-keyword">if</span> [[ <span class="hljs-string">&quot;<span class="hljs-subst">$(uname -m)</span>&quot;</span> = <span class="hljs-string">&quot;arm64&quot;</span> ]] &amp;&amp; [[ <span class="hljs-string">&quot;<span class="hljs-subst">$(uname)</span>&quot;</span> = <span class="hljs-string">&quot;Darwin&quot;</span> ]]; <span class="hljs-keyword">then</span>  HOMEBREW_APPLE_SILICON=1<span class="hljs-keyword">fi</span><span class="hljs-comment"># On macOS, this script installs to /usr/local only.</span><span class="hljs-comment"># On Linux, it installs to /home/linuxbrew/.linuxbrew if you have sudo access</span><span class="hljs-comment"># and ~/.linuxbrew otherwise.</span><span class="hljs-comment"># To install elsewhere (which is unsupported)</span><span class="hljs-comment"># you can untar https://github.com/Homebrew/brew/tarball/master</span><span class="hljs-comment"># anywhere you like.</span><span class="hljs-keyword">if</span> [[ -z <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;HOMEBREW_ON_LINUX-&#125;</span>&quot;</span> ]]; <span class="hljs-keyword">then</span>  HOMEBREW_PREFIX=<span class="hljs-string">&quot;/usr/local&quot;</span>  HOMEBREW_REPOSITORY=<span class="hljs-string">&quot;/usr/local/Homebrew&quot;</span>  HOMEBREW_CACHE=<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;HOME&#125;</span>/Library/Caches/Homebrew&quot;</span>  STAT=<span class="hljs-string">&quot;stat -f&quot;</span>  CHOWN=<span class="hljs-string">&quot;/usr/sbin/chown&quot;</span>  CHGRP=<span class="hljs-string">&quot;/usr/bin/chgrp&quot;</span>  GROUP=<span class="hljs-string">&quot;admin&quot;</span>  TOUCH=<span class="hljs-string">&quot;/usr/bin/touch&quot;</span><span class="hljs-keyword">else</span>  HOMEBREW_PREFIX_DEFAULT=<span class="hljs-string">&quot;/home/linuxbrew/.linuxbrew&quot;</span>  HOMEBREW_CACHE=<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;HOME&#125;</span>/.cache/Homebrew&quot;</span>  STAT=<span class="hljs-string">&quot;stat --printf&quot;</span>  CHOWN=<span class="hljs-string">&quot;/bin/chown&quot;</span>  CHGRP=<span class="hljs-string">&quot;/bin/chgrp&quot;</span>  GROUP=<span class="hljs-string">&quot;<span class="hljs-subst">$(id -gn)</span>&quot;</span>  TOUCH=<span class="hljs-string">&quot;/bin/touch&quot;</span><span class="hljs-keyword">fi</span>BREW_REPO=<span class="hljs-string">&quot;https://github.com/Homebrew/brew&quot;</span><span class="hljs-comment"># <span class="hljs-doctag">TODO:</span> bump version when new macOS is released</span>MACOS_LATEST_SUPPORTED=<span class="hljs-string">&quot;10.15&quot;</span><span class="hljs-comment"># <span class="hljs-doctag">TODO:</span> bump version when new macOS is released</span>MACOS_OLDEST_SUPPORTED=<span class="hljs-string">&quot;10.13&quot;</span><span class="hljs-comment"># For Homebrew on Linux</span>REQUIRED_RUBY_VERSION=2.6  <span class="hljs-comment"># https://github.com/Homebrew/brew/pull/6556</span>REQUIRED_GLIBC_VERSION=2.13  <span class="hljs-comment"># https://docs.brew.sh/Homebrew-on-Linux#requirements</span><span class="hljs-comment"># no analytics during installation</span><span class="hljs-built_in">export</span> HOMEBREW_NO_ANALYTICS_THIS_RUN=1<span class="hljs-built_in">export</span> HOMEBREW_NO_ANALYTICS_MESSAGE_OUTPUT=1<span class="hljs-comment"># string formatters</span><span class="hljs-keyword">if</span> [[ -t 1 ]]; <span class="hljs-keyword">then</span>  <span class="hljs-function"><span class="hljs-title">tty_escape</span></span>() &#123; <span class="hljs-built_in">printf</span> <span class="hljs-string">&quot;\033[%sm&quot;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span>; &#125;<span class="hljs-keyword">else</span>  <span class="hljs-function"><span class="hljs-title">tty_escape</span></span>() &#123; :; &#125;<span class="hljs-keyword">fi</span><span class="hljs-function"><span class="hljs-title">tty_mkbold</span></span>() &#123; tty_escape <span class="hljs-string">&quot;1;<span class="hljs-variable">$1</span>&quot;</span>; &#125;tty_underline=<span class="hljs-string">&quot;<span class="hljs-subst">$(tty_escape <span class="hljs-string">&quot;4;39&quot;</span>)</span>&quot;</span>tty_blue=<span class="hljs-string">&quot;<span class="hljs-subst">$(tty_mkbold 34)</span>&quot;</span>tty_red=<span class="hljs-string">&quot;<span class="hljs-subst">$(tty_mkbold 31)</span>&quot;</span>tty_bold=<span class="hljs-string">&quot;<span class="hljs-subst">$(tty_mkbold 39)</span>&quot;</span>tty_reset=<span class="hljs-string">&quot;<span class="hljs-subst">$(tty_escape 0)</span>&quot;</span><span class="hljs-function"><span class="hljs-title">have_sudo_access</span></span>() &#123;  <span class="hljs-built_in">local</span> -a args  <span class="hljs-keyword">if</span> [[ -n <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;SUDO_ASKPASS-&#125;</span>&quot;</span> ]]; <span class="hljs-keyword">then</span>    args=(<span class="hljs-string">&quot;-A&quot;</span>)  <span class="hljs-keyword">fi</span>  <span class="hljs-keyword">if</span> [[ -z <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;HAVE_SUDO_ACCESS-&#125;</span>&quot;</span> ]]; <span class="hljs-keyword">then</span>    <span class="hljs-keyword">if</span> [[ -n <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;args[*]-&#125;</span>&quot;</span> ]]; <span class="hljs-keyword">then</span>      /usr/bin/sudo <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;args[@]&#125;</span>&quot;</span> -l mkdir &amp;&gt;/dev/null    <span class="hljs-keyword">else</span>      /usr/bin/sudo -l mkdir &amp;&gt;/dev/null    <span class="hljs-keyword">fi</span>    HAVE_SUDO_ACCESS=<span class="hljs-string">&quot;$?&quot;</span>  <span class="hljs-keyword">fi</span>  <span class="hljs-keyword">if</span> [[ -z <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;HOMEBREW_ON_LINUX-&#125;</span>&quot;</span> ]] &amp;&amp; [[ <span class="hljs-string">&quot;<span class="hljs-variable">$HAVE_SUDO_ACCESS</span>&quot;</span> -ne 0 ]]; <span class="hljs-keyword">then</span>    abort <span class="hljs-string">&quot;Need sudo access on macOS (e.g. the user <span class="hljs-variable">$USER</span> to be an Administrator)!&quot;</span>  <span class="hljs-keyword">fi</span>  <span class="hljs-built_in">return</span> <span class="hljs-string">&quot;<span class="hljs-variable">$HAVE_SUDO_ACCESS</span>&quot;</span>&#125;<span class="hljs-function"><span class="hljs-title">shell_join</span></span>() &#123;  <span class="hljs-built_in">local</span> arg  <span class="hljs-built_in">printf</span> <span class="hljs-string">&quot;%s&quot;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span>  <span class="hljs-built_in">shift</span>  <span class="hljs-keyword">for</span> arg <span class="hljs-keyword">in</span> <span class="hljs-string">&quot;<span class="hljs-variable">$@</span>&quot;</span>; <span class="hljs-keyword">do</span>    <span class="hljs-built_in">printf</span> <span class="hljs-string">&quot; &quot;</span>    <span class="hljs-built_in">printf</span> <span class="hljs-string">&quot;%s&quot;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;arg// /\ &#125;</span>&quot;</span>  <span class="hljs-keyword">done</span>&#125;<span class="hljs-function"><span class="hljs-title">chomp</span></span>() &#123;  <span class="hljs-built_in">printf</span> <span class="hljs-string">&quot;%s&quot;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;1/&quot;$&#x27;\n&#x27;&quot;/&#125;</span>&quot;</span>&#125;<span class="hljs-function"><span class="hljs-title">ohai</span></span>() &#123;  <span class="hljs-built_in">printf</span> <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;tty_blue&#125;</span>==&gt;<span class="hljs-variable">$&#123;tty_bold&#125;</span> %s<span class="hljs-variable">$&#123;tty_reset&#125;</span>\n&quot;</span> <span class="hljs-string">&quot;<span class="hljs-subst">$(shell_join <span class="hljs-string">&quot;<span class="hljs-variable">$@</span>&quot;</span>)</span>&quot;</span>&#125;<span class="hljs-function"><span class="hljs-title">warn</span></span>() &#123;  <span class="hljs-built_in">printf</span> <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;tty_red&#125;</span>Warning<span class="hljs-variable">$&#123;tty_reset&#125;</span>: %s\n&quot;</span> <span class="hljs-string">&quot;<span class="hljs-subst">$(chomp <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span>)</span>&quot;</span>&#125;<span class="hljs-function"><span class="hljs-title">abort</span></span>() &#123;  <span class="hljs-built_in">printf</span> <span class="hljs-string">&quot;%s\n&quot;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span>  <span class="hljs-built_in">exit</span> 1&#125;<span class="hljs-function"><span class="hljs-title">execute</span></span>() &#123;  <span class="hljs-keyword">if</span> ! <span class="hljs-string">&quot;<span class="hljs-variable">$@</span>&quot;</span>; <span class="hljs-keyword">then</span>    abort <span class="hljs-string">&quot;<span class="hljs-subst">$(printf <span class="hljs-string">&quot;Failed during: %s&quot;</span> <span class="hljs-string">&quot;<span class="hljs-subst">$(shell_join <span class="hljs-string">&quot;<span class="hljs-variable">$@</span>&quot;</span>)</span>&quot;</span>)</span>&quot;</span>  <span class="hljs-keyword">fi</span>&#125;<span class="hljs-function"><span class="hljs-title">execute_sudo</span></span>() &#123;  <span class="hljs-built_in">local</span> -a args=(<span class="hljs-string">&quot;<span class="hljs-variable">$@</span>&quot;</span>)  <span class="hljs-keyword">if</span> [[ -n <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;SUDO_ASKPASS-&#125;</span>&quot;</span> ]]; <span class="hljs-keyword">then</span>    args=(<span class="hljs-string">&quot;-A&quot;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;args[@]&#125;</span>&quot;</span>)  <span class="hljs-keyword">fi</span>  <span class="hljs-keyword">if</span> have_sudo_access; <span class="hljs-keyword">then</span>    ohai <span class="hljs-string">&quot;/usr/bin/sudo&quot;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;args[@]&#125;</span>&quot;</span>    execute <span class="hljs-string">&quot;/usr/bin/sudo&quot;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;args[@]&#125;</span>&quot;</span>  <span class="hljs-keyword">else</span>    ohai <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;args[@]&#125;</span>&quot;</span>    execute <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;args[@]&#125;</span>&quot;</span>  <span class="hljs-keyword">fi</span>&#125;<span class="hljs-function"><span class="hljs-title">getc</span></span>() &#123;  <span class="hljs-built_in">local</span> save_state  save_state=$(/bin/stty -g)  /bin/stty raw -<span class="hljs-built_in">echo</span>  IFS= <span class="hljs-built_in">read</span> -r -n 1 -d <span class="hljs-string">&#x27;&#x27;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$@</span>&quot;</span>  /bin/stty <span class="hljs-string">&quot;<span class="hljs-variable">$save_state</span>&quot;</span>&#125;<span class="hljs-function"><span class="hljs-title">wait_for_user</span></span>() &#123;  <span class="hljs-built_in">local</span> c  <span class="hljs-built_in">echo</span>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Press RETURN to continue or any other key to abort&quot;</span>  getc c  <span class="hljs-comment"># we test for \r and \n because some stuff does \r instead</span>  <span class="hljs-keyword">if</span> ! [[ <span class="hljs-string">&quot;<span class="hljs-variable">$c</span>&quot;</span> == $<span class="hljs-string">&#x27;\r&#x27;</span> || <span class="hljs-string">&quot;<span class="hljs-variable">$c</span>&quot;</span> == $<span class="hljs-string">&#x27;\n&#x27;</span> ]]; <span class="hljs-keyword">then</span>    <span class="hljs-built_in">exit</span> 1  <span class="hljs-keyword">fi</span>&#125;<span class="hljs-function"><span class="hljs-title">major_minor</span></span>() &#123;  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;1%%.*&#125;</span>.<span class="hljs-subst">$(x=<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;1#*.&#125;</span>&quot;</span>; echo <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;x%%.*&#125;</span>&quot;</span>)</span>&quot;</span>&#125;<span class="hljs-keyword">if</span> [[ -z <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;HOMEBREW_ON_LINUX-&#125;</span>&quot;</span> ]]; <span class="hljs-keyword">then</span>  macos_version=<span class="hljs-string">&quot;<span class="hljs-subst">$(major_minor <span class="hljs-string">&quot;<span class="hljs-subst">$(/usr/bin/sw_vers -productVersion)</span>&quot;</span>)</span>&quot;</span><span class="hljs-keyword">fi</span><span class="hljs-function"><span class="hljs-title">version_gt</span></span>() &#123;  [[ <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;1%.*&#125;</span>&quot;</span> -gt <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;2%.*&#125;</span>&quot;</span> ]] || [[ <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;1%.*&#125;</span>&quot;</span> -eq <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;2%.*&#125;</span>&quot;</span> &amp;&amp; <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;1#*.&#125;</span>&quot;</span> -gt <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;2#*.&#125;</span>&quot;</span> ]]&#125;<span class="hljs-function"><span class="hljs-title">version_ge</span></span>() &#123;  [[ <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;1%.*&#125;</span>&quot;</span> -gt <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;2%.*&#125;</span>&quot;</span> ]] || [[ <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;1%.*&#125;</span>&quot;</span> -eq <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;2%.*&#125;</span>&quot;</span> &amp;&amp; <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;1#*.&#125;</span>&quot;</span> -ge <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;2#*.&#125;</span>&quot;</span> ]]&#125;<span class="hljs-function"><span class="hljs-title">version_lt</span></span>() &#123;  [[ <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;1%.*&#125;</span>&quot;</span> -lt <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;2%.*&#125;</span>&quot;</span> ]] || [[ <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;1%.*&#125;</span>&quot;</span> -eq <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;2%.*&#125;</span>&quot;</span> &amp;&amp; <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;1#*.&#125;</span>&quot;</span> -lt <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;2#*.&#125;</span>&quot;</span> ]]&#125;<span class="hljs-function"><span class="hljs-title">should_install_git</span></span>() &#123;  <span class="hljs-keyword">if</span> [[ $(<span class="hljs-built_in">command</span> -v git) ]]; <span class="hljs-keyword">then</span>    <span class="hljs-built_in">return</span> 1  <span class="hljs-keyword">fi</span>&#125;<span class="hljs-function"><span class="hljs-title">should_install_command_line_tools</span></span>() &#123;  <span class="hljs-keyword">if</span> [[ -n <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;HOMEBREW_ON_LINUX-&#125;</span>&quot;</span> ]]; <span class="hljs-keyword">then</span>    <span class="hljs-built_in">return</span> 1  <span class="hljs-keyword">fi</span>  <span class="hljs-keyword">if</span> [[ -n <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;HOMEBREW_APPLE_SILICON-&#125;</span>&quot;</span> ]]; <span class="hljs-keyword">then</span>    <span class="hljs-built_in">return</span> 1;  <span class="hljs-keyword">fi</span>  <span class="hljs-keyword">if</span> version_gt <span class="hljs-string">&quot;<span class="hljs-variable">$macos_version</span>&quot;</span> <span class="hljs-string">&quot;10.13&quot;</span>; <span class="hljs-keyword">then</span>    ! [[ -e <span class="hljs-string">&quot;/Library/Developer/CommandLineTools/usr/bin/git&quot;</span> ]]  <span class="hljs-keyword">else</span>    ! [[ -e <span class="hljs-string">&quot;/Library/Developer/CommandLineTools/usr/bin/git&quot;</span> ]] ||      ! [[ -e <span class="hljs-string">&quot;/usr/include/iconv.h&quot;</span> ]]  <span class="hljs-keyword">fi</span>&#125;<span class="hljs-function"><span class="hljs-title">get_permission</span></span>() &#123;  <span class="hljs-variable">$STAT</span> <span class="hljs-string">&quot;%A&quot;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span>&#125;<span class="hljs-function"><span class="hljs-title">user_only_chmod</span></span>() &#123;  [[ -d <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span> ]] &amp;&amp; [[ <span class="hljs-string">&quot;<span class="hljs-subst">$(get_permission <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span>)</span>&quot;</span> != <span class="hljs-string">&quot;755&quot;</span> ]]&#125;<span class="hljs-function"><span class="hljs-title">exists_but_not_writable</span></span>() &#123;  [[ -e <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span> ]] &amp;&amp; ! [[ -r <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span> &amp;&amp; -w <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span> &amp;&amp; -x <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span> ]]&#125;<span class="hljs-function"><span class="hljs-title">get_owner</span></span>() &#123;  <span class="hljs-variable">$STAT</span> <span class="hljs-string">&quot;%u&quot;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span>&#125;<span class="hljs-function"><span class="hljs-title">file_not_owned</span></span>() &#123;  [[ <span class="hljs-string">&quot;<span class="hljs-subst">$(get_owner <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span>)</span>&quot;</span> != <span class="hljs-string">&quot;<span class="hljs-subst">$(id -u)</span>&quot;</span> ]]&#125;<span class="hljs-function"><span class="hljs-title">get_group</span></span>() &#123;  <span class="hljs-variable">$STAT</span> <span class="hljs-string">&quot;%g&quot;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span>&#125;<span class="hljs-function"><span class="hljs-title">file_not_grpowned</span></span>() &#123;  [[ <span class="hljs-string">&quot; <span class="hljs-subst">$(id -G <span class="hljs-string">&quot;<span class="hljs-variable">$USER</span>&quot;</span>)</span> &quot;</span> != *<span class="hljs-string">&quot; <span class="hljs-subst">$(get_group <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span>)</span> &quot;</span>*  ]]&#125;<span class="hljs-comment"># Please sync with &#x27;test_ruby()&#x27; in &#x27;Library/Homebrew/utils/ruby.sh&#x27; from Homebrew/brew repository.</span><span class="hljs-function"><span class="hljs-title">test_ruby</span></span> () &#123;  <span class="hljs-keyword">if</span> [[ ! -x <span class="hljs-variable">$1</span> ]]  <span class="hljs-keyword">then</span>    <span class="hljs-built_in">return</span> 1  <span class="hljs-keyword">fi</span>  <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span> --enable-frozen-string-literal --<span class="hljs-built_in">disable</span>=gems,did_you_mean,rubyopt -rrubygems -e \    <span class="hljs-string">&quot;abort if Gem::Version.new(RUBY_VERSION.to_s.dup).to_s.split(&#x27;.&#x27;).first(2) != \</span><span class="hljs-string">              Gem::Version.new(&#x27;<span class="hljs-variable">$REQUIRED_RUBY_VERSION</span>&#x27;).to_s.split(&#x27;.&#x27;).first(2)&quot;</span> 2&gt;/dev/null&#125;<span class="hljs-function"><span class="hljs-title">no_usable_ruby</span></span>() &#123;  <span class="hljs-built_in">local</span> ruby_exec  IFS=$<span class="hljs-string">&#x27;\n&#x27;</span> <span class="hljs-comment"># Do word splitting on new lines only</span>  <span class="hljs-keyword">for</span> ruby_exec <span class="hljs-keyword">in</span> $(<span class="hljs-built_in">which</span> -a ruby); <span class="hljs-keyword">do</span>    <span class="hljs-keyword">if</span> test_ruby <span class="hljs-string">&quot;<span class="hljs-variable">$ruby_exec</span>&quot;</span>; <span class="hljs-keyword">then</span>      <span class="hljs-built_in">return</span> 1    <span class="hljs-keyword">fi</span>  <span class="hljs-keyword">done</span>  IFS=$<span class="hljs-string">&#x27; \t\n&#x27;</span> <span class="hljs-comment"># Restore IFS to its default value</span>  <span class="hljs-built_in">return</span> 0&#125;<span class="hljs-function"><span class="hljs-title">outdated_glibc</span></span>() &#123;  <span class="hljs-built_in">local</span> glibc_version  glibc_version=$(ldd --version | head -n1 | grep -o <span class="hljs-string">&#x27;[0-9.]*$&#x27;</span> | grep -o <span class="hljs-string">&#x27;^[0-9]\+\.[0-9]\+&#x27;</span>)  version_lt <span class="hljs-string">&quot;<span class="hljs-variable">$glibc_version</span>&quot;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$REQUIRED_GLIBC_VERSION</span>&quot;</span>&#125;<span class="hljs-keyword">if</span> [[ -n <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;HOMEBREW_ON_LINUX-&#125;</span>&quot;</span> ]] &amp;&amp; no_usable_ruby &amp;&amp; outdated_glibc<span class="hljs-keyword">then</span>    abort <span class="hljs-string">&quot;<span class="hljs-subst">$(cat &lt;&lt;-EOFABORT</span></span><span class="hljs-string"><span class="hljs-subst">    Homebrew requires Ruby $REQUIRED_RUBY_VERSION which was not found on your system.</span></span><span class="hljs-string"><span class="hljs-subst">    Homebrew portable Ruby requires Glibc version $REQUIRED_GLIBC_VERSION or newer,</span></span><span class="hljs-string"><span class="hljs-subst">    and your Glibc version is too old.</span></span><span class="hljs-string"><span class="hljs-subst">    See $&#123;tty_underline&#125;https://docs.brew.sh/Homebrew-on-Linux#requirements$&#123;tty_reset&#125;</span></span><span class="hljs-string"><span class="hljs-subst">    Install Ruby $REQUIRED_RUBY_VERSION and add its location to your PATH.</span></span><span class="hljs-string"><span class="hljs-subst">    EOFABORT</span></span><span class="hljs-string"><span class="hljs-subst">    )</span>&quot;</span><span class="hljs-keyword">fi</span><span class="hljs-comment"># USER isn&#x27;t always set so provide a fall back for the installer and subprocesses.</span><span class="hljs-keyword">if</span> [[ -z <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;USER-&#125;</span>&quot;</span> ]]; <span class="hljs-keyword">then</span>  USER=<span class="hljs-string">&quot;<span class="hljs-subst">$(chomp <span class="hljs-string">&quot;<span class="hljs-subst">$(id -un)</span>&quot;</span>)</span>&quot;</span>  <span class="hljs-built_in">export</span> USER<span class="hljs-keyword">fi</span><span class="hljs-comment"># Invalidate sudo timestamp before exiting (if it wasn&#x27;t active before).</span><span class="hljs-keyword">if</span> ! /usr/bin/sudo -n -v 2&gt;/dev/null; <span class="hljs-keyword">then</span>  <span class="hljs-built_in">trap</span> <span class="hljs-string">&#x27;/usr/bin/sudo -k&#x27;</span> EXIT<span class="hljs-keyword">fi</span><span class="hljs-comment"># Things can fail later if `pwd` doesn&#x27;t exist.</span><span class="hljs-comment"># Also sudo prints a warning message for no good reason</span><span class="hljs-built_in">cd</span> <span class="hljs-string">&quot;/usr&quot;</span> || <span class="hljs-built_in">exit</span> 1<span class="hljs-comment">####################################################################### script</span><span class="hljs-keyword">if</span> should_install_git; <span class="hljs-keyword">then</span>    abort <span class="hljs-string">&quot;<span class="hljs-subst">$(cat &lt;&lt;EOABORT</span></span><span class="hljs-string"><span class="hljs-subst">You must install Git before installing Homebrew. See:</span></span><span class="hljs-string"><span class="hljs-subst">  $&#123;tty_underline&#125;https://docs.brew.sh/Installation$&#123;tty_reset&#125;</span></span><span class="hljs-string"><span class="hljs-subst">EOABORT</span></span><span class="hljs-string"><span class="hljs-subst">)</span>&quot;</span><span class="hljs-keyword">fi</span><span class="hljs-keyword">if</span> [[ -z <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;HOMEBREW_ON_LINUX-&#125;</span>&quot;</span> ]]; <span class="hljs-keyword">then</span> have_sudo_access<span class="hljs-keyword">else</span>  <span class="hljs-keyword">if</span> [[ -n <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;CI-&#125;</span>&quot;</span> ]] || [[ -w <span class="hljs-string">&quot;<span class="hljs-variable">$HOMEBREW_PREFIX_DEFAULT</span>&quot;</span> ]] || [[ -w <span class="hljs-string">&quot;/home/linuxbrew&quot;</span> ]] || [[ -w <span class="hljs-string">&quot;/home&quot;</span> ]]; <span class="hljs-keyword">then</span>    HOMEBREW_PREFIX=<span class="hljs-string">&quot;<span class="hljs-variable">$HOMEBREW_PREFIX_DEFAULT</span>&quot;</span>  <span class="hljs-keyword">else</span>    <span class="hljs-built_in">trap</span> <span class="hljs-built_in">exit</span> SIGINT    <span class="hljs-keyword">if</span> [[ $(/usr/bin/sudo -n -l mkdir 2&gt;&amp;1) != *<span class="hljs-string">&quot;mkdir&quot;</span>* ]]; <span class="hljs-keyword">then</span>      ohai <span class="hljs-string">&quot;Select the Homebrew installation directory&quot;</span>      <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;- <span class="hljs-variable">$&#123;tty_bold&#125;</span>Enter your password<span class="hljs-variable">$&#123;tty_reset&#125;</span> to install to <span class="hljs-variable">$&#123;tty_underline&#125;</span><span class="hljs-variable">$&#123;HOMEBREW_PREFIX_DEFAULT&#125;</span><span class="hljs-variable">$&#123;tty_reset&#125;</span> (<span class="hljs-variable">$&#123;tty_bold&#125;</span>recommended<span class="hljs-variable">$&#123;tty_reset&#125;</span>)&quot;</span>      <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;- <span class="hljs-variable">$&#123;tty_bold&#125;</span>Press Control-D<span class="hljs-variable">$&#123;tty_reset&#125;</span> to install to <span class="hljs-variable">$&#123;tty_underline&#125;</span><span class="hljs-variable">$HOME</span>/.linuxbrew<span class="hljs-variable">$&#123;tty_reset&#125;</span>&quot;</span>      <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;- <span class="hljs-variable">$&#123;tty_bold&#125;</span>Press Control-C<span class="hljs-variable">$&#123;tty_reset&#125;</span> to cancel installation&quot;</span>    <span class="hljs-keyword">fi</span>    <span class="hljs-keyword">if</span> have_sudo_access; <span class="hljs-keyword">then</span>      HOMEBREW_PREFIX=<span class="hljs-string">&quot;<span class="hljs-variable">$HOMEBREW_PREFIX_DEFAULT</span>&quot;</span>    <span class="hljs-keyword">else</span>      HOMEBREW_PREFIX=<span class="hljs-string">&quot;<span class="hljs-variable">$HOME</span>/.linuxbrew&quot;</span>    <span class="hljs-keyword">fi</span>    <span class="hljs-built_in">trap</span> - SIGINT  <span class="hljs-keyword">fi</span>  HOMEBREW_REPOSITORY=<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;HOMEBREW_PREFIX&#125;</span>/Homebrew&quot;</span><span class="hljs-keyword">fi</span><span class="hljs-keyword">if</span> [[ <span class="hljs-string">&quot;<span class="hljs-variable">$UID</span>&quot;</span> == <span class="hljs-string">&quot;0&quot;</span> ]]; <span class="hljs-keyword">then</span>  abort <span class="hljs-string">&quot;Don&#x27;t run this as root!&quot;</span><span class="hljs-keyword">elif</span> [[ -d <span class="hljs-string">&quot;<span class="hljs-variable">$HOMEBREW_PREFIX</span>&quot;</span> &amp;&amp; ! -x <span class="hljs-string">&quot;<span class="hljs-variable">$HOMEBREW_PREFIX</span>&quot;</span> ]]; <span class="hljs-keyword">then</span>  abort <span class="hljs-string">&quot;<span class="hljs-subst">$(cat &lt;&lt;EOABORT</span></span><span class="hljs-string"><span class="hljs-subst">The Homebrew prefix, $&#123;HOMEBREW_PREFIX&#125;, exists but is not searchable. If this is</span></span><span class="hljs-string"><span class="hljs-subst">not intentional, please restore the default permissions and try running the</span></span><span class="hljs-string"><span class="hljs-subst">installer again:</span></span><span class="hljs-string"><span class="hljs-subst">    sudo chmod 775 $&#123;HOMEBREW_PREFIX&#125;</span></span><span class="hljs-string"><span class="hljs-subst">EOABORT</span></span><span class="hljs-string"><span class="hljs-subst">)</span>&quot;</span><span class="hljs-keyword">fi</span><span class="hljs-keyword">if</span> [[ -z <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;HOMEBREW_ON_LINUX-&#125;</span>&quot;</span> ]]; <span class="hljs-keyword">then</span>  <span class="hljs-keyword">if</span> version_lt <span class="hljs-string">&quot;<span class="hljs-variable">$macos_version</span>&quot;</span> <span class="hljs-string">&quot;10.7&quot;</span>; <span class="hljs-keyword">then</span>    abort <span class="hljs-string">&quot;<span class="hljs-subst">$(cat &lt;&lt;EOABORT</span></span><span class="hljs-string"><span class="hljs-subst">Your Mac OS X version is too old. See:</span></span><span class="hljs-string"><span class="hljs-subst">  $&#123;tty_underline&#125;https://github.com/mistydemeo/tigerbrew$&#123;tty_reset&#125;</span></span><span class="hljs-string"><span class="hljs-subst">EOABORT</span></span><span class="hljs-string"><span class="hljs-subst">)</span>&quot;</span>  <span class="hljs-keyword">elif</span> version_lt <span class="hljs-string">&quot;<span class="hljs-variable">$macos_version</span>&quot;</span> <span class="hljs-string">&quot;10.9&quot;</span>; <span class="hljs-keyword">then</span>    abort <span class="hljs-string">&quot;Your OS X version is too old&quot;</span>  <span class="hljs-keyword">elif</span> version_gt <span class="hljs-string">&quot;<span class="hljs-variable">$macos_version</span>&quot;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$MACOS_LATEST_SUPPORTED</span>&quot;</span> || \    version_lt <span class="hljs-string">&quot;<span class="hljs-variable">$macos_version</span>&quot;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$MACOS_OLDEST_SUPPORTED</span>&quot;</span>; <span class="hljs-keyword">then</span>    who=<span class="hljs-string">&quot;We&quot;</span>    what=<span class="hljs-string">&quot;&quot;</span>    <span class="hljs-keyword">if</span> version_gt <span class="hljs-string">&quot;<span class="hljs-variable">$macos_version</span>&quot;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$MACOS_LATEST_SUPPORTED</span>&quot;</span>; <span class="hljs-keyword">then</span>      what=<span class="hljs-string">&quot;pre-release version&quot;</span>    <span class="hljs-keyword">else</span>      who+=<span class="hljs-string">&quot; (and Apple)&quot;</span>      what=<span class="hljs-string">&quot;old version&quot;</span>    <span class="hljs-keyword">fi</span>    ohai <span class="hljs-string">&quot;You are using macOS <span class="hljs-variable">$&#123;macos_version&#125;</span>.&quot;</span>    ohai <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;who&#125;</span> do not provide support for this <span class="hljs-variable">$&#123;what&#125;</span>.&quot;</span>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-subst">$(cat &lt;&lt;EOS</span></span><span class="hljs-string"><span class="hljs-subst">This installation may not succeed.</span></span><span class="hljs-string"><span class="hljs-subst">After installation, you will encounter build failures with some formulae.</span></span><span class="hljs-string"><span class="hljs-subst">Please create pull requests instead of asking for help on Homebrew\&#x27;s GitHub,</span></span><span class="hljs-string"><span class="hljs-subst">Discourse, Twitter or IRC. You are responsible for resolving any issues you</span></span><span class="hljs-string"><span class="hljs-subst">experience while you are running this $&#123;what&#125;.</span></span><span class="hljs-string"><span class="hljs-subst">EOS</span></span><span class="hljs-string"><span class="hljs-subst">)</span></span><span class="hljs-string">&quot;</span>  <span class="hljs-keyword">fi</span><span class="hljs-keyword">fi</span>ohai <span class="hljs-string">&quot;This script will install:&quot;</span><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;HOMEBREW_PREFIX&#125;</span>/bin/brew&quot;</span><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;HOMEBREW_PREFIX&#125;</span>/share/doc/homebrew&quot;</span><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;HOMEBREW_PREFIX&#125;</span>/share/man/man1/brew.1&quot;</span><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;HOMEBREW_PREFIX&#125;</span>/share/zsh/site-functions/_brew&quot;</span><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;HOMEBREW_PREFIX&#125;</span>/etc/bash_completion.d/brew&quot;</span><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;HOMEBREW_REPOSITORY&#125;</span>&quot;</span><span class="hljs-comment"># Keep relatively in sync with</span><span class="hljs-comment"># https://github.com/Homebrew/brew/blob/master/Library/Homebrew/keg.rb</span>directories=(bin etc include lib sbin share opt var             Frameworks             etc/bash_completion.d lib/pkgconfig             share/aclocal share/doc share/info share/locale share/man             share/man/man1 share/man/man2 share/man/man3 share/man/man4             share/man/man5 share/man/man6 share/man/man7 share/man/man8             var/<span class="hljs-built_in">log</span> var/homebrew var/homebrew/linked             bin/brew)group_chmods=()<span class="hljs-keyword">for</span> dir <span class="hljs-keyword">in</span> <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;directories[@]&#125;</span>&quot;</span>; <span class="hljs-keyword">do</span>  <span class="hljs-keyword">if</span> exists_but_not_writable <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;HOMEBREW_PREFIX&#125;</span>/<span class="hljs-variable">$&#123;dir&#125;</span>&quot;</span>; <span class="hljs-keyword">then</span>    group_chmods+=(<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;HOMEBREW_PREFIX&#125;</span>/<span class="hljs-variable">$&#123;dir&#125;</span>&quot;</span>)  <span class="hljs-keyword">fi</span><span class="hljs-keyword">done</span><span class="hljs-comment"># zsh refuses to read from these directories if group writable</span>directories=(share/zsh share/zsh/site-functions)zsh_dirs=()<span class="hljs-keyword">for</span> dir <span class="hljs-keyword">in</span> <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;directories[@]&#125;</span>&quot;</span>; <span class="hljs-keyword">do</span>  zsh_dirs+=(<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;HOMEBREW_PREFIX&#125;</span>/<span class="hljs-variable">$&#123;dir&#125;</span>&quot;</span>)<span class="hljs-keyword">done</span>directories=(bin etc include lib sbin share var opt             share/zsh share/zsh/site-functions             var/homebrew var/homebrew/linked             Cellar Caskroom Homebrew Frameworks)mkdirs=()<span class="hljs-keyword">for</span> dir <span class="hljs-keyword">in</span> <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;directories[@]&#125;</span>&quot;</span>; <span class="hljs-keyword">do</span>  <span class="hljs-keyword">if</span> ! [[ -d <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;HOMEBREW_PREFIX&#125;</span>/<span class="hljs-variable">$&#123;dir&#125;</span>&quot;</span> ]]; <span class="hljs-keyword">then</span>    mkdirs+=(<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;HOMEBREW_PREFIX&#125;</span>/<span class="hljs-variable">$&#123;dir&#125;</span>&quot;</span>)  <span class="hljs-keyword">fi</span><span class="hljs-keyword">done</span>user_chmods=()<span class="hljs-keyword">if</span> [[ <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;#zsh_dirs[@]&#125;</span>&quot;</span> -gt 0 ]]; <span class="hljs-keyword">then</span>  <span class="hljs-keyword">for</span> dir <span class="hljs-keyword">in</span> <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;zsh_dirs[@]&#125;</span>&quot;</span>; <span class="hljs-keyword">do</span>    <span class="hljs-keyword">if</span> user_only_chmod <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;dir&#125;</span>&quot;</span>; <span class="hljs-keyword">then</span>      user_chmods+=(<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;dir&#125;</span>&quot;</span>)    <span class="hljs-keyword">fi</span>  <span class="hljs-keyword">done</span><span class="hljs-keyword">fi</span>chmods=()<span class="hljs-keyword">if</span> [[ <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;#group_chmods[@]&#125;</span>&quot;</span> -gt 0 ]]; <span class="hljs-keyword">then</span>  chmods+=(<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;group_chmods[@]&#125;</span>&quot;</span>)<span class="hljs-keyword">fi</span><span class="hljs-keyword">if</span> [[ <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;#user_chmods[@]&#125;</span>&quot;</span> -gt 0 ]]; <span class="hljs-keyword">then</span>  chmods+=(<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;user_chmods[@]&#125;</span>&quot;</span>)<span class="hljs-keyword">fi</span>chowns=()chgrps=()<span class="hljs-keyword">if</span> [[ <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;#chmods[@]&#125;</span>&quot;</span> -gt 0 ]]; <span class="hljs-keyword">then</span>  <span class="hljs-keyword">for</span> dir <span class="hljs-keyword">in</span> <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;chmods[@]&#125;</span>&quot;</span>; <span class="hljs-keyword">do</span>    <span class="hljs-keyword">if</span> file_not_owned <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;dir&#125;</span>&quot;</span>; <span class="hljs-keyword">then</span>      chowns+=(<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;dir&#125;</span>&quot;</span>)    <span class="hljs-keyword">fi</span>    <span class="hljs-keyword">if</span> file_not_grpowned <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;dir&#125;</span>&quot;</span>; <span class="hljs-keyword">then</span>      chgrps+=(<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;dir&#125;</span>&quot;</span>)    <span class="hljs-keyword">fi</span>  <span class="hljs-keyword">done</span><span class="hljs-keyword">fi</span><span class="hljs-keyword">if</span> [[ <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;#group_chmods[@]&#125;</span>&quot;</span> -gt 0 ]]; <span class="hljs-keyword">then</span>  ohai <span class="hljs-string">&quot;The following existing directories will be made group writable:&quot;</span>  <span class="hljs-built_in">printf</span> <span class="hljs-string">&quot;%s\n&quot;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;group_chmods[@]&#125;</span>&quot;</span><span class="hljs-keyword">fi</span><span class="hljs-keyword">if</span> [[ <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;#user_chmods[@]&#125;</span>&quot;</span> -gt 0 ]]; <span class="hljs-keyword">then</span>  ohai <span class="hljs-string">&quot;The following existing directories will be made writable by user only:&quot;</span>  <span class="hljs-built_in">printf</span> <span class="hljs-string">&quot;%s\n&quot;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;user_chmods[@]&#125;</span>&quot;</span><span class="hljs-keyword">fi</span><span class="hljs-keyword">if</span> [[ <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;#chowns[@]&#125;</span>&quot;</span> -gt 0 ]]; <span class="hljs-keyword">then</span>  ohai <span class="hljs-string">&quot;The following existing directories will have their owner set to <span class="hljs-variable">$&#123;tty_underline&#125;</span><span class="hljs-variable">$&#123;USER&#125;</span><span class="hljs-variable">$&#123;tty_reset&#125;</span>:&quot;</span>  <span class="hljs-built_in">printf</span> <span class="hljs-string">&quot;%s\n&quot;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;chowns[@]&#125;</span>&quot;</span><span class="hljs-keyword">fi</span><span class="hljs-keyword">if</span> [[ <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;#chgrps[@]&#125;</span>&quot;</span> -gt 0 ]]; <span class="hljs-keyword">then</span>  ohai <span class="hljs-string">&quot;The following existing directories will have their group set to <span class="hljs-variable">$&#123;tty_underline&#125;</span><span class="hljs-variable">$&#123;GROUP&#125;</span><span class="hljs-variable">$&#123;tty_reset&#125;</span>:&quot;</span>  <span class="hljs-built_in">printf</span> <span class="hljs-string">&quot;%s\n&quot;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;chgrps[@]&#125;</span>&quot;</span><span class="hljs-keyword">fi</span><span class="hljs-keyword">if</span> [[ <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;#mkdirs[@]&#125;</span>&quot;</span> -gt 0 ]]; <span class="hljs-keyword">then</span>  ohai <span class="hljs-string">&quot;The following new directories will be created:&quot;</span>  <span class="hljs-built_in">printf</span> <span class="hljs-string">&quot;%s\n&quot;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;mkdirs[@]&#125;</span>&quot;</span><span class="hljs-keyword">fi</span><span class="hljs-keyword">if</span> should_install_command_line_tools; <span class="hljs-keyword">then</span>  ohai <span class="hljs-string">&quot;The Xcode Command Line Tools will be installed.&quot;</span><span class="hljs-keyword">fi</span><span class="hljs-keyword">if</span> [[ -t 0 &amp;&amp; -z <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;CI-&#125;</span>&quot;</span> ]]; <span class="hljs-keyword">then</span>  wait_for_user<span class="hljs-keyword">fi</span><span class="hljs-keyword">if</span> [[ -d <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;HOMEBREW_PREFIX&#125;</span>&quot;</span> ]]; <span class="hljs-keyword">then</span>  <span class="hljs-keyword">if</span> [[ <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;#chmods[@]&#125;</span>&quot;</span> -gt 0 ]]; <span class="hljs-keyword">then</span>    execute_sudo <span class="hljs-string">&quot;/bin/chmod&quot;</span> <span class="hljs-string">&quot;u+rwx&quot;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;chmods[@]&#125;</span>&quot;</span>  <span class="hljs-keyword">fi</span>  <span class="hljs-keyword">if</span> [[ <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;#group_chmods[@]&#125;</span>&quot;</span> -gt 0 ]]; <span class="hljs-keyword">then</span>    execute_sudo <span class="hljs-string">&quot;/bin/chmod&quot;</span> <span class="hljs-string">&quot;g+rwx&quot;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;group_chmods[@]&#125;</span>&quot;</span>  <span class="hljs-keyword">fi</span>  <span class="hljs-keyword">if</span> [[ <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;#user_chmods[@]&#125;</span>&quot;</span> -gt 0 ]]; <span class="hljs-keyword">then</span>    execute_sudo <span class="hljs-string">&quot;/bin/chmod&quot;</span> <span class="hljs-string">&quot;755&quot;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;user_chmods[@]&#125;</span>&quot;</span>  <span class="hljs-keyword">fi</span>  <span class="hljs-keyword">if</span> [[ <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;#chowns[@]&#125;</span>&quot;</span> -gt 0 ]]; <span class="hljs-keyword">then</span>    execute_sudo <span class="hljs-string">&quot;<span class="hljs-variable">$CHOWN</span>&quot;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$USER</span>&quot;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;chowns[@]&#125;</span>&quot;</span>  <span class="hljs-keyword">fi</span>  <span class="hljs-keyword">if</span> [[ <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;#chgrps[@]&#125;</span>&quot;</span> -gt 0 ]]; <span class="hljs-keyword">then</span>    execute_sudo <span class="hljs-string">&quot;<span class="hljs-variable">$CHGRP</span>&quot;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$GROUP</span>&quot;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;chgrps[@]&#125;</span>&quot;</span>  <span class="hljs-keyword">fi</span><span class="hljs-keyword">else</span>  execute_sudo <span class="hljs-string">&quot;/bin/mkdir&quot;</span> <span class="hljs-string">&quot;-p&quot;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;HOMEBREW_PREFIX&#125;</span>&quot;</span>  <span class="hljs-keyword">if</span> [[ -z <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;HOMEBREW_ON_LINUX-&#125;</span>&quot;</span> ]]; <span class="hljs-keyword">then</span>    execute_sudo <span class="hljs-string">&quot;<span class="hljs-variable">$CHOWN</span>&quot;</span> <span class="hljs-string">&quot;root:wheel&quot;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;HOMEBREW_PREFIX&#125;</span>&quot;</span>  <span class="hljs-keyword">else</span>    execute_sudo <span class="hljs-string">&quot;<span class="hljs-variable">$CHOWN</span>&quot;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$USER</span>:<span class="hljs-variable">$GROUP</span>&quot;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;HOMEBREW_PREFIX&#125;</span>&quot;</span>  <span class="hljs-keyword">fi</span><span class="hljs-keyword">fi</span><span class="hljs-keyword">if</span> [[ <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;#mkdirs[@]&#125;</span>&quot;</span> -gt 0 ]]; <span class="hljs-keyword">then</span>  execute_sudo <span class="hljs-string">&quot;/bin/mkdir&quot;</span> <span class="hljs-string">&quot;-p&quot;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;mkdirs[@]&#125;</span>&quot;</span>  execute_sudo <span class="hljs-string">&quot;/bin/chmod&quot;</span> <span class="hljs-string">&quot;g+rwx&quot;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;mkdirs[@]&#125;</span>&quot;</span>  execute_sudo <span class="hljs-string">&quot;<span class="hljs-variable">$CHOWN</span>&quot;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$USER</span>&quot;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;mkdirs[@]&#125;</span>&quot;</span>  execute_sudo <span class="hljs-string">&quot;<span class="hljs-variable">$CHGRP</span>&quot;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$GROUP</span>&quot;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;mkdirs[@]&#125;</span>&quot;</span><span class="hljs-keyword">fi</span><span class="hljs-keyword">if</span> ! [[ -d <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;HOMEBREW_CACHE&#125;</span>&quot;</span> ]]; <span class="hljs-keyword">then</span>  <span class="hljs-keyword">if</span> [[ -z <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;HOMEBREW_ON_LINUX-&#125;</span>&quot;</span> ]]; <span class="hljs-keyword">then</span>    execute_sudo <span class="hljs-string">&quot;/bin/mkdir&quot;</span> <span class="hljs-string">&quot;-p&quot;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;HOMEBREW_CACHE&#125;</span>&quot;</span>  <span class="hljs-keyword">else</span>    execute <span class="hljs-string">&quot;/bin/mkdir&quot;</span> <span class="hljs-string">&quot;-p&quot;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;HOMEBREW_CACHE&#125;</span>&quot;</span>  <span class="hljs-keyword">fi</span><span class="hljs-keyword">fi</span><span class="hljs-keyword">if</span> exists_but_not_writable <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;HOMEBREW_CACHE&#125;</span>&quot;</span>; <span class="hljs-keyword">then</span>  execute_sudo <span class="hljs-string">&quot;/bin/chmod&quot;</span> <span class="hljs-string">&quot;g+rwx&quot;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;HOMEBREW_CACHE&#125;</span>&quot;</span><span class="hljs-keyword">fi</span><span class="hljs-keyword">if</span> file_not_owned <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;HOMEBREW_CACHE&#125;</span>&quot;</span>; <span class="hljs-keyword">then</span>  execute_sudo <span class="hljs-string">&quot;<span class="hljs-variable">$CHOWN</span>&quot;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$USER</span>&quot;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;HOMEBREW_CACHE&#125;</span>&quot;</span><span class="hljs-keyword">fi</span><span class="hljs-keyword">if</span> file_not_grpowned <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;HOMEBREW_CACHE&#125;</span>&quot;</span>; <span class="hljs-keyword">then</span>  execute_sudo <span class="hljs-string">&quot;<span class="hljs-variable">$CHGRP</span>&quot;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$GROUP</span>&quot;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;HOMEBREW_CACHE&#125;</span>&quot;</span><span class="hljs-keyword">fi</span><span class="hljs-keyword">if</span> [[ -d <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;HOMEBREW_CACHE&#125;</span>&quot;</span> ]]; <span class="hljs-keyword">then</span>  execute <span class="hljs-string">&quot;<span class="hljs-variable">$TOUCH</span>&quot;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;HOMEBREW_CACHE&#125;</span>/.cleaned&quot;</span><span class="hljs-keyword">fi</span><span class="hljs-keyword">if</span> should_install_command_line_tools &amp;&amp; version_ge <span class="hljs-string">&quot;<span class="hljs-variable">$macos_version</span>&quot;</span> <span class="hljs-string">&quot;10.13&quot;</span>; <span class="hljs-keyword">then</span>  ohai <span class="hljs-string">&quot;Searching online for the Command Line Tools&quot;</span>  <span class="hljs-comment"># This temporary file prompts the &#x27;softwareupdate&#x27; utility to list the Command Line Tools</span>  clt_placeholder=<span class="hljs-string">&quot;/tmp/.com.apple.dt.CommandLineTools.installondemand.in-progress&quot;</span>  execute_sudo <span class="hljs-string">&quot;<span class="hljs-variable">$TOUCH</span>&quot;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$clt_placeholder</span>&quot;</span>  clt_label_command=<span class="hljs-string">&quot;/usr/sbin/softwareupdate -l |</span><span class="hljs-string">                      grep -B 1 -E &#x27;Command Line Tools&#x27; |</span><span class="hljs-string">                      awk -F&#x27;*&#x27; &#x27;/^ *\\*/ &#123;print \$2&#125;&#x27; |</span><span class="hljs-string">                      sed -e &#x27;s/^ *Label: //&#x27; -e &#x27;s/^ *//&#x27; |</span><span class="hljs-string">                      sort -V |</span><span class="hljs-string">                      tail -n1&quot;</span>  clt_label=<span class="hljs-string">&quot;<span class="hljs-subst">$(chomp <span class="hljs-string">&quot;<span class="hljs-subst">$(/bin/bash -c <span class="hljs-string">&quot;<span class="hljs-variable">$clt_label_command</span>&quot;</span>)</span>&quot;</span>)</span>&quot;</span>  <span class="hljs-keyword">if</span> [[ -n <span class="hljs-string">&quot;<span class="hljs-variable">$clt_label</span>&quot;</span> ]]; <span class="hljs-keyword">then</span>    ohai <span class="hljs-string">&quot;Installing <span class="hljs-variable">$clt_label</span>&quot;</span>    execute_sudo <span class="hljs-string">&quot;/usr/sbin/softwareupdate&quot;</span> <span class="hljs-string">&quot;-i&quot;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$clt_label</span>&quot;</span>    execute_sudo <span class="hljs-string">&quot;/bin/rm&quot;</span> <span class="hljs-string">&quot;-f&quot;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$clt_placeholder</span>&quot;</span>    execute_sudo <span class="hljs-string">&quot;/usr/bin/xcode-select&quot;</span> <span class="hljs-string">&quot;--switch&quot;</span> <span class="hljs-string">&quot;/Library/Developer/CommandLineTools&quot;</span>  <span class="hljs-keyword">fi</span><span class="hljs-keyword">fi</span><span class="hljs-comment"># Headless install may have failed, so fallback to original &#x27;xcode-select&#x27; method</span><span class="hljs-keyword">if</span> should_install_command_line_tools &amp;&amp; <span class="hljs-built_in">test</span> -t 0; <span class="hljs-keyword">then</span>  ohai <span class="hljs-string">&quot;Installing the Command Line Tools (expect a GUI popup):&quot;</span>  execute_sudo <span class="hljs-string">&quot;/usr/bin/xcode-select&quot;</span> <span class="hljs-string">&quot;--install&quot;</span>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Press any key when the installation has completed.&quot;</span>  getc  execute_sudo <span class="hljs-string">&quot;/usr/bin/xcode-select&quot;</span> <span class="hljs-string">&quot;--switch&quot;</span> <span class="hljs-string">&quot;/Library/Developer/CommandLineTools&quot;</span><span class="hljs-keyword">fi</span><span class="hljs-keyword">if</span> [[ -z <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;HOMEBREW_ON_LINUX-&#125;</span>&quot;</span> ]] &amp;&amp; ! output=<span class="hljs-string">&quot;<span class="hljs-subst">$(/usr/bin/xcrun clang 2&gt;&amp;1)</span>&quot;</span> &amp;&amp; [[ <span class="hljs-string">&quot;<span class="hljs-variable">$output</span>&quot;</span> == *<span class="hljs-string">&quot;license&quot;</span>* ]]; <span class="hljs-keyword">then</span>  abort <span class="hljs-string">&quot;<span class="hljs-subst">$(cat &lt;&lt;EOABORT</span></span><span class="hljs-string"><span class="hljs-subst">You have not agreed to the Xcode license.</span></span><span class="hljs-string"><span class="hljs-subst">Before running the installer again please agree to the license by opening</span></span><span class="hljs-string"><span class="hljs-subst">Xcode.app or running:</span></span><span class="hljs-string"><span class="hljs-subst">    sudo xcodebuild -license</span></span><span class="hljs-string"><span class="hljs-subst">EOABORT</span></span><span class="hljs-string"><span class="hljs-subst">)</span>&quot;</span><span class="hljs-keyword">fi</span>ohai <span class="hljs-string">&quot;Downloading and installing Homebrew...&quot;</span>(  <span class="hljs-built_in">cd</span> <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;HOMEBREW_REPOSITORY&#125;</span>&quot;</span> &gt;/dev/null || <span class="hljs-built_in">return</span>  <span class="hljs-comment"># we do it in four steps to avoid merge errors when reinstalling</span>  execute <span class="hljs-string">&quot;git&quot;</span> <span class="hljs-string">&quot;init&quot;</span> <span class="hljs-string">&quot;-q&quot;</span>  <span class="hljs-comment"># &quot;git remote add&quot; will fail if the remote is defined in the global config</span>  execute <span class="hljs-string">&quot;git&quot;</span> <span class="hljs-string">&quot;config&quot;</span> <span class="hljs-string">&quot;remote.origin.url&quot;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;BREW_REPO&#125;</span>&quot;</span>  execute <span class="hljs-string">&quot;git&quot;</span> <span class="hljs-string">&quot;config&quot;</span> <span class="hljs-string">&quot;remote.origin.fetch&quot;</span> <span class="hljs-string">&quot;+refs/heads/*:refs/remotes/origin/*&quot;</span>  <span class="hljs-comment"># ensure we don&#x27;t munge line endings on checkout</span>  execute <span class="hljs-string">&quot;git&quot;</span> <span class="hljs-string">&quot;config&quot;</span> <span class="hljs-string">&quot;core.autocrlf&quot;</span> <span class="hljs-string">&quot;false&quot;</span>  execute <span class="hljs-string">&quot;git&quot;</span> <span class="hljs-string">&quot;fetch&quot;</span> <span class="hljs-string">&quot;origin&quot;</span> <span class="hljs-string">&quot;--force&quot;</span>  execute <span class="hljs-string">&quot;git&quot;</span> <span class="hljs-string">&quot;fetch&quot;</span> <span class="hljs-string">&quot;origin&quot;</span> <span class="hljs-string">&quot;--tags&quot;</span> <span class="hljs-string">&quot;--force&quot;</span>  execute <span class="hljs-string">&quot;git&quot;</span> <span class="hljs-string">&quot;reset&quot;</span> <span class="hljs-string">&quot;--hard&quot;</span> <span class="hljs-string">&quot;origin/master&quot;</span>  execute <span class="hljs-string">&quot;ln&quot;</span> <span class="hljs-string">&quot;-sf&quot;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;HOMEBREW_REPOSITORY&#125;</span>/bin/brew&quot;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;HOMEBREW_PREFIX&#125;</span>/bin/brew&quot;</span>  execute <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;HOMEBREW_PREFIX&#125;</span>/bin/brew&quot;</span> <span class="hljs-string">&quot;update&quot;</span> <span class="hljs-string">&quot;--force&quot;</span>) || <span class="hljs-built_in">exit</span> 1<span class="hljs-keyword">if</span> [[ <span class="hljs-string">&quot;:<span class="hljs-variable">$&#123;PATH&#125;</span>:&quot;</span> != *<span class="hljs-string">&quot;:<span class="hljs-variable">$&#123;HOMEBREW_PREFIX&#125;</span>/bin:&quot;</span>* ]]; <span class="hljs-keyword">then</span>  warn <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;HOMEBREW_PREFIX&#125;</span>/bin is not in your PATH.&quot;</span><span class="hljs-keyword">fi</span>ohai <span class="hljs-string">&quot;Installation successful!&quot;</span><span class="hljs-built_in">echo</span><span class="hljs-comment"># Use the shell&#x27;s audible bell.</span><span class="hljs-keyword">if</span> [[ -t 1 ]]; <span class="hljs-keyword">then</span>  <span class="hljs-built_in">printf</span> <span class="hljs-string">&quot;\a&quot;</span><span class="hljs-keyword">fi</span><span class="hljs-comment"># Use an extra newline and bold to avoid this being missed.</span>ohai <span class="hljs-string">&quot;Homebrew has enabled anonymous aggregate formulae and cask analytics.&quot;</span><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-subst">$(cat &lt;&lt;EOS</span></span><span class="hljs-string"><span class="hljs-subst">$&#123;tty_bold&#125;Read the analytics documentation (and how to opt-out)</span> here:</span><span class="hljs-string">  <span class="hljs-variable">$&#123;tty_underline&#125;</span>https://docs.brew.sh/Analytics<span class="hljs-variable">$&#123;tty_reset&#125;</span></span><span class="hljs-string">No analytics data has been sent yet (or will be during this \`install\` run).</span><span class="hljs-string">EOS</span><span class="hljs-string">)</span><span class="hljs-string">&quot;</span>ohai <span class="hljs-string">&quot;Homebrew is run entirely by unpaid volunteers. Please consider donating:&quot;</span><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-subst">$(cat &lt;&lt;EOS</span></span><span class="hljs-string"><span class="hljs-subst">  $&#123;tty_underline&#125;https://github.com/Homebrew/brew#donations$&#123;tty_reset&#125;</span></span><span class="hljs-string"><span class="hljs-subst">EOS</span></span><span class="hljs-string"><span class="hljs-subst">)</span></span><span class="hljs-string">&quot;</span>(  <span class="hljs-built_in">cd</span> <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;HOMEBREW_REPOSITORY&#125;</span>&quot;</span> &gt;/dev/null || <span class="hljs-built_in">return</span>  execute <span class="hljs-string">&quot;git&quot;</span> <span class="hljs-string">&quot;config&quot;</span> <span class="hljs-string">&quot;--replace-all&quot;</span> <span class="hljs-string">&quot;homebrew.analyticsmessage&quot;</span> <span class="hljs-string">&quot;true&quot;</span>  execute <span class="hljs-string">&quot;git&quot;</span> <span class="hljs-string">&quot;config&quot;</span> <span class="hljs-string">&quot;--replace-all&quot;</span> <span class="hljs-string">&quot;homebrew.caskanalyticsmessage&quot;</span> <span class="hljs-string">&quot;true&quot;</span>) || <span class="hljs-built_in">exit</span> 1ohai <span class="hljs-string">&quot;Next steps:&quot;</span><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;- Run \`brew help\` to get started&quot;</span><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;- Further documentation: &quot;</span><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;    <span class="hljs-variable">$&#123;tty_underline&#125;</span>https://docs.brew.sh<span class="hljs-variable">$&#123;tty_reset&#125;</span>&quot;</span><span class="hljs-keyword">if</span> [[ -n <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;HOMEBREW_ON_LINUX-&#125;</span>&quot;</span> ]]; <span class="hljs-keyword">then</span>  <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;<span class="hljs-variable">$SHELL</span>&quot;</span> <span class="hljs-keyword">in</span>    */bash*)      <span class="hljs-keyword">if</span> [[ -r <span class="hljs-string">&quot;<span class="hljs-variable">$HOME</span>/.bash_profile&quot;</span> ]]; <span class="hljs-keyword">then</span>        shell_profile=<span class="hljs-string">&quot;<span class="hljs-variable">$HOME</span>/.bash_profile&quot;</span>      <span class="hljs-keyword">else</span>        shell_profile=<span class="hljs-string">&quot;<span class="hljs-variable">$HOME</span>/.profile&quot;</span>      <span class="hljs-keyword">fi</span>      ;;    */zsh*)      shell_profile=<span class="hljs-string">&quot;<span class="hljs-variable">$HOME</span>/.zprofile&quot;</span>      ;;    *)      shell_profile=<span class="hljs-string">&quot;<span class="hljs-variable">$HOME</span>/.profile&quot;</span>      ;;  <span class="hljs-keyword">esac</span>  cat &lt;&lt;<span class="hljs-string">EOS</span><span class="hljs-string">- Install the Homebrew dependencies if you have sudo access:</span><span class="hljs-string">  $&#123;tty_bold&#125;Debian, Ubuntu, etc.$&#123;tty_reset&#125;</span><span class="hljs-string">    sudo apt-get install build-essential</span><span class="hljs-string">  $&#123;tty_bold&#125;Fedora, Red Hat, CentOS, etc.$&#123;tty_reset&#125;</span><span class="hljs-string">    sudo yum groupinstall &#x27;Development Tools&#x27;</span><span class="hljs-string">  See $&#123;tty_underline&#125;https://docs.brew.sh/linux$&#123;tty_reset&#125; for more information.</span><span class="hljs-string">- Configure Homebrew in your $&#123;tty_underline&#125;$&#123;shell_profile&#125;$&#123;tty_reset&#125; by running</span><span class="hljs-string">    echo &#x27;eval \$($&#123;HOMEBREW_PREFIX&#125;/bin/brew shellenv)&#x27; &gt;&gt; $&#123;shell_profile&#125;</span><span class="hljs-string">- Add Homebrew to your $&#123;tty_bold&#125;PATH$&#123;tty_reset&#125;</span><span class="hljs-string">    eval \$($&#123;HOMEBREW_PREFIX&#125;/bin/brew shellenv)</span><span class="hljs-string">- We recommend that you install GCC by running:</span><span class="hljs-string">    brew install gcc</span><span class="hljs-string"></span><span class="hljs-string">EOS</span><span class="hljs-keyword">fi</span></code></pre><p>执行前,需要给改脚本赋权限</p><pre><code class="hljs bash">sudo chmod -R 777 brew_install.sh./brew_install.sh</code></pre><p>等待安装成功(中间有过两次失败,主要原因是原来安装的Homebrew没有卸载干净)</p><h4 id="VMware-Fusion"><a href="#VMware-Fusion" class="headerlink" title="VMware Fusion"></a>VMware Fusion</h4><h5 id="物理内存不足，无法使用配置的设置开启虚拟机"><a href="#物理内存不足，无法使用配置的设置开启虚拟机" class="headerlink" title="物理内存不足，无法使用配置的设置开启虚拟机"></a>物理内存不足，无法使用配置的设置开启虚拟机</h5><p>原来的VMware Fusion 版本是11</p><p><img src="/images/mac/vmfusion_11.png"></p><p>Google后发现12可以用,于是下载了VMware Fusion安装,亲测可用</p><h5 id="无法将“Ethernet0”连接到虚拟网络“-dev-vmnet8”。"><a href="#无法将“Ethernet0”连接到虚拟网络“-dev-vmnet8”。" class="headerlink" title="无法将“Ethernet0”连接到虚拟网络“/dev/vmnet8”。"></a>无法将“Ethernet0”连接到虚拟网络“/dev/vmnet8”。</h5><p>VMware Fusion升级到12后，过了几天打开虚拟机时，发现“Ethernet0”连接到虚拟网络“/dev/vmnet8”</p><p>谷歌了好久后发现</p><pre><code class="hljs zsh">sudo rm /Library/Preferences/SystemConfiguration/NetworkInterfaces.plist &amp;&amp; sudo killall -9 configd</code></pre><p>解决方式来源：</p><p><a href="https://communities.vmware.com/t5/VMware-Fusion-Discussions/No-Ethernet-Connection-VMware-Fusion-12-macOS-Big-Sur-Beta-6/m-p/2303833#M140209">https://communities.vmware.com/t5/VMware-Fusion-Discussions/No-Ethernet-Connection-VMware-Fusion-12-macOS-Big-Sur-Beta-6/m-p/2303833#M140209</a></p><p>另外，当苹果电脑共享wifi时，也会造成这个结果。所以共享网络也需要关闭。</p><h3 id="命令行查看保存的密码"><a href="#命令行查看保存的密码" class="headerlink" title="命令行查看保存的密码"></a>命令行查看保存的密码</h3><h4 id="security-find-generic-password-ga-“wifi名称”"><a href="#security-find-generic-password-ga-“wifi名称”" class="headerlink" title="security find-generic-password -ga “wifi名称”"></a>security find-generic-password -ga “wifi名称”</h4><p><img src="/images/mac/wifi.png"></p>]]></content>
    
    
    <categories>
      
      <category>Develop</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mac</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Mac】hadoop开发环境配置</title>
    <link href="/2020/06/17/hadoop-dev-env/"/>
    <url>/2020/06/17/hadoop-dev-env/</url>
    
    <content type="html"><![CDATA[<blockquote><a id="more"></a></blockquote><h3 id="hdfs的java-API开发环境准备"><a href="#hdfs的java-API开发环境准备" class="headerlink" title="hdfs的java API开发环境准备"></a>hdfs的java API开发环境准备</h3><h4 id="修改hosts文件"><a href="#修改hosts文件" class="headerlink" title="修改hosts文件"></a>修改hosts文件</h4><ul><li><p>mac下修改hosts文件</p><p>文件所在位置<code>/etc/hosts</code></p><p>将虚拟机中/etc/hosts文件一下内容，添加到以上hosts文件末尾</p></li></ul><pre><code class="hljs accesslog"><span class="hljs-number">192.168.51.100</span> node01.hadoop.com node01<span class="hljs-number">192.168.51.110</span> node02.hadoop.com node02<span class="hljs-number">192.168.51.120</span> node03.hadoop.com node03</code></pre><h4 id="安装jdk"><a href="#安装jdk" class="headerlink" title="安装jdk"></a>安装jdk</h4><p>拷贝集群环境下的jdk到本地</p><pre><code class="hljs routeros"><span class="hljs-comment">#添加以下配置内容，配置jdk环境变量</span><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">JAVA_HOME</span>=/weitrue/install/jdk1.8.0_141<span class="hljs-builtin-name">export</span> <span class="hljs-attribute">PATH</span>=<span class="hljs-variable">$PATH</span>:$JAVA_HOME/binCopy</code></pre><p>让修改马上生效</p><pre><code class="hljs gradle"><span class="hljs-keyword">source</span> <span class="hljs-regexp">/etc/</span>profile</code></pre><h4 id="mac下hadoop环境配置"><a href="#mac下hadoop环境配置" class="headerlink" title="mac下hadoop环境配置"></a>mac下hadoop环境配置</h4><p>拷贝集群环境下<code>hadoop-2.6.0-cdh5.14.2</code>目录文件到本地，配置环境变量</p><p><img src="/images/hadoop-dev-env/hadoop.png"></p><h4 id="安装maven"><a href="#安装maven" class="headerlink" title="安装maven"></a>安装maven</h4><h5 id="maven是什么？"><a href="#maven是什么？" class="headerlink" title="maven是什么？"></a>maven是什么？</h5><p>Apache Maven是一个软件项目管理和理解工具。基于项目对象模型（POM）的概念，Maven可以从一个中心信息管理项目的构建，报告和文档。</p><h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><p>解压安装包<code>apache-maven-3.6.1-bin.zip</code>到安装目录</p><p>编辑<code>.bash_profile</code>，新增maven环境配置</p><p><img src="/images/hadoop-dev-env/maven.png"></p><h6 id="maven的仓库"><a href="#maven的仓库" class="headerlink" title="maven的仓库"></a>maven的仓库</h6><ul><li><p>创建maven工程后，maven会自动的去本地仓库查看时候有所需的jar包，如果没有的话，默认去中央仓库，将jar包下载到本地；以后如果再次使用此jar时，就直接使用本地仓库的jar即可</p></li><li><p>此过程是maven自动完成的</p></li><li><p>本地仓库：</p><p><img src="/images/hadoop-dev-env/repo.png"></p></li><li><p>私服仓库：就是我们自己搭建的一个远程仓库</p></li><li><p>中央仓库：是官方或者第三方提供的仓库</p></li></ul><h6 id="settings文件"><a href="#settings文件" class="headerlink" title="settings文件"></a>settings文件</h6><ul><li>声明文件规范</li></ul><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">settings</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/SETTINGS/1.0.0&quot;</span></span><span class="hljs-tag">          <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><span class="hljs-tag">          <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd&quot;</span>&gt;</span></code></pre><ul><li>本地仓库路径</li></ul><p><code>&lt;localRepository&gt;/path/to/local/repo&lt;/localRepository&gt;</code></p><ul><li>Maven是否需要和用户交互以获得输入。如果Maven需要和用户交互以获得输入，则设置成true，反之则应为false。默认为true </li></ul><p><code>&lt;interactiveMode&gt;true&lt;/interactiveMode&gt;</code></p><ul><li>表示Maven是否需要在离线模式下运行。如果构建系统需要在离线模式下运行，则为true，默认为false。当由于网络设置原因或者安全因素，构建服务器不能连接远程仓库的时候，该配置就十分有用 </li></ul><p><code>&lt;offline&gt;false&lt;/offline&gt;</code></p><ul><li>当插件的组织Id（groupId）没有显式提供时，供搜寻插件组织Id（groupId）的列表。该元素包含一个pluginGroup元素列表，每个子元素包含了一个组织Id（groupId）。</li></ul><p><code>pluginGroups</code></p><ul><li>为仓库列表配置的下载镜像列表 </li></ul><p><code>mirrors</code></p><h6 id="pom文件"><a href="#pom文件" class="headerlink" title="pom文件"></a>pom文件</h6><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span>     项目的模板版本<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.hadoop<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>         可以用这个来标识公司<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>TestFlume<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>     可以标识工程的作用<span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>jar<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span>             指定打包类型       <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        制定项目版本<span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span>       项目的依赖关系<span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span>                        构建项目的信息</code></pre><p>总项目/ pom.xml 总项目的pom配置文件 </p><p>子项目1/ pom.xml 子项目1的pom文件 </p><p>子项目2/ pom.xml 子项目2的pom文件 </p><h6 id="maven简单的命令"><a href="#maven简单的命令" class="headerlink" title="maven简单的命令"></a>maven简单的命令</h6><p>mvn clean </p><p>mvn clean package</p><p>mvn install:install-file -Dfile=junit-3.8.2.jar -DgroupId=junit -DartifactId=junit -Dversion=3.8.2 -Dpackaging=jar</p><p>如果依赖下载有问题，需要自己添加依赖包进仓库，不要复制粘贴，要用 mvn install这个命令将jar包打进仓库</p><h5 id="安装idea"><a href="#安装idea" class="headerlink" title="安装idea"></a>安装idea</h5>]]></content>
    
    
    <categories>
      
      <category>Bdata</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hadoop</tag>
      
      <tag>大数据</tag>
      
      <tag>mac</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Mac】搭建hadoop集群环境（三台）</title>
    <link href="/2020/06/15/hadoop-env/"/>
    <url>/2020/06/15/hadoop-env/</url>
    
    <content type="html"><![CDATA[<blockquote><p>The Apache Hadoop software library is a framework that allows for the distributed processing of large data sets across clusters of computers using simple programming models. It is designed to scale up from single servers to thousands of machines, each offering local computation and storage. Rather than rely on hardware to deliver high-availability, the library itself is designed to detect and handle failures at the application layer, so delivering a highly-available service on top of a cluster of computers, each of which may be prone to failures.<a id="more"></a> </p></blockquote><h3 id="1-三台linux服务器的安装"><a href="#1-三台linux服务器的安装" class="headerlink" title="1. 三台linux服务器的安装"></a>1. 三台linux服务器的安装</h3><h4 id="1-安装VmWare-Fusion"><a href="#1-安装VmWare-Fusion" class="headerlink" title="1. 安装VmWare Fusion"></a>1. 安装VmWare Fusion</h4><p><img src="/images/hadoop-env/fusion.png"></p><h4 id="2-通过Vmware安装三台linux机器"><a href="#2-通过Vmware安装三台linux机器" class="headerlink" title="2.通过Vmware安装三台linux机器"></a>2.通过Vmware安装三台linux机器</h4><p><img src="/images/hadoop-env/linux.png"></p><h4 id="3-为linux虚拟机设置网络配置"><a href="#3-为linux虚拟机设置网络配置" class="headerlink" title="3.为linux虚拟机设置网络配置"></a>3.为linux虚拟机设置网络配置</h4><p>安装VMWare Fusion成功后，Mac OS会新增两张网卡vmnet1以及vmnet8，其中vmnet1是Host-only模式，vmnet8是NAT模式，这里选择vmnet8使用NAT进行网络设置。</p><h5 id="1-修改Fusion网络配置"><a href="#1-修改Fusion网络配置" class="headerlink" title="1.修改Fusion网络配置"></a>1.修改Fusion网络配置</h5><p>修改配置文件:/Library/Preferences/VMware\ Fusion/networking</p><p><img src="/images/hadoop-env/fusion_net.png"></p><h5 id="2-修改网关"><a href="#2-修改网关" class="headerlink" title="2.修改网关"></a>2.修改网关</h5><p>修改配置文件：/Library/Preferences/VMware Fusion/vmnet8/nat.conf</p><p><img src="/images/hadoop-env/net8.png"></p><h5 id="3-修改linux虚拟机网卡"><a href="#3-修改linux虚拟机网卡" class="headerlink" title="3.修改linux虚拟机网卡"></a>3.修改linux虚拟机网卡</h5><p>修改配置文件(服务器版linux):/etc/sysconfig/network-scripts/ifcfg-ens33</p><p><img src="/images/hadoop-env/linux_net.png"></p><p>更改完成配置，重启网络服务</p><pre><code class="hljs shell">systemctl restart network</code></pre><p>安装一些常用的软件</p><pre><code class="hljs shell">yum -y install vimyum -y install net-tools</code></pre><p>关机</p><pre><code class="hljs angelscript">init <span class="hljs-number">0</span></code></pre><h5 id="4-克隆第一台linux虚拟机"><a href="#4-克隆第一台linux虚拟机" class="headerlink" title="4.克隆第一台linux虚拟机"></a>4.克隆第一台linux虚拟机</h5><p>现在已经有了种子机器了，我们可以通过种子机器进行复制或者克隆出三台机器</p><h6 id="更改克隆机器的IP地址"><a href="#更改克隆机器的IP地址" class="headerlink" title="更改克隆机器的IP地址"></a>更改克隆机器的IP地址</h6><ul><li><p>三台机器的ip地址分别是<code>192.168.51.100、192.168.51.110、192.168.51.120</code></p></li><li><p>克隆出来的机器IP地址与种子的ip地址一样，我们将第二台机器的IP地址更改为192.168.51.110即可</p></li><li><p>启动虚拟机，并通过root用户，密码******来进行登录，然后来更改linux机器的IP地址</p></li></ul><pre><code class="hljs shell">vi /etc/sysconfig/network-scripts/ifcfg-ens33</code></pre><pre><code class="hljs shell">IPADDR=192.168.51.110NETMASK=255.255.255.0GATEWAY=192.168.51.1DNS1=8.8.8.8</code></pre><ul><li><p>依照上面步骤，接着克隆第三台机器，并将第三台机器的IP地址设置为</p><p>192.168.51.120</p></li></ul><h3 id="2-安装大数据集群前环境准备"><a href="#2-安装大数据集群前环境准备" class="headerlink" title="2.安装大数据集群前环境准备"></a>2.安装大数据集群前环境准备</h3><h4 id="1-三台虚拟机关闭防火墙"><a href="#1-三台虚拟机关闭防火墙" class="headerlink" title="1. 三台虚拟机关闭防火墙"></a>1. 三台虚拟机关闭防火墙</h4><p>三台机器执行以下命令（<font color="red">root</font>用户来执行）</p><pre><code class="hljs shell">systemctl stop firewalldsystemctl disable firewalld</code></pre><h4 id="2-三台机器关闭selinux"><a href="#2-三台机器关闭selinux" class="headerlink" title="2. 三台机器关闭selinux"></a>2. 三台机器关闭selinux</h4><p>三台机器执行以下命令关闭selinux</p><pre><code class="hljs shell">vim /etc/sysconfig/selinuxSELINUX=disabled</code></pre><h4 id="3-三台机器更改主机名"><a href="#3-三台机器更改主机名" class="headerlink" title="3. 三台机器更改主机名"></a>3. 三台机器更改主机名</h4><p>三台机器执行以下命令更改主机名</p><pre><code class="hljs shell">vim /etc/hostname</code></pre><p>第一台机器更改内容</p><pre><code class="hljs css"><span class="hljs-selector-tag">node01</span><span class="hljs-selector-class">.hadoop</span><span class="hljs-selector-class">.com</span></code></pre><p>第二台机器更改内容</p><pre><code class="hljs css"><span class="hljs-selector-tag">node02</span><span class="hljs-selector-class">.hadoop</span><span class="hljs-selector-class">.com</span></code></pre><p>第三台机器更改内容</p><pre><code class="hljs css"><span class="hljs-selector-tag">node03</span><span class="hljs-selector-class">.hadoop</span><span class="hljs-selector-class">.com</span></code></pre><h4 id="4-三台机器做主机名与IP地址的映射"><a href="#4-三台机器做主机名与IP地址的映射" class="headerlink" title="4. 三台机器做主机名与IP地址的映射"></a>4. 三台机器做主机名与IP地址的映射</h4><p>三台机器执行以下命令更改主机名与IP地址的映射/etc/hosts</p><pre><code class="hljs shell">192.168.51.100 node01.hadoop.com node01192.168.51.110 node02.hadoop.com node02192.168.51.120 node03.hadoop.com node03</code></pre><h4 id="5-三台机器时钟同步"><a href="#5-三台机器时钟同步" class="headerlink" title="5. 三台机器时钟同步"></a>5. 三台机器时钟同步</h4><h5 id="第一种同步方式：通过网络进行时钟同步"><a href="#第一种同步方式：通过网络进行时钟同步" class="headerlink" title="第一种同步方式：通过网络进行时钟同步"></a>第一种同步方式：通过网络进行时钟同步</h5><p>通过网络连接外网进行时钟同步,必须保证虚拟机连上外网</p><p>三台机器都安装ntpdate</p><pre><code class="hljs shell">yum -y install ntpdate</code></pre><p>阿里云时钟同步服务器</p><pre><code class="hljs css"><span class="hljs-selector-tag">ntpdate</span> <span class="hljs-selector-tag">ntp4</span><span class="hljs-selector-class">.aliyun</span><span class="hljs-selector-class">.com</span></code></pre><p>三台机器定时任务</p><pre><code class="hljs shell">crontab -e</code></pre><p>添加如下内容</p><pre><code class="hljs shell">*/1 * * * * /usr/sbin/ntpdate ntp4.aliyun.com;</code></pre><h4 id="6-三台机器添加普通用户"><a href="#6-三台机器添加普通用户" class="headerlink" title="6. 三台机器添加普通用户"></a>6. 三台机器添加普通用户</h4><p>三台linux服务器统一添加普通用户hadoop，并给以sudo权限，用于以后所有的大数据软件的安装</p><p>并统一设置普通用户的密码为 ==<strong>**</strong>==</p><pre><code class="hljs shell">useradd hadooppasswd hadoop</code></pre><p>普通用户的密码设置为******</p><p>三台机器为普通用户添加sudo权限</p><pre><code class="hljs shell">visudo</code></pre><p> 增加如下内容</p><pre><code class="hljs shell">hadoop ALL=(ALL)    ALL</code></pre><h4 id="7-三台定义统一目录"><a href="#7-三台定义统一目录" class="headerlink" title="7. 三台定义统一目录"></a>7. 三台定义统一目录</h4><p>定义三台linux服务器软件压缩包存放目录，以及解压后安装目录，三台机器执行以下命令，创建两个文件夹，一个用于存放软件压缩包目录，一个用于存放解压后目录</p><pre><code class="hljs shell">mkdir -p /weitrue/soft   # 软件压缩包存放目录mkdir -p /weitrue/install # 软件解压后存放目录chown -R hadoop:hadoop /weitrue  # 将文件夹权限更改为hadoop用户</code></pre><h4 id="8-三台机器hadoop用户免密码登录"><a href="#8-三台机器hadoop用户免密码登录" class="headerlink" title="8. 三台机器hadoop用户免密码登录"></a>8. 三台机器hadoop用户免密码登录</h4><p>切换用户为hadoop</p><pre><code class="hljs shell">su hadoop</code></pre><p>第一步：三台机器在<font color="red">hadoop</font>用户下执行以下命令生成公钥与私钥</p><pre><code class="hljs shell">ssh-keygen -t rsa</code></pre><p><font color="red">执行上述命令之后，按三次Enter键即可生成了</font></p><p>第二步：三台机器在hadoop用户下，执行命令拷贝公钥到node01服务器</p><pre><code class="hljs shell">ssh-copy-id node01</code></pre><p>第三步：node01服务器将公钥拷贝给node02与node03</p><p>node01在hadoop用户下，执行以下命令，将authorized_keys拷贝到node02与node03服务器</p><pre><code class="hljs shell">cd /home/hadoop/.ssh/scp authorized_keys node02:$PWDscp authorized_keys node03:$PWD</code></pre><p>第四步：验证；从任意节点是否能免秘钥登陆其他节点；如node01免密登陆node02</p><pre><code class="hljs sh">ssh node02</code></pre><h4 id="9-三台机器关机重启"><a href="#9-三台机器关机重启" class="headerlink" title="9. 三台机器关机重启"></a>9. 三台机器关机重启</h4><p>三台机器在hadoop用户下执行以下命令，实现关机重启</p><pre><code class="hljs shell">sudo reboot -h now</code></pre><h4 id="10-三台机器安装jdk"><a href="#10-三台机器安装jdk" class="headerlink" title="10. 三台机器安装jdk"></a>10. 三台机器安装jdk</h4><ul><li><p>使用hadoop用户来重新连接三台机器，然后使用hadoop用户来安装jdk软件</p></li><li><p>上传压缩包到第一台服务器的/weitrue/soft下面，然后进行解压，配置环境变量即可，三台机器都依次安装即可</p></li></ul><pre><code class="hljs shell">cd /weitrue/soft/tar -xzvf jdk-8u141-linux-x64.tar.gz -C /weitrue/install/sudo vim /etc/profile</code></pre><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">添加以下配置内容，配置jdk环境变量</span>export JAVA_HOME=/weitrue/install/jdk1.8.0_141export PATH=$PATH:$JAVA_HOME/bin</code></pre><p>让修改马上生效</p><pre><code class="hljs shell">source /etc/profile</code></pre><h3 id="3-hadoop集群的安装"><a href="#3-hadoop集群的安装" class="headerlink" title="3. hadoop集群的安装"></a>3. hadoop集群的安装</h3><p>注意：这里使用打包好的包“hadoop-2.6.0-cdh5.14.2_after_compile.tar.gz”安装部署集群</p><p>编译没有什么技巧，主要跟网络好坏有关</p><h4 id="1-CDH软件版本重新进行编译"><a href="#1-CDH软件版本重新进行编译" class="headerlink" title="1. CDH软件版本重新进行编译"></a>1. CDH软件版本重新进行编译</h4><h4 id="2-hadoop集群的安装"><a href="#2-hadoop集群的安装" class="headerlink" title="2. hadoop集群的安装"></a>2. hadoop集群的安装</h4><p>安装环境服务部署规划</p><table><thead><tr><th>服务器IP</th><th>192.168.51.100</th><th>192.168.51.110</th><th>192.168.51.120</th></tr></thead><tbody><tr><td>HDFS</td><td>NameNode</td><td></td><td></td></tr><tr><td>HDFS</td><td>SecondaryNameNode</td><td></td><td></td></tr><tr><td>HDFS</td><td>DataNode</td><td>DataNode</td><td>DataNode</td></tr><tr><td>YARN</td><td>ResourceManager</td><td></td><td></td></tr><tr><td>YARN</td><td>NodeManager</td><td>NodeManager</td><td>NodeManager</td></tr><tr><td>历史日志服务器</td><td>JobHistoryServer</td><td></td><td></td></tr></tbody></table><h5 id="第一步：上传压缩包并解压"><a href="#第一步：上传压缩包并解压" class="headerlink" title="第一步：上传压缩包并解压"></a>第一步：上传压缩包并解压</h5><ul><li>将我们重新编译之后支持snappy压缩的hadoop包上传到第一台服务器并解压；第一台机器执行以下命令</li></ul><pre><code class="hljs shell">cd /weitrue/soft/tar -xzvf hadoop-2.6.0-cdh5.14.2_after_compile.tar.gz -C /weitrue/install/</code></pre><h5 id="第二步：查看hadoop支持的压缩方式以及本地库"><a href="#第二步：查看hadoop支持的压缩方式以及本地库" class="headerlink" title="第二步：查看hadoop支持的压缩方式以及本地库"></a>第二步：查看hadoop支持的压缩方式以及本地库</h5><p>第一台机器执行以下命令</p><pre><code class="hljs shell">cd /weitrue/install/hadoop-2.6.0-cdh5.14.2bin/hadoop checknative</code></pre><p>如果出现openssl为false，那么所有机器在线安装openssl即可，执行以下命令，虚拟机联网之后就可以在线进行安装了</p><pre><code class="hljs shell">sudo yum -y install openssl-devel</code></pre><h5 id="第三步：修改配置文件"><a href="#第三步：修改配置文件" class="headerlink" title="第三步：修改配置文件"></a>第三步：修改配置文件</h5><h6 id="修改hadoop-env-sh"><a href="#修改hadoop-env-sh" class="headerlink" title="修改hadoop-env.sh"></a>修改hadoop-env.sh</h6><p>第一台机器执行以下命令</p><pre><code class="hljs shell">cd /weitrue/install/hadoop-2.6.0-cdh5.14.2/etc/hadoopvim hadoop-env.sh</code></pre><pre><code class="hljs shell">export JAVA_HOME=/weitrue/install/jdk1.8.0_141</code></pre><h6 id="修改core-site-xml"><a href="#修改core-site-xml" class="headerlink" title="修改core-site.xml"></a>修改core-site.xml</h6><p>第一台机器执行以下命令</p><pre><code class="hljs shell">cd /weitrue/install/hadoop-2.6.0-cdh5.14.2/etc/hadoopvim core-site.xml</code></pre><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>fs.defaultFS<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>hdfs://node01:8020<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>hadoop.tmp.dir<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>/weitrue/install/hadoop-2.6.0-cdh5.14.2/hadoopDatas/tempDatas<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 缓冲区大小，实际工作中根据服务器性能动态调整 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>io.file.buffer.size<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>4096<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 开启hdfs的垃圾桶机制，删除掉的数据可以从垃圾桶中回收，单位分钟 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>fs.trash.interval<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>10080<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span></code></pre><h6 id="修改hdfs-site-xml"><a href="#修改hdfs-site-xml" class="headerlink" title="修改hdfs-site.xml"></a>修改hdfs-site.xml</h6><p>第一台机器执行以下命令</p><pre><code class="hljs shell">cd /weitrue/install/hadoop-2.6.0-cdh5.14.2/etc/hadoopvim hdfs-site.xml</code></pre><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><span class="hljs-comment">&lt;!-- NameNode存储元数据信息的路径，实际工作中，一般先确定磁盘的挂载目录，然后多个目录用，进行分割   --&gt;</span> <span class="hljs-comment">&lt;!--   集群动态上下线 </span><span class="hljs-comment">&lt;property&gt;</span><span class="hljs-comment">&lt;name&gt;dfs.hosts&lt;/name&gt;</span><span class="hljs-comment">&lt;value&gt;/weitrue/install/hadoop-2.6.0-cdh5.14.2/etc/hadoop/accept_host&lt;/value&gt;</span><span class="hljs-comment">&lt;/property&gt;</span><span class="hljs-comment">&lt;property&gt;</span><span class="hljs-comment">&lt;name&gt;dfs.hosts.exclude&lt;/name&gt;</span><span class="hljs-comment">&lt;value&gt;/weitrue/install/hadoop-2.6.0-cdh5.14.2/etc/hadoop/deny_host&lt;/value&gt;</span><span class="hljs-comment">&lt;/property&gt;</span><span class="hljs-comment">--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>dfs.namenode.secondary.http-address<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>node01:50090<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>dfs.namenode.http-address<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>node01:50070<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>dfs.namenode.name.dir<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>file:///weitrue/install/hadoop-2.6.0-cdh5.14.2/hadoopDatas/namenodeDatas<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><span class="hljs-comment">&lt;!-- 定义dataNode数据存储的节点位置，实际工作中，一般先确定磁盘的挂载目录，然后多个目录用，进行分割 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>dfs.datanode.data.dir<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>file:///weitrue/install/hadoop-2.6.0-cdh5.14.2/hadoopDatas/datanodeDatas<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>dfs.namenode.edits.dir<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>file:///weitrue/install/hadoop-2.6.0-cdh5.14.2/hadoopDatas/dfs/nn/edits<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>dfs.namenode.checkpoint.dir<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>file:///weitrue/install/hadoop-2.6.0-cdh5.14.2/hadoopDatas/dfs/snn/name<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>dfs.namenode.checkpoint.edits.dir<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>file:///weitrue/install/hadoop-2.6.0-cdh5.14.2/hadoopDatas/dfs/nn/snn/edits<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>dfs.replication<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>dfs.permissions<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>dfs.blocksize<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>134217728<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span></code></pre><h6 id="修改mapred-site-xml"><a href="#修改mapred-site-xml" class="headerlink" title="修改mapred-site.xml"></a>修改mapred-site.xml</h6><p>第一台机器执行以下命令</p><pre><code class="hljs shell">cd /weitrue/install/hadoop-2.6.0-cdh5.14.2/etc/hadoopmv mapred-site.xml.template mapred-site.xml vim mapred-site.xml</code></pre><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>mapreduce.framework.name<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>yarn<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>mapreduce.job.ubertask.enable<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>mapreduce.jobhistory.address<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>node01:10020<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>mapreduce.jobhistory.webapp.address<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>node01:19888<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span></code></pre><h6 id="修改yarn-site-xml"><a href="#修改yarn-site-xml" class="headerlink" title="修改yarn-site.xml"></a>修改yarn-site.xml</h6><p>第一台机器执行以下命令</p><pre><code class="hljs shell">cd /weitrue/install/hadoop-2.6.0-cdh5.14.2/etc/hadoopvim yarn-site.xml</code></pre><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>yarn.resourcemanager.hostname<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>node01<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>yarn.nodemanager.aux-services<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>mapreduce_shuffle<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span></code></pre><h6 id="修改slaves文件"><a href="#修改slaves文件" class="headerlink" title="修改slaves文件"></a>修改slaves文件</h6><p>第一台机器执行以下命令</p><pre><code class="hljs shell">cd /weitrue/install/hadoop-2.6.0-cdh5.14.2/etc/hadoopvim slaves</code></pre><p>原内容替换为</p><pre><code class="hljs gcode"><span class="hljs-symbol">node01</span><span class="hljs-symbol">node02</span><span class="hljs-symbol">node03</span></code></pre><h5 id="第四步：创建文件存放目录"><a href="#第四步：创建文件存放目录" class="headerlink" title="第四步：创建文件存放目录"></a>第四步：创建文件存放目录</h5><p>第一台机器执行以下命令</p><p>node01机器上面创建以下目录</p><pre><code class="hljs shell">mkdir -p /weitrue/install/hadoop-2.6.0-cdh5.14.2/hadoopDatas/tempDatasmkdir -p /weitrue/install/hadoop-2.6.0-cdh5.14.2/hadoopDatas/namenodeDatasmkdir -p /weitrue/install/hadoop-2.6.0-cdh5.14.2/hadoopDatas/datanodeDatas mkdir -p /weitrue/install/hadoop-2.6.0-cdh5.14.2/hadoopDatas/dfs/nn/editsmkdir -p /weitrue/install/hadoop-2.6.0-cdh5.14.2/hadoopDatas/dfs/snn/namemkdir -p /weitrue/install/hadoop-2.6.0-cdh5.14.2/hadoopDatas/dfs/nn/snn/edits</code></pre><h5 id="第五步：安装包的分发scp与rsync"><a href="#第五步：安装包的分发scp与rsync" class="headerlink" title="第五步：安装包的分发scp与rsync"></a>第五步：安装包的分发scp与rsync</h5><p>在linux当中，用于向远程服务器拷贝文件或者文件夹可以使用scp或者rsync，这两个命令功能类似都是向远程服务器进行拷贝，只不过scp是全量拷贝，rsync可以做到增量拷贝，rsync的效率比scp更高一些</p><h6 id="通过scp直接拷贝"><a href="#通过scp直接拷贝" class="headerlink" title="通过scp直接拷贝"></a>通过scp直接拷贝</h6><p>scp（secure copy）安全拷贝</p><p>可以通过scp进行不同服务器之间的文件或者文件夹的复制</p><p>使用语法 </p><pre><code class="hljs shell">scp -r sourceFile  username@host:destpath</code></pre><p>用法示例</p><pre><code class="hljs shell">scp -r hadoop-lzo-0.4.20.jar hadoop@node01:/weitrue/</code></pre><p>node01执行以下命令进行拷贝</p><pre><code class="hljs shell">cd /weitrue/install/scp -r hadoop-2.6.0-cdh5.14.2/ node02:$PWDscp -r hadoop-2.6.0-cdh5.14.2/ node03:$PWD</code></pre><h5 id="第六步：配置hadoop的环境变量"><a href="#第六步：配置hadoop的环境变量" class="headerlink" title="第六步：配置hadoop的环境变量"></a>第六步：配置hadoop的环境变量</h5><p>三台机器都要进行配置hadoop的环境变量</p><p>三台机器执行以下命令</p><pre><code class="hljs shell">sudo vim /etc/profile</code></pre><pre><code class="hljs shell">export HADOOP_HOME=/weitrue/install/hadoop-2.6.0-cdh5.14.2export PATH=$PATH:$HADOOP_HOME/bin:$HADOOP_HOME/sbin</code></pre><p>配置完成之后生效</p><pre><code class="hljs shell">source /etc/profile</code></pre><h5 id="第七步：集群启动"><a href="#第七步：集群启动" class="headerlink" title="第七步：集群启动"></a>第七步：集群启动</h5><h6 id="1-格式化集群"><a href="#1-格式化集群" class="headerlink" title="1. 格式化集群"></a>1. 格式化集群</h6><p>要启动 Hadoop 集群，需要启动 HDFS 和 YARN 两个集群。 </p><p>注意：首次启动HDFS时，必须对其进行格式化操作。本质上是一些清理和准备工作，因为此时的 HDFS 在物理上还是不存在的。<font color="red">格式化操作只有在首次启动的时候需要，以后再也不需要了</font></p><p><font color="red">node01执行一遍即可</font></p><pre><code class="hljs shell">hdfs namenode -format</code></pre><p>或者</p><pre><code class="hljs shell">hadoop namenode –format</code></pre><p><img src="/images/hadoop-env/hadoop.png"></p><p>启动集群有两种方式：①脚本一键启动；②单个进程逐个启动</p><h6 id="2-脚本一键启动"><a href="#2-脚本一键启动" class="headerlink" title="2. 脚本一键启动"></a>2. 脚本一键启动</h6><p>如果配置了 etc/hadoop/slaves 和 ssh 免密登录，则可以使用程序脚本启动所有Hadoop 两个集群的相关进程，在主节点所设定的机器上执行。</p><p>启动集群</p><p>node01节点上执行以下命令</p><p>第一台机器执行以下命令(hadoop/sbin目录下)</p><pre><code class="hljs shell">start-dfs.shstart-yarn.shmr-jobhistory-daemon.sh start historyserver</code></pre><p>停止集群：</p><pre><code class="hljs shell">stop-dfs.shstop-yarn.sh</code></pre><h6 id="3-单个进程逐个启动"><a href="#3-单个进程逐个启动" class="headerlink" title="3. 单个进程逐个启动"></a>3. 单个进程逐个启动</h6><pre><code class="hljs shell">在主节点上使用以下命令启动 HDFS NameNode： hadoop-daemon.sh start namenode 在每个从节点上使用以下命令启动 HDFS DataNode： hadoop-daemon.sh start datanode在主节点上使用以下命令启动 YARN ResourceManager： yarn-daemon.sh start resourcemanager 在每个从节点上使用以下命令启动 YARN nodemanager： yarn-daemon.sh start nodemanager 以上脚本位于$HADOOP_HOME/sbin/目录下。如果想要停止某个节点上某个角色，只需要把命令中的start 改为stop 即可。</code></pre><h6 id="4-一键启动hadoop集群的脚本"><a href="#4-一键启动hadoop集群的脚本" class="headerlink" title="4.一键启动hadoop集群的脚本"></a>4.一键启动hadoop集群的脚本</h6><p>我们也可以创建一键启动hadoop的脚本，以后启动hadoop都可以通过一个脚本即可</p><p>在node01服务器的/home/hadoop/bin目录下创建脚本</p><pre><code class="hljs shell">[hadoop@node01 bin]$ cd /home/hadoop/bin/[hadoop@node01 bin]$ vim hadoop.sh</code></pre><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span>case $1 in&quot;start&quot; )&#123; source /etc/profile; /weitrue/install/hadoop-2.6.0-cdh5.14.2/sbin/start-dfs.sh /weitrue/install/hadoop-2.6.0-cdh5.14.2/sbin/start-yarn.sh /weitrue/install/hadoop-2.6.0-cdh5.14.2/sbin/mr-jobhistory-daemon.sh start historyserver&#125;;;&quot;stop&quot;)&#123; /weitrue/install/hadoop-2.6.0-cdh5.14.2/sbin/stop-dfs.sh /weitrue/install/hadoop-2.6.0-cdh5.14.2/sbin/stop-yarn.sh /weitrue/install/hadoop-2.6.0-cdh5.14.2/sbin/mr-jobhistory-daemon.sh stop  historyserver&#125;;;esac</code></pre><p>修改脚本权限</p><pre><code class="hljs shell">[hadoop@node01 bin]$ chmod 777 hadoop.sh[hadoop@node01 bin]$ ./hadoop.sh start  # 启动hadoop集群[hadoop@node01 bin]$ ./hadoop.sh stop   # 停止hadoop集群</code></pre><h5 id="第八步：浏览器查看启动页面"><a href="#第八步：浏览器查看启动页面" class="headerlink" title="第八步：浏览器查看启动页面"></a>第八步：浏览器查看启动页面</h5><p>hdfs集群访问地址</p><p><a href="http://192.168.51.100:50070/">http://192.168.51.100:50070/</a></p><p>yarn集群访问地址</p><p><a href="http://192.168.51.100:8088/">http://192.168.51.100:8088</a></p><p>jobhistory访问地址：</p><p><a href="http://192.168.51.100:19888/">http://192.168.51.100:19888</a></p><p>==如果要关闭电脑时，清一定要按照以下顺序操作，否则集群可能会出问题==</p><ul><li><p>关闭hadoop集群</p></li><li><p>关闭虚拟机</p></li><li><p>关闭电脑</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Bdata</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hadoop</tag>
      
      <tag>大数据</tag>
      
      <tag>mac</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【ALL】Git学习笔记</title>
    <link href="/2020/06/14/git/"/>
    <url>/2020/06/14/git/</url>
    
    <content type="html"><![CDATA[<blockquote><p>a <a href="http://git-scm.com/about/free-and-open-source">free and open source</a> distributed version control system designed to handle everything from small to very large projects with speed and efficiency.<a id="more"></a> </p></blockquote><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><h4 id="git-config"><a href="#git-config" class="headerlink" title="git config"></a><code>git config</code></h4><pre><code class="hljs shell">git config --list                               # 查看git所有配置git config --global --unset user.name           # 删除用户git config --global --edit                      # 编辑配置文件git config --system --list                      # 查看系统配置git config --global --list                      # 查看当前用户（global）配置git config --local --list                       # 查看当前仓库配置信息</code></pre><h4 id="git-branch"><a href="#git-branch" class="headerlink" title="git branch"></a><code>git branch</code></h4><p>创建、重命名、查看、删除项目分支，通过 Git 做项目开发时，一般都是在开发分支中进行，开发完成后合并分支到主干。</p><pre><code class="hljs shell">git branch &lt;some_branch&gt;                        # 创建分支git branch -m &lt;old_branch&gt; &lt;new_branch&gt;         # 重命名分支git branch -D &lt;some_branch&gt;                     # 删除分支git branch                                      # 查看本地所有分支git branch -a                                   # 查看所有分支（本地和远程）git branch -r                                   # 查看远程版本库上的分支列表，加上 -d 参数可以删除远程版本库上的分支git branch -vv                                  # 查看带有最后提交id、最近提交原因等信息的本地版本库分支列表</code></pre><h4 id="git-tag"><a href="#git-tag" class="headerlink" title="git tag"></a><code>git tag</code></h4><p>为项目标记里程碑</p><pre><code class="hljs shell">git tag publish/xxxgit push origin publish/xxx</code></pre><p>当我们完成某个功能需求准备发布上线时，应该将此次完整的项目代码做个标记，并将这个标记好的版本发布到线上，这里我们以 publish/xxx 为标记名并发布，当看到命令行返回如下内容则表示发布成功了。</p><pre><code class="hljs shell">Total 0 (delta 0), reused 0 (delta 0)To https://github.com/xxx/xxx.github.com.git * [new tag]         publish/xxx -&gt; publish/xxx.gitignore</code></pre><h4 id="git-merge"><a href="#git-merge" class="headerlink" title="git merge"></a><code>git merge</code></h4><p>将其它分支合并到当前分支</p><pre><code class="hljs shell">git merge --squash<span class="hljs-meta">#</span><span class="bash">将待合并分支上的 commit 合并成一个新的 commit 放入当前分支，适用于待合并分支的提交记录不需要保留的情况</span>git merge --no-ff<span class="hljs-meta">#</span><span class="bash">默认情况下，Git 执行<span class="hljs-string">&quot;快进式合并&quot;</span>（fast-farward merge），会直接将 Master 分支指向 Develop 分支，使用 --no-ff 参数后，会执行正常合并，在 Master 分支上生成一个新节点，保证版本演进更清晰。</span>git merge --no-edit<span class="hljs-meta">#</span><span class="bash">在没有冲突的情况下合并，不想手动编辑提交原因，而是用 Git 自动生成的类似 Merge branch <span class="hljs-string">&#x27;test&#x27;</span>的文字直接提交</span></code></pre><h4 id="git-stash"><a href="#git-stash" class="headerlink" title="git stash"></a><code>git stash</code></h4><p>在Git的栈中保存当前修改或删除的工作进度，当你在一个分支里做某项功能开发时，接到通知把昨天已经测试完没问题的代码发布到线上，但这时你已经在这个分支里加入了其它未提交的代码，这个时候就可以把这些未提交的代码存到栈里。</p><pre><code class="hljs shell">git stash<span class="hljs-meta">#</span><span class="bash">将未提交的文件保存到Git栈中</span>git stash list<span class="hljs-meta">#</span><span class="bash">查看栈中保存的列表</span>git stash show stash@&#123;0&#125;<span class="hljs-meta">#</span><span class="bash">显示栈中其中一条记录</span>git stash drop stash@&#123;0&#125;<span class="hljs-meta">#</span><span class="bash">移除栈中其中一条记录</span>git stash pop<span class="hljs-meta">#</span><span class="bash">从Git栈中检出最新保存的一条记录，并将它从栈中移除</span>git stash apply stash@&#123;0&#125;<span class="hljs-meta">#</span><span class="bash">从Git栈中检出其中一条记录，但不从栈中移除</span>git stash branch new_banch<span class="hljs-meta">#</span><span class="bash">把当前栈中最近一次记录检出并创建一个新分支</span>git stash clear<span class="hljs-meta">#</span><span class="bash">清空栈里的所有记录</span>git stash create<span class="hljs-meta">#</span><span class="bash">为当前修改或删除的文件创建一个自定义的栈并返回一个ID，此时并未真正存储到栈里</span>git stash store xxxxxx<span class="hljs-meta">#</span><span class="bash">将 create 方法里返回的ID放到 store 后面，此时在栈里真正创建了一个记录，但当前修改或删除的文件并未从工作区移除</span><span class="hljs-meta">$</span><span class="bash"> git stash create</span>09eb9a97ad632d0825be1ece361936d1d0bdb5c7<span class="hljs-meta">$</span><span class="bash"> git stash store 09eb9a97ad632d0825be1ece361936d1d0bdb5c7</span><span class="hljs-meta">$</span><span class="bash"> git stash list</span>stash@&#123;0&#125;: Created via &quot;git stash store&quot;</code></pre><h4 id="git-log"><a href="#git-log" class="headerlink" title="git log"></a><code>git log</code></h4><pre><code class="hljs shell">git log -p                                      # 显示带提交差异对比的历史记录git log demo.html                               # 显示 demo.html 文件的历史记录git log --since=&quot;2 weeks ago&quot;                   # 显示2周前开始到现在的历史记录，其它时间可以类推git log --before=&quot;2 weeks ago&quot;                  # 显示截止到2周前的历史记录，其它时间可以类推git log -10                                     # 显示最近10条历史记录git log f5f630a..HEAD                           # 显示从提交ID f5f630a 到 HEAD 之间的记录，HEAD 可以为空或其它提交IDgit log --pretty=oneline                        # 在一行中输出简短的历史记录git log --pretty=format:&quot;%h&quot;                    # 格式化输出历史记录</code></pre><p>Git 用各种 placeholder 来决定各种显示内容，常用的显示如下：</p><pre><code class="hljs shell"><span class="hljs-meta">%</span><span class="bash">H:                                             <span class="hljs-comment"># commit hash</span></span><span class="hljs-meta">%</span><span class="bash">h:                                             <span class="hljs-comment"># 缩短的commit hash</span></span><span class="hljs-meta">%</span><span class="bash">T:                                             <span class="hljs-comment"># tree hash</span></span><span class="hljs-meta">%</span><span class="bash">t:                                             <span class="hljs-comment"># 缩短的 tree hash</span></span><span class="hljs-meta">%</span><span class="bash">P:                                             <span class="hljs-comment"># parent hashes</span></span><span class="hljs-meta">%</span><span class="bash">p:                                             <span class="hljs-comment"># 缩短的 parent hashes</span></span><span class="hljs-meta">%</span><span class="bash">an:                                            <span class="hljs-comment"># 作者名字</span></span><span class="hljs-meta">%</span><span class="bash">aN:                                            <span class="hljs-comment"># mailmap的作者名</span></span><span class="hljs-meta">%</span><span class="bash">ae:                                            <span class="hljs-comment"># 作者邮箱</span></span><span class="hljs-meta">%</span><span class="bash">ad:                                            <span class="hljs-comment"># 日期 (--date= 制定的格式)</span></span><span class="hljs-meta">%</span><span class="bash">ar:                                            <span class="hljs-comment"># 日期, 相对格式(1 day ago)</span></span><span class="hljs-meta">%</span><span class="bash">cn:                                            <span class="hljs-comment"># 提交者名字</span></span><span class="hljs-meta">%</span><span class="bash">ce:                                            <span class="hljs-comment"># 提交者 email</span></span><span class="hljs-meta">%</span><span class="bash"><span class="hljs-built_in">cd</span>:                                            <span class="hljs-comment"># 提交日期 (--date= 制定的格式)</span></span><span class="hljs-meta">%</span><span class="bash">cr:                                            <span class="hljs-comment"># 提交日期, 相对格式(1 day ago)</span></span><span class="hljs-meta">%</span><span class="bash">d:                                             <span class="hljs-comment"># ref名称</span></span><span class="hljs-meta">%</span><span class="bash">s:                                             <span class="hljs-comment"># commit信息标题</span></span><span class="hljs-meta">%</span><span class="bash">b:                                             <span class="hljs-comment"># commit信息内容</span></span><span class="hljs-meta">%</span><span class="bash">n:                                             <span class="hljs-comment"># 换行</span></span></code></pre><h4 id="如果远端仓库没有与本地仓库关联"><a href="#如果远端仓库没有与本地仓库关联" class="headerlink" title="如果远端仓库没有与本地仓库关联"></a>如果远端仓库没有与本地仓库关联</h4><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 本地执行（远端需要创建于本地相同名称的项目）</span><span class="hljs-meta">$</span><span class="bash"> git init</span><span class="hljs-meta">$</span><span class="bash"> git remote add origin https://github.com/xxx/xxx.git</span><span class="hljs-meta">$</span><span class="bash"> git add -A</span><span class="hljs-meta">$</span><span class="bash"> git commit -m <span class="hljs-string">&quot;first commit&quot;</span></span><span class="hljs-meta">$</span><span class="bash"> git push -u origin master</span></code></pre><h4 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h4><pre><code class="hljs shell">git status                                      # 查看git状态  git branch                                      # 查看git分支  git checkout feature/new_branch                 # 切换到feature/new_branch分支</code></pre><h4 id="提交代码"><a href="#提交代码" class="headerlink" title="提交代码"></a>提交代码</h4><pre><code class="hljs shell">git add .                                       # 添加数据到镜像仓库                                                                                             # 提交单个文件，进入你要提交的文件目录                                                          # git add &lt;你要提交的文件&gt; git commit -m &#x27;你要写的注释&#x27;                      # 提交到本地镜像仓库git push -u origin feature/new_branch           # 提交到远程镜像仓库</code></pre><h4 id="远程分支拉取到本地"><a href="#远程分支拉取到本地" class="headerlink" title="远程分支拉取到本地"></a>远程分支拉取到本地</h4><pre><code class="hljs shell">git branch -a                                   # 查询所有分支,包括远程分支 git checkout -b release remotes/origin/release  # 将远程release分支拉取到本地，并在本地创建release分支</code></pre><p>绿色是当前所在本地分支，白色是本地分支，红色是远程分支<br><img src="/images/git/git-a.png"></p><h4 id="分支代码拉取提交流程"><a href="#分支代码拉取提交流程" class="headerlink" title="分支代码拉取提交流程"></a>分支代码拉取提交流程</h4><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment"># 获取主干最新代码 </span></span><span class="hljs-meta">$</span><span class="bash"> git <span class="hljs-built_in">clone</span> &lt;repo&gt; </span><span class="hljs-meta">$</span><span class="bash"> git checkout develop                        <span class="hljs-comment"># 切换到develop分支 </span></span><span class="hljs-meta">$</span><span class="bash"> git pull                                    <span class="hljs-comment"># 同步分支 </span></span><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment"># 新建一个开发分支my_feature </span></span><span class="hljs-meta">$</span><span class="bash"> git checkout -b feature/my_feature  </span><span class="hljs-meta">$</span><span class="bash"> git branch                                  <span class="hljs-comment"># 确认已切换到当前分支</span></span><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment"># 提交代码</span></span><span class="hljs-meta">$</span><span class="bash"> git add --all 或者 git add .                 <span class="hljs-comment"># 保存所有的修改变化  </span></span><span class="hljs-meta">$</span><span class="bash"> git status                                  <span class="hljs-comment"># 查看发生变动的文件 </span></span><span class="hljs-meta">$</span><span class="bash"> git commit -m <span class="hljs-string">&quot;implement api architecture&quot;</span>  <span class="hljs-comment"># 编辑备注 </span></span><span class="hljs-meta">$</span><span class="bash"> git push origin -u feature/my_feature       <span class="hljs-comment"># 将分支代码push到服务器</span></span><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment"># 合并分支feature/my_feature到develop </span></span><span class="hljs-meta">$</span><span class="bash"> git checkout develop </span><span class="hljs-meta">$</span><span class="bash"> git pull                                    <span class="hljs-comment"># 确保develop分支是最新的 </span></span><span class="hljs-meta">$</span><span class="bash"> git merge --no-ff feature/my_feature  </span><span class="hljs-meta">#</span><span class="bash"> 分支开发过程中，为了减少冲突，尽量要多与主干同步 </span><span class="hljs-meta">$</span><span class="bash"> git fetch origin </span><span class="hljs-meta">$</span><span class="bash"> git rebase origin/develop </span><span class="hljs-meta">$</span><span class="bash"> git add .                                   <span class="hljs-comment"># 解决冲突后add </span></span><span class="hljs-meta">$</span><span class="bash"> git rebase --<span class="hljs-built_in">continue</span></span><span class="hljs-meta">#</span><span class="bash">删除分支 </span><span class="hljs-meta">$</span><span class="bash"> git branch -d feature/my_feature</span><span class="hljs-meta">#</span><span class="bash">取消commit </span><span class="hljs-meta">$</span><span class="bash"> git reset --hard &lt;commit <span class="hljs-built_in">log</span>&gt;</span></code></pre><h3 id="动图图解"><a href="#动图图解" class="headerlink" title="动图图解"></a>动图图解</h3><h4 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h4><p>拥有多个分支是很方便的，这样可以将不同的新修改互相隔离开，而且还能确保你不会意外地向生产代码推送未经许可或破损的代码修改。但一旦这些修改得到了批准许可，我们就需要将其部署到我们的生产分支中！</p><p>可将一个分支的修改融入到另一个分支的一种方式是执行 git merge。Git 可执行两种类型的合并：fast-forward 和 no-fast-forward。现在你可能分不清，但我们马上就来看看它们的差异所在。</p><h5 id="Fast-forward-—ff"><a href="#Fast-forward-—ff" class="headerlink" title="Fast-forward (—ff)"></a>Fast-forward (—ff)</h5><p>在当前分支相比于我们要合并的分支没有额外的提交（commit）时，可以执行 fast-forward 合并。Git 很懒，首先会尝试执行最简单的选项：fast-forward！这类合并不会创建新的提交，而是会将我们正在合并的分支上的提交直接合并到当前分支。</p><p><img src="/images/git/image1.gif"></p><p>完美！现在，我们在 dev 分支上所做的所有改变都合并到了 master 分支上。那么 no-fast-forward 又是什么意思呢？</p><h5 id="No-fast-foward-—no-ff"><a href="#No-fast-foward-—no-ff" class="headerlink" title="No-fast-foward (—no-ff)"></a>No-fast-foward (—no-ff)</h5><p>如果你的当前分支相比于你想要合并的分支没有任何提交，那当然很好，但很遗憾现实情况很少如此！如果我们在当前分支上提交我们想要合并的分支不具备的改变，那么 git 将会执行 no-fast-forward 合并。</p><p>使用 no-fast-forward 合并时，Git 会在当前活动分支上创建新的 merging commit。这个提交的父提交（parent commit）即指向这个活动分支，也指向我们想要合并的分支！</p><p><img src="/images/git/image2.gif"></p><p>没什么大不了的，完美的合并！现在，我们在 dev 分支上所做的所有改变都合并到了 master 分支上。</p><h5 id="合并冲突"><a href="#合并冲突" class="headerlink" title="合并冲突"></a>合并冲突</h5><p>尽管 Git 能够很好地决定如何合并分支以及如何向文件添加修改，但它并不总是能完全自己做决定。当我们想要合并的两个分支的同一文件中的同一行代码上有不同的修改，或者一个分支删除了一个文件而另一个分支修改了这个文件时，Git 就不知道如何取舍了。</p><p>在这样的情况下，Git 会询问你想要保留哪种选择？假设在这两个分支中，我们都编辑了 README.md 的第一行。</p><p><img src="/images/git/image3.png"></p><p>如果我们想把 dev 合并到 master，就会出现一个合并冲突：你想要标题是 Hello! 还是 Hey!？</p><p>当尝试合并这些分支时，Git 会向你展示冲突出现的位置。我们可以手动移除我们不想保留的修改，保存这些修改，再次添加这个已修改的文件，然后提交这些修改。</p><p><img src="/images/git/image4.gif"></p><p>完成！尽管合并冲突往往很让人厌烦，但这是合理的：Git 不应该瞎猜我们想要保留哪些修改。</p><h4 id="变基（Rebasing）"><a href="#变基（Rebasing）" class="headerlink" title="变基（Rebasing）"></a>变基（Rebasing）</h4><p>我们刚看到可通过执行 git merge 将一个分支的修改应用到另一个分支。另一种可将一个分支的修改融入到另一个分支的方式是执行 git rebase。</p><p>git rebase 会将当前分支的提交复制到指定的分支之上。</p><p><img src="/images/git/image5.gif"></p><p>完美，现在我们在 dev 分支上获取了 master 分支上的所有修改。</p><p>变基与合并有一个重大的区别：Git 不会尝试确定要保留或不保留哪些文件。我们执行 rebase 的分支总是含有我们想要保留的最新近的修改！这样我们不会遇到任何合并冲突，而且可以保留一个漂亮的、线性的 Git 历史记录。</p><p>上面这个例子展示了在 master 分支上的变基。但是，在更大型的项目中，你通常不需要这样的操作。git rebase 在为复制的提交创建新的 hash 时会修改项目的历史记录。</p><p>如果你在开发一个 feature 分支并且 master 分支已经更新过，那么变基就很好用。你可以在你的分支上获取所有更新，这能防止未来出现合并冲突。</p><h4 id="交互式变基（Interactive-Rebase）"><a href="#交互式变基（Interactive-Rebase）" class="headerlink" title="交互式变基（Interactive Rebase）"></a>交互式变基（Interactive Rebase）</h4><p>在为提交执行变基之前，我们可以修改它们！我们可以使用交互式变基来完成这一任务。交互式变基在你当前开发的分支上以及想要修改某些提交时会很有用。</p><p>在我们正在 rebase 的提交上，我们可以执行以下 6 个动作：</p><p>reword：修改提交信息；</p><p>edit：修改此提交；</p><p>squash：将提交融合到前一个提交中；</p><p>fixup：将提交融合到前一个提交中，不保留该提交的日志消息；</p><p>exec：在每个提交上运行我们想要 rebase 的命令；</p><p>drop：移除该提交。</p><p>很棒！这样我们就能完全控制我们的提交了。如果你想要移除一个提交，只需 drop 即可。</p><p><img src="/images/git/image6.gif"></p><p>如果你想把多个提交融合到一起以便得到清晰的提交历史，那也没有问题！</p><p><img src="/images/git/image7.gif"></p><p>交互式变基能为你在 rebase 时提供大量控制，甚至可以控制当前的活动分支。</p><h4 id="重置（Resetting）"><a href="#重置（Resetting）" class="headerlink" title="重置（Resetting）"></a>重置（Resetting）</h4><p>当我们不想要之前提交的修改时，就会用到这个命令。也许这是一个 WIP 提交或者可能是引入了 bug 的提交，这时候就要执行 git reset。</p><p>git reset 能让我们不再使用当前台面上的文件，让我们可以控制 HEAD 应该指向的位置。</p><h5 id="软重置"><a href="#软重置" class="headerlink" title="软重置"></a>软重置</h5><p>软重置会将 HEAD 移至指定的提交（或与 HEAD 相比的提交的索引），而不会移除该提交之后加入的修改！</p><p>假设我们不想保留添加了一个 style.css 文件的提交 9e78i，而且我们也不想保留添加了一个 index.js 文件的提交 035cc。但是，我们确实又想要保留新添加的 style.css 和 index.js 文件！这是软重置的一个完美用例。</p><p><img src="/images/git/image8.gif"></p><p>输入 git status 后，你会看到我们仍然可以访问在之前的提交上做过的所有修改。这很好，这意味着我们可以修复这些文件的内容，之后再重新提交它们！</p><h5 id="硬重置"><a href="#硬重置" class="headerlink" title="硬重置"></a>硬重置</h5><p>有时候我们并不想保留特定提交引入的修改。不同于软重置，我们应该再也无需访问它们。Git 应该直接将整体状态直接重置到特定提交之前的状态：这甚至包括你在工作目录中和暂存文件上的修改。</p><p><img src="/images/git/image9.gif"></p><p>Git 丢弃了 9e78i 和 035cc 引入的修改，并将状态重置到了 ec5be 的状态。</p><h4 id="还原（Reverting）"><a href="#还原（Reverting）" class="headerlink" title="还原（Reverting）"></a>还原（Reverting）</h4><p>另一种撤销修改的方法是执行 git revert。通过对特定的提交执行还原操作，我们会创建一个包含已还原修改的新提交。</p><p>假设 ec5be 添加了一个 index.js 文件。但之后我们发现其实我们再也不需要由这个提交引入的修改了。那就还原 ec5be 提交吧！</p><p><img src="/images/git/image10.gif"></p><p>完美！提交 9e78i 还原了由提交 ec5be 引入的修改。在撤销特定的提交时，git revert 非常有用，同时也不会修改分支的历史。</p><h4 id="拣选（Cherry-picking）"><a href="#拣选（Cherry-picking）" class="headerlink" title="拣选（Cherry-picking）"></a>拣选（Cherry-picking）</h4><p>当一个特定分支包含我们的活动分支需要的某个提交时，我们对那个提交执行 cherry-pick！对一个提交执行 cherry-pick 时，我们会在活动分支上创建一个新的提交，其中包含由拣选出来的提交所引入的修改。</p><p>假设 dev 分支上的提交 76d12 为 index.js 文件添加了一项修改，而我们希望将其整合到 master 分支中。我们并不想要整个 dev 分支，而只需要这个提交！</p><p><img src="/images/git/image11.gif"></p><p>现在 master 分支包含 76d12 引入的修改了。</p><h4 id="取回（Fetching）"><a href="#取回（Fetching）" class="headerlink" title="取回（Fetching）"></a>取回（Fetching）</h4><p>如果你有一个远程 Git 分支，比如在 GitHub 上的分支，当远程分支上包含当前分支没有的提交时，可以使用取回。比如当合并了另一个分支或你的同事推送了一个快速修复时。</p><p>通过在这个远程分支上执行 git fetch，我们就可在本地获取这些修改。这不会以任何方式影响你的本地分支：fetch 只是单纯地下载新的数据而已。</p><p><img src="/images/git/image12.gif"></p><p>现在我们可以看到自上次推送以来的所有修改了。这些新数据也已经在本地了，我们可以决定用这些新数据做什么了。</p><h4 id="拉取（Pulling）"><a href="#拉取（Pulling）" class="headerlink" title="拉取（Pulling）"></a>拉取（Pulling）</h4><p>尽管 git fetch 可用于获取某个分支的远程信息，但我们也可以执行 git pull。git pull 实际上是两个命令合成了一个：git fetch 和 git merge。当我们从来源拉取修改时，我们首先是像 git fetch 那样取回所有数据，然后最新的修改会自动合并到本地分支中。</p><p><img src="/images/git/image13.gif"></p><p>很好，我们现在与远程分支完美同步了，并且也有了所有最新的修改！</p><h4 id="Reflog"><a href="#Reflog" class="headerlink" title="Reflog"></a>Reflog</h4><p>每个人都会犯错，但犯错其实没啥！有时候你可能感觉你把 git repo 完全搞坏了，让你想完全删了了事。</p><p>git reflog 是一个非常有用的命令，可以展示已经执行过的所有动作的日志。包括合并、重置、还原，基本上包含你对你的分支所做的任何修改。</p><p><img src="/images/git/image14.gif"></p><p>如果你犯了错，你可以根据 reflog 提供的信息通过重置 HEAD 来轻松地重做！</p><p>假设我们实际上并不需要合并原有分支。当我们执行 git reflog 命令时，我们可以看到这个 repo 的状态在合并前位于 HEAD@{1}。那我们就执行一次 git reset，将 HEAD 重新指向在 HEAD@{1} 的位置。</p><p><img src="/images/git/image15.gif"></p><p>我们可以看到最新的动作已被推送给 reflog。</p><h3 id="Octotree-Chrome-github-浏览插件"><a href="#Octotree-Chrome-github-浏览插件" class="headerlink" title="Octotree: Chrome github 浏览插件"></a>Octotree: Chrome github 浏览插件</h3><p> 可以把 github 项目的目录树结构展示出来 </p><p><img src="/images/git/octotree_1.jpg"></p><p><img src="/images/git/octotree_2.jpg"></p><h4 id="GitHub搜索"><a href="#GitHub搜索" class="headerlink" title="GitHub搜索"></a>GitHub搜索</h4><p> 假如，正在做一个python项目，正好要用到一个爬虫处理的框架，关键词就是 <strong>Spider</strong> ，那就可以先试试搜索项目名称里面包含 <strong>Spider</strong> 的项目： </p><h5 id="in-name-Spider"><a href="#in-name-Spider" class="headerlink" title="in:name Spider"></a>in:name Spider</h5><p><img src="/images/git/git_hub_1.jpg"></p><h5 id="in-name-Spider-stars-gt-3000"><a href="#in-name-Spider-stars-gt-3000" class="headerlink" title="in:name Spider stars:&gt;3000"></a>in:name Spider stars:&gt;3000</h5><p>如果 需要约束搜索结果的star数大于3000+ </p><p><img src="/images/git/github_2.jpg"></p><h5 id="in-name-Spider-stars-gt-3000-forks-gt-1000"><a href="#in-name-Spider-stars-gt-3000-forks-gt-1000" class="headerlink" title="in:name Spider stars:&gt;3000 forks:&gt;1000"></a>in:name Spider stars:&gt;3000 forks:&gt;1000</h5><p>如果需要更小范围, 可以约束fork数 </p><p><img src="/images/git/github_3.jpg"></p><h5 id="in-name-Spider-stars-gt-3000-forks-gt-1000-language-python"><a href="#in-name-Spider-stars-gt-3000-forks-gt-1000-language-python" class="headerlink" title="in:name Spider stars:&gt;3000 forks:&gt;1000 language:python"></a>in:name Spider stars:&gt;3000 forks:&gt;1000 language:python</h5><p>当然，也可以约束语言</p><p><img src="/images/git/github_4.jpg"></p><h5 id="in-readme-Spider-stars-gt-3000-forks-gt-1000-language-python"><a href="#in-readme-Spider-stars-gt-3000-forks-gt-1000-language-python" class="headerlink" title="in:readme Spider stars:&gt;3000 forks:&gt;1000 language:python"></a>in:readme Spider stars:&gt;3000 forks:&gt;1000 language:python</h5><p> 如果不确定关键词是否会命中项目名称，那可以通过 <strong>readme</strong> 来搜索 。此时，就需要重新调整 star和fork数 了。</p><p><img src="/images/git/github_5.jpg"></p><h5 id="in-description-Spider-stars-gt-3000-forks-gt-1000-language-python"><a href="#in-description-Spider-stars-gt-3000-forks-gt-1000-language-python" class="headerlink" title="in:description Spider stars:&gt;3000 forks:&gt;1000 language:python"></a>in:description Spider stars:&gt;3000 forks:&gt;1000 language:python</h5><p>如果，我们想要找的项目，想不到一个英文关键词去描述，怎么办？</p><p>这种情况下，我们直接用一种简单粗暴的方式，按照 <strong>description</strong> 的方式来搜索：</p><p><img src="/images/git/github_6.jpg"></p><h5 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h5><p>根据开源项目的主要组成部分：</p><p>​    ◆ name: 项目名</p><p>​    ◆ description: 项目的简要描述</p><p>​    ◆ 项目的源码</p><p>​    ◆ README.md: 项目的详细情况的介绍</p><pre><code class="hljs markdown">|      筛选条件       |            备注            || ------------------ | ------------------------- || in:name xxx        | 按照项目名搜索              ｜| in:readme xxx      | 按照README搜索             ｜| in:description xxx | 按照description搜索        ｜| stars:&gt;xxx         | stars数大于xxx             ｜| forks:&gt;xxx         | forks数大于xxx             ｜| language:xxx       | 编程语言是xxx              ｜| pushed:&gt;YYYY-MM-DD | 最后更新时间大于YYYY-MM-DD  ｜</code></pre>]]></content>
    
    
    <categories>
      
      <category>Develop</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Go】并发之道</title>
    <link href="/2020/06/14/golang-concurrency/"/>
    <url>/2020/06/14/golang-concurrency/</url>
    
    <content type="html"><![CDATA[<blockquote></blockquote><h3 id="goroutine"><a href="#goroutine" class="headerlink" title="goroutine"></a><code>goroutine</code></h3><p><img src="/images/golang/goroutine.png"></p><h4 id="协程-Coroutine"><a href="#协程-Coroutine" class="headerlink" title="协程 Coroutine"></a>协程 <code>Coroutine</code></h4><ul><li><p><em>轻量级</em>线程</p></li><li><p><strong>非抢占式</strong>多任务处理，由协程主动交出控制权</p></li><li><p>编译器/解释器/虚拟机层的多任务</p></li><li><p>多个协程可以在一个或者多个线程上运行</p></li></ul><h5 id="其他语言对协程的支持"><a href="#其他语言对协程的支持" class="headerlink" title="其他语言对协程的支持"></a>其他语言对协程的支持</h5><p><code>Java</code>：标准库不支持</p><p><code>Python</code>：3.5版本前使用yield关键字</p><p>​                 3.5以后， <code>async def 方法名</code>实现协程的原生支持</p><h5 id="可能切换goroutine的事件"><a href="#可能切换goroutine的事件" class="headerlink" title="可能切换goroutine的事件"></a>可能切换<code>goroutine</code>的事件</h5><ul><li><p><code>I/O, Select</code></p></li><li><p><code>channel</code></p></li><li><p>等待锁</p></li><li><p>函数调用</p></li><li><p><code>runtime.Gosched()</code></p></li><li><p><code>.e.g</code></p></li></ul><pre><code class="hljs go"><span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;time&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Run</span><span class="hljs-params">()</span></span>  &#123;<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i ++ &#123;<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(j <span class="hljs-keyword">int</span>)</span></span> &#123;<span class="hljs-keyword">for</span>&#123;fmt.Println(<span class="hljs-string">&quot;go run from&quot;</span>, j)&#125;&#125;(i)&#125;time.Sleep(time.Minute)&#125;</code></pre><h4 id="channel"><a href="#channel" class="headerlink" title="channel"></a><code>channel</code></h4><p><img src="/images/golang/channel.png"></p><pre><code class="hljs go"><span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;time&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">works</span><span class="hljs-params">(id <span class="hljs-keyword">int</span>, c <span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)</span></span>  &#123;<span class="hljs-comment">// 不断的从channel取</span><span class="hljs-keyword">for</span>  &#123;fmt.Printf(<span class="hljs-string">&quot;channel %d receive %c\n&quot;</span>, id, &lt;-c)&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">workIfNotClose</span><span class="hljs-params">(id <span class="hljs-keyword">int</span>, c <span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)</span></span>  &#123;<span class="hljs-comment">// 接收方判断channel中有数据就不断的从channel取</span><span class="hljs-keyword">for</span>  &#123;n, ok := &lt;-c<span class="hljs-keyword">if</span> !ok&#123;<span class="hljs-keyword">break</span>&#125;fmt.Printf(<span class="hljs-string">&quot;channel %d receive %c\n&quot;</span>, id, n)&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">workIfNotCloseSimple</span><span class="hljs-params">(id <span class="hljs-keyword">int</span>, c <span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)</span></span>  &#123;<span class="hljs-comment">// 接收方判断channel中有数据就不断的从channel取</span><span class="hljs-keyword">for</span> n := <span class="hljs-keyword">range</span> c&#123;fmt.Printf(<span class="hljs-string">&quot;channel %d receive %c\n&quot;</span>, id, n)&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">createWorks</span><span class="hljs-params">(id <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">chan</span>&lt;- <span class="hljs-title">int</span></span> &#123;c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)<span class="hljs-keyword">go</span> works(id, c)<span class="hljs-keyword">return</span> c&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">first</span><span class="hljs-params">()</span></span>  &#123;<span class="hljs-comment">// 创建channel用例</span><span class="hljs-keyword">var</span> chans [<span class="hljs-number">10</span>]<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span><span class="hljs-keyword">for</span>  i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;chans[i] = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)<span class="hljs-keyword">go</span> works(i, chans[i])&#125;<span class="hljs-comment">// 往channel放</span><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;chans[i] &lt;- <span class="hljs-string">&#x27;a&#x27;</span> + i&#125;<span class="hljs-comment">// 往channel放</span><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;chans[i] &lt;- <span class="hljs-string">&#x27;A&#x27;</span> + i&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">second</span><span class="hljs-params">()</span></span>  &#123;<span class="hljs-comment">// 只能发数据  chan&lt;- int 将channel 作为函数返回参数  即 channel也是一等公民</span><span class="hljs-keyword">var</span> chann [<span class="hljs-number">10</span>] <span class="hljs-keyword">chan</span>&lt;- <span class="hljs-keyword">int</span><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;chann[i] = createWorks(i)&#125;<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;chann[i] &lt;- <span class="hljs-string">&#x27;k&#x27;</span> + i&#125;<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;chann[i] &lt;- <span class="hljs-string">&#x27;K&#x27;</span> + i&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">thirdBufferedChannel</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-comment">// channel缓冲区   可以放入不大于缓冲区的大小时，可以不用取</span>c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>, <span class="hljs-number">4</span>)<span class="hljs-keyword">go</span> works(<span class="hljs-number">0</span>, c)c &lt;- <span class="hljs-string">&#x27;u&#x27;</span>c &lt;- <span class="hljs-string">&#x27;v&#x27;</span>c &lt;- <span class="hljs-string">&#x27;w&#x27;</span>c &lt;- <span class="hljs-string">&#x27;x&#x27;</span>c &lt;- <span class="hljs-string">&#x27;y&#x27;</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">channelClose</span><span class="hljs-params">()</span></span>  &#123;c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>, <span class="hljs-number">4</span>)<span class="hljs-keyword">go</span> workIfNotCloseSimple(<span class="hljs-number">0</span>, c)c &lt;- <span class="hljs-string">&#x27;U&#x27;</span>c &lt;- <span class="hljs-string">&#x27;V&#x27;</span>c &lt;- <span class="hljs-string">&#x27;W&#x27;</span><span class="hljs-built_in">close</span>(c)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ChanDemo</span><span class="hljs-params">()</span></span>  &#123;<span class="hljs-comment">//  channel也是一等公民</span>first()second()fmt.Println(<span class="hljs-string">&quot;-----------------&quot;</span>)thirdBufferedChannel()channelClose()time.Sleep(time.Second)&#125;<span class="hljs-comment">// 输出</span>channel <span class="hljs-number">7</span> receive hchannel <span class="hljs-number">9</span> receive jchannel <span class="hljs-number">8</span> receive ichannel <span class="hljs-number">5</span> receive fchannel <span class="hljs-number">3</span> receive dchannel <span class="hljs-number">6</span> receive gchannel <span class="hljs-number">4</span> receive echannel <span class="hljs-number">2</span> receive cchannel <span class="hljs-number">1</span> receive bchannel <span class="hljs-number">0</span> receive achannel <span class="hljs-number">0</span> receive A-----------------channel <span class="hljs-number">4</span> receive Echannel <span class="hljs-number">3</span> receive Dchannel <span class="hljs-number">1</span> receive Bchannel <span class="hljs-number">7</span> receive Hchannel <span class="hljs-number">2</span> receive Cchannel <span class="hljs-number">5</span> receive Fchannel <span class="hljs-number">6</span> receive Gchannel <span class="hljs-number">9</span> receive Jchannel <span class="hljs-number">8</span> receive Ichannel <span class="hljs-number">0</span> receive kchannel <span class="hljs-number">1</span> receive lchannel <span class="hljs-number">2</span> receive mchannel <span class="hljs-number">3</span> receive nchannel <span class="hljs-number">4</span> receive ochannel <span class="hljs-number">5</span> receive pchannel <span class="hljs-number">6</span> receive qchannel <span class="hljs-number">7</span> receive rchannel <span class="hljs-number">7</span> receive Rchannel <span class="hljs-number">8</span> receive schannel <span class="hljs-number">8</span> receive Schannel <span class="hljs-number">3</span> receive Nchannel <span class="hljs-number">5</span> receive Pchannel <span class="hljs-number">0</span> receive Kchannel <span class="hljs-number">6</span> receive Qchannel <span class="hljs-number">9</span> receive tchannel <span class="hljs-number">9</span> receive Tchannel <span class="hljs-number">2</span> receive Mchannel <span class="hljs-number">4</span> receive Ochannel <span class="hljs-number">1</span> receive L-----------------channel <span class="hljs-number">0</span> receive uchannel <span class="hljs-number">0</span> receive vchannel <span class="hljs-number">0</span> receive wchannel <span class="hljs-number">0</span> receive xchannel <span class="hljs-number">0</span> receive ychannel <span class="hljs-number">0</span> receive Uchannel <span class="hljs-number">0</span> receive Vchannel <span class="hljs-number">0</span> receive WExiting.</code></pre><h5 id="通过通信来共享内存"><a href="#通过通信来共享内存" class="headerlink" title="通过通信来共享内存"></a>通过通信来共享内存</h5><pre><code class="hljs go"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Author: Wang P</span><span class="hljs-comment"> * Version: 1.0.0</span><span class="hljs-comment"> * Date: 2021/2/5 下午5:05</span><span class="hljs-comment"> * Description:</span><span class="hljs-comment"> **/</span><span class="hljs-keyword">package</span> goroutines<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-keyword">type</span> Worker <span class="hljs-keyword">struct</span> &#123;in <span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>done <span class="hljs-keyword">chan</span> <span class="hljs-keyword">bool</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">doWork</span><span class="hljs-params">(id <span class="hljs-keyword">int</span>, w Worker)</span></span>  &#123;<span class="hljs-comment">// 接收方判断channel中有数据就不断的从channel取</span><span class="hljs-keyword">for</span> n := <span class="hljs-keyword">range</span> w.in&#123;fmt.Printf(<span class="hljs-string">&quot;channel %d receive %c\n&quot;</span>, id, n)w.done &lt;- <span class="hljs-literal">true</span>&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">createWorkers</span><span class="hljs-params">(id <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">Worker</span></span> &#123;w := Worker&#123;in: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>),done: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">bool</span>),&#125;<span class="hljs-keyword">go</span> doWork(id, w)<span class="hljs-keyword">return</span> w&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">communicate</span><span class="hljs-params">()</span></span>  &#123;<span class="hljs-comment">// 只能发数据  chan&lt;- int 将channel 作为函数返回参数  即 channel也是一等公民</span><span class="hljs-keyword">var</span> works [<span class="hljs-number">10</span>]Worker<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;works[i] = createWorkers(i)&#125;<span class="hljs-keyword">for</span> i, worker := <span class="hljs-keyword">range</span> works&#123;worker.in &lt;- <span class="hljs-string">&#x27;a&#x27;</span> + i&#125;<span class="hljs-keyword">for</span> _, worker := <span class="hljs-keyword">range</span> works&#123;&lt;- worker.done&#125;<span class="hljs-keyword">for</span> i, worker := <span class="hljs-keyword">range</span> works&#123;worker.in &lt;- <span class="hljs-string">&#x27;A&#x27;</span> + i&#125;<span class="hljs-keyword">for</span> _, worker := <span class="hljs-keyword">range</span> works&#123;&lt;- worker.done&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">doWork2</span><span class="hljs-params">(id <span class="hljs-keyword">int</span>, w Worker)</span></span>  &#123;<span class="hljs-comment">// 接收方判断channel中有数据就不断的从channel取</span><span class="hljs-keyword">for</span> n := <span class="hljs-keyword">range</span> w.in&#123;fmt.Printf(<span class="hljs-string">&quot;channel %d receive %c\n&quot;</span>, id, n)<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;w.done &lt;- <span class="hljs-literal">true</span>&#125;()&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">createWorkers2</span><span class="hljs-params">(id <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">Worker</span></span> &#123;w := Worker&#123;in: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>),done: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">bool</span>),&#125;<span class="hljs-keyword">go</span> doWork2(id, w)<span class="hljs-keyword">return</span> w&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">communicateDoneAll</span><span class="hljs-params">()</span></span>  &#123;<span class="hljs-comment">// 只能发数据  chan&lt;- int 将channel 作为函数返回参数  即 channel也是一等公民</span><span class="hljs-keyword">var</span> worksAll [<span class="hljs-number">10</span>]Worker<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;worksAll[i] = createWorkers2(i)&#125;<span class="hljs-keyword">for</span> i, worker := <span class="hljs-keyword">range</span> worksAll &#123;worker.in &lt;- <span class="hljs-string">&#x27;j&#x27;</span> + i&#125;<span class="hljs-keyword">for</span> i, worker := <span class="hljs-keyword">range</span> worksAll &#123;worker.in &lt;- <span class="hljs-string">&#x27;J&#x27;</span> + i&#125;<span class="hljs-comment">// 等所有任务都取完 再结束</span><span class="hljs-keyword">for</span> _, worker := <span class="hljs-keyword">range</span> worksAll &#123;&lt;- worker.done&lt;- worker.done&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">communicateDemo</span><span class="hljs-params">()</span></span>  &#123;communicate()fmt.Println(<span class="hljs-string">&quot;----------------&quot;</span>)communicateDoneAll()&#125;<span class="hljs-comment">// 输出</span>channel <span class="hljs-number">7</span> receive hchannel <span class="hljs-number">5</span> receive fchannel <span class="hljs-number">8</span> receive ichannel <span class="hljs-number">9</span> receive jchannel <span class="hljs-number">2</span> receive cchannel <span class="hljs-number">3</span> receive dchannel <span class="hljs-number">1</span> receive bchannel <span class="hljs-number">0</span> receive achannel <span class="hljs-number">4</span> receive echannel <span class="hljs-number">6</span> receive gchannel <span class="hljs-number">6</span> receive Gchannel <span class="hljs-number">7</span> receive Hchannel <span class="hljs-number">8</span> receive Ichannel <span class="hljs-number">9</span> receive Jchannel <span class="hljs-number">0</span> receive Achannel <span class="hljs-number">1</span> receive Bchannel <span class="hljs-number">2</span> receive Cchannel <span class="hljs-number">3</span> receive Dchannel <span class="hljs-number">5</span> receive Fchannel <span class="hljs-number">4</span> receive E----------------channel <span class="hljs-number">0</span> receive jchannel <span class="hljs-number">1</span> receive kchannel <span class="hljs-number">4</span> receive nchannel <span class="hljs-number">2</span> receive lchannel <span class="hljs-number">3</span> receive mchannel <span class="hljs-number">2</span> receive Lchannel <span class="hljs-number">8</span> receive rchannel <span class="hljs-number">0</span> receive Jchannel <span class="hljs-number">1</span> receive Kchannel <span class="hljs-number">7</span> receive qchannel <span class="hljs-number">5</span> receive ochannel <span class="hljs-number">9</span> receive schannel <span class="hljs-number">3</span> receive Mchannel <span class="hljs-number">5</span> receive Ochannel <span class="hljs-number">6</span> receive pchannel <span class="hljs-number">4</span> receive Nchannel <span class="hljs-number">6</span> receive Pchannel <span class="hljs-number">9</span> receive Schannel <span class="hljs-number">7</span> receive Qchannel <span class="hljs-number">8</span> receive R</code></pre><h5 id="利用channel遍历树"><a href="#利用channel遍历树" class="headerlink" title="利用channel遍历树"></a>利用channel遍历树</h5><pre><code class="hljs go"><span class="hljs-keyword">package</span> goroutines<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-keyword">type</span> Node <span class="hljs-keyword">struct</span> &#123;Value       <span class="hljs-keyword">int</span>Left, Right *Node&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">createNode</span><span class="hljs-params">(value <span class="hljs-keyword">int</span>)</span> *<span class="hljs-title">Node</span></span> &#123;<span class="hljs-keyword">return</span> &amp;Node&#123;Value: value&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(node *Node)</span> <span class="hljs-title">setValue</span><span class="hljs-params">(value <span class="hljs-keyword">int</span>)</span></span> &#123;<span class="hljs-comment">// 接收者使用指针才可以改变结构内容</span><span class="hljs-keyword">if</span> node == <span class="hljs-literal">nil</span> &#123;fmt.Println(<span class="hljs-string">&quot;Setting Value to nil node. Ignored.&quot;</span>)<span class="hljs-keyword">return</span>&#125;node.Value = value&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(node *Node)</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">if</span> node == <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span>&#125;fmt.Print(node.Value, <span class="hljs-string">&quot; &quot;</span>)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(node *Node)</span><span class="hljs-title">travelsWithFunc</span><span class="hljs-params">(f <span class="hljs-keyword">func</span>(*Node)</span>)</span> &#123;<span class="hljs-keyword">if</span> node == <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span>&#125;node.Left.travelsWithFunc(f)f(node)node.Right.travelsWithFunc(f)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(node *Node)</span><span class="hljs-title">travelWithChannel</span><span class="hljs-params">()</span> <span class="hljs-title">chan</span> *<span class="hljs-title">Node</span></span>&#123;c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> *Node)<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;node.travelsWithFunc(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(node *Node)</span></span> &#123;c &lt;- node&#125;)<span class="hljs-built_in">close</span>(c)&#125;()<span class="hljs-keyword">return</span> c&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">initTree</span><span class="hljs-params">()</span> *<span class="hljs-title">Node</span></span> &#123;<span class="hljs-keyword">var</span> root Noderoot = Node&#123;Value: <span class="hljs-number">3</span>&#125;root.Left = &amp;Node&#123;&#125;root.Right = &amp;Node&#123;<span class="hljs-number">5</span>, <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>&#125;root.Right.Left = <span class="hljs-built_in">new</span>(Node)root.Left.Right = createNode(<span class="hljs-number">2</span>)root.Right.Left.setValue(<span class="hljs-number">4</span>)<span class="hljs-keyword">return</span> &amp;root&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Demo</span><span class="hljs-params">()</span></span>  &#123;t := initTree()<span class="hljs-comment">// 计数</span>  nodeCount := <span class="hljs-number">0</span>t.travelsWithFunc(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(node *Node)</span></span> &#123;nodeCount++&#125;)fmt.Println(<span class="hljs-string">&quot;Node counts&quot;</span>, nodeCount)<span class="hljs-comment">// 树中最大值</span>  c := t.travelWithChannel()maxNode := <span class="hljs-number">0</span><span class="hljs-comment">// 从channel中取</span><span class="hljs-keyword">for</span> n := <span class="hljs-keyword">range</span> c &#123;<span class="hljs-keyword">if</span> maxNode &lt; n.Value &#123;maxNode = n.Value&#125;&#125;fmt.Println(<span class="hljs-string">&quot;Max node:&quot;</span>, maxNode)&#125;</code></pre><h4 id="Select调度"><a href="#Select调度" class="headerlink" title="Select调度"></a><code>Select</code>调度</h4><pre><code class="hljs go"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Author: Wang P</span><span class="hljs-comment"> * Version: 1.0.0</span><span class="hljs-comment"> * Date: 2021/2/5 上午10:37</span><span class="hljs-comment"> * Description: select</span><span class="hljs-comment"> **/</span><span class="hljs-keyword">package</span> goroutines<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;math/rand&quot;</span><span class="hljs-string">&quot;time&quot;</span>)<span class="hljs-keyword">type</span> SelectWorker <span class="hljs-keyword">struct</span> &#123;id <span class="hljs-keyword">string</span>c <span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(w *SelectWorker)</span> <span class="hljs-title">setValue</span><span class="hljs-params">(id <span class="hljs-keyword">string</span>)</span></span>  &#123;w.id = id&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">selectNotBlock</span><span class="hljs-params">(c1, c2 <span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)</span></span>  &#123;<span class="hljs-keyword">for</span> &#123;<span class="hljs-keyword">select</span> &#123;<span class="hljs-keyword">case</span> n := &lt;- c1:fmt.Printf(<span class="hljs-string">&quot;receice %d from c1\n&quot;</span>, n)<span class="hljs-keyword">case</span> n := &lt;-c2:fmt.Printf(<span class="hljs-string">&quot;receice %d from c2\n&quot;</span>, n)<span class="hljs-keyword">default</span>:fmt.Println(<span class="hljs-string">&quot;not receive anything&quot;</span>)&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">selectBlock</span><span class="hljs-params">(c1, c2 <span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)</span></span>  &#123;<span class="hljs-keyword">for</span> &#123;<span class="hljs-keyword">select</span> &#123;<span class="hljs-keyword">case</span> n := &lt;- c1:fmt.Printf(<span class="hljs-string">&quot;receice %d from c1\n&quot;</span>, n)<span class="hljs-keyword">case</span> n := &lt;-c2:fmt.Printf(<span class="hljs-string">&quot;receice %d from c2\n&quot;</span>, n)&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">selectWorkConditionBlock</span><span class="hljs-params">(rw, sw1, sw2 SelectWorker)</span></span>  &#123;<span class="hljs-keyword">var</span> values []<span class="hljs-keyword">int</span>id := <span class="hljs-string">&quot;&quot;</span>endTime := time.After(time.Second * <span class="hljs-number">10</span>)tick := time.Tick(time.Second)<span class="hljs-keyword">for</span> &#123;activeWorker := SelectWorker&#123;c:  <span class="hljs-literal">nil</span>,&#125;<span class="hljs-keyword">var</span> activeValue <span class="hljs-keyword">int</span><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(values) &gt;<span class="hljs-number">0</span> &#123;rw.setValue(id)activeWorker = rwactiveValue = values[<span class="hljs-number">0</span>]&#125;<span class="hljs-keyword">select</span> &#123;<span class="hljs-keyword">case</span> n := &lt;-sw1.c:id = sw1.idvalues = <span class="hljs-built_in">append</span>(values, n)<span class="hljs-keyword">case</span> n := &lt;-sw2.c:id = sw2.idvalues = <span class="hljs-built_in">append</span>(values, n)<span class="hljs-keyword">case</span> activeWorker.c &lt;- activeValue:values = values[<span class="hljs-number">1</span>:]<span class="hljs-keyword">case</span> &lt;-time.After(time.Millisecond * <span class="hljs-number">600</span>):  <span class="hljs-comment">// 500毫秒未产生数据</span>fmt.Println(<span class="hljs-string">&quot;程序超时&quot;</span>)<span class="hljs-keyword">case</span> &lt;- tick:fmt.Println(<span class="hljs-string">&quot;queue len = &quot;</span>, <span class="hljs-built_in">len</span>(values))<span class="hljs-keyword">case</span> &lt;- endTime:  <span class="hljs-comment">// 程序执行到endTime时结束</span>fmt.Println(<span class="hljs-string">&quot;程序执行结束&quot;</span>)<span class="hljs-keyword">return</span>&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">generateChannel</span><span class="hljs-params">()</span> <span class="hljs-title">chan</span> <span class="hljs-title">int</span></span>&#123;c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;i := <span class="hljs-number">0</span><span class="hljs-keyword">for</span> &#123;time.Sleep(time.Duration(rand.Intn(<span class="hljs-number">1000</span>)) * time.Millisecond)c &lt;- ii++&#125;&#125;()<span class="hljs-keyword">return</span> c&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">generateWorkChannel</span><span class="hljs-params">(id <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">SelectWorker</span></span> &#123;w := SelectWorker&#123;id:id,c: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>),&#125;<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;i := <span class="hljs-number">0</span><span class="hljs-keyword">for</span> &#123;time.Sleep(time.Duration(rand.Intn(<span class="hljs-number">1000</span>)) * time.Millisecond)w.c &lt;- ii++&#125;&#125;()<span class="hljs-keyword">return</span> w&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">selectWorks</span><span class="hljs-params">(id <span class="hljs-keyword">string</span>, rw SelectWorker)</span></span>  &#123;<span class="hljs-comment">// 不断的从channel取</span><span class="hljs-keyword">for</span>  &#123;fmt.Printf(<span class="hljs-string">&quot;channel %s from %s receive %d\n&quot;</span>, id, rw.id, &lt;-rw.c)time.Sleep(time.Second)&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">createSelectWorks</span><span class="hljs-params">(id <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">SelectWorker</span></span> &#123;rw := SelectWorker&#123;c:  <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>),&#125;<span class="hljs-keyword">go</span> selectWorks(id, rw)<span class="hljs-keyword">return</span> rw&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">channelSelectBlock</span><span class="hljs-params">()</span></span>  &#123;<span class="hljs-keyword">var</span> c1, c2 = generateChannel(), generateChannel()selectBlock(c1, c2)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">channelSelectWork</span><span class="hljs-params">()</span></span>  &#123;<span class="hljs-keyword">var</span> sw1, sw2 = generateWorkChannel(<span class="hljs-string">&quot;send worker1&quot;</span>), generateWorkChannel(<span class="hljs-string">&quot;send worker2&quot;</span>)rw := createSelectWorks(<span class="hljs-string">&quot;receive work1&quot;</span>)selectWorkConditionBlock(rw, sw1, sw2)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">selectDemo</span><span class="hljs-params">()</span></span>  &#123;<span class="hljs-comment">//var c1, c2 chan int</span><span class="hljs-comment">//selectNotBlock(c1, c2)</span><span class="hljs-comment">//channelSelectBlock()</span>channelSelectWork()&#125;</code></pre><h4 id="同步机制"><a href="#同步机制" class="headerlink" title="同步机制"></a>同步机制</h4><ul><li><code>WaitGroup</code></li></ul><p>基于<code>WaitGroup</code>实现通信来共享内存</p><pre><code class="hljs go"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Author: Wang P</span><span class="hljs-comment"> * Version: 1.0.0</span><span class="hljs-comment"> * Date: 2021/2/5 下午5:37</span><span class="hljs-comment"> * Description: 基于WaitGroup实现通信来共享内存</span><span class="hljs-comment"> **/</span><span class="hljs-keyword">package</span> goroutines<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;sync&quot;</span>)<span class="hljs-keyword">type</span> WorkerWG <span class="hljs-keyword">struct</span> &#123;in <span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>wg *sync.WaitGroup&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">doWorkWaitDone</span><span class="hljs-params">(id <span class="hljs-keyword">int</span>, w WorkerWG)</span></span>  &#123;<span class="hljs-comment">// 接收方判断channel中有数据就不断的从channel取</span><span class="hljs-keyword">for</span> n := <span class="hljs-keyword">range</span> w.in&#123;fmt.Printf(<span class="hljs-string">&quot;channel %d receive %c\n&quot;</span>, id, n)w.wg.Done()&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">createWaitDoneWorkers</span><span class="hljs-params">(id <span class="hljs-keyword">int</span>, wg *sync.WaitGroup)</span> <span class="hljs-title">WorkerWG</span></span> &#123;w := WorkerWG&#123;in: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>),wg: wg,&#125;<span class="hljs-keyword">go</span> doWorkWaitDone(id, w)<span class="hljs-keyword">return</span> w&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">communicateWaitDone</span><span class="hljs-params">()</span></span>  &#123;<span class="hljs-comment">// 只能发数据  chan&lt;- int 将channel 作为函数返回参数  即 channel也是一等公民</span><span class="hljs-keyword">var</span> works [<span class="hljs-number">10</span>]WorkerWG<span class="hljs-keyword">var</span> wg sync.WaitGroup<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;works[i] = createWaitDoneWorkers(i, &amp;wg)&#125;<span class="hljs-comment">//wg.Add(20)</span><span class="hljs-keyword">for</span> i, worker := <span class="hljs-keyword">range</span> works&#123;worker.in &lt;- <span class="hljs-string">&#x27;a&#x27;</span> + iwg.Add(<span class="hljs-number">1</span>)&#125;<span class="hljs-keyword">for</span> i, worker := <span class="hljs-keyword">range</span> works&#123;worker.in &lt;- <span class="hljs-string">&#x27;A&#x27;</span> + iwg.Add(<span class="hljs-number">1</span>)&#125;wg.Wait()&#125;<span class="hljs-keyword">type</span> WorkerWG2 <span class="hljs-keyword">struct</span> &#123;in <span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>done <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span>  // 函数式编程</span>&#125;<span class="hljs-comment">// WorkerWG封装</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">doWorkWaitDone2</span><span class="hljs-params">(id <span class="hljs-keyword">int</span>, w WorkerWG2)</span></span>  &#123;<span class="hljs-comment">// 接收方判断channel中有数据就不断的从channel取</span><span class="hljs-keyword">for</span> n := <span class="hljs-keyword">range</span> w.in&#123;fmt.Printf(<span class="hljs-string">&quot;channel %d receive %c\n&quot;</span>, id, n)w.done()&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">createWaitDoneWorkers2</span><span class="hljs-params">(id <span class="hljs-keyword">int</span>, wg *sync.WaitGroup)</span> <span class="hljs-title">WorkerWG2</span></span> &#123;w := WorkerWG2&#123;in: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>),done: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;wg.Done()&#125;,&#125;<span class="hljs-keyword">go</span> doWorkWaitDone2(id, w)<span class="hljs-keyword">return</span> w&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">communicateWaitDone2</span><span class="hljs-params">()</span></span>  &#123;<span class="hljs-comment">// 只能发数据  chan&lt;- int 将channel 作为函数返回参数  即 channel也是一等公民</span><span class="hljs-keyword">var</span> works [<span class="hljs-number">10</span>]WorkerWG2<span class="hljs-keyword">var</span> wg sync.WaitGroup<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;works[i] = createWaitDoneWorkers2(i, &amp;wg)&#125;wg.Add(<span class="hljs-number">20</span>)<span class="hljs-keyword">for</span> i, worker := <span class="hljs-keyword">range</span> works&#123;worker.in &lt;- <span class="hljs-string">&#x27;a&#x27;</span> + i<span class="hljs-comment">//wg.Add(1)</span>&#125;<span class="hljs-keyword">for</span> i, worker := <span class="hljs-keyword">range</span> works&#123;worker.in &lt;- <span class="hljs-string">&#x27;A&#x27;</span> + i<span class="hljs-comment">//wg.Add(1)</span>&#125;wg.Wait()&#125;<span class="hljs-comment">// 输出</span>channel <span class="hljs-number">7</span> receive hchannel <span class="hljs-number">5</span> receive fchannel <span class="hljs-number">6</span> receive gchannel <span class="hljs-number">0</span> receive achannel <span class="hljs-number">8</span> receive ichannel <span class="hljs-number">1</span> receive bchannel <span class="hljs-number">3</span> receive dchannel <span class="hljs-number">2</span> receive cchannel <span class="hljs-number">4</span> receive echannel <span class="hljs-number">9</span> receive jchannel <span class="hljs-number">9</span> receive Jchannel <span class="hljs-number">3</span> receive Dchannel <span class="hljs-number">0</span> receive Achannel <span class="hljs-number">5</span> receive Fchannel <span class="hljs-number">2</span> receive Cchannel <span class="hljs-number">4</span> receive Echannel <span class="hljs-number">6</span> receive Gchannel <span class="hljs-number">1</span> receive Bchannel <span class="hljs-number">7</span> receive Hchannel <span class="hljs-number">8</span> receive Ichannel <span class="hljs-number">9</span> receive jchannel <span class="hljs-number">6</span> receive gchannel <span class="hljs-number">8</span> receive ichannel <span class="hljs-number">4</span> receive echannel <span class="hljs-number">0</span> receive achannel <span class="hljs-number">0</span> receive Achannel <span class="hljs-number">2</span> receive cchannel <span class="hljs-number">3</span> receive dchannel <span class="hljs-number">5</span> receive fchannel <span class="hljs-number">1</span> receive bchannel <span class="hljs-number">1</span> receive Bchannel <span class="hljs-number">7</span> receive hchannel <span class="hljs-number">7</span> receive Hchannel <span class="hljs-number">3</span> receive Dchannel <span class="hljs-number">5</span> receive Fchannel <span class="hljs-number">4</span> receive Echannel <span class="hljs-number">6</span> receive Gchannel <span class="hljs-number">9</span> receive Jchannel <span class="hljs-number">2</span> receive Cchannel <span class="hljs-number">8</span> receive I</code></pre><ul><li><code>Mutux</code></li></ul><pre><code class="hljs go"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Author: Wang P</span><span class="hljs-comment"> * Version: 1.0.0</span><span class="hljs-comment"> * Date: 2021/2/5 下午2:34</span><span class="hljs-comment"> * Description:</span><span class="hljs-comment"> **/</span><span class="hljs-keyword">package</span> goroutines<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;sync&quot;</span><span class="hljs-string">&quot;time&quot;</span>)<span class="hljs-keyword">type</span> AtomicInt <span class="hljs-keyword">struct</span> &#123;value <span class="hljs-keyword">int</span>lock sync.Mutex&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a *AtomicInt)</span> <span class="hljs-title">increase</span><span class="hljs-params">()</span></span>  &#123;fmt.Println(<span class="hljs-string">&quot;safe Increase&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-comment">//a.lock.Lock()</span><span class="hljs-comment">//defer a.lock.Unlock()</span>a.value++&#125;()&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a *AtomicInt)</span> <span class="hljs-title">get</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span> &#123;<span class="hljs-comment">//a.lock.Lock()</span><span class="hljs-comment">//defer a.lock.Unlock()</span><span class="hljs-keyword">return</span> a.value&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">AtomicDemo</span><span class="hljs-params">()</span></span>  &#123; i := AtomicInt&#123;&#125; i.increase() <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; i.increase() &#125;()time.Sleep(time.Millisecond) fmt.Println(i.get())&#125;<span class="hljs-comment">// 输出</span>xxx@xxxdeMacBook-Pro  ~/Projects/golang/src/offer/note   master ±✚  <span class="hljs-keyword">go</span> run -race main.<span class="hljs-keyword">go</span>safe Increasesafe Increase==================WARNING: DATA RACERead at <span class="hljs-number">0x00c000134010</span> by main goroutine:  offer/note/goroutines.(*AtomicInt).get()      /Users/wangpeng/Projects/golang/src/offer/note/goroutines/atomic.<span class="hljs-keyword">go</span>:<span class="hljs-number">33</span> +<span class="hljs-number">0xab</span>  offer/note/goroutines.AtomicDemo()      /Users/wangpeng/Projects/golang/src/offer/note/goroutines/atomic.<span class="hljs-keyword">go</span>:<span class="hljs-number">43</span> +<span class="hljs-number">0xb4</span>  main.main()      /Users/wangpeng/Projects/golang/src/offer/note/main.<span class="hljs-keyword">go</span>:<span class="hljs-number">75</span> +<span class="hljs-number">0x2f</span>Previous write at <span class="hljs-number">0x00c000134010</span> by goroutine <span class="hljs-number">7</span>:  offer/note/goroutines.(*AtomicInt).increase.func1()      /Users/wangpeng/Projects/golang/src/offer/note/goroutines/atomic.<span class="hljs-keyword">go</span>:<span class="hljs-number">26</span> +<span class="hljs-number">0xbd</span>  offer/note/goroutines.(*AtomicInt).increase()      /Users/wangpeng/Projects/golang/src/offer/note/goroutines/atomic.<span class="hljs-keyword">go</span>:<span class="hljs-number">27</span> +<span class="hljs-number">0x9e</span>  offer/note/goroutines.AtomicDemo.func1()      /Users/wangpeng/Projects/golang/src/offer/note/goroutines/atomic.<span class="hljs-keyword">go</span>:<span class="hljs-number">40</span> +<span class="hljs-number">0x38</span>Goroutine <span class="hljs-number">7</span> (finished) created at:  offer/note/goroutines.AtomicDemo()      /Users/wangpeng/Projects/golang/src/offer/note/goroutines/atomic.<span class="hljs-keyword">go</span>:<span class="hljs-number">39</span> +<span class="hljs-number">0x90</span>  main.main()      /Users/wangpeng/Projects/golang/src/offer/note/main.<span class="hljs-keyword">go</span>:<span class="hljs-number">75</span> +<span class="hljs-number">0x2f</span>==================<span class="hljs-number">2</span>Found <span class="hljs-number">1</span> data race(s)exit status <span class="hljs-number">66</span></code></pre><pre><code class="hljs go"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Author: Wang P</span><span class="hljs-comment"> * Version: 1.0.0</span><span class="hljs-comment"> * Date: 2021/2/5 下午2:34</span><span class="hljs-comment"> * Description:</span><span class="hljs-comment"> **/</span><span class="hljs-keyword">package</span> goroutines<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;sync&quot;</span><span class="hljs-string">&quot;time&quot;</span>)<span class="hljs-keyword">type</span> AtomicInt <span class="hljs-keyword">struct</span> &#123;value <span class="hljs-keyword">int</span>lock sync.Mutex&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a *AtomicInt)</span> <span class="hljs-title">increase</span><span class="hljs-params">()</span></span>  &#123;fmt.Println(<span class="hljs-string">&quot;safe Increase&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>&#123;a.lock.Lock()<span class="hljs-keyword">defer</span> a.lock.Unlock()a.value++&#125;()&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a *AtomicInt)</span> <span class="hljs-title">get</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span> &#123;a.lock.Lock()<span class="hljs-keyword">defer</span> a.lock.Unlock()<span class="hljs-keyword">return</span> a.value&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">AtomicDemo</span><span class="hljs-params">()</span></span>  &#123; i := AtomicInt&#123;&#125; i.increase() <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; i.increase() &#125;()time.Sleep(time.Millisecond) fmt.Println(i.get())&#125;<span class="hljs-comment">// 输出</span>xxx@xxxdeMacBook-Pro  ~/Projects/golang/src/offer/note   master ±✚  <span class="hljs-keyword">go</span> run -race main.<span class="hljs-keyword">go</span>safe Increasesafe Increase<span class="hljs-number">2</span></code></pre><ul><li><code>Cond</code></li></ul>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【windows】基于Django构建与开发在线学习项目</title>
    <link href="/2020/06/14/django-web-windows/"/>
    <url>/2020/06/14/django-web-windows/</url>
    
    <content type="html"><![CDATA[<p><img src="/images/django-web/logo.jpg"><a id="more"></a> </p><h3 id="项目创建"><a href="#项目创建" class="headerlink" title="项目创建"></a>项目创建</h3><p><strong>1.安装第三方库Django</strong></p><p><img src="/images/django-web/1.png"></p><p><strong>2.pycharm创建Django项目</strong></p><p><img src="/images/django-web/2.png"></p><h3 id="数据库环境与资源层设置"><a href="#数据库环境与资源层设置" class="headerlink" title="数据库环境与资源层设置"></a>数据库环境与资源层设置</h3><p><strong>3.安装mysql第三方库</strong></p><p><img src="/images/django-web/3.png"></p><p><strong>4.配置mysql数据库环境</strong></p><p><img src="/images/django-web/4.png"></p><p><strong>5.生成django默认数据表</strong></p><p>tool –&gt;Run manage.py task</p><pre><code class="hljs ebnf"><span class="hljs-attribute">makemigrations</span> <span class="hljs-attribute">migrate</span></code></pre><p><img src="/images/django-web/5.png"></p><p>查看数据表，会发现生成了django的数据表</p><p><img src="/images/django-web/5-1.png"></p><p><strong>6.创建一个app</strong></p><p>startapp user</p><p><img src="/images/django-web/6-1.png"></p><p>项目目录下会生成</p><p><img src="/images/django-web/6-2.png"></p><p><strong>7.自定义user表</strong></p><p>Django生成的user表</p><ul><li>id: 主键, password 密码, last_login Django自动记录用户最后登录时间,。</li><li>is_superuser 表明用户是否是超级用户(后台管理会用到)。</li><li>username 用户名字段不要随便改动, email 邮箱,</li><li>is_staff 表示是否是员工(后台管理会用到)。</li><li>is_active 用户是否是激活状态, date_joined 注册时间。</li></ul><p>这些往往不能满足我们自身的需求，因此需要自定义user表，在user下的models.py文件添加代码</p><pre><code class="hljs python"><span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> datetime<span class="hljs-keyword">from</span> django.db <span class="hljs-keyword">import</span> models<span class="hljs-keyword">from</span> django.contrib.auth.models <span class="hljs-keyword">import</span> AbstractUser<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TbUser</span>(<span class="hljs-params">AbstractUser</span>):</span>    nickname = models.CharField(null=<span class="hljs-literal">True</span>, max_length=<span class="hljs-number">50</span>, verbose_name=<span class="hljs-string">&#x27;昵称&#x27;</span>,)    birthday = models.DateField(null=<span class="hljs-literal">True</span>, verbose_name=<span class="hljs-string">&#x27;生日&#x27;</span>)    gender = models.IntegerField(choices=((<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;男&#x27;</span>), (<span class="hljs-number">0</span>, <span class="hljs-string">&#x27;女&#x27;</span>)), verbose_name=<span class="hljs-string">&#x27;性别&#x27;</span>, default=<span class="hljs-number">1</span>)    address = models.CharField(null=<span class="hljs-literal">True</span>, max_length=<span class="hljs-number">200</span>, verbose_name=<span class="hljs-string">&#x27;地址&#x27;</span>)    phone = models.CharField(null=<span class="hljs-literal">True</span>, blank=<span class="hljs-literal">True</span>, max_length=<span class="hljs-number">11</span>, verbose_name=<span class="hljs-string">&#x27;手机&#x27;</span>)    head = models.ImageField(upload_to=<span class="hljs-string">&#x27;image/%Y/%m&#x27;</span>, max_length=<span class="hljs-number">100</span>, verbose_name=<span class="hljs-string">&#x27;头像&#x27;</span>, default=<span class="hljs-string">&#x27;image/default_m.png&#x27;</span>) <span class="hljs-comment"># 注意这里的head使用ImageField，需要安装依赖库pip install pillow</span>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Meta</span>:</span>        db_table = <span class="hljs-string">&#x27;tb_user&#x27;</span>        verbose_name = <span class="hljs-string">&#x27;用户信息&#x27;</span>        verbose_name_plural = verbose_name    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__str__</span>(<span class="hljs-params">self</span>):</span>        <span class="hljs-keyword">return</span> self.username</code></pre><p>修改settings.py文件</p><p><img src="/images/django-web/7-1.png"></p><p>在这里，def <strong>str</strong>(self)：方法在python3.x版本使用，用于后台展示样式是显示的是用户名。保存后，使用django敏玲重新生成表</p><p>tool –&gt;Run manage.py task</p><pre><code class="hljs routeros">makemigrations<span class="hljs-built_in"> user </span>migrate user</code></pre><p>创建后台管理用户</p><pre><code class="hljs ebnf"><span class="hljs-attribute">createsuperuser</span></code></pre><p>填写用户名、邮箱和密码</p><p><img src="/images/django-web/7-2.png"></p><p>可以查看到数据库中新增一条数据</p><p><img src="/images/django-web/7-3.png"></p><p>这样就可以登录后台管理页面了</p><h3 id="后台集成"><a href="#后台集成" class="headerlink" title="后台集成"></a>后台集成</h3><p><strong>8.集成xadmin组件</strong></p><p>python3.x无法直接使用安装包</p><pre><code class="hljs awk">pip install git+git:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/sshwsfc/</span>xadmin.git@django2</code></pre><p>或者访问<code>https://github.com/sshwsfc/xadmin/tree/django2 </code>，</p><p>或<code>git clone -b django2  https://github.com/sshwsfc/xadmin.git </code>将xadmin目录下文件拷贝到项目下</p><p><img src="/images/django-web/8-1.png"></p><p>在settings.py文件下添加相应配置</p><p><img src="/images/django-web/8-2.png"></p><p>把urls中默认admin指向Xadmin</p><pre><code class="hljs python"><span class="hljs-comment"># 导入 xadmin，替换admin</span><span class="hljs-keyword">import</span> xadminurlpatterns = [    path(<span class="hljs-string">&#x27;xadmin/&#x27;</span>, xadmin.site.urls),, <span class="hljs-comment"># django2中也可以是 url(r&#x27;^xadmin/&#x27;, xadmin.site.urls)</span>]</code></pre><p>点击Tools 菜单下 Run manage.py Task</p><pre><code class="hljs ebnf"><span class="hljs-attribute">makemigrations</span> <span class="hljs-attribute">migrate</span></code></pre><p>访问<a href="http://127.0.0.1/admin/">http://127.0.0.1/admin/</a></p><p><img src="/images/django-web/8-3.png"></p><p>新建user/adminx.py，进行app model注册：</p><pre><code class="hljs python"><span class="hljs-comment"># 创建xadmin的全局管理器并与view绑定。</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseSetting</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span>    <span class="hljs-comment"># 开启主题功能</span>    enable_themes = <span class="hljs-literal">True</span>    use_bootswatch = <span class="hljs-literal">True</span><span class="hljs-comment"># xadmin 全局配置参数信息设置</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GlobalSettings</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span>    site_title = <span class="hljs-string">&quot;supe-wa慕课小站&quot;</span>    site_footer = <span class="hljs-string">&quot;supe-wa慕课小站|后台管理系统&quot;</span>    <span class="hljs-comment"># 收起菜单</span>    menu_style = <span class="hljs-string">&quot;accordion&quot;</span>    <span class="hljs-comment"># 自定义导航楼目录</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_site_menu</span>(<span class="hljs-params">self</span>):</span>        <span class="hljs-keyword">return</span> (            &#123;<span class="hljs-string">&#x27;title&#x27;</span>: <span class="hljs-string">&#x27;课程信息管理&#x27;</span>, <span class="hljs-string">&#x27;menus&#x27;</span>: (                &#123;<span class="hljs-string">&#x27;title&#x27;</span>: <span class="hljs-string">&#x27;课程信息管理&#x27;</span>, <span class="hljs-string">&#x27;url&#x27;</span>: self.get_model_url(TbCourse, <span class="hljs-string">&#x27;changelist&#x27;</span>)&#125;,                &#123;<span class="hljs-string">&#x27;title&#x27;</span>: <span class="hljs-string">&#x27;章节信息管理&#x27;</span>, <span class="hljs-string">&#x27;url&#x27;</span>: self.get_model_url(TbCourseLesson, <span class="hljs-string">&#x27;changelist&#x27;</span>)&#125;,                &#123;<span class="hljs-string">&#x27;title&#x27;</span>: <span class="hljs-string">&#x27;视频信息管理&#x27;</span>, <span class="hljs-string">&#x27;url&#x27;</span>: self.get_model_url(TbCourseVideo, <span class="hljs-string">&#x27;changelist&#x27;</span>)&#125;,                &#123;<span class="hljs-string">&#x27;title&#x27;</span>: <span class="hljs-string">&#x27;课程资源管理&#x27;</span>, <span class="hljs-string">&#x27;url&#x27;</span>: self.get_model_url(TbCourseResource, <span class="hljs-string">&#x27;changelist&#x27;</span>)&#125;,                &#123;<span class="hljs-string">&#x27;title&#x27;</span>: <span class="hljs-string">&#x27;课程评论管理&#x27;</span>, <span class="hljs-string">&#x27;url&#x27;</span>: self.get_model_url(TbCourseComment, <span class="hljs-string">&#x27;changelist&#x27;</span>)&#125;,            )&#125;,            &#123;<span class="hljs-string">&#x27;title&#x27;</span>: <span class="hljs-string">&#x27;机构信息管理&#x27;</span>, <span class="hljs-string">&#x27;menus&#x27;</span>: (                &#123;<span class="hljs-string">&#x27;title&#x27;</span>: <span class="hljs-string">&#x27;城市信息管理&#x27;</span>, <span class="hljs-string">&#x27;url&#x27;</span>: self.get_model_url(TcCityDict, <span class="hljs-string">&#x27;changelist&#x27;</span>)&#125;,                &#123;<span class="hljs-string">&#x27;title&#x27;</span>: <span class="hljs-string">&#x27;机构信息管理&#x27;</span>, <span class="hljs-string">&#x27;url&#x27;</span>: self.get_model_url(TbOrg, <span class="hljs-string">&#x27;changelist&#x27;</span>)&#125;,                &#123;<span class="hljs-string">&#x27;title&#x27;</span>: <span class="hljs-string">&#x27;机构讲师管理&#x27;</span>, <span class="hljs-string">&#x27;url&#x27;</span>: self.get_model_url(TbOrgTeacher, <span class="hljs-string">&#x27;changelist&#x27;</span>)&#125;,            )&#125;,            &#123;<span class="hljs-string">&#x27;title&#x27;</span>: <span class="hljs-string">&#x27;用户信息管理&#x27;</span>, <span class="hljs-string">&#x27;menus&#x27;</span>: (                &#123;<span class="hljs-string">&#x27;title&#x27;</span>: <span class="hljs-string">&#x27;用户信息管理&#x27;</span>, <span class="hljs-string">&#x27;url&#x27;</span>: self.get_model_url(TbUser, <span class="hljs-string">&#x27;changelist&#x27;</span>)&#125;,                &#123;<span class="hljs-string">&#x27;title&#x27;</span>: <span class="hljs-string">&#x27;用户验证管理&#x27;</span>, <span class="hljs-string">&#x27;url&#x27;</span>: self.get_model_url(TbEmailVerifyRecord, <span class="hljs-string">&#x27;changelist&#x27;</span>)&#125;,                &#123;<span class="hljs-string">&#x27;title&#x27;</span>: <span class="hljs-string">&#x27;用户课程管理&#x27;</span>, <span class="hljs-string">&#x27;url&#x27;</span>: self.get_model_url(TbUserCourse, <span class="hljs-string">&#x27;changelist&#x27;</span>)&#125;,                &#123;<span class="hljs-string">&#x27;title&#x27;</span>: <span class="hljs-string">&#x27;用户收藏管理&#x27;</span>, <span class="hljs-string">&#x27;url&#x27;</span>: self.get_model_url(TbUserFavorite, <span class="hljs-string">&#x27;changelist&#x27;</span>)&#125;,                &#123;<span class="hljs-string">&#x27;title&#x27;</span>: <span class="hljs-string">&#x27;用户消息管理&#x27;</span>, <span class="hljs-string">&#x27;url&#x27;</span>: self.get_model_url(TbUserMessage, <span class="hljs-string">&#x27;changelist&#x27;</span>)&#125;,            )&#125;,            &#123;<span class="hljs-string">&#x27;title&#x27;</span>: <span class="hljs-string">&#x27;系统信息管理&#x27;</span>, <span class="hljs-string">&#x27;menus&#x27;</span>: (                &#123;<span class="hljs-string">&#x27;title&#x27;</span>: <span class="hljs-string">&#x27;用户咨询&#x27;</span>, <span class="hljs-string">&#x27;url&#x27;</span>: self.get_model_url(TbUserAsk, <span class="hljs-string">&#x27;changelist&#x27;</span>)&#125;,                &#123;<span class="hljs-string">&#x27;title&#x27;</span>: <span class="hljs-string">&#x27;首页轮播&#x27;</span>, <span class="hljs-string">&#x27;url&#x27;</span>: self.get_model_url(TcBanner, <span class="hljs-string">&#x27;changelist&#x27;</span>)&#125;,                &#123;<span class="hljs-string">&#x27;title&#x27;</span>: <span class="hljs-string">&#x27;用户分组&#x27;</span>, <span class="hljs-string">&#x27;url&#x27;</span>: self.get_model_url(Group, <span class="hljs-string">&#x27;changelist&#x27;</span>)&#125;,                &#123;<span class="hljs-string">&#x27;title&#x27;</span>: <span class="hljs-string">&#x27;用户权限&#x27;</span>, <span class="hljs-string">&#x27;url&#x27;</span>: self.get_model_url(Permission, <span class="hljs-string">&#x27;changelist&#x27;</span>)&#125;,                &#123;<span class="hljs-string">&#x27;title&#x27;</span>: <span class="hljs-string">&#x27;日志记录&#x27;</span>, <span class="hljs-string">&#x27;url&#x27;</span>: self.get_model_url(Log, <span class="hljs-string">&#x27;changelist&#x27;</span>)&#125;,            )&#125;,)            <span class="hljs-comment"># 将全局配置管理与view绑定注册</span>xadmin.site.register(views.CommAdminView, GlobalSettings)xadmin.site.register(views.BaseAdminView, BaseSetting)</code></pre><p>登录后</p><p><img src="/images/django-web/8-4.png"></p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Windows</tag>
      
      <tag>Django</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
